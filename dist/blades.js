var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateMethod = (obj, member, method) => {
  __accessCheck(obj, member, "access private method");
  return method;
};
var _ParseChildLinkData, ParseChildLinkData_fn, _ParseConfigToData, ParseConfigToData_fn, _updateTargetViaMerge, updateTargetViaMerge_fn, _updateTargetPropVal, updateTargetPropVal_fn;
var BladesPermissions = ((BladesPermissions2) => {
  BladesPermissions2[BladesPermissions2["NONE"] = CONST.DOCUMENT_PERMISSION_LEVELS.NONE] = "NONE";
  BladesPermissions2[BladesPermissions2["BASIC"] = CONST.DOCUMENT_PERMISSION_LEVELS.LIMITED] = "BASIC";
  BladesPermissions2[BladesPermissions2["FULL"] = CONST.DOCUMENT_PERMISSION_LEVELS.OBSERVER] = "FULL";
  BladesPermissions2[BladesPermissions2["OWNER"] = CONST.DOCUMENT_PERMISSION_LEVELS.OWNER] = "OWNER";
  return BladesPermissions2;
})(BladesPermissions || {});
var BladesActorType = /* @__PURE__ */ ((BladesActorType2) => {
  BladesActorType2["pc"] = "pc";
  BladesActorType2["npc"] = "npc";
  BladesActorType2["crew"] = "crew";
  BladesActorType2["faction"] = "faction";
  return BladesActorType2;
})(BladesActorType || {});
var BladesItemType = /* @__PURE__ */ ((BladesItemType2) => {
  BladesItemType2["ability"] = "ability";
  BladesItemType2["background"] = "background";
  BladesItemType2["clock_keeper"] = "clock_keeper";
  BladesItemType2["cohort_gang"] = "cohort_gang";
  BladesItemType2["cohort_expert"] = "cohort_expert";
  BladesItemType2["crew_ability"] = "crew_ability";
  BladesItemType2["crew_reputation"] = "crew_reputation";
  BladesItemType2["crew_playbook"] = "crew_playbook";
  BladesItemType2["crew_upgrade"] = "crew_upgrade";
  BladesItemType2["feature"] = "feature";
  BladesItemType2["gm_tracker"] = "gm_tracker";
  BladesItemType2["heritage"] = "heritage";
  BladesItemType2["gear"] = "gear";
  BladesItemType2["playbook"] = "playbook";
  BladesItemType2["preferred_op"] = "preferred_op";
  BladesItemType2["stricture"] = "stricture";
  BladesItemType2["vice"] = "vice";
  BladesItemType2["project"] = "project";
  BladesItemType2["ritual"] = "ritual";
  BladesItemType2["design"] = "design";
  BladesItemType2["location"] = "location";
  BladesItemType2["score"] = "score";
  return BladesItemType2;
})(BladesItemType || {});
var PrereqType = /* @__PURE__ */ ((PrereqType2) => {
  PrereqType2["HasActiveItem"] = "HasActiveItem";
  PrereqType2["HasActiveItemsByTag"] = "HasActiveItemByTag";
  PrereqType2["AdvancedPlaybook"] = "AdvancedPlaybook";
  PrereqType2["HasAllTags"] = "HasAllTags";
  PrereqType2["HasAnyTag"] = "HasAnyTag";
  PrereqType2["Not_HasActiveItem"] = "Not_HasActiveItem";
  PrereqType2["Not_HasActiveItemsByTag"] = "Not_HasActiveItemsByTag";
  PrereqType2["Not_AdvancedPlaybook"] = "Not_AdvancedPlaybook";
  PrereqType2["Not_HasAllTags"] = "Not_HasAllTags";
  PrereqType2["Not_HasAnyTag"] = "Not_HasAnyTag";
  return PrereqType2;
})(PrereqType || {});
var ClockColor = /* @__PURE__ */ ((ClockColor2) => {
  ClockColor2["yellow"] = "yellow";
  ClockColor2["red"] = "red";
  ClockColor2["white"] = "white";
  ClockColor2["cyan"] = "cyan";
  return ClockColor2;
})(ClockColor || {});
var ClockDisplayContext = /* @__PURE__ */ ((ClockDisplayContext2) => {
  ClockDisplayContext2["overlay"] = "overlay";
  ClockDisplayContext2["pcSheet"] = "pcSheet";
  ClockDisplayContext2["factionSheet"] = "factionSheet";
  ClockDisplayContext2["projectSheet"] = "projectSheet";
  ClockDisplayContext2["scoreSheet"] = "scoreSheet";
  ClockDisplayContext2["rollCollab"] = "rollCollab";
  ClockDisplayContext2["chatMessage"] = "chatMessage";
  return ClockDisplayContext2;
})(ClockDisplayContext || {});
var ClockKeyDisplayMode = /* @__PURE__ */ ((ClockKeyDisplayMode2) => {
  ClockKeyDisplayMode2["full"] = "full";
  ClockKeyDisplayMode2["clocks"] = "clocks";
  ClockKeyDisplayMode2["activeClocks"] = "activeClocks";
  ClockKeyDisplayMode2["presentCurrentClock"] = "presentCurrentClock";
  ClockKeyDisplayMode2["present0"] = "present0";
  ClockKeyDisplayMode2["present1"] = "present1";
  ClockKeyDisplayMode2["present2"] = "present2";
  ClockKeyDisplayMode2["present3"] = "present3";
  ClockKeyDisplayMode2["present4"] = "present4";
  ClockKeyDisplayMode2["present5"] = "present5";
  return ClockKeyDisplayMode2;
})(ClockKeyDisplayMode || {});
var BladesNoticeType = /* @__PURE__ */ ((BladesNoticeType2) => {
  BladesNoticeType2["push"] = "push";
  return BladesNoticeType2;
})(BladesNoticeType || {});
var MainDistrict = /* @__PURE__ */ ((MainDistrict2) => {
  MainDistrict2["Barrowcleft"] = "Barrowcleft";
  MainDistrict2["Brightstone"] = "Brightstone";
  MainDistrict2["Charhollow"] = "Charhollow";
  MainDistrict2["Charterhall"] = "Charterhall";
  MainDistrict2["Coalridge"] = "Coalridge";
  MainDistrict2["Crows Foot"] = "Crows Foot";
  MainDistrict2["The Docks"] = "The Docks";
  MainDistrict2["Dunslough"] = "Dunslough";
  MainDistrict2["Nightmarket"] = "Nightmarket";
  MainDistrict2["Silkshore"] = "Silkshore";
  MainDistrict2["Six Towers"] = "Six Towers";
  MainDistrict2["Whitecrown"] = "Whitecrown";
  return MainDistrict2;
})(MainDistrict || {});
var OtherDistrict = /* @__PURE__ */ ((OtherDistrict2) => {
  OtherDistrict2["Gaddoc Station"] = "Gaddoc Station";
  OtherDistrict2["The Lost District"] = "The Lost District";
  OtherDistrict2["The Void Sea"] = "The Void Sea";
  OtherDistrict2["Ironhook Prison"] = "Ironhook Prison";
  OtherDistrict2["Old North Port"] = "Old North Port";
  OtherDistrict2["Deathlands"] = "Deathlands";
  return OtherDistrict2;
})(OtherDistrict || {});
var AttributeTrait = /* @__PURE__ */ ((AttributeTrait2) => {
  AttributeTrait2["insight"] = "insight";
  AttributeTrait2["prowess"] = "prowess";
  AttributeTrait2["resolve"] = "resolve";
  return AttributeTrait2;
})(AttributeTrait || {});
var ActionTrait = /* @__PURE__ */ ((ActionTrait2) => {
  ActionTrait2["hunt"] = "hunt";
  ActionTrait2["study"] = "study";
  ActionTrait2["survey"] = "survey";
  ActionTrait2["tinker"] = "tinker";
  ActionTrait2["finesse"] = "finesse";
  ActionTrait2["prowl"] = "prowl";
  ActionTrait2["skirmish"] = "skirmish";
  ActionTrait2["wreck"] = "wreck";
  ActionTrait2["attune"] = "attune";
  ActionTrait2["command"] = "command";
  ActionTrait2["consort"] = "consort";
  ActionTrait2["sway"] = "sway";
  return ActionTrait2;
})(ActionTrait || {});
var DowntimeAction = /* @__PURE__ */ ((DowntimeAction2) => {
  DowntimeAction2["AcquireAsset"] = "AcquireAsset";
  DowntimeAction2["IndulgeVice"] = "IndulgeVice";
  DowntimeAction2["LongTermProject"] = "LongTermProject";
  DowntimeAction2["Recover"] = "Recover";
  DowntimeAction2["ReduceHeat"] = "ReduceHeat";
  DowntimeAction2["Train"] = "Train";
  return DowntimeAction2;
})(DowntimeAction || {});
var RollPermissions = /* @__PURE__ */ ((RollPermissions2) => {
  RollPermissions2["Primary"] = "Primary";
  RollPermissions2["Observer"] = "Observer";
  RollPermissions2["GM"] = "GM";
  RollPermissions2["Participant"] = "Participant";
  return RollPermissions2;
})(RollPermissions || {});
var RollType = /* @__PURE__ */ ((RollType2) => {
  RollType2["Action"] = "Action";
  RollType2["Resistance"] = "Resistance";
  RollType2["Fortune"] = "Fortune";
  RollType2["IndulgeVice"] = "IndulgeVice";
  return RollType2;
})(RollType || {});
var RollSubType = /* @__PURE__ */ ((RollSubType2) => {
  RollSubType2["Incarceration"] = "Incarceration";
  RollSubType2["Engagement"] = "Engagement";
  RollSubType2["GatherInfo"] = "GatherInfo";
  RollSubType2["GroupLead"] = "GroupLead";
  RollSubType2["GroupParticipant"] = "GroupParticipant";
  return RollSubType2;
})(RollSubType || {});
var RollModType = /* @__PURE__ */ ((RollModType2) => {
  RollModType2["general"] = "general";
  RollModType2["harm"] = "harm";
  RollModType2["teamwork"] = "teamwork";
  RollModType2["ability"] = "ability";
  RollModType2["gear"] = "gear";
  RollModType2["crew_ability"] = "crew_ability";
  RollModType2["crew_upgrade"] = "crew_upgrade";
  RollModType2["advantage"] = "advantage";
  RollModType2["disadvantage"] = "disadvantage";
  return RollModType2;
})(RollModType || {});
var ConsequenceType = /* @__PURE__ */ ((ConsequenceType2) => {
  ConsequenceType2["ReducedEffect"] = "ReducedEffect";
  ConsequenceType2["ComplicationMinor"] = "ComplicationMinor";
  ConsequenceType2["ComplicationMajor"] = "ComplicationMajor";
  ConsequenceType2["ComplicationSerious"] = "ComplicationSerious";
  ConsequenceType2["LostOpportunity"] = "LostOpportunity";
  ConsequenceType2["WorsePosition"] = "WorsePosition";
  ConsequenceType2["InsightHarm1"] = "InsightHarm1";
  ConsequenceType2["InsightHarm2"] = "InsightHarm2";
  ConsequenceType2["InsightHarm3"] = "InsightHarm3";
  ConsequenceType2["InsightHarm4"] = "InsightHarm4";
  ConsequenceType2["ProwessHarm1"] = "ProwessHarm1";
  ConsequenceType2["ProwessHarm2"] = "ProwessHarm2";
  ConsequenceType2["ProwessHarm3"] = "ProwessHarm3";
  ConsequenceType2["ProwessHarm4"] = "ProwessHarm4";
  ConsequenceType2["ResolveHarm1"] = "ResolveHarm1";
  ConsequenceType2["ResolveHarm2"] = "ResolveHarm2";
  ConsequenceType2["ResolveHarm3"] = "ResolveHarm3";
  ConsequenceType2["ResolveHarm4"] = "ResolveHarm4";
  ConsequenceType2["None"] = "None";
  return ConsequenceType2;
})(ConsequenceType || {});
var RollModStatus = /* @__PURE__ */ ((RollModStatus2) => {
  RollModStatus2["Hidden"] = "Hidden";
  RollModStatus2["ForcedOff"] = "ForcedOff";
  RollModStatus2["ToggledOff"] = "ToggledOff";
  RollModStatus2["ToggledOn"] = "ToggledOn";
  RollModStatus2["ForcedOn"] = "ForcedOn";
  RollModStatus2["Dominant"] = "Dominant";
  return RollModStatus2;
})(RollModStatus || {});
var RollModSection = /* @__PURE__ */ ((RollModSection2) => {
  RollModSection2["roll"] = "roll";
  RollModSection2["position"] = "position";
  RollModSection2["effect"] = "effect";
  RollModSection2["result"] = "result";
  RollModSection2["after"] = "after";
  return RollModSection2;
})(RollModSection || {});
var Position = /* @__PURE__ */ ((Position2) => {
  Position2["desperate"] = "desperate";
  Position2["risky"] = "risky";
  Position2["controlled"] = "controlled";
  return Position2;
})(Position || {});
var Effect = /* @__PURE__ */ ((Effect2) => {
  Effect2["zero"] = "zero";
  Effect2["limited"] = "limited";
  Effect2["standard"] = "standard";
  Effect2["great"] = "great";
  Effect2["extreme"] = "extreme";
  return Effect2;
})(Effect || {});
var Factor = /* @__PURE__ */ ((Factor2) => {
  Factor2["tier"] = "tier";
  Factor2["quality"] = "quality";
  Factor2["scale"] = "scale";
  Factor2["magnitude"] = "magnitude";
  return Factor2;
})(Factor || {});
var RollResult = /* @__PURE__ */ ((RollResult2) => {
  RollResult2["critical"] = "critical";
  RollResult2["success"] = "success";
  RollResult2["partial"] = "partial";
  RollResult2["fail"] = "fail";
  return RollResult2;
})(RollResult || {});
var RollPhase = /* @__PURE__ */ ((RollPhase2) => {
  RollPhase2["Collaboration"] = "Collaboration";
  RollPhase2["AwaitingRoll"] = "AwaitingRoll";
  RollPhase2["AwaitingConsequences"] = "AwaitingConsequences";
  RollPhase2["Complete"] = "Complete";
  return RollPhase2;
})(RollPhase || {});
var Harm = /* @__PURE__ */ ((Harm2) => {
  Harm2["Weakened"] = "Weakened";
  Harm2["Impaired"] = "Impaired";
  Harm2["Broken"] = "Broken";
  Harm2["Dead"] = "Dead";
  return Harm2;
})(Harm || {});
var Vice = /* @__PURE__ */ ((Vice2) => {
  Vice2["Faith"] = "Faith";
  Vice2["Gambling"] = "Gambling";
  Vice2["Luxury"] = "Luxury";
  Vice2["Obligation"] = "Obligation";
  Vice2["Pleasure"] = "Pleasure";
  Vice2["Stupor"] = "Stupor";
  Vice2["Weird"] = "Weird";
  Vice2["Worship"] = "Worship";
  Vice2["Life_Essence"] = "Life_Essence";
  Vice2["Living_Essence"] = "Living_Essence";
  Vice2["Electroplasmic_Power"] = "Electroplasmic_Power";
  Vice2["Servitude"] = "Servitude";
  return Vice2;
})(Vice || {});
var Playbook = /* @__PURE__ */ ((Playbook2) => {
  Playbook2["Cutter"] = "Cutter";
  Playbook2["Hound"] = "Hound";
  Playbook2["Leech"] = "Leech";
  Playbook2["Lurk"] = "Lurk";
  Playbook2["Slide"] = "Slide";
  Playbook2["Spider"] = "Spider";
  Playbook2["Whisper"] = "Whisper";
  Playbook2["Vampire"] = "Vampire";
  Playbook2["Hull"] = "Hull";
  Playbook2["Ghost"] = "Ghost";
  Playbook2["Assassins"] = "Assassins";
  Playbook2["Bravos"] = "Bravos";
  Playbook2["Cult"] = "Cult";
  Playbook2["Hawkers"] = "Hawkers";
  Playbook2["Shadows"] = "Shadows";
  Playbook2["Smugglers"] = "Smugglers";
  Playbook2["Vigilantes"] = "Vigilantes";
  return Playbook2;
})(Playbook || {});
var AdvancementPoint = /* @__PURE__ */ ((AdvancementPoint2) => {
  AdvancementPoint2["UpgradeOrAbility"] = "UpgradeOrAbility";
  AdvancementPoint2["Ability"] = "Ability";
  AdvancementPoint2["Upgrade"] = "Upgrade";
  AdvancementPoint2["Cohort"] = "Cohort";
  AdvancementPoint2["CohortType"] = "CohortType";
  AdvancementPoint2["GeneralAction"] = "GeneralAction";
  AdvancementPoint2["GeneralInsight"] = "GeneralInsight";
  AdvancementPoint2["GeneralProwess"] = "GeneralProwess";
  AdvancementPoint2["GeneralResolve"] = "GeneralResolve";
  AdvancementPoint2["hunt"] = "hunt";
  AdvancementPoint2["study"] = "study";
  AdvancementPoint2["survey"] = "survey";
  AdvancementPoint2["tinker"] = "tinker";
  AdvancementPoint2["finesse"] = "finesse";
  AdvancementPoint2["prowl"] = "prowl";
  AdvancementPoint2["skirmish"] = "skirmish";
  AdvancementPoint2["wreck"] = "wreck";
  AdvancementPoint2["attune"] = "attune";
  AdvancementPoint2["command"] = "command";
  AdvancementPoint2["consort"] = "consort";
  AdvancementPoint2["sway"] = "sway";
  return AdvancementPoint2;
})(AdvancementPoint || {});
var BladesPhase = /* @__PURE__ */ ((BladesPhase2) => {
  BladesPhase2["CharGen"] = "CharGen";
  BladesPhase2["Freeplay"] = "Freeplay";
  BladesPhase2["Score"] = "Score";
  BladesPhase2["Downtime"] = "Downtime";
  return BladesPhase2;
})(BladesPhase || {});
var Tag;
((Tag2) => {
  ((System2) => {
    System2["Archived"] = "Archived";
    System2["Featured"] = "Featured";
    System2["Hidden"] = "Hidden";
    System2["MultiplesOK"] = "MultiplesOK";
  })(Tag2.System || (Tag2.System = {}));
  ((Gear2) => {
    Gear2["Fine"] = "Fine";
    Gear2["General"] = "General";
    Gear2["Advanced"] = "Advanced";
    Gear2["Upgraded"] = "Upgraded";
  })(Tag2.Gear || (Tag2.Gear = {}));
  ((PC2) => {
    PC2["Member"] = "Member";
    PC2["CharacterCrew"] = "CharacterCrew";
    PC2["ActivePC"] = "ActivePC";
    PC2["Small"] = "Small";
    PC2["Medium"] = "Medium";
    PC2["Large"] = "Large";
    PC2["CanHeal"] = "CanHeal";
  })(Tag2.PC || (Tag2.PC = {}));
  ((Invention2) => {
    Invention2["Arcane"] = "Arcane";
    Invention2["SparkCraft"] = "SparkCraft";
    Invention2["Alchemical"] = "Alchemical";
    Invention2["Mundane"] = "Mundane";
    Invention2["Ritual"] = "Ritual";
  })(Tag2.Invention || (Tag2.Invention = {}));
  ((GearCategory2) => {
    GearCategory2["ArcaneImplement"] = "ArcaneImplement";
    GearCategory2["Document"] = "Document";
    GearCategory2["GearKit"] = "GearKit";
    GearCategory2["SubterfugeSupplies"] = "SubterfugeSupplies";
    GearCategory2["Tool"] = "Tool";
    GearCategory2["Weapon"] = "Weapon";
  })(Tag2.GearCategory || (Tag2.GearCategory = {}));
  ((NPC2) => {
    NPC2["Acquaintance"] = "Acquaintance";
    NPC2["VicePurveyor"] = "VicePurveyor";
    NPC2["CanHeal"] = "CanHeal";
  })(Tag2.NPC || (Tag2.NPC = {}));
  ((GangType2) => {
    GangType2["Thugs"] = "Thugs";
    GangType2["Rooks"] = "Rooks";
    GangType2["Adepts"] = "Adepts";
    GangType2["Rovers"] = "Rovers";
    GangType2["Skulks"] = "Skulks";
    GangType2["Vehicle"] = "Vehicle";
  })(Tag2.GangType || (Tag2.GangType = {}));
})(Tag || (Tag = {}));
const C = {
  SYSTEM_ID: "eunos-blades",
  SYSTEM_NAME: "Euno's Blades",
  SYSTEM_FULL_NAME: "Euno's Blades In The Dark",
  TEMPLATE_ROOT: "systems/eunos-blades/templates",
  GM_PORTRAIT: "systems/eunos-blades/assets/portraits/gm-chat.png",
  // SCSS_STYLES:      Colors,
  AI_MODELS: {
    baseContext: [
      "babbage-002",
      "gpt-3.5-turbo",
      "gpt-4"
    ],
    extendedContext: [
      "gpt-3.5-turbo-16k",
      "gpt-3.5-turbo-16k",
      "gpt-4-32k"
    ]
  },
  MIN_MOUSE_MOVEMENT_THRESHOLD: 200,
  AI_FILE_IDS: {
    BladesPDF: "file-n72HTTNwt051piPbswQ8isUa"
  },
  Rumors: [
    "Crows' boss? Vanished. Streets are a battleground now. Blood's cheap as ever in the Foot.",
    "Purest leviathan blood yet's hit Crow's Foot. Is it cursed? Pro'lly... but aren't we all?",
    "A blue specter stalks these rooftops. A dead Crow's scorned ghost seeking payback, I wager...",
    "The Sashes and Lampblacks are quiet, like before a storm. I heard they're uniting. Somethin's got 'em scared.",
    "Found a sealed tunnel under Crow's Foot. Ancient relics for the taking, mayhaps? Or death waitin' to get ya?",
    "Crow's Foot gots a new shadow I hear, one who deals with the livin' and dead alike.",
    "The Iruvian Consulate's dark secret is they made a pact with a demon for power? I mean... who hasn't?",
    "Heard it from a hunter who was there: a beast in the Void Sea, bigger than any leviathan, drivin' sailors mad.",
    "Rail Jacks found a ghost train, its screamin' passengers beggin' for release. How long you think they been out there?",
    "His huge fancy manor just gone! Poof! Just a misty hole left! Dimmer Sisters' doing, hunting some dusty tome.",
    "Another ship lost to the Void, chasing a cursed whirlpool's heart. Bad omens on the winds these nights.",
    "Red Sashes and Lampblacks, all quiet like, digging for the dead under Crow's Foot. For a ghost fight club.",
    "A vengeful lover's wailing ghost haunts the Foot. She hunts the Crows' chief, I hear...",
    "Scurlock's lost some spark-craft gadget. It opens death-doors to tickle ghosts, who knows? Wait, do you know?",
    "Silkshore's peddlin' future-sight dreams ripped from a spirit's mind, potent, dark and dire.",
    "Charhollow's gang war? Demonic blood? Something unnatural taking lives? They say it's all about a stolen book.",
    "Heard a whisper atop Six Towers... chattin' with a ghost 'bout a vault's secrets. Powers beyond reckonin', they say...",
    "Leviathan ship back, crew gone, hold filled with whisperin' artifacts... Night's got new horrors now.",
    "Shadows in Crow's Foot move on their own... Gang boss made a dark deal, power for sacrifices. Streets are hungry tonight.",
    "Fight club in the Docks, a front for those cult loonies. Winners get to 'ascend'... or so they disappear.",
    "New spirit-drug in Nightmarket, made from ghost essence. Shows ya visions, future glimpses... or drives ya mad."
  ],
  ClockKeySquareSize: 100,
  DowntimeActionDisplay: {
    [
      "AcquireAsset"
      /* AcquireAsset */
    ]: "Acquire an Asset",
    [
      "IndulgeVice"
      /* IndulgeVice */
    ]: "Indulge Your Vice",
    [
      "LongTermProject"
      /* LongTermProject */
    ]: "Work on a Project",
    [
      "Recover"
      /* Recover */
    ]: "Heal",
    [
      "ReduceHeat"
      /* ReduceHeat */
    ]: "Reduce the Crew's Heat",
    [
      "Train"
      /* Train */
    ]: "Train"
  },
  ConsequenceValues: {
    [
      "ReducedEffect"
      /* ReducedEffect */
    ]: void 0,
    [
      "LostOpportunity"
      /* LostOpportunity */
    ]: 2,
    [
      "WorsePosition"
      /* WorsePosition */
    ]: void 0,
    [
      "None"
      /* None */
    ]: 0,
    [
      "InsightHarm4"
      /* InsightHarm4 */
    ]: 4,
    [
      "InsightHarm3"
      /* InsightHarm3 */
    ]: 3,
    [
      "InsightHarm2"
      /* InsightHarm2 */
    ]: 2,
    [
      "InsightHarm1"
      /* InsightHarm1 */
    ]: 1,
    [
      "ProwessHarm4"
      /* ProwessHarm4 */
    ]: 4,
    [
      "ProwessHarm3"
      /* ProwessHarm3 */
    ]: 3,
    [
      "ProwessHarm2"
      /* ProwessHarm2 */
    ]: 2,
    [
      "ProwessHarm1"
      /* ProwessHarm1 */
    ]: 1,
    [
      "ResolveHarm4"
      /* ResolveHarm4 */
    ]: 4,
    [
      "ResolveHarm3"
      /* ResolveHarm3 */
    ]: 3,
    [
      "ResolveHarm2"
      /* ResolveHarm2 */
    ]: 2,
    [
      "ResolveHarm1"
      /* ResolveHarm1 */
    ]: 1,
    [
      "ComplicationSerious"
      /* ComplicationSerious */
    ]: 3,
    [
      "ComplicationMajor"
      /* ComplicationMajor */
    ]: 2,
    [
      "ComplicationMinor"
      /* ComplicationMinor */
    ]: 1
  },
  ResistedConsequenceTypes: {
    [
      "None"
      /* None */
    ]: [],
    [
      "InsightHarm4"
      /* InsightHarm4 */
    ]: [
      "InsightHarm3"
      /* InsightHarm3 */
    ],
    [
      "InsightHarm3"
      /* InsightHarm3 */
    ]: [
      "InsightHarm2"
      /* InsightHarm2 */
    ],
    [
      "InsightHarm2"
      /* InsightHarm2 */
    ]: [
      "InsightHarm1"
      /* InsightHarm1 */
    ],
    [
      "InsightHarm1"
      /* InsightHarm1 */
    ]: [
      "None"
      /* None */
    ],
    [
      "ProwessHarm4"
      /* ProwessHarm4 */
    ]: [
      "ProwessHarm3"
      /* ProwessHarm3 */
    ],
    [
      "ProwessHarm3"
      /* ProwessHarm3 */
    ]: [
      "ProwessHarm2"
      /* ProwessHarm2 */
    ],
    [
      "ProwessHarm2"
      /* ProwessHarm2 */
    ]: [
      "ProwessHarm1"
      /* ProwessHarm1 */
    ],
    [
      "ProwessHarm1"
      /* ProwessHarm1 */
    ]: [
      "None"
      /* None */
    ],
    [
      "ResolveHarm4"
      /* ResolveHarm4 */
    ]: [
      "ResolveHarm3"
      /* ResolveHarm3 */
    ],
    [
      "ResolveHarm3"
      /* ResolveHarm3 */
    ]: [
      "ResolveHarm2"
      /* ResolveHarm2 */
    ],
    [
      "ResolveHarm2"
      /* ResolveHarm2 */
    ]: [
      "ResolveHarm1"
      /* ResolveHarm1 */
    ],
    [
      "ResolveHarm1"
      /* ResolveHarm1 */
    ]: [
      "None"
      /* None */
    ],
    [
      "ComplicationSerious"
      /* ComplicationSerious */
    ]: [
      "ComplicationMajor"
      /* ComplicationMajor */
    ],
    [
      "ComplicationMajor"
      /* ComplicationMajor */
    ]: [
      "ComplicationMinor"
      /* ComplicationMinor */
    ],
    [
      "ComplicationMinor"
      /* ComplicationMinor */
    ]: [
      "None"
      /* None */
    ]
  },
  ConsequenceDisplay: {
    [
      "ReducedEffect"
      /* ReducedEffect */
    ]: "Reduced Effect",
    [
      "ComplicationMinor"
      /* ComplicationMinor */
    ]: "Minor Complication",
    [
      "ComplicationMajor"
      /* ComplicationMajor */
    ]: "Major Complication",
    [
      "ComplicationSerious"
      /* ComplicationSerious */
    ]: "Serious Complication",
    [
      "LostOpportunity"
      /* LostOpportunity */
    ]: "Lost Opportunity",
    [
      "WorsePosition"
      /* WorsePosition */
    ]: "Worse Position",
    [
      "InsightHarm1"
      /* InsightHarm1 */
    ]: "Level 1 Harm (Lesser)",
    [
      "InsightHarm2"
      /* InsightHarm2 */
    ]: "Level 2 Harm (Moderate)",
    [
      "InsightHarm3"
      /* InsightHarm3 */
    ]: "Level 3 Harm (Severe)",
    [
      "InsightHarm4"
      /* InsightHarm4 */
    ]: "Level 4 Harm (FATAL)",
    [
      "ProwessHarm1"
      /* ProwessHarm1 */
    ]: "Level 1 Harm (Lesser)",
    [
      "ProwessHarm2"
      /* ProwessHarm2 */
    ]: "Level 2 Harm (Moderate)",
    [
      "ProwessHarm3"
      /* ProwessHarm3 */
    ]: "Level 3 Harm (Severe)",
    [
      "ProwessHarm4"
      /* ProwessHarm4 */
    ]: "Level 4 Harm (FATAL)",
    [
      "ResolveHarm1"
      /* ResolveHarm1 */
    ]: "Level 1 Harm (Lesser)",
    [
      "ResolveHarm2"
      /* ResolveHarm2 */
    ]: "Level 2 Harm (Moderate)",
    [
      "ResolveHarm3"
      /* ResolveHarm3 */
    ]: "Level 3 Harm (Severe)",
    [
      "ResolveHarm4"
      /* ResolveHarm4 */
    ]: "Level 4 Harm (FATAL)",
    [
      "None"
      /* None */
    ]: "None"
  },
  ConsequenceIcons: {
    [
      "ReducedEffect"
      /* ReducedEffect */
    ]: "reduced-effect",
    [
      "ComplicationMinor"
      /* ComplicationMinor */
    ]: "complication-minor",
    [
      "ComplicationMajor"
      /* ComplicationMajor */
    ]: "complication-major",
    [
      "ComplicationSerious"
      /* ComplicationSerious */
    ]: "complication-serious",
    [
      "LostOpportunity"
      /* LostOpportunity */
    ]: "lost-opportunity",
    [
      "WorsePosition"
      /* WorsePosition */
    ]: "worse-position",
    [
      "InsightHarm1"
      /* InsightHarm1 */
    ]: "harm-insight-1",
    [
      "InsightHarm2"
      /* InsightHarm2 */
    ]: "harm-insight-2",
    [
      "InsightHarm3"
      /* InsightHarm3 */
    ]: "harm-insight-3",
    [
      "InsightHarm4"
      /* InsightHarm4 */
    ]: "harm-insight-4",
    [
      "ProwessHarm1"
      /* ProwessHarm1 */
    ]: "harm-prowess-1",
    [
      "ProwessHarm2"
      /* ProwessHarm2 */
    ]: "harm-prowess-2",
    [
      "ProwessHarm3"
      /* ProwessHarm3 */
    ]: "harm-prowess-3",
    [
      "ProwessHarm4"
      /* ProwessHarm4 */
    ]: "harm-prowess-4",
    [
      "ResolveHarm1"
      /* ResolveHarm1 */
    ]: "harm-resolve-1",
    [
      "ResolveHarm2"
      /* ResolveHarm2 */
    ]: "harm-resolve-2",
    [
      "ResolveHarm3"
      /* ResolveHarm3 */
    ]: "harm-resolve-3",
    [
      "ResolveHarm4"
      /* ResolveHarm4 */
    ]: "harm-resolve-4",
    [
      "None"
      /* None */
    ]: ""
  },
  RollResultDescriptions: {
    [
      "controlled"
      /* controlled */
    ]: {
      [
        "critical"
        /* critical */
      ]: "You critically succeed from a controlled position!",
      [
        "success"
        /* success */
      ]: "You fully succeed from a controlled position!",
      [
        "partial"
        /* partial */
      ]: "You partially succeed from a controlled position!",
      [
        "fail"
        /* fail */
      ]: "You fail from a controlled position!"
    },
    [
      "risky"
      /* risky */
    ]: {
      [
        "critical"
        /* critical */
      ]: "You critically succeed from a risky position!",
      [
        "success"
        /* success */
      ]: "You fully succeed from a risky position!",
      [
        "partial"
        /* partial */
      ]: "You partially succeed from a risky position!",
      [
        "fail"
        /* fail */
      ]: "You fail from a risky position!"
    },
    [
      "desperate"
      /* desperate */
    ]: {
      [
        "critical"
        /* critical */
      ]: "You critically succeed from a desperate position!",
      [
        "success"
        /* success */
      ]: "You fully succeed from a desperate position!",
      [
        "partial"
        /* partial */
      ]: "You partially succeed from a desperate position!",
      [
        "fail"
        /* fail */
      ]: "You fail from a desperate position!"
    }
  },
  Loadout: {
    selections: [
      { value: "Light", display: "Light" },
      { value: "Normal", display: "Normal" },
      { value: "Heavy", display: "Heavy" }
    ],
    levels: ["BITD.Light", "BITD.Normal", "BITD.Heavy", "BITD.Encumbered", "BITD.OverMax"]
  },
  AttributeTooltips: {
    [
      "insight"
      /* insight */
    ]: "<p>Resists consequences from <strong>deception</strong> or <strong>understanding</strong></p>",
    [
      "prowess"
      /* prowess */
    ]: "<p>Resists consequences from <strong>physical strain</strong> or <strong>injury</strong></p>",
    [
      "resolve"
      /* resolve */
    ]: "<p>Resists consequences from <strong>mental strain</strong> or <strong>willpower</strong></p>"
  },
  ShortAttributeTooltips: {
    [
      "insight"
      /* insight */
    ]: "vs. <strong>deception</strong> or <strong>(mis)understanding</strong>",
    [
      "prowess"
      /* prowess */
    ]: "vs. <strong>physical strain</strong> or <strong>injury</strong>",
    [
      "resolve"
      /* resolve */
    ]: "vs. <strong>mental strain</strong> or <strong>willpower</strong>"
  },
  ShortActionTooltips: {
    [
      "hunt"
      /* hunt */
    ]: "carefully track a target",
    [
      "study"
      /* study */
    ]: "scrutinize details and interpret evidence",
    [
      "survey"
      /* survey */
    ]: "observe the situation and anticipate outcomes",
    [
      "tinker"
      /* tinker */
    ]: "fiddle with devices and mechanisms",
    [
      "finesse"
      /* finesse */
    ]: "employ dexterity or subtle misdirection",
    [
      "prowl"
      /* prowl */
    ]: "traverse skillfully and quietly",
    [
      "skirmish"
      /* skirmish */
    ]: "entangle a target in melee so they can't escape",
    [
      "wreck"
      /* wreck */
    ]: "unleash savage force",
    [
      "attune"
      /* attune */
    ]: "open your mind to the ghost field or channel nearby electroplasmic energy through your body",
    [
      "command"
      /* command */
    ]: "compel swift obedience",
    [
      "consort"
      /* consort */
    ]: "socialize with friends and contacts",
    [
      "sway"
      /* sway */
    ]: "influence someone with guile, charm, or argument"
  },
  ActionTooltips: {
    [
      "hunt"
      /* hunt */
    ]: "<p>When you <strong>Hunt</strong>, you carefully track a target.</p><ul><li>You might follow a person or discover their location.</li><li>You might arrange an ambush.</li><li>You might attack with precision shooting from a distance.</li></ul><ul><li>You could try to wield your guns in a melee <em>(but <strong>Skirmishing</strong> might be better)</em>.</li></ul>",
    [
      "study"
      /* study */
    ]: "<p>When you <strong>Study</strong>, you scrutinize details and interpret evidence.</p><ul><li>You might gather information from documents, newspapers, and books.</li><li>You might do research on an esoteric topic.</li><li>You might closely analyze a person to detect lies or true feelings.</li></ul><ul><li>You could try to understand a pressing situation <em>(but <strong>Surveying</strong> might be better)</em>.</li></ul>",
    [
      "survey"
      /* survey */
    ]: "<p>When you <strong>Survey</strong>, you observe the situation and anticipate outcomes.</p><ul><li>You might spot telltale signs of trouble before it happens.</li><li>You might uncover opportunities or weaknesses.</li></ul><ul><li>You might detect a person's motives or intentions <em>(but <strong>Studying</strong> might be better)</em>.</li><li>You could try to spot a good ambush point <em>(but <strong>Hunting</strong> might be better)</em>.</li></ul>",
    [
      "tinker"
      /* tinker */
    ]: "<p>When you <strong>Tinker</strong>, you fiddle with devices and mechanisms.</p><ul><li>You might create a new gadget or alter an existing item.</li><li>You might pick a lock or crack a safe.</li><li>You might disable an alarm or trap.</li><li>You might turn the sparkcraft and electroplasmic devices around the city to your advantage.</li></ul><ul><li>You could try to control a vehicle with your tech-savvy <em>(but <strong>Finessing</strong> might be better)</em>.</li></ul>",
    [
      "finesse"
      /* finesse */
    ]: "<p>When you <strong>Finesse</strong>, you employ dexterity or subtle misdirection.</p><ul><li>You might pick someone's pocket.</li><li>You might handle the controls of a vehicle or direct a mount.</li><li>You might formally duel an opponent with graceful fighting arts.</li></ul><ul><li>You could try to leverage agility in a melee <em>(but <strong>Skirmishing</strong> might be better)</em>.</li><li>You could try to pick a lock <em>(but <strong>Tinkering</strong> might be better)</em>.</li></ul>",
    [
      "prowl"
      /* prowl */
    ]: "<p>When you <strong>Prowl</strong>, you traverse skillfully and quietly.</p><ul><li>You might sneak past a guard or hide in the shadows.</li><li>You might run and leap across the rooftops.</li><li>You might attack someone from hiding with a back-stab or blackjack.</li></ul><ul><li>You could try to waylay a victim during combat <em>(but <strong>Skirmishing</strong> might be better)</em>.</li></ul>",
    [
      "skirmish"
      /* skirmish */
    ]: "<p>When you <strong>Skirmish</strong>, you entangle a target in melee so they can't escape.</p><ul><li>You might brawl or wrestle with them.</li><li>You might hack and slash.</li><li>You might seize or hold a position in battle.</li></ul><ul><li>You could try to fight in a formal duel <em>(but <strong>Finessing</strong> might be better)</em>.</li></ul>",
    [
      "wreck"
      /* wreck */
    ]: "<p>When you <strong>Wreck</strong>, you unleash savage force.</p><ul><li>You might smash down a door or wall with a sledgehammer.</li><li>You might use an explosive to do the same.</li><li>You might use chaos or sabotage to create distractions or overcome obstacles.</li></ul><ul><li>You could try to overwhelm an enemy with sheer force in battle <em>(but <strong>Skirmishing</strong> might be better)</em>.</li></ul>",
    [
      "attune"
      /* attune */
    ]: "<p>When you <strong>Attune</strong>, you open your mind to the ghost field or channel nearby electroplasmic energy through your body.</p><ul><li>You might communicate with a ghost or understand aspects of spectrology.</li><li>You might peer into the echo of Doskvol in the ghost field.</li></ul><ul><li>You could try to perceive beyond sight in order to better understand your situation <em>(but <strong>Surveying</strong> might be better)</em>.</li></ul>",
    [
      "command"
      /* command */
    ]: "<p>When you <strong>Command</strong>, you compel swift obedience.</p><ul><li>You might intimidate or threaten to get what you want.</li><li>You might lead a gang in a group action.</li></ul><ul><li>You could try to persuade people by giving orders <em>(but <strong>Consorting</strong> might be better)</em>.</li></ul>",
    [
      "consort"
      /* consort */
    ]: "<p>When you <strong>Consort</strong>, you socialize with friends and contacts.</p><ul><li>You might gain access to resources, information, people, or places.</li><li>You might make a good impression or win someone over with charm and style.</li><li>You might make new friends or connect with your heritage or background.</li></ul><ul><li>You could try to direct allies with social pressure <em>(but <strong>Commanding</strong> might be better)</em>.</li></ul>",
    [
      "sway"
      /* sway */
    ]: "<p>When you <strong>Sway</strong>, you influence someone with guile, charm, or argument.</p><ul><li>You might lie convincingly.</li><li>You might persuade someone to do what you want.</li><li>You might argue a case that leaves no clear rebuttal.</li></ul><ul><li>You could try to trick people into affection or obedience <em>(but <strong>Consorting</strong> or <strong>Commanding</strong> might be better)</em>.</li></ul>"
  },
  ActionTooltipsGM: {
    [
      "hunt"
      /* hunt */
    ]: "<p>When you <strong>Hunt</strong>, you carefully track a target.</p><ul><li>You might follow a person or discover their location.</li><li>You might arrange an ambush.</li><li>You might attack with precision shooting from a distance.</li></ul><ul><li>You could try to wield your guns in a melee <em>(but <strong>Skirmishing</strong> might be better)</em>.</li></ul><hr><ul><li>How do you hunt them down?</li><li>What methods do you use?</li><li>What do you hope to achieve?</li></ul>",
    [
      "study"
      /* study */
    ]: "<p>When you <strong>Study</strong>, you scrutinize details and interpret evidence.</p><ul><li>You might gather information from documents, newspapers, and books.</li><li>You might do research on an esoteric topic.</li><li>You might closely analyze a person to detect lies or true feelings.</li></ul><ul><li>You could try to understand a pressing situation <em>(but <strong>Surveying</strong> might be better)</em>.</li></ul><hr><ul><li>What do you study?</li><li>What details or evidence do you scrutinize?</li><li>What do you hope to understand?</li></ul>",
    [
      "survey"
      /* survey */
    ]: "<p>When you <strong>Survey</strong>, you observe the situation and anticipate outcomes.</p><ul><li>You might spot telltale signs of trouble before it happens.</li><li>You might uncover opportunities or weaknesses.</li></ul><ul><li>You might detect a person's motives or intentions <em>(but <strong>Studying</strong> might be better)</em>.</li><li>You could try to spot a good ambush point <em>(but <strong>Hunting</strong> might be better)</em>.</li></ul><hr><ul><li>How do you survey the situation?</li><li>Is there anything special you're looking out for?</li><li>What do you hope to understand?</li></ul>",
    [
      "tinker"
      /* tinker */
    ]: "<p>When you <strong>Tinker</strong>, you fiddle with devices and mechanisms.</p><ul><li>You might create a new gadget or alter an existing item.</li><li>You might pick a lock or crack a safe.</li><li>You might disable an alarm or trap.</li><li>You might turn the sparkcraft and electroplasmic devices around the city to your advantage.</li></ul><ul><li>You could try to control a vehicle with your tech-savvy <em>(but <strong>Finessing</strong> might be better)</em>.</li></ul><hr><ul><li>What do you tinker with?</li><li>What do you hope to accomplish?</li></ul>",
    [
      "finesse"
      /* finesse */
    ]: "<p>When you <strong>Finesse</strong>, you employ dexterity or subtle misdirection.</p><ul><li>You might pick someone's pocket.</li><li>You might handle the controls of a vehicle or direct a mount.</li><li>You might formally duel an opponent with graceful fighting arts.</li></ul><ul><li>You could try to leverage agility in a melee <em>(but <strong>Skirmishing</strong> might be better)</em>.</li><li>You could try to pick a lock <em>(but <strong>Tinkering</strong> might be better)</em>.</li></ul><hr><ul><li>What do you finesse?</li><li>What's graceful or subtle about this?</li><li>What do you hope to achieve?</li></ul>",
    [
      "prowl"
      /* prowl */
    ]: "<p>When you <strong>Prowl</strong>, you traverse skillfully and quietly.</p><ul><li>You might sneak past a guard or hide in the shadows.</li><li>You might run and leap across the rooftops.</li><li>You might attack someone from hiding with a back-stab or blackjack.</li></ul><ul><li>You could try to waylay a victim during combat <em>(but <strong>Skirmishing</strong> might be better)</em>.</li></ul><hr><ul><li>How do you prowl?</li><li>How do you use the environment around you?</li><li>What do you hope to achieve?</li></ul>",
    [
      "skirmish"
      /* skirmish */
    ]: "<p>When you <strong>Skirmish</strong>, you entangle a target in melee so they can't escape.</p><ul><li>You might brawl or wrestle with them.</li><li>You might hack and slash.</li><li>You might seize or hold a position in battle.</li></ul><ul><li>You could try to fight in a formal duel <em>(but <strong>Finessing</strong> might be better)</em>.</li></ul><hr><ul><li>How do you skirmish with them?</li><li>What combat methods do you use?</li><li>What do you hope to achieve?</li></ul>",
    [
      "wreck"
      /* wreck */
    ]: "<p>When you <strong>Wreck</strong>, you unleash savage force.</p><ul><li>You might smash down a door or wall with a sledgehammer.</li><li>You might use an explosive to do the same.</li><li>You might use chaos or sabotage to create distractions or overcome obstacles.</li></ul><ul><li>You could try to overwhelm an enemy with sheer force in battle <em>(but <strong>Skirmishing</strong> might be better)</em>.</li></ul><hr><ul><li>What do you wreck?</li><li>What force do you bring to bear?</li><li>What do you hope to accomplish?</li></ul>",
    [
      "attune"
      /* attune */
    ]: "<p>When you <strong>Attune</strong>, you open your mind to the ghost field or channel nearby electroplasmic energy through your body.</p><ul><li>You might communicate with a ghost or understand aspects of spectrology.</li><li>You might peer into the echo of Doskvol in the ghost field.</li></ul><ul><li>You could try to perceive beyond sight in order to better understand your situation <em>(but <strong>Surveying</strong> might be better)</em>.</li></ul><hr><ul><li>How do you open your mind to the ghost field?</li><li>What does that look like?</li><li>What energy are you attuning to?</li><li>How are you channeling that energy?</li><li>What do you hope the energy will do?</li></ul>",
    [
      "command"
      /* command */
    ]: "<p>When you <strong>Command</strong>, you compel swift obedience.</p><ul><li>You might intimidate or threaten to get what you want.</li><li>You might lead a gang in a group action.</li></ul><ul><li>You could try to persuade people by giving orders <em>(but <strong>Consorting</strong> might be better)</em>.</li></ul><hr><ul><li>Who do you command?</li><li>How do you do it—what's your leverage here?</li><li>What do you hope they'll do?</li></ul>",
    [
      "consort"
      /* consort */
    ]: "<p>When you <strong>Consort</strong>, you socialize with friends and contacts.</p><ul><li>You might gain access to resources, information, people, or places.</li><li>You might make a good impression or win someone over with charm and style.</li><li>You might make new friends or connect with your heritage or background.</li></ul><ul><li>You could try to direct allies with social pressure <em>(but <strong>Commanding</strong> might be better)</em>.</li></ul><hr><ul><li>Who do you consort with?</li><li>Where do you meet?</li><li>What do you talk about?</li><li>What do you hope to achieve?</li></ul>",
    [
      "sway"
      /* sway */
    ]: "<p>When you <strong>Sway</strong>, you influence someone with guile, charm, or argument.</p><ul><li>You might lie convincingly.</li><li>You might persuade someone to do what you want.</li><li>You might argue a case that leaves no clear rebuttal.</li></ul><ul><li>You could try to trick people into affection or obedience <em>(but <strong>Consorting</strong> or <strong>Commanding</strong> might be better)</em>.</li></ul><hr><ul><li>Who do you sway?</li><li>What kind of leverage do you have here?</li><li>What do you hope they'll do?</li></ul>"
  },
  ActionVerbs: {
    [
      "hunt"
      /* hunt */
    ]: "hunts",
    [
      "study"
      /* study */
    ]: "studies",
    [
      "survey"
      /* survey */
    ]: "surveys",
    [
      "tinker"
      /* tinker */
    ]: "tinkers",
    [
      "finesse"
      /* finesse */
    ]: "finesses",
    [
      "prowl"
      /* prowl */
    ]: "prowls",
    [
      "skirmish"
      /* skirmish */
    ]: "skirmishes",
    [
      "wreck"
      /* wreck */
    ]: "wrecks",
    [
      "attune"
      /* attune */
    ]: "attunes",
    [
      "command"
      /* command */
    ]: "commands",
    [
      "consort"
      /* consort */
    ]: "consorts",
    [
      "sway"
      /* sway */
    ]: "sways"
  },
  ActionPastVerbs: {
    [
      "hunt"
      /* hunt */
    ]: "hunted",
    [
      "study"
      /* study */
    ]: "studied",
    [
      "survey"
      /* survey */
    ]: "surveyed",
    [
      "tinker"
      /* tinker */
    ]: "tinkered",
    [
      "finesse"
      /* finesse */
    ]: "finessed",
    [
      "prowl"
      /* prowl */
    ]: "prowled",
    [
      "skirmish"
      /* skirmish */
    ]: "skirmished",
    [
      "wreck"
      /* wreck */
    ]: "wrecked",
    [
      "attune"
      /* attune */
    ]: "attuned",
    [
      "command"
      /* command */
    ]: "commanded",
    [
      "consort"
      /* consort */
    ]: "consorted",
    [
      "sway"
      /* sway */
    ]: "swayed"
  },
  TraumaTooltips: {
    Cold: "You're not moved by emotional appeals or social bonds.",
    Haunted: "You're often lost in reverie, reliving past horrors, seeing things.",
    Obsessed: "You're enthralled by one thing: an activity, a person, an ideology.",
    Paranoid: "You imagine danger everywhere; you can't trust others.",
    Reckless: "You have little regard for your own safety or best interests.",
    Soft: "You lose your edge; you become sentimental, passive, gentle.",
    Unstable: "Your emotional state is volatile. You can instantly rage, or fall into despair, act impulsively, or freeze up.",
    Vicious: "You seek out opportunities to hurt people, even for no good reason.",
    Chaotic: "You've become so detached from the living that inhibitions fall away, leaving you impulsive and unpredictable.",
    Destructive: "You are easily angered by reminders of all you've lost, and can lash out violently against the trappings of the living world.",
    Furious: "Your ravaged soul is fertile kindling for rage, and your fury is easily ignited.",
    Obsessive: "Your wants and desires become fixations and compulsions, driving you to achieve them at any cost.",
    Territorial: "You see some place as yours: Trespassers are dealt with, and even guests must respect your claim.",
    Savage: "When moved to anger or violence, you act with cruelty and feral malevolence.",
    Clanking: "Your frame has developed a persistent metallic clang with each step, making stealth difficult.",
    Leaking: "You continuously leak oil, leviathan blood, distilled electroplasm or some other potentially-dangerous substance.",
    Fixated: "You have become fixated on a function of your choice, and lose all memory of your humanity when you pursue it.",
    Smoking: "Your frame exudes a constant miasma of acrid, foul-smelling smoke.",
    Sparking: "Electroplasmic energy erupts in arcing sparks from joints and junctions throughout your frame.",
    Ruthless: "You lose any sense of humanity when indulging your Vice or pursuing your most important goal.",
    Secretive: "Knowledge has become so precious to you, that even your closest allies are on a need-to-know basis."
  },
  EdgeTooltips: {
    "Fearsome": "<p>The cohort is terrifying in aspect and reputation.</p>",
    "Independent": "<p>The cohort can be trusted to make good decisions and act on their own initiative in the absence of direct orders.</p>",
    "Loyal": "<p>The cohort can't be bribed or turned against you. </p>",
    "Tenacious": "<p>The cohort won't be deterred from a task.</p>",
    "Nimble": "<p>The vehicle handles easily. Consider this an <strong>assist</strong> for tricky maneuvers.</p>",
    "Simple": "<p>The vehicle is easy to repair. Remove all of its <strong>Harm</strong> during <strong>downtime</strong></p>",
    "Sturdy": "<p>The vehicle keeps operating even when <strong>Broken</strong>.</p>",
    "Arrow-Swift": "<p>Your pet gains <strong>Potency</strong> when tracking or fighting the supernatural.</p><p>It can move extremely quickly, outpacing any other creature or vehicle.</p>",
    "Ghost Form": "<p>Your pet gains <strong>Potency</strong> when tracking or fighting the supernatural.</p><p>It can transform into electroplasmic vapor as if it were a spirit.</p>",
    "Mind Link": "<p>Your pet gains <strong>Potency</strong> when tracking or fighting the supernatural.</p><p>You and your pet can share senses and thoughts telepathically.</p>"
  },
  FlawTooltips: {
    Principled: "<p>The cohort has an ethic or values that it won't betray.</p>",
    Savage: "<p>The cohort is excessively violent and cruel.</p>",
    Unreliable: "<p>The cohort isn't always available, due to other obligations, stupefaction from their vices, etc.</p>",
    Wild: "<p>The cohort is drunken, debauched, and loud-mouthed.</p>",
    Costly: "<p>The vehicle costs <strong>1 Coin</strong> per <strong>downtime</strong> to keep it in operation.</p>",
    Distinct: "<p>The vehicle has memorable features. Take <strong>+1 Heat</strong> when you use it on a score.</p>",
    Finicky: "<p>The vehicle has quirks that only one person understands. When operated without them, it has <strong>-1 Quality</strong>.</p>"
  },
  QualityDescriptors: [
    "Poor",
    "Adequate",
    "Good",
    "Excellent",
    "Superior",
    "Impeccable",
    "Legendary"
  ],
  ForceDescriptors: [
    "Weak",
    "Moderate",
    "Strong",
    "Serious",
    "Powerful",
    "Overwhelming",
    "Devastating"
  ],
  VehicleDescriptors: [
    "A Vehicle?",
    "A Vehicle",
    "A Respectable Vehicle",
    "A Respected Vehicle",
    "A Precision-Built Vehicle",
    "A Powerful, Advanced Vehicle",
    "A Uniquely Strong, Extremely Advanced Vehicle"
  ],
  PetDescriptors: [
    "A Weak Hunting Pet",
    "A Hunting Pet",
    "A Strong Hunting Pet",
    "A Serious Hunting Pet",
    "A Powerful Hunting Pet",
    "An Overwhelmingly Powerful Hunting Pet",
    "A Devastating Hunting Pet"
  ],
  AreaExamples: [
    "a closet",
    "a small room",
    "a large room",
    "several rooms",
    "a small building",
    "a large building",
    "a city block"
  ],
  ScaleExamples: [
    "(1 or 2 members)",
    "(3 - 6 members)",
    "(~12 members)",
    "(~20 members)",
    "(~40 members)",
    "(~80 members)",
    "(~160 members)"
  ],
  ScaleSizes: [
    "A Few ",
    "A Small Gang of ",
    "A Gang of ",
    "A Large Gang of ",
    "A Small Army of ",
    "An Army of ",
    "A Massive Army of "
  ],
  DiceOddsStandard: [
    { crit: 0, success: 2.8, partial: 22.2, fail: 75 },
    { crit: 0, success: 16.7, partial: 33.3, fail: 50 },
    { crit: 2.8, success: 27.8, partial: 44.4, fail: 25 },
    { crit: 7.4, success: 34.7, partial: 45.4, fail: 12.5 },
    { crit: 13.2, success: 38.6, partial: 42, fail: 6.3 },
    { crit: 19.6, success: 40.2, partial: 37.1, fail: 3.1 },
    { crit: 26.3, success: 40.2, partial: 31.9, fail: 1.6 },
    { crit: 33, success: 39.1, partial: 27.1, fail: 0.8 },
    { crit: 39.5, success: 37.2, partial: 22.9, fail: 0.4 },
    { crit: 45.7, success: 34.9, partial: 19.2, fail: 0.2 },
    { crit: 51.5, success: 32.3, partial: 16.1, fail: 0.1 },
    { crit: 56.9, success: 29.6, partial: 13.4, fail: 0 },
    { crit: 61.9, success: 26.9, partial: 11.2, fail: 0 },
    { crit: 66.3, success: 24.3, partial: 9.3, fail: 0 },
    { crit: 70.4, success: 21.8, partial: 7.8, fail: 0 },
    { crit: 74, success: 19.5, partial: 6.5, fail: 0 },
    { crit: 77.3, success: 17.3, partial: 5.4, fail: 0 },
    { crit: 80.2, success: 15.3, partial: 4.5, fail: 0 },
    { crit: 82.7, success: 13.5, partial: 3.8, fail: 0 },
    { crit: 85, success: 11.9, partial: 3.1, fail: 0 },
    { crit: 87, success: 10.4, partial: 2.6, fail: 0 }
  ],
  DiceOddsResistance: [
    // Stress Cost: [-1, 0, 1, 2, 3, 4, 5]
    [0, 2.8, 8.3, 13.9, 19.4, 25, 30.6],
    [0, 16.7, 16.7, 16.7, 16.6, 16.7, 16.7],
    [2.8, 27.8, 25, 19.4, 13.9, 8.3, 2.8],
    [7.4, 34.7, 28.3, 17.1, 8.8, 3.2, 0.5],
    [13.2, 38.6, 28.5, 13.5, 5, 1.2, 0.1],
    [19.6, 40.2, 27, 10.1, 2.7, 0.4, 0],
    [26.3, 40.2, 24.7, 7.2, 1.4, 0.1, 0]
  ],
  ExperienceClues: {
    Scoundrel: [
      "You expressed your beliefs, drives, heritage, or background.",
      "You struggled with issues from your vice or traumas during the session."
    ],
    Crew: [
      "You contended with challenges above your current station.",
      "You bolstered your crew's reputation, or developed a new one.",
      "You expressed the goals, drives, inner conflict, or essential nature of the crew."
    ]
  },
  GatherInfoQuestions: {
    Cutter: [
      "How can I hurt them?",
      "Who's most afraid of me?",
      "Who's most dangerous here?",
      "What do they intend to do?",
      "How can I get them to [X]?",
      "Are they telling the truth?",
      "What's really going on here?"
    ],
    Hound: [
      "What do they intend to do?",
      "How can I get them to [X]?",
      "What are they really feeling?",
      "Where are they vulnerable?",
      "Where did [X] go?",
      "How can I find [X]?",
      "What's really going on here?"
    ],
    Leech: [
      "What do they intend to do?",
      "How can I get them to [X]?",
      "Are they telling the truth?",
      "What can I tinker with here?",
      "What might happen if I [X]?",
      "How can I find [X]?",
      "What's really going on here?"
    ],
    Lurk: [
      "What do they intend to do?",
      "How can I get them to [X]?",
      "What should I look out for?",
      "What's the best way in?",
      "Where can I hide here?",
      "How can I find [X]?",
      "What's really going on here?"
    ],
    Slide: [
      "What do they intend to do?",
      "How can I get them to [X]?",
      "Are they telling the truth?",
      "What are they really feeling?",
      "What do they really care about?",
      "How can I blend in here?",
      "What's really going on here?"
    ],
    Spider: [
      "What do they want most?",
      "What should I look out for?",
      "Where's the leverage here?",
      "How can I discover [X]?",
      "What do they intend to do?",
      "How can I get them to [X]?",
      "What's really going on here?"
    ],
    Whisper: [
      "What is arcane or weird here?",
      "What echoes in the ghost field?",
      "What is hidden or lost here?",
      "What do they intend to do?",
      "What drives them to do this?",
      "How can I reveal [X]?",
      "What's really going on here?"
    ],
    Ghost: [
      "What do they intend to do?",
      "How can I get them to [X]?",
      "What are they really feeling?",
      "What should I lookout for?",
      "Where's the weakness here?",
      "How can I find [X]?",
      "What's really going on here?"
    ],
    Hull: [
      "What do they intend to do?",
      "How can I get them to [X]?",
      "What are they really doing?",
      "What should I lookout for?",
      "Where's the weakness here?",
      "How can I find [X]?",
      "What's really going on here?"
    ],
    Vampire: [
      "What do they intend to do?",
      "How can I get them to [X]?",
      "What are they really feeling?",
      "What should I lookout for?",
      "Where's the weakness here?",
      "How can I find [X]?",
      "What's really going on here?"
    ]
  },
  Playbooks: {
    Cutter: {
      "system.experience_clues": [
        "You addressed a challenge with violence or coercion.",
        "You expressed your beliefs, drives, heritage, or background.",
        "You struggled with issues from your vice or traumas during the session."
      ],
      "system.trauma_conditions": ["Cold", "Haunted", "Obsessed", "Paranoid", "Reckless", "Soft", "Unstable", "Vicious"],
      "system.gather_info_questions": [
        "How can I hurt them?",
        "Who's most afraid of me?",
        "Who's most dangerous here?",
        "What do they intend to do?",
        "How can I get them to [X]?",
        "Are they telling the truth?",
        "What's really going on here?"
      ],
      "system.suggested_ability": "Battleborn"
    },
    Hound: {
      "system.bgImg": "systems/eunos-blades/assets/icons/class-icons/hound-trans.svg",
      "system.tagline": "A Deadly Sharpshooter & Tracker",
      // "system.acquaintances_name": "Deadly Friends & Rivals",
      "system.friends_name": "Deadly Friends",
      "system.rivals_name": "Deadlier Rivals",
      "system.starting_stats.chargen": {
        "system.attributes.insight.hunt.value": 2,
        "system.attributes.insight.survey.value": 1
      },
      "system.experience_clues": [
        "You addressed a challenge with tracking or violence.",
        "You expressed your beliefs, drives, heritage, or background.",
        "You struggled with issues from your vice or traumas during the session."
      ],
      "system.trauma_conditions": ["Cold", "Haunted", "Obsessed", "Paranoid", "Reckless", "Soft", "Unstable", "Vicious"],
      "system.gather_info_questions": [
        "What do they intend to do?",
        "How can I get them to [X]?",
        "What are they really feeling?",
        "Where are they vulnerable?",
        "Where did [X] go?",
        "How can I find [X]?",
        "What's really going on here?"
      ],
      "system.suggested_ability": "Sharpshooter"
    },
    Leech: {
      "system.bgImg": "systems/eunos-blades/assets/icons/class-icons/leech-trans.svg",
      "system.tagline": "A Saboteur & Technician",
      // "system.acquaintances_name": "Clever Friends & Rivals",
      "system.friends_name": "Clever Friends",
      "system.rivals_name": "Cleverer Rivals",
      "system.starting_stats.chargen": {
        "system.attributes.insight.tinker.value": 2,
        "system.attributes.prowess.wreck.value": 1
      },
      "system.experience_clues": [
        "You addressed a challenge with technical skill or mayhem.",
        "You expressed your beliefs, drives, heritage, or background.",
        "You struggled with issues from your vice or traumas during the session."
      ],
      "system.trauma_conditions": ["Cold", "Haunted", "Obsessed", "Paranoid", "Reckless", "Soft", "Unstable", "Vicious"],
      "system.gather_info_questions": [
        "What do they intend to do?",
        "How can I get them to [X]?",
        "Are they telling the truth?",
        "What can I tinker with here?",
        "What might happen if I [X]?",
        "How can I find [X]?",
        "What's really going on here?"
      ],
      "system.suggested_ability": "Alchemist"
    },
    Lurk: {
      "system.bgImg": "systems/eunos-blades/assets/icons/class-icons/lurk-trans.svg",
      "system.tagline": "A Stealthy Infiltrator & Burglar",
      // "system.acquaintances_name": "Shady Friends & Rivals",
      "system.friends_name": "Shady Friends",
      "system.rivals_name": "Shadier Rivals",
      "system.starting_stats.chargen": {
        "system.attributes.prowess.prowl.value": 2,
        "system.attributes.prowess.finesse.value": 1
      },
      "system.experience_clues": [
        "You addressed a challenge with stealth or evasion.",
        "You expressed your beliefs, drives, heritage, or background.",
        "You struggled with issues from your vice or traumas during the session."
      ],
      "system.trauma_conditions": ["Cold", "Haunted", "Obsessed", "Paranoid", "Reckless", "Soft", "Unstable", "Vicious"],
      "system.gather_info_questions": [
        "What do they intend to do?",
        "How can I get them to [X]?",
        "What should I look out for?",
        "What's the best way in?",
        "Where can I hide here?",
        "How can I find [X]?",
        "What's really going on here?"
      ],
      "system.suggested_ability": "Infiltrator"
    },
    Slide: {
      "system.bgImg": "systems/eunos-blades/assets/icons/class-icons/slide-trans.svg",
      "system.tagline": "A Subtle Manipulator & Spy",
      // "system.acquaintances_name": "Sly Friends & Rivals",
      "system.friends_name": "Sly Friends",
      "system.rivals_name": "Slyer Rivals",
      "system.starting_stats.chargen": {
        "system.attributes.resolve.sway.value": 2,
        "system.attributes.resolve.consort.value": 1
      },
      "system.experience_clues": [
        "You addressed a challenge with deception or influence.",
        "You expressed your beliefs, drives, heritage, or background.",
        "You struggled with issues from your vice or traumas during the session."
      ],
      "system.trauma_conditions": ["Cold", "Haunted", "Obsessed", "Paranoid", "Reckless", "Soft", "Unstable", "Vicious"],
      "system.gather_info_questions": [
        "What do they intend to do?",
        "How can I get them to [X]?",
        "Are they telling the truth?",
        "What are they really feeling?",
        "What do they really care about?",
        "How can I blend in here?",
        "What's really going on here?"
      ],
      "system.suggested_ability": "Rook's Gambit"
    },
    Spider: {
      "system.bgImg": "systems/eunos-blades/assets/icons/class-icons/spider-trans.svg",
      "system.tagline": "A Devious Mastermind",
      // "system.acquaintances_name": "Shrewd Friends & Rivals",
      "system.friends_name": "Shrewd Friends",
      "system.rivals_name": "Very Shrewd Rivals",
      "system.starting_stats.chargen": {
        "system.attributes.resolve.consort.value": 2,
        "system.attributes.insight.study.value": 1
      },
      "system.experience_clues": [
        "You addressed a challenge with calculation or conspiracy.",
        "You expressed your beliefs, drives, heritage, or background.",
        "You struggled with issues from your vice or traumas during the session."
      ],
      "system.trauma_conditions": ["Cold", "Haunted", "Obsessed", "Paranoid", "Reckless", "Soft", "Unstable", "Vicious"],
      "system.gather_info_questions": [
        "What do they want most?",
        "What should I look out for?",
        "Where's the leverage here?",
        "How can I discover [X]?",
        "What do they intend to do?",
        "How can I get them to [X]?",
        "What's really going on here?"
      ],
      "system.suggested_ability": "Foresight"
    },
    Whisper: {
      "system.bgImg": "systems/eunos-blades/assets/icons/class-icons/whisper-trans.svg",
      "system.tagline": "An Arcane Adept & Channeler",
      // "system.acquaintances_name": "Strange Friends & Rivals",
      "system.friends_name": "Strange Friends",
      "system.rivals_name": "Stranger Rivals",
      "system.starting_stats.chargen": {
        "system.attributes.resolve.attune.value": 2,
        "system.attributes.insight.study.value": 1
      },
      "system.experience_clues": [
        "You addressed a challenge with knowledge or arcane power.",
        "You expressed your beliefs, drives, heritage, or background.",
        "You struggled with issues from your vice or traumas during the session."
      ],
      "system.trauma_conditions": ["Cold", "Haunted", "Obsessed", "Paranoid", "Reckless", "Soft", "Unstable", "Vicious"],
      "system.gather_info_questions": [
        "What is arcane or weird here?",
        "What echoes in the ghost field?",
        "What is hidden or lost here?",
        "What do they intend to do?",
        "What drives them to do this?",
        "How can I reveal [X]?",
        "What's really going on here?"
      ],
      "system.suggested_ability": "Compel"
    },
    Ghost: {
      "system.bgImg": "systems/eunos-blades/assets/icons/class-icons/ghost-trans.svg",
      "system.tagline": "A Vengeful Disembodied Spirit",
      "system.acquaintances_name": "Enemies & Rivals",
      "system.starting_stats.add": {
        "system.attributes.insight.hunt.value": 1,
        "system.attributes.prowess.prowl.value": 1,
        "system.attributes.resolve.attune.value": 1
      },
      "system.experience_clues": [
        "You exacted vengeance upon those whom you deem deserving.",
        "You expressed your outrage or anger, or settled scores from your heritage, or background.",
        "You struggled with issues from your need or glooms during the session."
      ],
      "system.trauma_conditions": ["Chaotic", "Destructive", "Furious", "Obsessive", "Territorial", "Savage"],
      "system.gather_info_questions": [
        "What do they intend to do?",
        "How can I get them to [X]?",
        "What are they really feeling?",
        "What should I lookout for?",
        "Where's the weakness here?",
        "How can I find [X]?",
        "What's really going on here?"
      ],
      "system.auto_abilities": ["Ghost Form"]
    },
    Hull: {
      "system.bgImg": "systems/eunos-blades/assets/icons/class-icons/hull-trans.svg",
      "system.tagline": "An Animated Spark-Craft Frame",
      "system.acquaintances_name": "Master",
      "system.starting_stats.add": {
        "system.attributes.prowess.skirmish.value": 1,
        "system.attributes.resolve.attune.value": 1
      },
      "system.experience_clues": [
        "You fulfilled your functions despite difficulty or danger.",
        "You suppressed or ignored your former human beliefs, drives, heritage, or background.",
        "You struggled with issues from your wear during the session."
      ],
      "system.trauma_conditions": ["Clanking", "Leaking", "Fixated", "Smoking", "Sparking", "Unstable"],
      "system.gather_info_questions": [
        "What do they intend to do?",
        "How can I get them to [X]?",
        "What are they really doing?",
        "What should I lookout for?",
        "Where's the weakness here?",
        "How can I find [X]?",
        "What's really going on here?"
      ],
      "system.auto_abilities": ["Automaton"]
    },
    Vampire: {
      "system.bgImg": "systems/eunos-blades/assets/icons/class-icons/vampire-trans.svg",
      "system.tagline": "An Animated Undead Body",
      "system.acquaintances_name": "Dark Servants",
      "system.starting_stats.add": {
        "system.attributes.insight.hunt.value": 1,
        "system.attributes.prowess.prowl.value": 1,
        "system.attributes.prowess.skirmish.value": 1,
        "system.attributes.resolve.attune.value": 1,
        "system.attributes.resolve.command.value": 1,
        "system.attributes.resolve.sway.value": 1
      },
      "system.experience_clues": [
        "You displayed your dominance or slayed without mercy.",
        "You expressed your beliefs, drives, heritage, or background.",
        "You struggled with issues from your vice, traumas, or strictures during the session."
      ],
      "system.trauma_conditions": ["Cold", "Haunted", "Obsessed", "Paranoid", "Ruthless", "Secretive", "Unstable", "Vicious"],
      "system.gather_info_questions": [
        "What do they intend to do?",
        "How can I get them to [X]?",
        "What are they really feeling?",
        "What should I lookout for?",
        "Where's the weakness here?",
        "How can I find [X]?",
        "What's really going on here?"
      ],
      "system.auto_abilities": ["Undead"]
    }
  },
  ClockSizes: [1, 2, 3, 4, 5, 6, 8, 10, 12],
  ActorTypes: [
    "pc",
    "npc",
    "crew",
    "faction"
    /* faction */
  ],
  ItemTypes: [
    "ability",
    "background",
    "clock_keeper",
    "cohort_gang",
    "cohort_expert",
    "crew_ability",
    "crew_reputation",
    "crew_playbook",
    "crew_upgrade",
    "feature",
    "gm_tracker",
    "heritage",
    "gear",
    "playbook",
    "preferred_op",
    "stricture",
    "vice",
    "project",
    "ritual",
    "design",
    "location",
    "score"
    /* score */
  ],
  SimpleItemTypes: [
    "background",
    "crew_reputation",
    "feature",
    "heritage",
    "preferred_op",
    "stricture"
    /* stricture */
  ],
  Attribute: [
    "insight",
    "prowess",
    "resolve"
    /* resolve */
  ],
  Action: {
    [
      "insight"
      /* insight */
    ]: [
      "hunt",
      "study",
      "survey",
      "tinker"
      /* tinker */
    ],
    [
      "prowess"
      /* prowess */
    ]: [
      "finesse",
      "prowl",
      "skirmish",
      "wreck"
      /* wreck */
    ],
    [
      "resolve"
      /* resolve */
    ]: [
      "attune",
      "command",
      "consort",
      "sway"
      /* sway */
    ]
  },
  Vices: [
    "Faith",
    "Gambling",
    "Luxury",
    "Obligation",
    "Pleasure",
    "Stupor",
    "Weird",
    "Worship",
    "Living_Essence",
    "Life_Essence",
    "Electroplasmic_Power"
    /* Electroplasmic_Power */
  ]
};
const Randomizers = {
  NPC: {
    heritage: [
      "Akorosi",
      "Akorosi",
      "Akorosi",
      "Akorosi",
      "Akorosi",
      "Akorosi",
      "Dagger Islander",
      "Iruvian",
      "Severosi",
      "Skovlander",
      "Skovlander",
      "Tycherosi"
    ],
    background: [
      "Academic",
      "Academic",
      "Academic",
      "Labor",
      "Labor",
      "Labor",
      "Labor",
      "Law",
      "Law",
      "Law",
      "Military",
      "Military",
      "Military",
      "Military",
      "Military",
      "New Money",
      "New Money",
      "Old Money",
      "Old Money",
      "Politics",
      "Politics",
      "Trade",
      "Trade",
      "Trade",
      "Underworld",
      "Underworld",
      "Underworld",
      "Underworld",
      "Underworld",
      "Weird"
    ],
    gender: [
      "M",
      "M",
      "M",
      "M",
      "F",
      "F",
      "F",
      "U",
      "X"
    ],
    appearance: [
      "Athletic",
      "Beard",
      "Bony",
      "Chiseled",
      "Crippled / Prosthetic",
      "Cute",
      "Dark",
      "Delicate",
      "Disfigured / Maimed",
      "Elegant",
      "Fair",
      "Glasses / Monocle",
      "Handsome",
      "Large",
      "Long Hair",
      "Lovely",
      "Old",
      "Plain",
      "Plump",
      "Rough",
      "Scarred",
      "Sexy",
      "Shaved Bald",
      "Short",
      "Slim",
      "Stooped",
      "Stout",
      "Strange",
      "Striking",
      "Stylish",
      "Tall",
      "Tattooed",
      "Weathered",
      "Wig",
      "Wild",
      "Wiry",
      "Worn",
      "Young"
    ],
    goal: [
      "Achievement",
      "Authority",
      "Change",
      "Chaos / Destruction",
      "Control",
      "Cooperation",
      "Freedom",
      "Happiness",
      "Infamy / Fear",
      "Justice",
      "Knowledge",
      "Love",
      "Pleasure",
      "Power",
      "Prestige / Fame",
      "Respect",
      "Revenge",
      "Wealth"
    ],
    method: [
      "Alchemy",
      "Arcane",
      "Blackmail",
      "Chaos",
      "Commerce",
      "Espionage",
      "Hard Work",
      "Law / Politics",
      "Manipulation",
      "Negotiation",
      "Sabotage",
      "Strategy",
      "Study",
      "Subterfuge",
      "Teamwork",
      "Theft",
      "Threats",
      "Violence"
    ],
    profession: [
      "Advocate",
      "Apiarist",
      "Architect",
      "Artist",
      "Author",
      "Bailiff",
      "Baker",
      "Baker",
      "Baker",
      "Banker",
      "Barber",
      "Barber",
      "Barber",
      "Blacksmith",
      "Blacksmith",
      "Blacksmith",
      "Bounty Hunter",
      "Brewer",
      "Brewer",
      "Brewer",
      "Butcher",
      "Butcher",
      "Butcher",
      "Captain",
      "Carpenter",
      "Carpenter",
      "Carpenter",
      "Cartwright",
      "Cartwright",
      "Cartwright",
      "Chandler",
      "Chandler",
      "Chandler",
      "Clerk",
      "Clerk",
      "Clerk",
      "Clockmaker",
      "Cobbler",
      "Cobbler",
      "Cobbler",
      "Composer",
      "Cooper",
      "Cooper",
      "Cooper",
      "Courtesan",
      "Criminal",
      "Criminal",
      "Criminal",
      "Cultivator",
      "Cultivator",
      "Cultivator",
      "Diplomat",
      "Driver",
      "Driver",
      "Driver",
      "Dyer",
      "Dyer",
      "Dyer",
      "Embroiderer",
      "Embroiderer",
      "Embroiderer",
      "Explorer",
      "Fishmonger",
      "Fishmonger",
      "Fishmonger",
      "Furrier",
      "Glass Blower",
      "Goat Herd",
      "Goat Herd",
      "Goat Herd",
      "Gondolier",
      "Gondolier",
      "Gondolier",
      "Guard",
      "Guard",
      "Guard",
      "Jailer",
      "Jeweler",
      "Journalist",
      "Leatherworker",
      "Leatherworker",
      "Leatherworker",
      "Leech",
      "Locksmith",
      "Magistrate",
      "Mason",
      "Mason",
      "Mason",
      "Merchant",
      "Merchant",
      "Merchant",
      "Messenger",
      "Messenger",
      "Messenger",
      "Musician",
      "Physicker",
      "Plumber",
      "Printer",
      "Rail Jack",
      "Roofer",
      "Roofer",
      "Roofer",
      "Ropemaker",
      "Ropemaker",
      "Ropemaker",
      "Rug Maker",
      "Rug Maker",
      "Rug Maker",
      "Sailor",
      "Sailor",
      "Sailor",
      "Scholar",
      "Scribe",
      "Servant",
      "Servant",
      "Servant",
      "Shipwright",
      "Shipwright",
      "Shipwright",
      "Soldier",
      "Sparkwright",
      "Spirit Warden",
      "Steward",
      "Tailor",
      "Tailor",
      "Tailor",
      "Tanner",
      "Tanner",
      "Tanner",
      "Tax Collector",
      "Tinkerer",
      "Tinkerer",
      "Tinkerer",
      "Treasurer",
      "Vendor",
      "Vendor",
      "Vendor",
      "Weaver",
      "Weaver",
      "Weaver",
      "Whisper",
      "Woodworker",
      "Woodworker",
      "Woodworker"
    ],
    trait: [
      "Arcane",
      "Arrogant",
      "Artistic",
      "Bold",
      "Brash",
      "Brave",
      "Calculating",
      "Calm",
      "Candid",
      "Careless",
      "Cautious",
      "Cavalier",
      "Charming",
      "Cold",
      "Commanding",
      "Compassionate",
      "Confident",
      "Connected",
      "Cooperative",
      "Creative",
      "Cruel",
      "Cultured",
      "Daring",
      "Defiant",
      "Dishonest",
      "Dramatic",
      "Elitist",
      "Enigmatic",
      "Enthusiastic",
      "Erudite",
      "Experienced",
      "Fierce",
      "Flexible",
      "Friendly",
      "Gracious",
      "Greedy",
      "Haunted",
      "Insightful",
      "Kind",
      "Melancholy",
      "Moody",
      "Obsessive",
      "Paranoid",
      "Patient",
      "Popular",
      "Principled",
      "Proud",
      "Quiet",
      "Reckless",
      "Respected",
      "Ruthless",
      "Sadistic",
      "Savage",
      "Secretive",
      "Shrewd",
      "Sincere",
      "Sneaky",
      "Sophisticated",
      "Strange",
      "Stylish",
      "Subtle",
      "Suspicious",
      "Tough",
      "Vain",
      "Vengeful",
      "Vicious",
      "Visionary",
      "Volatile",
      "Weird",
      "Wise"
    ],
    interests: [
      "Alchemy, medicine",
      "Antiques, artifacts, curios",
      "Arcane books, rituals",
      "Architecture, furnishings",
      "Church of Ecstasy",
      "Cooking, gardening",
      "Craft (leatherwork, etc.)",
      "Demon lore, legends",
      "Drugs, essences, tobacco",
      "Essences, alchemy",
      "Exploration, adventure",
      "Fine arts, opera, theater",
      "Fine clothes, jewelry, furs",
      "Fine food, restaurants",
      "Fine whiskey, wine, beer",
      "Forgotten gods",
      "Gadgets, new technology",
      "Gambling, cards, dice",
      "History, legends",
      "Horses, riding",
      "Hunting, shooting",
      "Lovers, romance, trysts",
      "Music, instruments, dance",
      "Natural philosophy",
      "Painting, drawing, sculpture",
      "Parties, social events",
      "Path of Echoes",
      "Pets (birds, dogs, cats)",
      "Pit-fighting, duels",
      "Poetry, novels, writing",
      "Politics, journalism",
      "Pre-cataclysm legends",
      "Ships, boating",
      "Spectrology, electroplasm",
      "Weapons collector",
      "Weeping Lady, charity"
    ],
    quirk: [
      "A fraud. Some important aspect is fabricated.",
      "Bigoted against culture / belief / social class.",
      "Black sheep / outcast from family or organization.",
      "Blind to flaws in friends, allies, family, etc.",
      "Celebrity. Popularized in print / song / theater.",
      "Concerned with appearances, gossip, peers.",
      "Cursed, haunted, harassed by spirits or demon.",
      "Deeply traditional. Opposed to new ideas.",
      "Devoted to their family.",
      "Drug / alcohol abuser. Often impaired by their vice.",
      "Extensive education on every scholarly subject.",
      "Has chronic illness that requires frequent care.",
      "Holds their position due to blackmail.",
      "Holds their position to spy for another faction.",
      "In prison or under noble's house arrest.",
      "Inherited their position. May not deserve / want it.",
      "Intense, unreasonable phobia or loathing.",
      "Involved with war crimes from the Unity War.",
      "Is blindly faithful to an ideal, group, or tradition.",
      "Keeps detailed journals, notes, records, ledgers.",
      "Leads a double life using cover identity.",
      "Married into important / powerful family.",
      "Massive debts (to banks / criminals / family)",
      "Once hollowed, then restored. Immune to spirits.",
      "Proud of heritage, traditions, native language.",
      "Reclusive. Prefers to interact via messengers.",
      "Relies on council to make decisions.",
      "Revolutionary. Plots against the Imperium.",
      "Scandalous reputation (deserved or not).",
      "Secretly (openly?) controlled by possessing spirit.",
      "Serves a demon's agenda (knowingly or not).",
      "Spotless reputation. Highly regarded.",
      "Superstitious. Believes in signs, magic numbers.",
      "Surrounded by sycophants, supplicants, toadies.",
      "Visionary. Holds radical views for future.",
      "Well-traveled. Connections outside Doskvol."
    ],
    style: {
      male: [
        "Apron",
        "Cane",
        "Collared Shirt",
        "Crutches",
        "Eelskin Bodysuit",
        "Face Mask",
        "Fitted Leggings",
        "Heavy Cloak",
        "Heavy Gloves",
        "Hide & Furs",
        "Hood & Veil",
        "Hooded Coat",
        "Knit Cap",
        "Leathers",
        "Long Coat",
        "Long Scarf",
        "Loose Silks",
        "Mask & Robes",
        "Rough Tunic",
        "Sharp Trousers",
        "Short Cloak",
        "Slim Jacket",
        "Soft Boots",
        "Suit & Vest",
        "Suspenders",
        "Tall Boots",
        "Tatters",
        "Thick Greatcoat",
        "Tool Belt",
        "Tricorn Hat",
        "Uniform",
        "Waxed Coat",
        "Wheelchair",
        "Wide Belt",
        "Work Boots"
      ],
      female: [
        "Apron",
        "Cane",
        "Crutches",
        "Eelskin Bodysuit",
        "Face Mask",
        "Fitted Dress",
        "Fitted Leggings",
        "Heavy Cloak",
        "Heavy Gloves",
        "Hide & Furs",
        "Hood & Veil",
        "Hooded Coat",
        "Knit Cap",
        "Leathers",
        "Long Coat",
        "Long Scarf",
        "Loose Silks",
        "Mask & Robes",
        "Rough Tunic",
        "Sharp Trousers",
        "Short Cloak",
        "Skirt & Blouse",
        "Slim Jacket",
        "Soft Boots",
        "Suspenders",
        "Tall Boots",
        "Tatters",
        "Thick Greatcoat",
        "Tool Belt",
        "Uniform",
        "Waxed Coat",
        "Wheelchair",
        "Wide Belt",
        "Work Boots"
      ]
    },
    name_title: [
      "Adept",
      "Archivist",
      "Captain",
      "Charter",
      "Scrivener"
    ],
    name_first: {
      male: [
        "Abel",
        "Abenthy",
        "Adric",
        "Airic",
        "Alabaster",
        "Alastair",
        "Aldo",
        "Alen",
        "Aleph",
        "Ambrose",
        "Amosen",
        "Andal",
        "Andrel",
        "Anton",
        "Aquilla",
        "Aradan",
        "Aram",
        "Archibald",
        "Archie",
        "Arden",
        "Arliden",
        "Arlyn",
        "Armand",
        "Arquo",
        "Arrell",
        "Arvus",
        "Asher",
        "Aurelio",
        "Benedict",
        "Bolster",
        "Brace",
        "Bran",
        "Brance",
        "Branon",
        "Bricks",
        "Brock",
        "Brutus",
        "Caius",
        "Carro",
        "Casian",
        "Cato",
        "Cavelle",
        "Cedric",
        "Chance",
        "Chauncey",
        "Cid",
        "Clave",
        "Cliff",
        "Cornelius",
        "Cross",
        "Crowl",
        "Cym",
        "Cyrus",
        "Declan",
        "Del",
        "Drav",
        "Drazhan",
        "Drem",
        "Edlun",
        "Edmund",
        "Edrom",
        "Edwin",
        "Elan",
        "Elend",
        "Elias",
        "Elodin",
        "Ephrim",
        "Erasmus",
        "Eremon",
        "Ethan",
        "Everitt",
        "Feldspar",
        "Fero",
        "Finn",
        "Fisher",
        "Galen",
        "Gallahad",
        "Garner",
        "Gilbert",
        "Glint",
        "Gnik",
        "Gregalos",
        "Grey",
        "Greyson",
        "Grifter",
        "Grine",
        "Gristofer",
        "Hadrian",
        "Hagran",
        "Hammond",
        "Hix",
        "Holtz",
        "Hugo",
        "Iden",
        "Irton",
        "Isaac",
        "Ivellios",
        "Jabari",
        "Jericho",
        "Jerod",
        "Kazimir",
        "Kellan",
        "Kelvyn",
        "Kelyr",
        "Khafra",
        "Kobb",
        "Kristov",
        "Kyrilu",
        "Lael",
        "Lafayette",
        "Laudius",
        "Lawrence",
        "Leif",
        "Lem",
        "Lenny",
        "Logan",
        "Lucas",
        "Lucius",
        "Lysander",
        "Milos",
        "Mord",
        "Morketh",
        "Morlan",
        "Myre",
        "Narcus",
        "Nehi",
        "Noggs",
        "Norton",
        "Obel",
        "Obelas",
        "Octavius",
        "Odelay",
        "Orem",
        "Orlan",
        "Orth",
        "Orton",
        "Pavel",
        "Perceval",
        "Percival",
        "Peregrine",
        "Phin",
        "Phineas",
        "Porto",
        "Preston",
        "Primo",
        "Quess",
        "Quill",
        "Rafe",
        "Rasmus",
        "Raul",
        "Resh",
        "Rias",
        "Ring",
        "Rivallo",
        "Rodmund",
        "Roethe",
        "Roose",
        "Roric",
        "Sethla",
        "Silas",
        "Sindri",
        "Snitch",
        "Sol",
        "Solomon",
        "Sprig",
        "Stavrul",
        "Stellan",
        "Stev",
        "Sym",
        "Tacitus",
        "Tarn",
        "Taylor",
        "Thackeray",
        "Thaddeus",
        "Thane",
        "Thelian",
        "Theo",
        "Theron",
        "Thurston",
        "Timoth",
        "Tisk",
        "Tocker",
        "Tristero",
        "Ulric",
        "Vask",
        "Veleris",
        "Ventaro",
        "Virgil",
        "Vond",
        "Wax",
        "Wayne",
        "Weaver",
        "Wester",
        "Winsley"
      ],
      female: [
        "Adaire",
        "Adelaide",
        "Adella",
        "Adroit",
        "Ailen",
        "Aina",
        "Akilah",
        "Albinia",
        "Althaea",
        "Alyosha",
        "Ansa",
        "Arabella",
        "Arwyl",
        "Ashlyn",
        "Avora",
        "Brena",
        "Brenna",
        "Calienthe",
        "Camilla",
        "Candor",
        "Candra",
        "Carissa",
        "Cascabel",
        "Casslyn",
        "Castille",
        "Celeste",
        "Chen",
        "Claret",
        "Clementine",
        "Constance",
        "Cordelia",
        "Corille",
        "Corsica",
        "Cyrene",
        "Dahlia",
        "Daphnia",
        "Delia",
        "Dena",
        "Denna",
        "Desmona",
        "Dolores",
        "Drenna",
        "Edie",
        "Eira",
        "Elsie",
        "Emeline",
        "Etta",
        "Fela",
        "Felicity",
        "Galenica",
        "Galina",
        "Gitta",
        "Gloria",
        "Gwen",
        "Hedy",
        "Hella",
        "Helles",
        "Henrietta",
        "Iduna",
        "Iona",
        "Isa",
        "Isabella",
        "Iskra",
        "Isolde",
        "Jasna",
        "Jaxi",
        "Joan",
        "Juno",
        "Kamelin",
        "Kari",
        "Koli",
        "Lauria",
        "Lenia",
        "Leona",
        "Leyva",
        "Lieu",
        "Lilith",
        "Lin",
        "Lizete",
        "Lorette",
        "Lucella",
        "Lynthia",
        "Lyra",
        "Maia",
        "Maiathah",
        "Maie",
        "Mara",
        "Marasi",
        "Marielda",
        "Marisol",
        "Marris",
        "Mira",
        "Naria",
        "Nasha",
        "Octavia",
        "Odrienne",
        "Olivia",
        "Ora",
        "Ordenna",
        "Oressia",
        "Orsella",
        "Pardenna",
        "Penelope",
        "Penny",
        "Phoebe",
        "Polonia",
        "Pravda",
        "Prudence",
        "Quelenna",
        "Raisa",
        "Redji",
        "Remira",
        "Rey",
        "Riven",
        "Runa",
        "Sabina",
        "Sabinia",
        "Sabrina",
        "Sadeh",
        "Sahar",
        "Selma",
        "Sesereth",
        "Severea",
        "Silaqui",
        "Skannon",
        "Sprig",
        "Stabitha",
        "Syra",
        "Tabitha",
        "Talitha",
        "Tamsyn",
        "Tasi",
        "Terra",
        "Tesslyn",
        "Thava",
        "Thena",
        "Tiff",
        "Una",
        "Vaurin",
        "Veretta",
        "Vesna",
        "Vestine",
        "Vey",
        "Victoria",
        "Vin",
        "Vita",
        "Volette",
        "Vorka",
        "Wander",
        "Ylva",
        "Zahra",
        "Zaida",
        "Zamira",
        "Zarya"
      ]
    },
    name_surname: [
      "Abberwick",
      "Adelbury",
      "Adleton",
      "Aloro",
      "Alsa",
      "Ankhayat",
      "Arran",
      "Ashton",
      "Ashweather",
      "Athanoch",
      "Axelrod",
      "Backworth",
      "Barrow",
      "Basran",
      "Black",
      "Blackford",
      "Blackpool",
      "Blackthorne",
      "Bluff",
      "Boden",
      "Booker",
      "Boulder",
      "Bowman",
      "Braeside",
      "Bramble",
      "Braum",
      "Bray",
      "Breakiron",
      "Bristle",
      "Brocken",
      "Brogan",
      "Bromley",
      "Burnsides",
      "Caebrek",
      "Cartwright",
      "Carver",
      "Childermass",
      "Claw",
      "Clelland",
      "Clemont",
      "Clermont",
      "Cobblecarver",
      "Coleburn",
      "Combe",
      "Comber",
      "Crofty",
      "Cunningham",
      "Daava",
      "Dal",
      "Dalmore",
      "Danfield",
      "Drawlight",
      "Drigg",
      "Dunvil",
      "Elmore",
      "Eveningeyes",
      "Evensteps",
      "Eventide",
      "Everpenny",
      "Fairplay",
      "Farros",
      "Fellwater",
      "Fogg",
      "Gatcombe",
      "Glasseye",
      "Goldsworth",
      "Grave",
      "Graythwaite",
      "Greysteel",
      "Grine",
      "Haig",
      "Half-Off",
      "Havelton",
      "Havenhorst",
      "Hectares",
      "Helker",
      "Helles",
      "Hellyers",
      "Hemme",
      "Hightower",
      "Hightown",
      "Highwater",
      "Hill",
      "Hitchcock",
      "Innerwick",
      "Jayan",
      "Jeduin",
      "Kardera",
      "Karstas",
      "Keel",
      "Kempt",
      "Kessarin",
      "Kinclaith",
      "King",
      "Lake",
      "Larriston",
      "Leake",
      "Lomond",
      "Longstaff",
      "Lorewood",
      "Maroden",
      "Mayson",
      "Merriweather",
      "Michter",
      "Mindwell",
      "Morcombe",
      "Morriston",
      "Mortimer",
      "Netherton",
      "Night",
      "Nighteyre",
      "Nightly",
      "Noctoft",
      "Notherhome",
      "Orchard",
      "Orchid",
      "Path",
      "Peak",
      "Pegg",
      "Penderyn",
      "Pond",
      "Pool",
      "Prichard",
      "Raines",
      "Ravenglass",
      "Ravenwood",
      "Reigns",
      "Reyes",
      "Reynes",
      "Rhodes",
      "Riverford",
      "Robel",
      "Rowan",
      "Sable",
      "Sage",
      "Salkara",
      "Salos",
      "Sevoy",
      "Shilbottle",
      "Shillmoor",
      "Shook",
      "Skelkallan",
      "Skora",
      "Slane",
      "Song",
      "Steadystep",
      "Stoutale",
      "Stovestoker",
      "Strange",
      "Strangford",
      "Strathmill",
      "Sunder",
      "Sunderland",
      "Swiftwhistle",
      "Tailor",
      "Tallfellow",
      "Templeton",
      "Tenpenny",
      "Tevilton",
      "Thistle",
      "Thrysus",
      "Thurston",
      "Tinmouth",
      "Tower",
      "Tristé",
      "Tyrconnell",
      "Vale",
      "Valentine",
      "Veldaire",
      "Venture",
      "Walund",
      "Warren",
      "Waters",
      "Wecker",
      "Welker",
      "Wend",
      "Wharver",
      "Whythe",
      "Woodall"
    ],
    name_alias: [
      "Bell",
      "Birch",
      "Bird",
      "Bliss",
      "Bricks",
      "Bug",
      "Chime",
      "Coil",
      "Cricket",
      "Cross",
      "Crow",
      "Echo",
      "Flint",
      "Frog",
      "Frost",
      "Goods",
      "Grip",
      "Gunner",
      "Hammer",
      "Hook",
      "Ink",
      "Junker",
      "Mist",
      "Moon",
      "Nail",
      "Needle",
      "Ogre",
      "Pool",
      "Ring",
      "Ruby",
      "Silver",
      "Skinner",
      "Song",
      "Spur",
      "Tackle",
      "Thistle",
      "Thorn",
      "Tick",
      "Tick-Tock",
      "Tock",
      "Trick",
      "Twelves",
      "Vixen",
      "Whip",
      "Wicker"
    ],
    name_suffix: [
      "Jr.",
      "Sr.",
      "III",
      "IV"
    ]
  },
  GM: {
    Bargains: [
      { name: "Infected Wound", category: "Character Effect", effect: "The next time you Recover from Harm, your Physicker is at -1d." },
      { name: "Infected Wound", category: "Character Effect", effect: "The next time you Recover from Harm, your Physicker is at -1d." },
      { name: "Infected Wound", category: "Character Effect", effect: "The next time you Recover from Harm, your Physicker is at -1d." },
      { name: "It's Mine Now", category: "Character Effect", effect: "You discover a small item that belongs to a rival. What is it? Who used to own it? How does this change things for you?" },
      { name: "It's Mine Now", category: "Character Effect", effect: "You discover a small item that belongs to a rival. What is it? Who used to own it? How does this change things for you?" },
      { name: "It's Mine Now", category: "Character Effect", effect: "You discover a small item that belongs to a rival. What is it? Who used to own it? How does this change things for you?" },
      { name: "Mine By Blood", category: "Character Effect", effect: "You discover evidence of the death of a family member during the Score. Who is it? How did they die? How does this change things for your character?" },
      { name: "Mine By Blood", category: "Character Effect", effect: "You discover evidence of the death of a family member during the Score. Who is it? How did they die? How does this change things for your character?" },
      { name: "Mine By Blood", category: "Character Effect", effect: "You discover evidence of the death of a family member during the Score. Who is it? How did they die? How does this change things for your character?" },
      { name: "Mine By Name", category: "Character Effect", effect: "You discover an envelope addressed to you during the Score. What is in it? Who left it here for you to find? How does this change things for your character?" },
      { name: "Mine By Name", category: "Character Effect", effect: "You discover an envelope addressed to you during the Score. What is in it? Who left it here for you to find? How does this change things for your character?" },
      { name: "Mine By Name", category: "Character Effect", effect: "You discover an envelope addressed to you during the Score. What is in it? Who left it here for you to find? How does this change things for your character?" },
      { name: "Mine By Rights", category: "Character Effect", effect: "You discover a small item from your past during the Score. What is it? What does it mean that it's here? Does this change things for your character?" },
      { name: "Mine By Rights", category: "Character Effect", effect: "You discover a small item from your past during the Score. What is it? What does it mean that it's here? Does this change things for your character?" },
      { name: "Mine By Rights", category: "Character Effect", effect: "You discover a small item from your past during the Score. What is it? What does it mean that it's here? Does this change things for your character?" },
      { name: "Not Paying Attention", category: "Character Effect", effect: "Uncheck one of the XP triggers already marked for your character for this Score." },
      { name: "Not Paying Attention", category: "Character Effect", effect: "Uncheck one of the XP triggers already marked for your character for this Score." },
      { name: "Shadow From the Past", category: "Character Effect", effect: "Your intel missed that someone from your past is associated with the target of the Score. Who is it, and how does that change things for you?" },
      { name: "Shadow From the Past", category: "Character Effect", effect: "Your intel missed that someone from your past is associated with the target of the Score. Who is it, and how does that change things for you?" },
      { name: "Shadow From the Past", category: "Character Effect", effect: "Your intel missed that someone from your past is associated with the target of the Score. Who is it, and how does that change things for you?" },
      { name: "Thicker than Blood", category: "Character Effect", effect: "Your intel missed that one of your family members is associated with the target of the Score. How does that change things for you?" },
      { name: "Thicker than Blood", category: "Character Effect", effect: "Your intel missed that one of your family members is associated with the target of the Score. How does that change things for you?" },
      { name: "Thicker than Blood", category: "Character Effect", effect: "Your intel missed that one of your family members is associated with the target of the Score. How does that change things for you?" },
      { name: "Why'd It Have To Be...", category: "Character Effect", effect: "The room you're in triggers a phobia that the Crew didn't know about before. Describe the phobia and take 2 Stress." },
      { name: "Why'd It Have To Be...", category: "Character Effect", effect: "The room you're in triggers a phobia that the Crew didn't know about before. Describe the phobia and take 2 Stress." },
      { name: "Why'd It Have To Be...", category: "Character Effect", effect: "The room you're in triggers a phobia that the Crew didn't know about before. Describe the phobia and take 2 Stress." },
      { name: "Demonic Guest", category: "Crew Effect", effect: "A demonic presence has appeared in your Lair and will need to be dealt with during Free Play." },
      { name: "Demonic Guest", category: "Crew Effect", effect: "A demonic presence has appeared in your Lair and will need to be dealt with during Free Play." },
      { name: "Fracturing Faction", category: "Crew Effect", effect: "If your Hold is Strong, reduce it to Weak. If your Hold is Weak, reduce your Rep to zero." },
      { name: "Lesson Not Learned", category: "Crew Effect", effect: "Uncheck one of the XP triggers already marked for your crew for this Score." },
      { name: "Lesson Not Learned", category: "Crew Effect", effect: "Uncheck one of the XP triggers already marked for your crew for this Score." },
      { name: "Otherworldly Guest", category: "Crew Effect", effect: "A scion of one of the Old Gods has appeared in your Lair and will need to be dealt with during Free Play." },
      { name: "Otherworldly Guest", category: "Crew Effect", effect: "A scion of one of the Old Gods has appeared in your Lair and will need to be dealt with during Free Play." },
      { name: "Rebellious Faction", category: "Crew Effect", effect: "A new crew has taken possession of one of your Claims, and will have to be dealt with in Free Play." },
      { name: "Spectral Guest", category: "Crew Effect", effect: "A ghostly presence has appeared in your Lair and will need to be dealt with during Free Play." },
      { name: "Spectral Guest", category: "Crew Effect", effect: "A ghostly presence has appeared in your Lair and will need to be dealt with during Free Play." },
      { name: "Turncoat", category: "Crew Effect", effect: "One of your Cohorts leaves your crew and joins a rival." },
      { name: "Double-Crossed", category: "Downtime Effect", effect: "After the normal Entanglement roll and result, your Crew takes an additional Flipped result." },
      { name: "Double-Crossed", category: "Downtime Effect", effect: "After the normal Entanglement roll and result, your Crew takes an additional Flipped result." },
      { name: "Double-Crossed", category: "Downtime Effect", effect: "After the normal Entanglement roll and result, your Crew takes an additional Flipped result." },
      { name: "Easily Identified", category: "Downtime Effect", effect: "You left something behind that is easily traced to you. Choose either +2 Heat and −2 Rep, or +1 Heat and −1 Rep." },
      { name: "Easily Identified", category: "Downtime Effect", effect: "You left something behind that is easily traced to you. Choose either +2 Heat and −2 Rep, or +1 Heat and −1 Rep." },
      { name: "Easily Identified", category: "Downtime Effect", effect: "You left something behind that is easily traced to you. Choose either +2 Heat and −2 Rep, or +1 Heat and −1 Rep." },
      { name: "High Profile", category: "Downtime Effect", effect: "This Score gains +2 Heat." },
      { name: "High Profile", category: "Downtime Effect", effect: "This Score gains +2 Heat." },
      { name: "High Profile", category: "Downtime Effect", effect: "This Score gains +2 Heat." },
      { name: "Most Wanted", category: "Downtime Effect", effect: "After the normal Entanglement roll and result, you are the target of an additional Arrest result." },
      { name: "Most Wanted", category: "Downtime Effect", effect: "After the normal Entanglement roll and result, you are the target of an additional Arrest result." },
      { name: "Project Setback", category: "Downtime Effect", effect: "Mark one less Clock segment the first time you work on a Long-Term Project." },
      { name: "Project Setback", category: "Downtime Effect", effect: "Mark one less Clock segment the first time you work on a Long-Term Project." },
      { name: "Project Setback", category: "Downtime Effect", effect: "Mark one less Clock segment the first time you work on a Long-Term Project." },
      { name: "Quelle Horreur!", category: "Downtime Effect", effect: "You suffer nightmares for a week. −1d to all Downtime Actions after this Score." },
      { name: "Quelle Horreur!", category: "Downtime Effect", effect: "You suffer nightmares for a week. −1d to all Downtime Actions after this Score." },
      { name: "Shortchanged", category: "Downtime Effect", effect: "This Score's payoff is −2 Coin." },
      { name: "Shortchanged", category: "Downtime Effect", effect: "This Score's payoff is −2 Coin." },
      { name: "Shortchanged", category: "Downtime Effect", effect: "This Score's payoff is −2 Coin." },
      { name: "Supply Challenges", category: "Downtime Effect", effect: "The next time you pay Coin for an Acquire Asset roll, you must pay 3 instead of 2 Coin per Tier." },
      { name: "Supply Challenges", category: "Downtime Effect", effect: "The next time you pay Coin for an Acquire Asset roll, you must pay 3 instead of 2 Coin per Tier." },
      { name: "Supply Delays", category: "Downtime Effect", effect: "Suffer -1d to your next Acquire Asset roll." },
      { name: "Supply Delays", category: "Downtime Effect", effect: "Suffer -1d to your next Acquire Asset roll." },
      { name: "Supply Delays", category: "Downtime Effect", effect: "Suffer -1d to your next Acquire Asset roll." },
      { name: "Tastes Like Ashes", category: "Downtime Effect", effect: "The next time you indulge your Vice, only clear half as much Stress (rounded down) as normal." },
      { name: "Tastes Like Ashes", category: "Downtime Effect", effect: "The next time you indulge your Vice, only clear half as much Stress (rounded down) as normal." },
      { name: "Thrice-Named", category: "Downtime Effect", effect: "After the normal Entanglement roll and result, your Crew takes an additional Demonic Notice result." },
      { name: "Thrice-Named", category: "Downtime Effect", effect: "After the normal Entanglement roll and result, your Crew takes an additional Demonic Notice result." },
      { name: "Thrice-Named", category: "Downtime Effect", effect: "After the normal Entanglement roll and result, your Crew takes an additional Demonic Notice result." },
      { name: "Warden's Attention", category: "Downtime Effect", effect: "+4 Heat (instead of the normal +2 Heat) if there is a death during this Score." },
      { name: "Warden's Attention", category: "Downtime Effect", effect: "+4 Heat (instead of the normal +2 Heat) if there is a death during this Score." },
      { name: "We Want a Bigger Take!", category: "Downtime Effect", effect: "The gang wants a bigger piece of the action. −2 Coin to Payoff for each Cohort used in this Score." },
      { name: "We Want a Bigger Take!", category: "Downtime Effect", effect: "The gang wants a bigger piece of the action. −2 Coin to Payoff for each Cohort used in this Score." },
      { name: "Weekend Getaway", category: "Downtime Effect", effect: "If you indulge your Vice after this Score, you automatically overindulge." },
      { name: "Weekend Getaway", category: "Downtime Effect", effect: "If you indulge your Vice after this Score, you automatically overindulge." },
      { name: "Weekend Getaway", category: "Downtime Effect", effect: "If you indulge your Vice after this Score, you automatically overindulge." },
      { name: "What's Our Take?", category: "Downtime Effect", effect: "The gang wants a bigger piece of the action. −1 Coin to Payoff for each Cohort used in this Score." },
      { name: "What's Our Take?", category: "Downtime Effect", effect: "The gang wants a bigger piece of the action. −1 Coin to Payoff for each Cohort used in this Score." },
      { name: "What's Our Take?", category: "Downtime Effect", effect: "The gang wants a bigger piece of the action. −1 Coin to Payoff for each Cohort used in this Score." },
      { name: "Accelerating Plans", category: "Faction Relationship Effect", effect: "A rival faction advances one of its Clocks by two before your next Score." },
      { name: "Accelerating Plans", category: "Faction Relationship Effect", effect: "A rival faction advances one of its Clocks by two before your next Score." },
      { name: "Accelerating Plans", category: "Faction Relationship Effect", effect: "A rival faction advances one of its Clocks by two before your next Score." },
      { name: "Escalating Tensions", category: "Faction Relationship Effect", effect: "A faction of your choice that is unfriendly to your crew moves one step towards War." },
      { name: "Escalating Tensions", category: "Faction Relationship Effect", effect: "A faction of your choice that is unfriendly to your crew moves one step towards War." },
      { name: "Forgiveness or Vengeance?", category: "Faction Relationship Effect", effect: "During the Score, one of your Cohorts got in a fight with an neutral Cohort. Choose −2 Rep and +1 faction relationship, or +2 Rep and −1 faction relationship." },
      { name: "Forgiveness or Vengeance?", category: "Faction Relationship Effect", effect: "During the Score, one of your Cohorts got in a fight with an neutral Cohort. Choose −2 Rep and +1 faction relationship, or +2 Rep and −1 faction relationship." },
      { name: "Forgiveness or Vengeance?", category: "Faction Relationship Effect", effect: "During the Score, one of your Cohorts got in a fight with an neutral Cohort. Choose −2 Rep and +1 faction relationship, or +2 Rep and −1 faction relationship." },
      { name: "Hot-Headed Cohort", category: "Faction Relationship Effect", effect: "During the Score, one of your Cohorts picked a fight with an allied Cohort. Pay 2 Coin, lose 2 Rep, or −1 faction relationship." },
      { name: "Hot-Headed Cohort", category: "Faction Relationship Effect", effect: "During the Score, one of your Cohorts picked a fight with an allied Cohort. Pay 2 Coin, lose 2 Rep, or −1 faction relationship." },
      { name: "Hot-Headed Cohort", category: "Faction Relationship Effect", effect: "During the Score, one of your Cohorts picked a fight with an allied Cohort. Pay 2 Coin, lose 2 Rep, or −1 faction relationship." },
      { name: "Mixed Messages", category: "Faction Relationship Effect", effect: "A faction of your choice that is friendly to your crew moves one step towards Neutral." },
      { name: "Mixed Messages", category: "Faction Relationship Effect", effect: "A faction of your choice that is friendly to your crew moves one step towards Neutral." },
      { name: "Mutual Defense", category: "Faction Relationship Effect", effect: "A friendly Faction goes to War with a neutral Faction. Either join their War, or they move to −1 on the relationship chart." },
      { name: "Mutual Defense", category: "Faction Relationship Effect", effect: "A friendly Faction goes to War with a neutral Faction. Either join their War, or they move to −1 on the relationship chart." },
      { name: "Tensions Spread", category: "Faction Relationship Effect", effect: "One Neutral Faction moves a step towards War, and another Neutral Faction moves a step towards Ally." },
      { name: "Tensions Spread", category: "Faction Relationship Effect", effect: "One Neutral Faction moves a step towards War, and another Neutral Faction moves a step towards Ally." },
      { name: "Tensions Spread", category: "Faction Relationship Effect", effect: "One Neutral Faction moves a step towards War, and another Neutral Faction moves a step towards Ally." },
      { name: "The Walls Have Ears", category: "Faction Relationship Effect", effect: "A friendly faction hears you did a Score against their ally. −1 to that faction's relationship rating." },
      { name: "The Walls Have Ears", category: "Faction Relationship Effect", effect: "A friendly faction hears you did a Score against their ally. −1 to that faction's relationship rating." },
      { name: "The Walls Have Ears", category: "Faction Relationship Effect", effect: "A friendly faction hears you did a Score against their ally. −1 to that faction's relationship rating." },
      { name: "The Walls Have Eyes", category: "Faction Relationship Effect", effect: "A friendly faction hears you did a Score against their ally. −1 to both factions' relationship ratings." },
      { name: "The Walls Have Eyes", category: "Faction Relationship Effect", effect: "A friendly faction hears you did a Score against their ally. −1 to both factions' relationship ratings." },
      { name: "...and Into the Fire", category: "Immediate Effect", effect: "You are ambushed by an assassin or bounty hunter. Start a 4-Clock, 'Elite Ambusher' to overcome this new foe." },
      { name: "...and Into the Fire", category: "Immediate Effect", effect: "You are ambushed by an assassin or bounty hunter. Start a 4-Clock, 'Elite Ambusher' to overcome this new foe." },
      { name: "A Familiar Face", category: "Immediate Effect", effect: "You recognize a contact of your choice among the rivals you are running the Score against." },
      { name: "A Familiar Face", category: "Immediate Effect", effect: "You recognize a contact of your choice among the rivals you are running the Score against." },
      { name: "A Familiar Face", category: "Immediate Effect", effect: "You recognize a contact of your choice among the rivals you are running the Score against." },
      { name: "Accidental Discharge", category: "Immediate Effect", effect: "A weapon or item you are carrying loudly discharges and needs to be reloaded before it can be used." },
      { name: "Accidental Discharge", category: "Immediate Effect", effect: "A weapon or item you are carrying loudly discharges and needs to be reloaded before it can be used." },
      { name: "Accidental Discharge", category: "Immediate Effect", effect: "A weapon or item you are carrying loudly discharges and needs to be reloaded before it can be used." },
      { name: "All or Nothing", category: "Immediate Effect", effect: "If you fail this roll, you cannot resist the effects of that failure." },
      { name: "All or Nothing", category: "Immediate Effect", effect: "If you fail this roll, you cannot resist the effects of that failure." },
      { name: "All or Nothing", category: "Immediate Effect", effect: "If you fail this roll, you cannot resist the effects of that failure." },
      { name: "Bishop's Gambit", category: "Immediate Effect", effect: "If you are not in combat, gain +2d for this roll instead of the standard +1d; but you can roll no more than 1d for your next Action." },
      { name: "Bishop's Gambit", category: "Immediate Effect", effect: "If you are not in combat, gain +2d for this roll instead of the standard +1d; but you can roll no more than 1d for your next Action." },
      { name: "Bishop's Gambit", category: "Immediate Effect", effect: "If you are not in combat, gain +2d for this roll instead of the standard +1d; but you can roll no more than 1d for your next Action." },
      { name: "Brute Force Method", category: "Immediate Effect", effect: "You noisily break a weapon of your choice while attempting this Action, even if it is not a combat Action." },
      { name: "Brute Force Method", category: "Immediate Effect", effect: "You noisily break a weapon of your choice while attempting this Action, even if it is not a combat Action." },
      { name: "Brute Force Method", category: "Immediate Effect", effect: "You noisily break a weapon of your choice while attempting this Action, even if it is not a combat Action." },
      { name: "Clear the Board", category: "Immediate Effect", effect: "If you succeed at this roll, clear or fill a Score Clock of your choice. If you fail the roll, you Trauma out of the scene." },
      { name: "Clear the Board", category: "Immediate Effect", effect: "If you succeed at this roll, clear or fill a Score Clock of your choice. If you fail the roll, you Trauma out of the scene." },
      { name: "Devil's Exchange", category: "Immediate Effect", effect: "You gain the normal +1d to this roll, but suffer −1d to your next Action, and cannot take a Devil's Bargain to offset it." },
      { name: "Devil's Exchange", category: "Immediate Effect", effect: "You gain the normal +1d to this roll, but suffer −1d to your next Action, and cannot take a Devil's Bargain to offset it." },
      { name: "Devil's Exchange", category: "Immediate Effect", effect: "You gain the normal +1d to this roll, but suffer −1d to your next Action, and cannot take a Devil's Bargain to offset it." },
      { name: "Ghostly Attention", category: "Immediate Effect", effect: "Whether you succeed in this roll or not, a ghost in the area notices you and begins stalking you." },
      { name: "Ghostly Attention", category: "Immediate Effect", effect: "Whether you succeed in this roll or not, a ghost in the area notices you and begins stalking you." },
      { name: "Ghostly Attention", category: "Immediate Effect", effect: "Whether you succeed in this roll or not, a ghost in the area notices you and begins stalking you." },
      { name: "Gimcrack Gear", category: "Immediate Effect", effect: "Whatever weapon or tool you are using is cheaply made and breaks whether the roll succeeds or not." },
      { name: "Gimcrack Gear", category: "Immediate Effect", effect: "Whatever weapon or tool you are using is cheaply made and breaks whether the roll succeeds or not." },
      { name: "Gimcrack Gear", category: "Immediate Effect", effect: "Whatever weapon or tool you are using is cheaply made and breaks whether the roll succeeds or not." },
      { name: "Gone Rogue", category: "Immediate Effect", effect: "You cannot accept an Assist for the rest of this Score." },
      { name: "Gone Rogue", category: "Immediate Effect", effect: "You cannot accept an Assist for the rest of this Score." },
      { name: "Hunter Becomes Hunted", category: "Immediate Effect", effect: "You've been so preoccupied with the obstacles in front of you that you didn't notice the rival lining up a shot behind you." },
      { name: "Hunter Becomes Hunted", category: "Immediate Effect", effect: "You've been so preoccupied with the obstacles in front of you that you didn't notice the rival lining up a shot behind you." },
      { name: "Hunter Becomes Hunted", category: "Immediate Effect", effect: "You've been so preoccupied with the obstacles in front of you that you didn't notice the rival lining up a shot behind you." },
      { name: "I Know I Packed It!", category: "Immediate Effect", effect: "You must immediately check off 1 Load to no effect, representing equipment you've misplaced." },
      { name: "I Know I Packed It!", category: "Immediate Effect", effect: "You must immediately check off 1 Load to no effect, representing equipment you've misplaced." },
      { name: "I Know I Packed It!", category: "Immediate Effect", effect: "You must immediately check off 1 Load to no effect, representing equipment you've misplaced." },
      { name: "I Know I Packed Them!", category: "Immediate Effect", effect: "You must immediately check off 2 Load to no effect, representing equipment you've misplaced." },
      { name: "I Know I Packed Them!", category: "Immediate Effect", effect: "You must immediately check off 2 Load to no effect, representing equipment you've misplaced." },
      { name: "I Know I Packed Them!", category: "Immediate Effect", effect: "You must immediately check off 2 Load to no effect, representing equipment you've misplaced." },
      { name: "Jangled Nerves", category: "Immediate Effect", effect: "For the rest of the Score, all rolls to Resist generate +1 Stress." },
      { name: "Jangled Nerves", category: "Immediate Effect", effect: "For the rest of the Score, all rolls to Resist generate +1 Stress." },
      { name: "Jangled Nerves", category: "Immediate Effect", effect: "For the rest of the Score, all rolls to Resist generate +1 Stress." },
      { name: "Just a Little Spark", category: "Immediate Effect", effect: "A lamp or candle gets knocked over, catching a curtain or rug on fire. Start a Clock: 'Building is on Fire'." },
      { name: "Just a Little Spark", category: "Immediate Effect", effect: "A lamp or candle gets knocked over, catching a curtain or rug on fire. Start a Clock: 'Building is on Fire'." },
      { name: "Just a Little Spark", category: "Immediate Effect", effect: "A lamp or candle gets knocked over, catching a curtain or rug on fire. Start a Clock: 'Building is on Fire'." },
      { name: "King's Gambit", category: "Immediate Effect", effect: "If you fail at this roll, you are immune to any Harm; but you have a zero rating to your next Action." },
      { name: "King's Gambit", category: "Immediate Effect", effect: "If you fail at this roll, you are immune to any Harm; but you have a zero rating to your next Action." },
      { name: "King's Gambit", category: "Immediate Effect", effect: "If you fail at this roll, you are immune to any Harm; but you have a zero rating to your next Action." },
      { name: "Knight's Gambit", category: "Immediate Effect", effect: "If you are in combat, gain +2d for this roll instead of the standard +1d; but you can roll no more than 1d for your next Action." },
      { name: "Knight's Gambit", category: "Immediate Effect", effect: "If you are in combat, gain +2d for this roll instead of the standard +1d; but you can roll no more than 1d for your next Action." },
      { name: "Knight's Gambit", category: "Immediate Effect", effect: "If you are in combat, gain +2d for this roll instead of the standard +1d; but you can roll no more than 1d for your next Action." },
      { name: "Knuckle Buster", category: "Immediate Effect", effect: "Whether this Action succeeds or not, you accidentally inflict level 1 Harm on your hand, 'Busted Knuckles.'" },
      { name: "Knuckle Buster", category: "Immediate Effect", effect: "Whether this Action succeeds or not, you accidentally inflict level 1 Harm on your hand, 'Busted Knuckles.'" },
      { name: "Knuckle Buster", category: "Immediate Effect", effect: "Whether this Action succeeds or not, you accidentally inflict level 1 Harm on your hand, 'Busted Knuckles.'" },
      { name: "Now or Never", category: "Immediate Effect", effect: "If you fail this roll, you lose this opportunity and cannot retry it for this Score." },
      { name: "Now or Never", category: "Immediate Effect", effect: "If you fail this roll, you lose this opportunity and cannot retry it for this Score." },
      { name: "Now or Never", category: "Immediate Effect", effect: "If you fail this roll, you lose this opportunity and cannot retry it for this Score." },
      { name: "Out of the Frying Pan...", category: "Immediate Effect", effect: "Things are about to go from bad to worse. Start a 4-Clock, 'Surprise Reinforcements'." },
      { name: "Out of the Frying Pan...", category: "Immediate Effect", effect: "Things are about to go from bad to worse. Start a 4-Clock, 'Surprise Reinforcements'." },
      { name: "Out of the Frying Pan...", category: "Immediate Effect", effect: "Things are about to go from bad to worse. Start a 4-Clock, 'Surprise Reinforcements'." },
      { name: "Overextended", category: "Immediate Effect", effect: "Your next Action automatically has reduced Effect." },
      { name: "Overextended", category: "Immediate Effect", effect: "Your next Action automatically has reduced Effect." },
      { name: "Overextended", category: "Immediate Effect", effect: "Your next Action automatically has reduced Effect." },
      { name: "Pawn's Gambit", category: "Immediate Effect", effect: "You cannot use Load for Armor during this Score. You cannot accept this bargain if you already have used Load for Armor." },
      { name: "Pawn's Gambit", category: "Immediate Effect", effect: "You cannot use Load for Armor during this Score. You cannot accept this bargain if you already have used Load for Armor." },
      { name: "Pawn's Gambit", category: "Immediate Effect", effect: "You cannot use Load for Armor during this Score. You cannot accept this bargain if you already have used Load for Armor." },
      { name: "Plan C...", category: "Immediate Effect", effect: "Things are not going according to plan. Flashbacks cost +1 Stress for the rest of the Score." },
      { name: "Plan C...", category: "Immediate Effect", effect: "Things are not going according to plan. Flashbacks cost +1 Stress for the rest of the Score." },
      { name: "Queen's Gambit", category: "Immediate Effect", effect: "You automatically succeed at this Action as if you rolled a 6; but you have a zero rating to your next Action." },
      { name: "Queen's Gambit", category: "Immediate Effect", effect: "You automatically succeed at this Action as if you rolled a 6; but you have a zero rating to your next Action." },
      { name: "Queen's Gambit", category: "Immediate Effect", effect: "You automatically succeed at this Action as if you rolled a 6; but you have a zero rating to your next Action." },
      { name: "Quicksilver Poisoning", category: "Immediate Effect", effect: "Used in electroplasmic containers and devices, you get a noseful of quicksilver vapor, suffering level 1 Harm, 'Silverlung' which starts a 4-Clock Project to heal." },
      { name: "Quicksilver Poisoning", category: "Immediate Effect", effect: "Used in electroplasmic containers and devices, you get a noseful of quicksilver vapor, suffering level 1 Harm, 'Silverlung' which starts a 4-Clock Project to heal." },
      { name: "Quicksilver Poisoning", category: "Immediate Effect", effect: "Used in electroplasmic containers and devices, you get a noseful of quicksilver vapor, suffering level 1 Harm, 'Silverlung' which starts a 4-Clock Project to heal." },
      { name: "Rook's Gambit", category: "Immediate Effect", effect: "You cannot use Load for Unusual or Scary Weapons this Score. You cannot accept this bargain if you already have used Load for these." },
      { name: "Rook's Gambit", category: "Immediate Effect", effect: "You cannot use Load for Unusual or Scary Weapons this Score. You cannot accept this bargain if you already have used Load for these." },
      { name: "Rook's Gambit", category: "Immediate Effect", effect: "You cannot use Load for Unusual or Scary Weapons this Score. You cannot accept this bargain if you already have used Load for these." },
      { name: "Shot Nerves", category: "Immediate Effect", effect: "For the rest of the Score, all rolls to Resist generate +2 Stress." },
      { name: "Shot Nerves", category: "Immediate Effect", effect: "For the rest of the Score, all rolls to Resist generate +2 Stress." },
      { name: "Turned Around", category: "Immediate Effect", effect: "You lose track of your position. Start a 4-Clock, 'Where Am I?' You must use Actions looking for your Crew to rejoin them." },
      { name: "Turned Around", category: "Immediate Effect", effect: "You lose track of your position. Start a 4-Clock, 'Where Am I?' You must use Actions looking for your Crew to rejoin them." },
      { name: "Turned Around", category: "Immediate Effect", effect: "You lose track of your position. Start a 4-Clock, 'Where Am I?' You must use Actions looking for your Crew to rejoin them." },
      { name: "Unsure Footing", category: "Immediate Effect", effect: "Whether you succeed in this roll or not, you loose your footing and fall prone after this Action." },
      { name: "Unsure Footing", category: "Immediate Effect", effect: "Whether you succeed in this roll or not, you loose your footing and fall prone after this Action." },
      { name: "Unsure Footing", category: "Immediate Effect", effect: "Whether you succeed in this roll or not, you loose your footing and fall prone after this Action." },
      { name: "Worse than We thought", category: "Immediate Effect", effect: "A Clock of your choice that is running for this Score is either advanced or set back by two segments (whichever is worse for the Crew)." },
      { name: "Worse than We thought", category: "Immediate Effect", effect: "A Clock of your choice that is running for this Score is either advanced or set back by two segments (whichever is worse for the Crew)." },
      { name: "You're All On Your Own", category: "Immediate Effect", effect: "After this roll, you cannot offer to Assist on anyone else's roll for the rest of the Score." },
      { name: "You're All On Your Own", category: "Immediate Effect", effect: "After this roll, you cannot offer to Assist on anyone else's roll for the rest of the Score." },
      { name: "You're All On Your Own", category: "Immediate Effect", effect: "After this roll, you cannot offer to Assist on anyone else's roll for the rest of the Score." },
      { name: "Death Will Not Stop Me", category: "Long-Term Effect", effect: "The ghost of someone you killed is driven to take you with it. Start a 12-Clock, 'Spectral Vengence'" },
      { name: "That's Enough of That", category: "Long-Term Effect", effect: "Someone whose goals are affected by this Score is going to focus on you now. Start a 8-Clock, 'Cold Vengence'" },
      { name: "That's Enough of That", category: "Long-Term Effect", effect: "Someone whose goals are affected by this Score is going to focus on you now. Start a 8-Clock, 'Cold Vengence'" },
      { name: "The Last Straw", category: "Long-Term Effect", effect: "You've royally pissed off someone with real clout in the city. Start a 12-Clock, 'Furious Vengence'" },
      { name: "You'll Pay For This", category: "Long-Term Effect", effect: "Someone hurt by this Score will come back to collect what's owed. Start a 6-Clock, 'Petty Vengence'" },
      { name: "You'll Pay For This", category: "Long-Term Effect", effect: "Someone hurt by this Score will come back to collect what's owed. Start a 6-Clock, 'Petty Vengence'" },
      { name: "You'll Pay For This", category: "Long-Term Effect", effect: "Someone hurt by this Score will come back to collect what's owed. Start a 6-Clock, 'Petty Vengence'" },
      { name: "Dalgomur, the Heart of the Storm", category: "Mandatory Effect", effect: "If one is not already active for the crew, start a 12-Clock labeled 'The Heart of the Storm' and set it to one. If the Clock is already active, advance it by one." },
      { name: "Dalgomur, the Heart of the Storm", category: "Mandatory Effect", effect: "If one is not already active for the crew, start a 12-Clock labeled 'The Heart of the Storm' and set it to one. If the Clock is already active, advance it by one." },
      { name: "Ulf Ironborn, the Skovlan Agitator", category: "Mandatory Effect", effect: "If one is not already active for the crew, start a 4-Clock labeled 'Skovlander Uprising' and set it to one. If the Clock is already active, advance it by one." },
      { name: "Ulf Ironborn, the Skovlan Agitator", category: "Mandatory Effect", effect: "If one is not already active for the crew, start a 4-Clock labeled 'Skovlander Uprising' and set it to one. If the Clock is already active, advance it by one." },
      { name: "Urumbar, the Closed Eye", category: "Mandatory Effect", effect: "If one is not already active for the crew, start an 8-Clock labeled 'The Closed Eye' and set it to one. If the Clock is already active, advance it by one." },
      { name: "Urumbar, the Closed Eye", category: "Mandatory Effect", effect: "If one is not already active for the crew, start an 8-Clock labeled 'The Closed Eye' and set it to one. If the Clock is already active, advance it by one." },
      { name: "Vaskani, the Crossroads Demon", category: "Mandatory Effect", effect: "If one is not already active for the crew, start a 6-Clock labeled 'The Crossroads Demon' and set it to one. If the Clock is already active, advance it by one." },
      { name: "Vaskani, the Crossroads Demon", category: "Mandatory Effect", effect: "If one is not already active for the crew, start a 6-Clock labeled 'The Crossroads Demon' and set it to one. If the Clock is already active, advance it by one." }
    ],
    Obstacles: [
      {
        name: "Centipedes",
        category: "Animal Guards",
        desc: "Centipedes the length of a forearm are almost noiseless. If they bite, their toxin causes living flesh to blacken and die, leading to amputation if the poison isn't countered. People tend to scream when bit.",
        questions: [
          "Were the centipedes brought in as guardians, or are they a local nuisance?",
          "There are many different breeds, how will you describe the appearance of yours?",
          "Do they have a nasty local nickname?"
        ],
        modsHarder: [
          "When one attacks it releases a scent that enrages others nearby, so they tend to swarm.",
          "They are excellent swimmers, and they hunt in bog-like areas under the surface."
        ],
        modsEasier: [
          "They are bright yellow and red, and hiss before striking, giving all the warning possible.",
          "All the guardians and neighbors carry the antidote, the local apothecary knows what you need."
        ]
      },
      {
        name: "Great Cats",
        category: "Animal Guards",
        desc: "One or more great cats slink through the shadows. They like to attack from high places. Their fur mottles to match the colors and tones and textures around them.",
        questions: [
          "Did the current owners bring them in, or are they inherited from a previous owner?",
          "Do they stay on the estate, or go hunting in the local neighborhood?"
        ],
        modsHarder: [
          "The cats are trained to alert guards (or wear charm jewelry to alert supernatural guardians) when they detect intruders with their keen senses.",
          "Massive old trees draped with moss, or many ledges and overlooks, provide the cats cover."
        ],
        modsEasier: [
          "There is only one, with a regular feeding time and place.",
          "The cats are well fed and lazy, mostly for show unless provoked."
        ]
      },
      {
        name: "Hunting Spiders",
        category: "Animal Guards",
        desc: "These lightning-fast nightmares are about twenty pounds and three feet across, built like jumping spiders and loaded with paralytic venom.",
        questions: [
          "Were these spiders bred for a decadent aristocrat, or warped to this impossible size by an insane whisper?",
          "Can they survive away from a spirit well?",
          "What noise do they make?",
          "How do they smell?"
        ],
        modsHarder: [
          "They are mostly trained, their handler using a slide whistle to give orders to hunt, attack, withdraw, or guard.",
          "The color of the stone, the shape of the underbrush, the leaf litter--everything matches the spider color scheme and hides its movement."
        ],
        modsEasier: [
          "Little lasting harm at first; paralyzed prey is dragged back to a lair and webbed up. You have a day or so to rescue the prey before the spider injects acid into the web bundle so it can drink its victim.",
          "The poison is weak and easy to resist, requiring several successful bites to put a human down."
        ]
      },
      {
        name: "Mastiff Pack",
        category: "Animal Guards",
        desc: "A pack of mastiffs have run of the guarded area when it is not in more public use. They only respond to their masters, who have special tunics, whistles, and gloves. They kill anyone or anything else.",
        questions: [
          "What is their heraldry?",
          "How many mastiffs are in the pack?",
          "Are they trained well enough to ignore poisoned meat or live animal distractions?"
        ],
        modsHarder: [
          "Each one is precious to the site owner, who will tirelessly seek vengeance if they are hurt.",
          "The pack masters are elite veterans with firearms and excellent tracking and hunting skills."
        ],
        modsEasier: [
          "The equipment is properly installed, its vulnerable parts behind the energy curtain, directly guarding what needs protecting.",
          "The lightning walls attract loose spirits, intruders may also have to contend with confused ghosts."
        ]
      },
      {
        name: "Venomous Snakes",
        category: "Animal Guards",
        desc: "Venomous snakes have lairs prepared for them in the guarded area.",
        questions: [
          "How fast acting is their venom?",
          "How aggressive are they?",
          "Is their hide camouflage for hunting, or bright to warn away predators?",
          "Are there only a few big ones, or many small snakes?",
          "Do the site guardians feed them, or can they find enough vermin on their own?"
        ],
        modsHarder: [
          "Knee-deep plants and elevation shifts intentionally make it difficult to see snakes.",
          "Other guardians have a side business in selling venom and meat and hides. They have venom blowdarts and poisoned daggers."
        ],
        modsEasier: [
          "The snakes dislike a certain whistle tone. Let out a blast occasionally and they'll stay away.",
          "A former employee knows how guardians got around the site with minimal risk of snakes."
        ]
      },
      {
        name: "Armor Hosts",
        category: "Ghostly Guards",
        desc: "Guardian spirits are able to inhabit a crystal melded to each suit of armor in a guarded area. When melded, the spirit can control the armor. Spirits use the armor to attack intruders.",
        questions: [
          "Were the suits of armor built for this purpose, or retrofitted by a spirit trafficker?",
          "Are the guardian spirits loyal, or were they stripped of their will by a ritual or other power?",
          "Are the suits visibly paranormal?"
        ],
        modsHarder: [
          "A single powerful (relatively sane) spirit can flit from armor to armor, backed up by two slave spirits. The guardian can form an electroplasmic face in the helmet to sneer at intruders.",
          "A swarm of spirits are eager to take their turn in armor. When one tires another drops in.",
          "Ceaseless patrol."
        ],
        modsEasier: [
          "The ghost(s) that animate the armor are murderous and difficult to control.",
          "The guardians can play a chime to recall them to a restraining prism.",
          "The suits of armor are old, battered, and prone to physical failure."
        ]
      },
      {
        name: "Coldrooms",
        category: "Ghostly Guards",
        desc: "The defended area is kept cold. Body heat registers like a plume of blood in the water. Ghosts flood living meat with cold, gorging on body heat, becoming more visible as their outlines swirl with life-blood.",
        questions: [
          "Were they created by ritually starving victims to death in the defended space?",
          "Were they stolen from the site of a massive horrific disaster?",
          "Does a spirit trafficker maintain the wards on the space?"
        ],
        modsHarder: [
          "A dead whisper leads them, countering defensive charms and magic, sniffing out breath even if heat is concealed, dueling any supernatural defense.",
          "The guarded area is powerfully warded and underground where temperature is easy to maintain."
        ],
        modsEasier: [
          "The guarded area is vulnerable to weather conditions. It is sharp in the cold, but almost dormant in the heat.",
          "A relatively simple spirit bane charm can keep them at bay if created in tune with the site."
        ]
      },
      {
        name: "Cursed Treasure",
        category: "Ghostly Guards",
        desc: "Treasures are infused with a haunting spirit. Anyone touching the treasure will be cursed, dreaming the crimes of the ghost and attracting anger and distaste from strangers. Friends become uncomfortable and suspicious around the cursed scoundrel.",
        questions: [
          "Were those sacrificed to make the haunts loyal, serving past death, or punished by undeath?",
          "Is the treasure marked as cursed?"
        ],
        modsHarder: [
          "The haunting is so deadly that it drives most victims to suicide within a week. Resourceful scoundrels with access to spirit traffickers have days to somehow break the hold. Others are doomed.",
          "Electroplasmic poisoning begins, and within a week the scoundrel will become a vampire."
        ],
        modsEasier: [
          "All the bad luck waiting in the wings (unfinished clocks from foes, poorly protected stashes, jilted lovers, false identities) go wrong in quick succession. Then the curse is over.",
          "A competent occultist can break the curse as a down time project with a four segment clock."
        ]
      },
      {
        name: "Darkrooms",
        category: "Ghostly Guards",
        desc: "The defended area is dark. The ragged ghosts hate light. They shriek horribly as they attack light sources with slapping leathery hands, like bat wings. Intruders may glimpse their luminous fangs.",
        questions: [
          "Were these ghosts placed here intentionally, or are they the result of some horror that left a print in the Ghost Field?",
          "Is this defense maintained, or passive?"
        ],
        modsHarder: [
          "Another guardian lurks in the dark and takes advantage of the distraction to steal from intruders, perhaps killing them too.",
          "The ghosts are aggressive, pushing intruders. Surroundings include long drops, spikes, mazes, or other hazards difficult to navigate in darkness."
        ],
        modsEasier: [
          "While annoying, they do no real damage, and forewarned scoundrels may prepare unbreakable light sources or supernatural dark vision.",
          "There is enough ambient light to see."
        ]
      },
      {
        name: "Dynastic Hive",
        category: "Ghostly Guards",
        desc: "Ancestors have been ritually infused into the defense site, it is a dynastic holding. The spirits are old, and insane, but strategically placed to act out their madness in the most damaging way.",
        questions: [
          "Did the family get special permission to harbor ghosts?",
          "Do they have connections to limmers?",
          "Are spirits tied to leviathan bone shards?",
          "Are they moving pictures, or conversationalists with clues?"
        ],
        modsHarder: [
          "The ghosts are legally protected, like landmarks or artwork. Damaging them is a serious crime.",
          "Some of the more powerful or canny ghosts are still somewhat sane collaborators with the site owners."
        ],
        modsEasier: [
          "They are out of control, and few dare to enter the site now (or it is abandoned.)",
          "They will not harm family members (but may not react well to hostages.)"
        ]
      },
      {
        name: "Hunting Ghostpack",
        category: "Ghostly Guards",
        desc: "A group of weaponized ghosts haunts the defended area. They are capable of scouting to find intruders, descending on them with lethal force.",
        questions: [
          "Do they appear as a pack with a mounted hunter, spectral hounds, and a ghostly horn call?",
          "Or an armored warband?",
          "Shapeless lethal electroplasmic stalkers?",
          "Are the wounds they inflict bloody cuts, or hard frostbite?",
          "Is their area surrounded with runes that let them see into the material world?"
        ],
        modsHarder: [
          "The ghost leader feels all life force in its hunting ground, knowing its location.",
          "The hunt can only rise when certain conditions like anniversaries, moon phases, etc. are met. However, they have a treasure that can only be taken from them when they manifest."
        ],
        modsEasier: [
          "The attack is purely psychological, killing with supernatural fear. The effect can be resisted.",
          "They are summoned and directed by a command artifact like a hunting horn or special weapon. If someone else tunes to the weapon, control (and its obligations) may shift to a new bearer."
        ]
      },
      {
        name: "Possession Gate",
        category: "Ghostly Guards",
        desc: "If an intruder breaks a clearly marked seal, the intruder is attacked by a possessing spirit that takes on the traits of the most strong-willed, brutal person the seal-breaker ever killed. The possessing spirit and the seal-breaker struggle for control. This counts as a harm.",
        questions: [
          "Is the possessing spirit a ghost, or a shape-shifting construct made by an expert that makes a shape out of something in the target?",
          "If an innocent triggers the trap, what form does the spirit take then?"
        ],
        modsHarder: [
          "The only way to be free is to die, undergo electroplasmic surgery while dead, and be revived. Otherwise the curse is protected by the victim's life force.",
          "The haunting spirit tries to take possession once a day or so, sending the host into a blackout and acting out vicious crimes against allies, loved ones, and bluecoats."
        ],
        modsEasier: [
          "The condition can be reduced with a resist roll, but still is likely a 6 segment clock to clear.",
          "The curse haunt would rather have a host ally than kill its victim, and may bargain for shared control."
        ]
      },
      {
        name: "Spirit-Infused Art",
        category: "Ghostly Guards",
        desc: "Art works are haunted by spirits that are capable of spying. They observe their area, and may be able to murmur about what they see to a guardian.",
        questions: [
          "Was art repurposed to host spirits, or was it created for them and around them?",
          "Is the art mosaics, portraits, statues, or some other form?",
          "How sane and coherent are the spirits?",
          "How loyal are they?",
          "Do they have the power to attack intruders?"
        ],
        modsHarder: [
          "One or more guardians has a signet ring tuned to the haunted art pieces, and can hear what they whisper as they spy.",
          "The ghosts inhabiting the art can move from one piece to another, following intruders or retreating to report."
        ],
        modsEasier: [
          "One spirit per art piece, and each spirit has its own unbalanced personality.",
          "Unhinged art is violent, so it has to be shrouded or restrained when guardians go through the defended area."
        ]
      },
      {
        name: "Starving Fog",
        category: "Ghostly Guards",
        desc: "The guarded area is in a clinging cold fog. Fog draws energy from those breathing in it until it manifests shadows that increase target fear, which feeds it more. Eventually it can manifest a killing shape.",
        questions: [
          "What do intruders in the fog see when it reflects their fears?",
          "Are there sound effects, smells, and sounds, or just fleeting glimpses and silhouettes?",
          "Does it project hallucinations or trigger memories?"
        ],
        modsHarder: [
          "The fog strengthens the Ghost Field, making ghosts within it more powerful.",
          "The fog can move, summoned or controlled by other guardians to provide backup or help search."
        ],
        modsEasier: [
          "The fog is generated by an artifact. If the artifact is neutralized so is the fog.",
          "Those with the proper energy keyed amulet or other trinket are invisible to the fog."
        ]
      },
      {
        name: "Sweat Nectar",
        category: "Ghostly Guards",
        desc: "The defended area is kept hot. Sweat tastes like nectar to swarming ghosts, who dehydrate targets into mummies. The stolen life force and moisture flows to prepared corpses, so ghosts can ride them again.",
        questions: [
          "Were they created by dehydrating sacrifices to death in the defended space?",
          "Were they gathered from outside the lightning walls to stand guard here?",
          "Does a spirit trafficker maintain the wards on the space?"
        ],
        modsHarder: [
          "Many prepared corpses are stashed in unexpected places, bursting into combat when rejuvenated.",
          "Once they rise, the desiccated spirit-ridden corpses will chase intruders until they can't."
        ],
        modsEasier: [
          "Only a few corpses are left to revive.",
          "The site is difficult to keep hot enough to extract the necessary sweat from intruders."
        ]
      },
      {
        name: "Dartus Weed",
        category: "Supernatural Plants",
        desc: "When something moves near a tangled bank of dartus weed, the vines flex, flicking barbed tips towards the source of motion within arm's reach. The darts are paralytic; a target will pass out for about an hour.",
        questions: [
          "Do they have a distinctive flower or smell?",
          "What is the aftertaste of the poison's effect?"
        ],
        modsHarder: [
          "Hounds with chemically toughened hides patrol the weed banks, brutally killing intruders.",
          "Weed banks are cultivated strategically, flanking important doorways or draped over arborwalks, straggling along verges."
        ],
        modsEasier: [
          "The weeds are young. Darts can be stopped with thick leather.",
          "Weed banks are out of the way of defended valuables, but too close to very annoyed neighbors who may hold a grudge."
        ]
      },
      {
        name: "Dreamspore Shrooms",
        category: "Supernatural Plants",
        desc: "Placed on the ceiling, they drizzle sandy spores when they sense motion below. Victims hallucinate, heightening subconscious emotion (so they are very mellow, or super anxious, or filled with rage, etc.).",
        questions: [
          "Were these intended to be a site defense?",
          "Did they instead serve a religious or recreational function?",
          "Are there special techniques for harvesting them, perhaps selling them to alchemists?"
        ],
        modsHarder: [
          "A more intense strain, these can knock out those who succumb, and give them vivid dreams for several hours.",
          "They are placed near other guardians as well as hazards like a steep drop or running water."
        ],
        modsEasier: [
          "Other guardians come here recreationally, their effectiveness reduced.",
          "The spores are weak and easier to resist."
        ]
      },
      {
        name: "Floormesh",
        category: "Supernatural Plants",
        desc: "Flat vines grow together to make flooring. Connected below is the bulb, covered in venomous spikes. Anyone heavier than a child will fall through. Blood and rot feed the floormesh.",
        questions: [
          "Have site defenders put carpet over the flat vines to further hide the threat?",
          "What colors, textures, and patterns does this version have?",
          "How dangerous is the venom?"
        ],
        modsHarder: [
          "The building's architecture assumes use of floormesh, the carpets are woven to look like floormesh so the guardians don't have to cover the actual pits.",
          "The mesh itself has venomous thorns in it, so stepping on it or falling through poisons the target."
        ],
        modsEasier: [
          "The pit is not cleaned, the area near it stinks heavily of corpserot. The mesh sags visibly.",
          "Floormesh is mostly hung like tapestries, living decorations, rather than forming pit traps."
        ]
      },
      {
        name: "Ghost Crystal Topiary",
        category: "Supernatural Plants",
        desc: "Ghost crystals are worked into the roots of fancifully trimmed bushes. Ghosts may be able to inhabit the bushes and make them move. This gardening curiosity can be weaponized.",
        questions: [
          "Is this a currently maintained garden, or one that is overgrown and abandoned?",
          "Who provides the necessary skilled care to create or maintain the topiary?",
          "Is there a theme to the sculptures?"
        ],
        modsHarder: [
          "Certain of the most powerful bushes can uproot and move around like living green golems driven by electroplasmic energy.",
          "The bushes hardly move, but the powerful energies of the crystals make ghosts much more coherent and powerful in the garden."
        ],
        modsEasier: [
          "Left unprotected at one point, the garden was raided by thieves after the ghost crystals. Few crystals are left in the shaggy bushes.",
          "Incompetent handling has drained most of the power from the crystals."
        ]
      },
      {
        name: "Keenshrooms",
        category: "Supernatural Plants",
        desc: "These fist-sized mushrooms let out a keening wail when light comes within about thirty feet.",
        questions: [
          "What do they look like?",
          "Is their smell distinctive?",
          "Are they good eating?"
        ],
        modsHarder: [
          "They are strategically placed to surprise intruders; inside doors, on ceilings, in alcoves, behind statues.",
          "Masses of keenshrooms have been allowed to coat walls or fill rooms, and their keen is strong enough to deafen or kill."
        ],
        modsEasier: [
          "The keenshrooms were placed too close to trafficked paths inside or outside the defended site. Constant false alarms dull vigilance.",
          "Too far from site defenders, their keens are seldom investigated."
        ]
      },
      {
        name: "Murder Tree",
        category: "Supernatural Plants",
        desc: "The willow tree grew around bones wired to it, spirit crystals studded in its bark, and leviathan blood at its roots. lt is dimly self-aware. It senses and hates life, whipping and clubbing any who approach.",
        questions: [
          "How do guardians move around the tree?",
          "Suggestions include knowing passwords, having enchanted amulets, or attuning to its blind spots. How many guard the site?",
          "Who had the expertise to cultivate this living weapon, how long ago?"
        ],
        modsHarder: [
          "The chorus of semi-aware spirits that fuel the tree are enslaved by one domineering will. The tree is as coherent as a person.",
          "Multiple murder trees are connected by roots and share knowledge with each other (and any other site guardians.)"
        ],
        modsEasier: [
          "No one can communicate with the murder tree, or control it, so it is isolated from other defenses.",
          "The tree sleeps most of the time, and it is difficult to rouse it to fighting fury."
        ]
      },
      {
        name: "Snatchweed",
        category: "Supernatural Plants",
        desc: "It grows in fresh water, lengthening its long winding tendrils almost to the surface. When touched, it snatches and pulls, coiling down to the bottom and holding for a few minutes before relaxing back up.",
        questions: [
          "Is their growth boosted supernaturally, and can you see faces reflecting from the Ghost Field beneath their fronds?",
          "Are the locals aware of the threat, willing to talk about it?"
        ],
        modsHarder: [
          "Snatchweed is cultivated in areas where intruders must enter the water to get past other obstacles.",
          "The bottom of the water has two foot spikes, victims are pulled down onto them."
        ],
        modsEasier: [
          "A sign warns of the hazard, as required by law.",
          "This particular breed of snatchweed recoils from salt; put enough on the surface and tendrils recoil."
        ]
      },
      {
        name: "Thirstclimber",
        category: "Supernatural Plants",
        desc: "The vines are red, and when flesh touches them (even through leather) the vine draws blood to the surface in alarming quantities. The vines are slippery, and almost impossible to grasp with wet hands.",
        questions: [
          "Are the vines clearly visible to those who can see in the Ghost Field?",
          "Do the vines cause damage that must be healed, or does the blood only flow when they are nearby?"
        ],
        modsHarder: [
          "The site has guard creatures that track by scent and are drawn to attack things that smell bloody.",
          "Thirstclimber is cultivated at the mid-point of a really difficult climb."
        ],
        modsEasier: [
          "Annoyed locals keep it trimmed back on outside walls periodically in spite of the guardian's threats.",
          "Guards know the ingredients to make a special paste, and the symbol to paint on skin with it, to protect from the plant's effects. A former guard might share the secret."
        ]
      },
      {
        name: "Thirsty Thorns",
        category: "Supernatural Plants",
        desc: "Strategically placed thornbushes grow on walls and serve as decorations. They live on blood. They only flower if something dies on them; the bigger the life, the more impressive the bloom.",
        questions: [
          "Do they feed on radiant light?",
          "Are they along the interior walls, lining the walks, and climbing walls outside?",
          "Are there thorns inside, along windows or protecting secret doors?"
        ],
        modsHarder: [
          "The thorns are poisonous, inflicting some condition on those who fail to resist.",
          "Possibilities include sleep, death by choking, blinding blood from the eyes, or paralysis.",
          "The thorns are considered a gardening achievement, with some fame and support as local culture."
        ],
        modsEasier: [
          "A custom amulet tuned to their life energy turns the thorns away, allowing its bearer to push through them unharmed. A site defender may have one, or one could be made.",
          "They are old and brittle, dying by inches and neglected."
        ]
      },
      {
        name: "Vine Curtains",
        category: "Supernatural Plants",
        desc: "Curtains of vines connect back to a radiant root that has grown semi­aware, fed on rogue spirits. If touched, the vines slither and writhe to entangle, hoist, and bundle the target for a guardian to find.",
        questions: [
          "What do the vines look like?",
          "Do they use their scent to attract or repel?",
          "Where is the root relative to the curtain?"
        ],
        modsHarder: [
          "Many curtains and roots of different sizes (some quite big) connect back to a central bulb somewhere in the defense site.",
          "The vines also have a contact poison that makes their target go limp for 10-60 minutes."
        ],
        modsEasier: [
          "The site owner does not have legal permission to have the vine curtains, so they are only used inside.",
          "The vine curtains grow wild and the lazy site owner does not keep them trimmed back, so other guards must stay away from them."
        ]
      },
      {
        name: "Caul Piercers",
        category: "Traps",
        desc: "Piercers are designed to puncture whoever touches them. They pierce the energy caul of the character's life force in the Ghost Field. This causes a harm condition that worsens or costs stress every down time cycle until the caul can be mended (6 segment project.) Interpret as needed.",
        questions: [
          "Do the piercers resemble knives, nails, or thorn-like carvings?",
          "What sadistic expert crafted these dire traps?",
          "If pried out of their settings, how long do they retain potency?"
        ],
        modsHarder: [
          "Those affected will trail life energy like a wounded fish bleeding in the water; demons and ghosts alike will investigate the scent.",
          "They are worked into important doorknobs, strategic ledges, and concealed flooring."
        ],
        modsEasier: [
          "They all look alike and are similarly placed, relying on surprise to be effective.",
          "They are only on the main treasure."
        ]
      },
      {
        name: "Collapsing Ceilings",
        category: "Traps",
        desc: "If triggered, this trap drops a mass of stone. That seals off the threatened area, and crushes anyone tampering with its defenses.",
        questions: [
          "Who put valuables behind a trap that could seal them away for good?",
          "How old is this defense, and who takes care of it?",
          "What warning signs tip off an intruder that continuing is dangerous?"
        ],
        modsHarder: [
          "Hidden mechanisms can raise the block back up to the ceiling, so the trap can be reused (or defeated remotely.)",
          "More than one block falls; the first one cuts off escape, then death seems inevitable."
        ],
        modsEasier: [
          "The stone dropped long ago. Site guardians or intruders have developed ways to climb over it or get past it. Other blocks may still be untriggered, but some of them are no longer dangerous.",
          "More like a mine collapse, difficult to control and possible to tunnel past."
        ]
      },
      {
        name: "Combination or Trick",
        category: "Traps",
        desc: "Various portals and defenses of the site are protected by combination locks or riddles to solve. Lockpicks will not work against them, though finesse may solve them eventually.",
        questions: [
          "Are there a series of combination locks expressing a religious or eccentric worldview?",
          "Are there picture arranging puzzles, or unusual  keys  to go in sculpture locks?",
          "Are the locks mechanical or supernatural?"
        ],
        modsHarder: [
          "Powerful runic work or enslaved ghosts make the obstacle difficult to smash or trick--the right combination or object must be used to bypass it.",
          "Clues and needed items are spread across a large estate, or multiple estates."
        ],
        modsEasier: [
          "The combination or solution to the puzzle is in a scholarly work, and can be found or bought ahead of time.",
          "The solutions are painfully obvious to someone with the right upbringing and background."
        ]
      },
      {
        name: "Contact Needles",
        category: "Traps",
        desc: "Small needles are worked into contact surfaces and poisoned, to deter intruders. They may be on doorknobs, seat backs or cushions, doorframes, stair treads, ledges, beds—anywhere, really.",
        questions: [
          "Are the needles easily visible if you look for them, or camouflaged?",
          "Are they retractable if you know what you're doing?",
          "What kind of poison is on them?",
          "Will the victim sleep, freeze, die, or hallucinate?"
        ],
        modsHarder: [
          "The needles are only corporeal to those who touch them without wearing a certain amulet. Important site guardians are immune to the needles.",
          "Anything important or at an unguarded entry point is going to be festooned with needles."
        ],
        modsEasier: [
          "They are not well maintained. Many have snapped off, and few retain much poison.",
          "They are only on the most important objects or the most useful trap objects (like a chair for guests.)"
        ]
      },
      {
        name: "Excellent Locks",
        category: "Traps",
        desc: "Beyond simple security, these locks are works of art. They are higher potency than they would normally be. Also, they are equipped with poison needle traps, or pick breakers, or redundancies.",
        questions: [
          "Who put in these superior locks, and for what reason?",
          "Are the locks designed to defeat entry, or actively punish intruders?",
          "Do the specialized keys have a distinctive look, like two flanges?",
          "Is there a master key?"
        ],
        modsHarder: [
          "Everything is locked, and all the locks are good. Somebody had a real lock problem.",
          "The locks involve supernatural components, like hidden keyholes or paralyzing energy."
        ],
        modsEasier: [
          "The locks are in poor repair, of variable quality after indifferent maintenance and many intrusion attempts.",
          "Very fancy locks, but they are padlocks, and bolt cutters can circumvent the problem."
        ]
      },
      {
        name: "Murder Holes",
        category: "Traps",
        desc: "Intruders go past one door, into a hallway or small room, and the door closes behind them. Arrow slits open in the walls, and slots in the ceiling allow boiling oil to be poured down. Intruders are trapped and vulnerable. These are often in doors through defenses.",
        questions: [
          "Was the original site builder often under siege?",
          "Are the murder holes obvious or concealed?"
        ],
        modsHarder: [
          "Murder holes are automated with self- slamming doors and pre-boiling oil, so a few defenders can trap and/or kill many intruders.",
          "The whole layout is built with many murder hole areas to deter invasion."
        ],
        modsEasier: [
          "The walls are wooden, and determined captives can break through to face their attackers.",
          "This area does not have enough staff to monitor intruders and make best use of murder holes."
        ]
      },
      {
        name: "Pit Traps",
        category: "Traps",
        desc: "The defended site has pit traps in strategic places. They are between 10 and 40 feet deep.",
        questions: [
          "Do they have slick sides?",
          "Are there spikes at the bottom?",
          "Are the covers mechanized, or flimsy boards and carpets, grass turf, or leaves over canvas?",
          "Are the sides stone, earth, or clay?"
        ],
        modsHarder: [
          "Fist sized tunnels connect pits. Predatory creatures (crabs, snakes, spiders, rats) scurry to devour victims.",
          "Once someone falls into the pit the covers close again, and will not open until unlocked."
        ],
        modsEasier: [
          "The pits drop into a lower area, mostly abandoned except for predators. It is possible to find a way out.",
          "The pits are mostly open and filled with junk."
        ]
      },
      {
        name: "Retractable Spikes",
        category: "Traps",
        desc: "Spring-loaded spears or racks of spears launch at intruders. They can come from the side, behind, ahead, below, or above.",
        questions: [
          "Are the defenses standardized to protect guardians, or random to confuse intruders?",
          "Are they in an area that site defenders use, or in an isolated off-limits area?",
          "How long have they been in use, and how often are they maintained?"
        ],
        modsHarder: [
          "After doing their killing work, they retract, and the launch points are not obvious.",
          "The spears are slathered with some toxin, further affecting the victim."
        ],
        modsEasier: [
          "The mechanisms are not well maintained. Sometimes they don't work, and when they do, there is a screech and they are a bit slow.",
          "The spears are designed to pin an intruder in place, to be interrogated and punished, rather than to kill outright."
        ]
      },
      {
        name: "Secret Doors & Spyholes",
        category: "Traps",
        desc: "Guardians are well trained in the use of numerous secret doors and hidden passages with spyholes. They can attack from unexpected directions, escape without a trace, and watch intruders unobserved.",
        questions: [
          "Was this site built by a spy, or a cult, or a paranoid aristocrat?",
          "Are there consistent tells, a code built into the decor and architecture, or must all secrets be known individually?"
        ],
        modsHarder: [
          "Ongoing rearrangement and construction means old information from plans or people ages out fast.",
          "Supernatural locks and keys mean that triggers and spyholes and seams may not be visible in the material world at all."
        ],
        modsEasier: [
          "Frequent use has made secret doors easier to spot. Poor baffling of lights may reveal spyholes in use.",
          "Current residents are only aware of some secrets; intruders may use back ways to elude security."
        ]
      },
      {
        name: "Shock Grips",
        category: "Traps",
        desc: "One or more contact points are connected to energy so they will badly shock anyone who touches them. These could be doorknobs, chest lids, floor plates, ladders, and so on.",
        questions: [
          "Are they powered by batteries or enslaved ghosts?",
          "Does the site have legal permission to use them?",
          "How loud is the shock?",
          "How do site guardians avoid getting shocked?"
        ],
        modsHarder: [
          "The shock grips are numerous and concealed, connected to their energy source through the Ghost Field.",
          "The shock is designed to stop the heart and kill the victim (possibly setting hair on fire.)"
        ],
        modsEasier: [
          "The shock grips are connected to control boxes and energy sources by cables.",
          "Shock grips are marked by a rune, and shiny, and also give out a palpable hum of energy. They are easy to detect."
        ]
      },
      {
        name: "Brutal Sadists",
        category: "Twisted Guards",
        desc: "Only brutal sadists are hired on as guards. They have permission to play with captured intruders.",
        questions: [
          "Is the owner of the protected property aware of this cultural rule, or are guards hired by an employee?",
          "Do they share cultural roots (slaughterhouse workers, leviathan hunters, soldiers, city guards, etc)?",
          "How do the neighbors feel about their occasional scandals?"
        ],
        modsHarder: [
          "Several of them are skilled in both torture and interrogation; they extract secrets from intruders. A side business in blackmail helps them avoid legal trouble.",
          "They are hardened veterans, exceptionally tough and dangerous. They aim to incapacitate."
        ],
        modsEasier: [
          "Their ugly tactics and poorly chosen victims have earned them (and their employer) enemies in lots of unexpected places.",
          "They really, really like to drink."
        ]
      },
      {
        name: "Close-Knit Guard Network",
        category: "Twisted Guards",
        desc: "Guards are only hired by referral. Failure results in punishment for both the guard and the sponsor. Their loyalty is tested many ways before and after they are hired.",
        questions: [
          "Do they favor bastards of the employer?",
          "Are they connected to one military unit?",
          "Are they refugees from another place?",
          "Do they come from a single neighborhood?",
          "Does punishment extend to their families?"
        ],
        modsHarder: [
          "They are connected to a larger sponsoring organization that would seek vengeance if they are attacked or insulted, and also offer them favors.",
          "They speak in code and have passwords that include safewords and warnings."
        ],
        modsEasier: [
          "Nepotism has pulled in some really incompetent guards.",
          "Endless drama from working with family and friends."
        ]
      },
      {
        name: "Compulsive Detail Focus",
        category: "Twisted Guards",
        desc: "Only a certain type is hired; a type that checks every lock and every dark corner. Schedules are strict, thoroughness is a guarantee, and they seem unable to cut corners or skip steps. Everything is by the book.",
        questions: [
          "Are they altered to be like this, or just screened for a mindset?",
          "What are the detailed parts of the defended site that need this kind of attention?",
          "How does their gear reflect this fussy attention to detail?"
        ],
        modsHarder: [
          "There are other elements of the defended site that require their focus, like a pattern of stepping over tiles to avoid triggering traps or complex combination locks or dozens of cells with dangerous prisoners.",
          "They are trusted with specialty items like firearms or charms because they are responsible with them."
        ],
        modsEasier: [
          "Everyone knows that they fall apart if things deviate from the pattern, like distractions or chaos.",
          "The locals pick on them when they are off duty, teasing them for their compulsions. They have enemies, and could use friends."
        ]
      },
      {
        name: "Convict Public Service",
        category: "Twisted Guards",
        desc: "Due to prison overcrowding, some criminals are sentenced to indentured service to a noble to work off their debt to society. This site's guardian uses criminals as guards, under the stern eye of professionals.",
        questions: [
          "Are casualties high due to danger from intruders or other site defenses?",
          "Is the patron benevolent and trying to rehabilitate criminals, or using them as disposable fodder?",
          "How do the convicts like this place?"
        ],
        modsHarder: [
          "Serving here is a known post among criminals, both a resume builder and networking site.",
          "Angering these guards could bring consequences from unexpected directions in the criminal underworld.",
          "Hand picked as the hardest and deadliest, these criminal guards are canny and tough."
        ],
        modsEasier: [
          "Convicts are eager to assist anyone with enough Coin or pull to secure their pardon and freedom.",
          "The convicts are bullied and sullen, as much a hindrance to defenders as a defense themselves."
        ]
      },
      {
        name: "Demonic Mutations",
        category: "Twisted Guards",
        desc: "About a quarter of the guards have been mutated by contact with demonic essence. They are strong, and their senses are sharp.",
        questions: [
          "Do they share one demon patron?",
          "Did they become guards to gain this power?",
          "Are they worshippers or mercenaries?",
          "Did they volunteer or are they victims?",
          "What element is their demonic affinity?"
        ],
        modsHarder: [
          "They share a supernatural connection and can sense when other demonic guards are in trouble.",
          "They are highly resistant to normal damage. They may be vulnerable to supernatural attacks or a specific allergy (silver, garlic, salt, etc.) Or, they may be resistant to supernatural attacks instead."
        ],
        modsEasier: [
          "They become physically impressive, but their minds are lost to incoherent lusts and fury.",
          "The rest of the staff resent or fear the demonic guards. Loyalty and morale are low among mundane employees."
        ]
      },
      {
        name: "Enchanted Prosthetics",
        category: "Twisted Guards",
        desc: "Guards are all amputees with at least one prosthetic. Each prosthetic tunes to its owner. The prosthetics can stun on contact.",
        questions: [
          "Are the false limbs the work of one genius?",
          "Are they part of a collection?",
          "Were they made for this use?",
          "Is a ghost bound to each?",
          "Are they scientific, with batteries?",
          "Are they powered by the bearer's life force?"
        ],
        modsHarder: [
          "All guards have some adept training and spirit bane charms, alert against supernatural forces.",
          "Veteran guards have learned to tune to their prosthetics to get an additional effect, like life detection or firing energy blasts."
        ],
        modsEasier: [
          "Only one use between recharges.",
          "The guards are mostly old or broken, relying on reputation and supernatural energy to be effective."
        ]
      },
      {
        name: "Feral Pen",
        category: "Twisted Guards",
        desc: "Some areas of the defended site have free-range maniacs. Destitute and wretched beggars are treated as guard dogs, expected to attack intruders and draw attention to anything unusual.",
        questions: [
          "Does the guarded site pretend to be charitable, or a madhouse, or a prison?",
          "What philosophy leads to treating people this way?",
          "How do the city authorities feel about the site?",
          "Religious authorities?",
          "Does the site feed into the Ghost Field in an unusual way?"
        ],
        modsHarder: [
          "Most of the feral guards are killers, possibly haunted, and extremely dangerous.",
          "This pet project is as much art and religion as defense, and has support from a variety of decadent aristocrats in positions of power."
        ],
        modsEasier: [
          "The rest of the site guards hate the feral pen and ignore it as best they can.",
          "It is as much prison hospice as guard dog kennel. Its victims are weak, sick, and starving."
        ]
      },
      {
        name: "Fighting School",
        category: "Twisted Guards",
        desc: "An onsite training school focuses on the lifestyle and skill of a school of fighting. Site defenders are part of a group identity with specialty training.",
        questions: [
          "Is the school's focus on dueling, a martial art, commando training, or something else?",
          "What is their crest, uniform, motto, and lore?",
          "What sort of training space do they have?"
        ],
        modsHarder: [
          "The school itself is an impressive fortress or defense.",
          "The school has an impressive alumni network that visits occasionally and would avenge wrongs to the honor of the school."
        ],
        modsEasier: [
          "This is an off-site shrine or expansion, where they send troublemakers and those they can't eject for political or financial reasons.",
          "Leadership is riddled with rivalries and power struggles. Outsiders know some details."
        ]
      },
      {
        name: "Performance Enhancers",
        category: "Twisted Guards",
        desc: "Guards have ready access to drugs. Some of the drugs enhance performance.",
        questions: [
          "Do the drugs give them a burst of combat effectiveness?",
          "Are the drugs recreational, making them popular with a customer base that pays well and owes favors?",
          "Who provides them with drugs?"
        ],
        modsHarder: [
          "As dealers, the guards are difficult to bribe or intimidate, as they have money and prestige.",
          "Guards can medicate flexibly, with concoctions to enhance perception (even to see the supernatural,) gain combat prowess, or heal."
        ],
        modsEasier: [
          "Their peddling of illegal drugs has made enemies among bluecoats and inspectors.",
          "The guards are junkies. Their employer uses addiction to control them, keeping them near the edge. They are often distractible or unconscious."
        ]
      },
      {
        name: "Zealots",
        category: "Twisted Guards",
        desc: "Guards share a religion that binds them together and makes them resistant to intimidation or corruption.",
        questions: [
          "Do they worship one of the Forgotten Gods? The Church of the Ecstasy of the Flesh? Weeping Lady?",
          "Have they sworn oaths?",
          "What does religion require them to hate, or to love?"
        ],
        modsHarder: [
          "The defended site includes a shrine or temple. Violating the site angers offended worshippers.",
          "Serving as a site guardian is part of a religious duty. Unexpectedly seasoned warriors or important people may serve as lowly guards for a time."
        ],
        modsEasier: [
          "Mandatory prayer times, unclean objects or places left uninspected, and restricted areas may create holes in security.",
          "Enemies of their religion may offer help to embarrass, discredit, or injure the zealots."
        ]
      },
      {
        name: "Ghostport Lock",
        category: "Weird Tech",
        desc: "Keys are tuned to locks that cannot be picked by normal means, or bypassed without whisper expertise. Their access point is in the Ghost Field until the key is present.",
        questions: [
          "Are these locks modem scientific triumphs, or old arcane defenses?",
          "Does he key look like a key, or does it look like a missing decoration, or a gem?",
          "Is the key physical, or energy, like living blood of the right family?"
        ],
        modsHarder: [
          "The locks are hidden and trapped. Messing with the lock could hollow the intruder (tearing the spirit out of the body) or other unpleasantness.",
          "The precise location of the lock must be known, and it is not near what it is locking."
        ],
        modsEasier: [
          "The ghostport lock has been a fad several times in Duskwall. Each time, there was some mass production, and a key to a similar lock might work with a little help.",
          "The owner may have stiffed a whisper locksmith on the fee, or otherwise offended the expert, who is knowledgeable and disgruntled."
        ]
      },
      {
        name: "Lightning Walls",
        category: "Weird Tech",
        desc: "Runic energy twisting technology can make pylons that project a curtain of energy between them. The glowing walls are transparent, but crippling to touch and lethal to pass through. They stop projectiles.",
        questions: [
          "Does the site have the technology legally, or is it stolen?",
          "Maybe cobbled together from leftovers by a mad alchemist?",
          "Is it on all the time (expensive to fuel) or only if the alarm is raised?",
          "Where are the fuel cells kept?"
        ],
        modsHarder: [
          "The equipment is properly installed, its vulnerable parts behind the energy curtain, directly guarding what needs protecting.",
          "The lightning walls attract loose spirits, intruders may also have to contend with confused ghosts."
        ],
        modsEasier: [
          "The walls guard a few key access points, but there are multiple ways around.",
          "The walls are installed poorly, so their machinery is vulnerable from the outside while it is on. If no other guards are present, they can be wrecked."
        ]
      },
      {
        name: "Panopticon",
        category: "Weird Tech",
        desc: "Special crystal lenses transmit their sight through the Ghost Field to mirrors in a central location. From one place, a guardian can monitor views all over the defended site.",
        questions: [
          "Is this new industrial alchemical technology, or an ancient enchanted construction?",
          "Does the current owner know how to get the most functionality out of it?",
          "Who maintains the system?"
        ],
        modsHarder: [
          "The lenses are hidden in mirror frames, statues, and other decor. They are difficult to spot.",
          "The lenses can see into the Ghost Field as well, observing ghosts or occult work, and life force."
        ],
        modsEasier: [
          "The guardians watching the mirrors are somewhat lax.",
          "Over time, many lenses have not been replaced or repaired. Views are limited."
        ]
      },
      {
        name: "Shadow Lanterns",
        category: "Weird Tech",
        desc: "Guards are equipped with lanterns that detect shadows of recent life force as well as shedding light.",
        questions: [
          "Are the lanterns traditional lantern shape, or a glowing ball, or something else?",
          "Does an expert keep the guardians supplied, or is their supply jealously guarded?",
          "Does it cost the guards something to activate the lanterns?",
          "Will the lanterns work if taken off-site?"
        ],
        modsHarder: [
          "Guards are trained to tune into the life force energy to also hear conversations of the life shadows. Guards can tune into the life force energy to know the owner's current location, if in the defended area.",
          "Untended lanterns can be set to transmit detection of a life force to a nearby guardian."
        ],
        modsEasier: [
          "The lanterns can be rendered blind by properly tuning a spiritbane charm while near one.",
          "Every sunrise wipes all traces of past life forces, and they only work at night."
        ]
      },
      {
        name: "Shadow Rooms",
        category: "Weird Tech",
        desc: "The Ghost Field sometimes remembers rooms or entire neighborhoods that no longer exist in the material world. Some defended sites hide treasures in these spaces that can only be accessed if you knowhow.",
        questions: [
          "How are colors different in these shadow rooms?",
          "Is there a smell or sound that lingers?",
          "How does it feel to step out of the material world?",
          "What natural laws work differently here, like fire not flickering?"
        ],
        modsHarder: [
          "The access point to the shadow rooms is an enchanted lock, its location is known and guarded.",
          "The shadow rooms are only connected to the material world a few times a year, or less."
        ],
        modsEasier: [
          "Transitioning from the material world to the shadow rooms involves certain proscribed movements; cross the courtyard three times, then back down stairs with eyes closed (for example.) Too many people know the formula.",
          "The current site owners do not know these rooms exist."
        ]
      }
    ],
    NPCs: [
      {
        name: "Arturo Montastic",
        type: "npc",
        concept: "Addicted Gambler",
        arena: "New Money",
        description: "He is impossibly lucky. He wins enough at games of chance to pay for his addictions, and to treat the consequences (transfusions, transplants, cutting-edge treatments.) His relationships are intense but brief. He often loses everything, but then wins it all back and more. He has owned epic treasures many times.",
        notes: "Risk-averse collectors cannot bear his cavalier attitude on winning and losing priceless art. He does not truly appreciate his treasures, and should not be trusted with them. Losers can take their losses hard."
      },
      {
        name: "Baron Kelyr Strathmill",
        type: "npc",
        concept: "Hardened Industrialist",
        arena: "Old Money",
        description: "His family has controlled the docks for many generations. They quietly destroy competition, and get lucrative city contracts to re-develop blighted areas if the money slows down. Graceful, educated, and pleasant, he is ruthless as barbed steel under a cultured veneer. He is proud of his estate's gardens.",
        notes: "Competition doesn't like being crippled. He often hires outsiders for the dirtiest work, and his victims often hire outsiders to get revenge."
      },
      {
        name: "Baroness Thena Hellyers",
        type: "npc",
        concept: "Hazy Art Patron",
        arena: "Old Money",
        description: "Thena is one of the least emotionally scarred survivors in her weird family. She is a leading light in the art world. She is patron to many artists and her criticism and evaluation drives a significant element of Duskwall's art scene. Whispers have noted she has an unusual connection to the Ghost Field.",
        notes: "Sometimes she hires outsiders to sort out one of her artists' problems. She has a private gallery that she updates with her current trending tastes—those in the art market need to know what's in it."
      },
      {
        name: "Calvin Dannos",
        type: "npc",
        concept: "Eerie Assassin",
        arena: "Underworld",
        description: "The Inkvein was a cabal of seven anonymous assassins, named for their maps of the canals. If one of them was identified as a member, the other six were sworn to kill the outed assassin. Dannos was outed a decade ago, and he killed the other members and their undying founder. Now he IS Inkvein.",
        notes: "Easily bored, he prefers interesting challenges to high paying or easy kills. Of course, many bereaved or power hungry individuals want him dead."
      },
      {
        name: "Commissioner Naria Haig",
        type: "npc",
        concept: "Political Matchmaker",
        arena: "City Law",
        description: "She exudes a plump grandmotherly innocence, but she is one of the sharpest politicians in Duskwall. She supervises over the merging of unexpected allies and the schism of monolithic interests. She cares about one thing—the good of Duskwall as a whole. She is Chair of the Ethics Oversight Committee.",
        notes: "Always playing a bigger game, she uses outsiders to manage errands whose purpose they cannot see. Those she outmaneuvers tend to want to get back at her with violence."
      },
      {
        name: "Doc Sarnin",
        type: "npc",
        concept: "Lecherous Leech",
        arena: "Underworld",
        description: `Doc can keep life in you if you're alive (or recently dead) when you get to him. His extreme methods are often horrifying. Still, his concoctions can crush ghosts, re-attach limbs, and more. The Crows, a tough crew, protect him. They give him victims for his "needs," which are emotional, physical, and scientific.`,
        notes: "Sometimes the Crows hire outsiders to go after rare components or victims for Doc. He has many, many enemies who want to either steal him and force him to serve them, or punish him."
      },
      {
        name: "Doctor Ixit Crichelle",
        type: "npc",
        concept: "Elegant Spook",
        arena: "Old Money",
        description: "Crechelle calls himself an Oneiric Master. He interprets dreams for a fee. He enters them, alters them, and moves through veils to understand truths and secrets the dreamer may not grasp. If he touches a target, or one of their possessions, he may enter their dreams. He appears feeble, but his mind is deadly.",
        notes: "Aristocratic patrons invite him to parties. He needs a person's possession to see into their dreams; he pays for objects to visit some people's dreams. Victims will pay to free themselves ."
      },
      {
        name: "Dr. Hansel Kryvanntic",
        type: "npc",
        concept: "Brilliant Scientist",
        arena: "Foreign",
        description: "He is Severosi, bow-legged and wild-haired. His work on electroplasmic poisoning and mutation in animals and humans is ground-breaking. Fleeing persecution because of his ethically questionable methods back in Severos, he found a more open-minded scientific community in Duskwall.",
        notes: "His research has applications in art, medicine, and war. Those with sufficient resources to further his studies want to control him. He has hurt a lot of people, over time, so he has many enemies."
      },
      {
        name: "Dr. Yerial Crabbskidditch",
        type: "npc",
        concept: "Sleazy Lawyer",
        arena: "New Money",
        description: "He firmly believes those who are wealthy should not be pestered with the law. No matter what you do, if you have means you can arrange for an alternate story that favors you. Deaths, frauds, robberies, and other crimes can be reduced to a few fines. He throws money at problems until they disappear.",
        notes: "He routinely hires outsiders to destroy evidence, intimidate witnesses, compel confessions, and so forth. He has countless enemies, both those seeking justice and former clients who ran out of money."
      },
      {
        name: "Duvrel the Snake",
        type: "npc",
        concept: "Cunning Smuggler",
        arena: "Foreign",
        description: "She is Tycherosian, with the eyes and horns of a goat. Snake tattoos coil around her arms. Exotic drugs from the Dagger Isles flow through her distribution network in Duskwall. She hires outsiders to remove stubborn people while she has an alibi, or to retrieve drugs misplaced at incriminating locations.",
        notes: "Inspectors have orders from the Spirit Wardens to take her alive, to study her uncanny ability to flex with the Ghost Field for supernatural stealth."
      },
      {
        name: "Dylayzia Finchester",
        type: "npc",
        concept: "Fashionable Whisper",
        arena: "New Money",
        description: "Her exotic looks, tattoos, and bright green eyes draw attention. She popularized thigh-high buckled leather boots and spirit bane chokers. Her opinions echo in drawing rooms across the city. People enjoy her feud with the Church of the Ecstasy of the Flesh.",
        notes: "Wealthy figures in the fashion world pay top win for sneak peeks at her clothing designs. Her opinions inflame many enemies­-especially the Church. She hires outsiders to get rare components for her rituals."
      },
      {
        name: "Emeline Coleburn",
        type: "npc",
        concept: "Weary Regulator",
        arena: "City Law",
        description: "She inspects buildings and reports to the Duskwall Council whether they are sound, and whether they serve the purpose listed on the owner's taxation form. She is front-line in the tug-of-war between criminals, politicians, and nobles. She no longer cares about the greater good. Now it's about kickbacks.",
        notes: "She takes the path of least resistance in her evaluations, so people pay to make their preference easier and other roads harder. She hires outsiders for off-the-books communication with pushy customers."
      },
      {
        name: "Eric the White",
        type: "npc",
        concept: "Vigilante Rebel",
        arena: "Foreign",
        description: "The War of Skovlan Unity is over, but this slender maniac with a brushy beard can't let it go. He plans to destroy the government and turn Duskwall into a Skovlan colony to punish them for the destructive war. He wants to discredit and disrupt the government at every turn.",
        notes: "He targets gavernment officials as high up as he can reach, hoping to cause enough trouble to make the government vulnerable to change. He has gathered zealots, and he uses outsiders for disposable work."
      },
      {
        name: "Gi Aniru Ga of Sultha",
        type: "npc",
        concept: "Sacrificing Cultist",
        arena: "Supernatural",
        description: "She worships the Gaping Maw, the Runnel of Life, the Cosmic Thirst. She builds a cult, teaching them to hunt and conduct rituals. Then she moves on. Witnesses uneasily describe her supernatural abilities, including shapeshifting, flight, killing people by attacking their shadows, and so on.",
        notes: "Bereaved relatives, rival cultists, and law enforcers all want her stopped. She hires outsiders to threaten, misdirect, or kill law enforcement. Determined inspectors crush cults she trained, need help to catch her."
      },
      {
        name: "Holtz Clermont",
        type: "npc",
        concept: "Reformed Clerk",
        arena: "City Law",
        description: "He used to be a forger. After he served stint in prison, some respectable family friends got him a position as City Clerk for the whole district. He manages correspondence for permit requests and official notices. When corrupt people inside and outside the system need to adjust evidence, they come to him.",
        notes: "Jilted clients can be threatening, leading him to take steps to adjust their attitude by hiring outside help. He's smarter than he looks, and knows how to back people off. He also might know too much."
      },
      {
        name: "Inspector Lorette Salkha",
        type: "npc",
        concept: "Crusading Inspector",
        arena: "City Law",
        description: 'She needs allies in her hopeless quest to clean up the city. Corruption is everywhere, crime runs rampant, and the bluecoats serve the powerful (on both sides of the law.) Some tragedy in her past propels her into a suicidal effort to restore "rule of law.” Her peers muse it is a shame she will die young.',
        notes: "She could be helpful if she focuses on the right bad guys—your enemies. She can't be bought, so maybe someone needs her killed (or otherwise neutralized.)"
      },
      {
        name: "Jemma Dropkick",
        type: "npc",
        concept: "Feminist Vigilante",
        arena: "Underworld",
        description: "She is a legend in the Seven Shallows neighborhood. She attacks men who abuse women. She survives because she has friends—a few bluecoats, a gang of thugs, and a grateful public. She carefully plans attacks to hurt abusers. Lf her victims abuse again, they are mutilated, packed like luggage, and shipped out of town.",
        notes: "Many powerful men would pay for revenge on Jemma. Sometimes she hires outsiders to help out."
      },
      {
        name: "Kheldaria Whinnich",
        type: "npc",
        concept: "Implacable Developer",
        arena: "New Money",
        description: "She has a vision for developing the Crow's Foot district. It will be divided between businesses, estates, and parks. To realize her vision, she has been selectively buying real estate all around the city, bartering for land in Crow's Foot, and using whatever persuasion is needed to convince owners to sell to her.",
        notes: "She has an estate where she stores induce­ments of all sorts, a variety of treasure designed to persuade owners to sell in exchange for what they want most. They say you could find almost anything there."
      },
      {
        name: "Lady Ashlyn Tyrconnel",
        type: "npc",
        concept: "Decadent Duelist",
        description: "For centuries, aristocrats of Duskwall have learned the Tyrconnel Method of swordplay and self defense. The Tyrconnel family produces countless public servants and warriors—but also a share of scoundrels. Ashlyn's trademark suite of moves is to duel, win, bed someone, and drink to unconsciousness.",
        notes: "You're hired to join the spy game in the Tyrconnel family. Or, someone is targeting her. Either way. Watch your back. Outsiders in the games of nobles are uniformly expendable."
      },
      {
        name: "Lady Candra Dunvil",
        type: "npc",
        concept: "Corrupt Fixer",
        arena: "Old Money",
        description: "Her family built Ironhook Prison. Her wealth is built on generations of shady deals with incarcerated aristocrats and business owners. She sees the world as a rigged game and has contempt for anyone who finds corruption shocking or fixable. She is vain, practical, and ruthless.",
        notes: "She hires outsiders to carry out promises she made to inmates. Her family has casually wrecked reputations and lives over centuries, and that leaves a trail of vengeance seekers."
      },
      {
        name: "Lady Polonia Brogan",
        type: "npc",
        concept: "Desirable Dowry",
        arena: "Old Money",
        description: "She's ugly, smelly, stupid, and rude--and also the key to the Brogan fortune. Her lucky spouse will have access to massive wealth and infrastructure among professional builders and shipwrights of Duskwall. Only her aunt, CECILIA DURWITHE, looks out for her best interests with sharp disapproval.",
        notes: "Brogan hires outsiders to punish those who slight her, or to investigate potential partners. She collects fake wills rogues have planted during assassination attempts, trying to leave her fortune to usurpers ."
      },
      {
        name: "Lord Branon Kinclaith",
        type: "npc",
        concept: "Romantic Horseman",
        arena: "Old Money",
        description: "Branon looks like a hero from a legendary story. He manages the family's stables, the finest horses in Duskwall (where horses are a rare luxury.) His tumultuous trysts with both men and women are common knowledge. Business suffers from his impulsive romantic gestures, but benefits from his charm.",
        notes: "Branon sometimes refuses to sell horses, or breed them, if he dislikes the buyer. Some buyers want access to horseflesh anyway. If his horses are attacked, he hires outsiders to get revenge."
      },
      {
        name: "Lord Bulward Skinnester",
        type: "npc",
        concept: "Greedy Banker",
        arena: "New Money",
        description: "This portly curmudgeon does a brisk trade in real estate titles, both lending and foreclosing. He is acutely aware of the value of properties and how neighbors affect value. He takes particular glee in foreclosing on aristocracy and setting up the newly rich in ancient estates.",
        notes: "Sometimes he hires outsiders to solve problems that his hired bluecoats and bribed councilmen cannot manage. He collects sculpture by Duskwall artists. He has ruined the lives of many formerly influential people."
      },
      {
        name: "Lord Orlan Booker",
        type: "npc",
        concept: "Insulated Mastermind",
        arena: "Old Money",
        description: "Ennui is a danger to the wealthy. Booker fills his days by gathering intelligence and planning heists, then selling the plans to ambitious gangs that lack his patience, experience, resources, and insight. Twice a month he goes to the opera, and meets those who have arranged to purchase a score.",
        notes: "Sometimes things go wrong, and it is natural to blame the planner and want revenge. Sometimes a target wants to punish those who acted against them, even if the act was planning."
      },
      {
        name: "Master Slen Dallicore",
        type: "npc",
        concept: "Protective Guilder",
        arena: "New Money",
        description: "Master Dallicore is the Guildmaster for the Docker's Guild. They move all cargo on and off ships, boats, and gondolas. Their role is protected by law, as are the fees they charge. The guild uses low-level violence to discourage non-guild laborers and smugglers. However, some challenges require proper scoundrels.",
        notes: "Dallicore is not above hiring outsiders to punish powerful patrons of smugglers or illegal dock workers. His position of power also gives him access to rare antiquities, both purchased and acquired."
      },
      {
        name: "Minister Fourteen",
        type: "npc",
        concept: "Grungy Fixer",
        arena: "Underworld",
        description: "The blind Skovlander holds court on the docks, moving from one basement to another. He favors baggy shirts, stained vests, shiny jewelry, and fraying lace. He often acts through his massive bodyguard Severen and his weedy messenger Torok.",
        notes: "He is connected in the Skovlander refugee community, and in Skovlan. For a price (either wealth or an errand) he will share information about Skovlanders. He often hires outsiders to handle sensitive tasks."
      },
      {
        name: "Moonslider the Third",
        type: "npc",
        concept: "Eccentric Artist",
        arena: "New Money",
        description: "She feels moon phases. Her family put her in an asylum for a decade. Later, she won her freedom and inherited the family bootmaking fortune. She makes art. She tries to communicate her moon feelings. She uses oil paint, glass blowing, sculpture, song, and dance in multimedia recitals and art pieces.",
        notes: "Her family bought nice things before they all died and she inherited them; she ignores most of it. She needs expensive equipment and supplies for her bizarre art shows."
      },
      {
        name: "Officer Milos Penderyn",
        type: "npc",
        concept: "Corrupt Bailiff",
        arena: "City Law",
        description: "Milos has access to trial evidence, and to prisoners awaiting trial. He can't get people out, but he can silence them. He has a network of corrupt peers, judges, bluecoats, and others so he can trade favors to accomplish the impossible. Huge and greasy, he is built like a bull and he enjoys the scent of fear.",
        notes: "Controlling Milos could mean protecting or killing someone in bluecoat custody. An endless stream of people want revenge on him, and a more select group would like to control or use him."
      },
      {
        name: "Officer Veleris Walund",
        type: "npc",
        concept: "Heroic Bluecoat",
        description: "There are actually songs about him. He is very popular. Veleris is a skilled orator (though he retreats into modesty) and a canny judge of character and situations. (He insists he just tries to do the right thing.) His opinion is influential in his district. He is trusted to guard valuables. His moustaches are his pride and joy.",
        notes: "He has no family, and he seems to be an idealist. Some try to persuade him, others try to threaten him. Threats don't seem to work. He has been known to quietly hire outsiders to get justice."
      },
      {
        name: "Pebbler",
        type: "npc",
        concept: "Demon Spy",
        arena: "Supernatural",
        description: "This earth demon looks like a fat man built around a boulder gut, leaking sand from joints. It is able to see and hear through sand, earth, and stone within a range of miles. It works with non-cultists voluntarily, selling information in exchange for raids into the rare areas protected from its prying.",
        notes: "Dozens of powerful people want Pebbler banished or robbed. However, the demon is a peerless information exchange, valuable even if it is difficult to control."
      },
      {
        name: "Saithernon",
        type: "npc",
        concept: "Exotic Fence",
        arena: "Underworld",
        description: "He drapes his python, DELGRAAZ, around his neck. He wears a turban with a jewel on it. He is willing to buy almost anything, no matter how strange. He also knows what you need, sometimes before you know you need it. His bazaar unfurls below the Kennington market in an abandoned gondola dock.",
        notes: "He pays people to get things for him, then sells them at tremendously inflated prices to those desperate to have them. This can cause hurt feelings among the desperate."
      },
      {
        name: "Serlevica the Brander",
        type: "npc",
        concept: "Spy Whisper",
        arena: "Underworld",
        description: "Gaunt and frizzed, this foul-smelling Whisper has a secret ritual that allows her to control and see through rats she brands. She sells her services as a spy or site guardian. She has survived by retreating into slums and sewers when threatened, and striking from the shadows until it is safe to emerge again.",
        notes: "She is closely tied to the information marketplace, buying and selling secrets. She often hires outsiders to deal with her enemies through theft or violence, and she is in turn a frequent target."
      },
      {
        name: "Sir Mournseller",
        type: "npc",
        concept: "Anarchist Ghost",
        arena: "Supernatural",
        description: "This ghost possesses old men from the Draymach Asylum, breaking them out to find and hire scoundrels for obscure tasks with no independent purpose. Examples include killing an insignificant chandler or stealing a specific stone from a wall in a noble's estate. Payment is the location of hidden treasure.",
        notes: "A decade ago, an astute inspector began picking out the connection between errands, seeing a very long and very dangerous game to unseat the city's rulers emerging."
      },
      {
        name: "Sir Olen Llanwold",
        type: "npc",
        concept: "Piratical Industrialist",
        arena: "New Money",
        description: "He is thin and nervous, easy to underestimate. He specializes in stripping foes of their assets and taking over their operations. His father was a butler, and he grew up hating aristocrats. He understands power structures and corrupts retainers. His top agent, Ellsfielder, is a beautiful and ruthless woman.",
        notes: "Many ruined aristocrats (and their allies) hate Danwold passionately. He does not hesitate to use his assets, legal and otherwise, to defend himself and cripple his foes. He hires outsiders through proxies."
      },
      {
        name: "Sir Tocker Farros",
        type: "npc",
        concept: "Pragmatic Councilman",
        arena: "City Law",
        description: "Sometimes the law works, and sometimes it doesn't. Regardless, the Council must rule and there must be order. Sir Farros ensures the districts he serves do not get too far out of hand before lawless elements are curbed. One way or another. He looks like an affable grandfather, but he has a dark past.",
        notes: "Sir Farros uses inspectors or scoundrels, politicians or housemaids—anyone who will get the job done. He has an endless list of enemies who feel he wronged them, and want revenge. His agents are disposable."
      },
      {
        name: "SLOPSPATTER",
        type: "npc",
        concept: "Canal Hull",
        arena: "Supernatural",
        description: "This hull learned to consume spirits and bolster its strength with theirs. It cannibalizes machinery and rummages in wrecked boats for parts. It has gondola prow shoulder guards and helm, and strange banded armor made of water-logged wood over intricate mechanical parts. It fears destruction.",
        notes: "It assassinates targets, with its body or by possessing machines near them. It hunts whispers, leeches, and scholars, stealing their knowledge and killing them. Their allies want revenge."
      },
      {
        name: "Syla DuTorrivestria",
        type: "npc",
        concept: "Famous Connoisseur",
        arena: "Foreign",
        description: "This mysterious Iruvian hides behind a veil. For years, she has been the final word on Duskwall delicacies. She specializes in evaluating high-end cuisine (including spore wines and cooking with leviathan blood.) She stays in the public eye with racy politics and a string of scandalous romances.",
        notes: 'She must keep any real competitors for her fame weakened and embarrassed, and she has countless enemies. Everyone "knows" she is an Iruvian spy.'
      },
      {
        name: "The Honorable Telia Cray",
        type: "npc",
        concept: "Stern Prosecutor",
        arena: "City Law",
        description: "She's old, she's sour, and she has a reputation for jailing Duskwall's criminals. As thin and hard as an iron poker, she relentlessly pursues her cases, bending the law with a passionate hatred of scoundrels. She runs a special unit of Inspectors dedicated to investigating her cases, run by INSPECTOR ULEK.",
        notes: "If she is taking a case personally ( as she often does) she may hire outsiders to acquire or create evidence. She also conduds a brutal war of counter-intelligence against rogues looking to free their associates."
      },
      {
        name: "The Wooden Judge",
        type: "npc",
        concept: "Haunted Puppet",
        arena: "Underworld",
        description: "This knee-high ventriloquist dummy looks like a caricature of a grim Judge. It is supernaturally animated. The puppet appears unexpectedly, interrupting a scoundrel's routine by offering jobs in a squeaky voice. He pays by revealing the location of hidden caches of ancient coin.",
        notes: "Many angry victims want to know who pulls the strings of the Wooden Judge. The puppet often hires fresh talent for dubious work."
      },
      {
        name: "Theodore Lysander",
        type: "npc",
        concept: "Bard Pimp",
        arena: "Underworld",
        description: "Elegant and charismatic, this well-dressed man runs the Tenpenny Court Network. He manages prostitutes and their customers, his personal connections and charm monetized. He is also a skilled composer and performer, often seen at the Worldsedge Theater in Crow's Foot.",
        notes: "He is a skilled networker. He takes the safety of his friends seriously, and is protedive of his employees, to the point of using blackmail to force powerful patrons to back off."
      },
      {
        name: "Chief Prichard",
        type: "npc",
        description: "The head Overseer of the Ministry of Provisions in Duskwall. Manages the workers and food allotments for the city districts.",
        district: "Barrowcleft",
        traits: [
          "calculating",
          "confident",
          "calm"
        ]
      },
      {
        name: "Lord Strangford",
        type: "npc",
        description: "Operates one of the largest leviathan hunter fleets, serves on the City Council and is a high-ranking member of the secret order within the Church of Ecstasy.",
        district: "Brightstone",
        traits: [
          "secretive",
          "calculating",
          "arrogant"
        ]
      },
      {
        name: "Hutton",
        type: "npc",
        description: "A Skovlander refugee and former soldier, now the leader of an anarchist revolutionary movement, bent on forcing the government to acknowledge Skovlander rights in the Empire.",
        district: "Charhollow",
        traits: [
          "brave",
          "compassionate",
          "wise"
        ]
      },
      {
        name: "Lady Drake",
        type: "npc",
        description: `A magistrate who is "reasonable" when it comes to street crime, so long as the offender's purse is sufficient.`,
        district: "Charterhall",
        traits: [
          "flexible",
          "shrewd",
          "subtle"
        ]
      },
      {
        name: "Master Slane",
        type: "npc",
        description: "A notorious factory foreman known for excessive and cruel punishments for the smallest infractions. Many attempts have been made on his life, but all have failed. Some say he's a devil.",
        district: "Coalridge",
        traits: [
          "cold",
          "cruel",
          "sadistic"
        ]
      },
      {
        name: "Sergeant Lochlan",
        type: "npc",
        description: "The senior Bluecoat squad leader in the district, reporting to Captain Dunvil. Lochlan is flexible and reasonable, taking bribes and payoffs when she can; enforcing the law and making examples when necessary.",
        district: "Crow's Foot",
        traits: [
          "shrewd",
          "tough",
          "commanding"
        ]
      },
      {
        name: "Chief Helker",
        type: "npc",
        description: "One of the most influential senior Dockers. Helker has a lot of sway at the docks, and if you cross him, you might find your cargo tossed into the drink—and possibly you along with it.",
        district: "The Docks",
        traits: [
          "cautious",
          "greedy",
          "vengeful"
        ]
      },
      {
        name: "Master Krocket",
        type: "npc",
        description: "An unsavory, greasy-haired, scarecrow of a man who runs the snarling pack of vicious dogs used by Ironhook to track down escapees and sniff out contraband and tunnels. His dog-handlers can be found around the labor camp and all about Dunslough, using their status with the prison for favors and bribes.",
        district: "Dunslough",
        traits: [
          "cruel",
          "greedy",
          "ruthless"
        ]
      },
      {
        name: "Jira",
        type: "npc",
        description: 'A dealer of fine weapons from the Dagger Isles. Greatly respected by many street toughs in The Dusk—a "jira blade" is a status symbol that many aspire to.',
        district: "Nightmarket",
        traits: [
          "bold",
          "tough",
          "confident"
        ]
      },
      {
        name: "Levyra",
        type: "npc",
        description: 'A medium who invites clients to bring ghosts in bottles to posses her so they can share a few final words before the ghost is "freed" (Levyra hands it off to the waiting Spirit Wardens nearby).',
        district: "Silkshore",
        traits: [
          "weird",
          "daring",
          "dishonest",
          ""
        ]
      },
      {
        name: "Mother Narya",
        type: "npc",
        description: "Runs the Arms of the Weeping Lady charity house.",
        district: "Six Towers",
        traits: [
          "kind",
          "patient",
          "gracious"
        ]
      },
      {
        name: "Maestro Helleren",
        type: "npc",
        description: "Senior composer and conductor of the Spiregarden Theater, premiere performance venue for the elite of the city.",
        district: "Whitecrown",
        traits: [
          "sincere",
          "dramatic",
          "vain"
        ]
      },
      {
        name: "Hester Vale",
        type: "npc",
        description: 'Matriarch of the oldest farm family. The living embodiment of "tough but fair."',
        district: "Barrowcleft",
        traits: [
          "proud",
          "fierce",
          "suspicious"
        ]
      },
      {
        name: "Commander Bowmore",
        type: "npc",
        description: "Chief Officer of the Watch in Brightstone. Bowmore's family financed Bowmore Bridge centuries ago and now holds many positions of power.",
        district: "Brightstone",
        traits: [
          "proud",
          "principled",
          "connected"
        ]
      },
      {
        name: "Briggs",
        type: "npc",
        description: "The owner of a merchant stall at Charhollow market, cover for a network of gossips, spies, and code-smiths among the working class people of the district, selling their services to those who need them.",
        district: "Charhollow",
        traits: [
          "secretive",
          "sneaky",
          "cautious"
        ]
      },
      {
        name: "Lord Penderyn",
        type: "npc",
        description: "Chief Scholar of the Archive of Echoes, authorized by the Emperor to keep a collection of ancient ghosts trapped in spirit bottles, to be consulted in cases where knowledge from the distant past would benefit the operation of the Imperial government. Lord Penderyn also consults the spirits on his own volition, forming the rebellious Path of Echoes society for other elites and nobles who seek communion with the spectral realm.",
        district: "Charterhall",
        traits: [
          "reckless",
          "strange",
          "obsessive"
        ]
      },
      {
        name: "Belle Brogan",
        type: "npc",
        description: "A Skovlander factory worker who's been gaining popularity as a potential union organizer. It's only a matter of time before a factory boss tries make an example of her.",
        district: "Coalridge",
        traits: [
          "charming",
          "confident",
          "bold"
        ]
      },
      {
        name: "Lewit, Jol, Myra, Reyf",
        type: "npc",
        description: "Bluecoat constables; run an extortion racket.",
        district: "Crow's Foot",
        traits: [
          "arrogant",
          "vain",
          "volatile"
        ]
      },
      {
        name: "Tris",
        type: "npc",
        description: "A legendary tattooist who only inks those that have looked upon a leviathan and lived to tell the tale. Getting a tattoo from Tris is a rite of passage for everyone who hunts the demons of the void sea.",
        district: "The Docks",
        traits: [
          "artistic",
          "popular",
          "insightful"
        ]
      },
      {
        name: "Vandra",
        type: "npc",
        description: "A deathlands scavenger that survived six runs and was pardoned. She knows the landscape beyond the barrier very well—but few can make sense of her haunted mumblings.",
        district: "Dunslough",
        traits: [
          "haunted",
          "wise",
          "daring"
        ]
      },
      {
        name: "Leclure",
        type: "npc",
        description: "A purveyor of personal luxuries (soaps, hair oils, perfume, fine silks) who dabbles in fortune telling. Some say her that drowned lover is a ghost that whispers secrets in her ear.",
        district: "Nightmarket",
        traits: [
          "shrewd",
          "tough",
          "commanding"
        ]
      },
      {
        name: "Helene",
        type: "npc",
        description: "The elegant and mysterious proprietor of the Silver Stag Casino. People say she would have been a queen of Severos had she lived in the old days before the Empire.",
        district: "Silkshore",
        traits: [
          "cultured",
          "charming",
          "secretive"
        ]
      },
      {
        name: "Chef Roselle",
        type: "npc",
        description: "One of the best cooks in the city, still operating the legendary Golden Plum restaurant—worth the trip into the haunted streets of Six Towers.",
        district: "Six Towers",
        traits: [
          "creative",
          "insightful",
          "friendly"
        ]
      },
      {
        name: "Lady Freyla",
        type: "npc",
        description: "Regarded by some as the finest sommelier in the Empire. She serves only the most deserving at the Emperor's Cask.",
        district: "Whitecrown",
        traits: [
          "erudite",
          "cultured",
          "charming"
        ]
      },
      {
        name: "Mara Keel",
        type: "npc",
        description: "A former smuggler who's gone into hiding among the farm laborers of Barrowcleft.",
        district: "Barrowcleft",
        traits: [
          "quiet",
          "secretive",
          "patient"
        ]
      },
      {
        name: "Rolan Wott",
        type: "npc",
        description: "An influential magistrate who handles property, endowments, and financial cases. Famous for his extravagant parties.",
        district: "Brightstone",
        traits: [
          "stylish",
          "elitist",
          "shrewd"
        ]
      },
      {
        name: "Corben",
        type: "npc",
        description: "An ex-military Skovlander on the lam for crimes against the empire.",
        district: "Charhollow",
        traits: [
          "tough",
          "reckless",
          "candid"
        ]
      },
      {
        name: "Hopper",
        type: "npc",
        description: 'A drug addict, whisper, and all-around weirdo who perches on rooftops in the district. Hopper claims to see "ghost rails" and "spirit trains" originating deep beneath Coalridge, stretching beyond the horizon.',
        district: "Coalridge",
        traits: [
          "weird",
          "visionary",
          "enthusiastic"
        ]
      },
      {
        name: "Mardin Gull",
        type: "npc",
        description: "Owner and operator of the Leaky Bucket public house. Mardin was the leader of the Crows many years ago, before Roric and Lyssa, and now enjoys a comfortable retirement out of the scoundrel life.",
        district: "Crow's Foot",
        traits: [
          "charming",
          "experienced",
          "respected"
        ]
      },
      {
        name: "Mordis",
        type: "npc",
        description: "A strange merchant which hides its true appearance beneath many layers of robes and hoods. Also fences occult and arcane stolen goods, no questions asked.",
        district: "Nightmarket",
        traits: [
          "secretive",
          "insightful",
          "arcane"
        ]
      },
      {
        name: "Madame Tesslyn",
        type: "npc",
        description: "Operates the Red Lamp brothel, the oldest and most respected institution of its sort in the city.",
        district: "Silkshore",
        traits: [
          "confident",
          "insightful",
          "enthusiastic"
        ]
      },
      {
        name: "Flint",
        type: "npc",
        description: "A spirit trafficker who trades out of a condemned manor house.",
        district: "Six Towers",
        traits: [
          "weird",
          "calculating",
          "suspicious"
        ]
      }
    ],
    Scores: [
      {
        name: "Accidental Death",
        category: "Secret Dirty Work",
        desc: "Not only must the target die, the target must not know how death came. If by some misfortune the ghost of the victim is interrogated, it must not have any special knowledge. There is a ritual and an amulet for the assassins to ensure secrecy. No one living or dead can know who did this deed.",
        narrative: "By the time the crew knows the job, there is a better than even chance their knowledge is too much risk and their employer plans to kill them. They might want some leverage."
      },
      {
        name: "Bayer's Train Heist",
        category: "Misplaced Fortune",
        desc: "Bayer was a rail jack fired for being drunk. Over years, he built a crew with one mission in mind--robbing a train. When lruvia completed negotiations with Akoros to buy an unprecedented mass of leviathan blood to pour into industrialization, Bayer's crew hit the train carrying the payment, sabotaging a bridge. Rescuers found the train in the canyon, but no gold--an impossible feat. Bayer's crew vanished.",
        narrative: 'An Iruvian ingot stamped with the year "802" will attract attention.'
      },
      {
        name: "Bellweather Architectural Plans",
        category: "Historical Curiosity",
        desc: "The Duskwall Archives have the sanitized blueprints of the Bellweather Crematorium on file. The original plans were drawn by a Spirit Warden driven mad by an internal rift, so he haunted himself. He drew peculiar plans with occult underpinnings, and those original drawings were interpreted by architects.",
        narrative: "Are there coded secrets in the original plans that reveal a repellant secret or ominous threat? Or are the plans the scribbling of a madman? Either way, some people would pay top coin to get a good look."
      },
      {
        name: "Book of Walls",
        category: "Historical Curiosity",
        desc: "Long ago, a nameless rogue cultivated a mass of bloodworms in a wall. He wrote a book with their blood. The words were nonsense, but strangely affecting; if the reader tuned in to them, and held the book, the reader could walk through a wall. Spirit Wardens ruined the book with holy smoke.",
        narrative: "A legend, or is there truth to it? Walking through walls is a neat trick, and the book may hold the key to learning it. It is sought by a wide variety of the curious—scholars, collectors, and scoundrels."
      },
      {
        name: "Censer Mace of Udoch",
        category: "Religious Object",
        desc: "The head of this ornately carved mace opens on hinges so incense can be put inside to wisp as the mace swings. The haft has a recipe carved into it, instructions to make special incense out of bone and rare sap and unguents. If that incense bums in the mace, it can destroy ghosts or demons with a single hit.",
        narrative: "This was a founding artifact of the Church of the Ecstasy of the Flesh. If it were returned, they would gain a fresh following from critics who feel the church cannot protect against supernatural threats."
      },
      {
        name: "Charter of Crows",
        category: "Historical Curiosity",
        desc: "This gauntlet is made out of crow beaks. Each beak is carved with arcane symbols. Consulting Whispers officially report it does not have any power in the Ghost Field. It was made by the Spirit Warden who first tamed the deathseeker crows; he claimed it was a treaty that guaranteed their service.",
        narrative: "Spirit Wardens lost this gauntlet decades ago, but they want it back. The idea it is a treaty with the deathseeker crows is probably nonsense. They can't take that chance."
      },
      {
        name: "Combination Harpsichord",
        category: "Weird Scholarship",
        desc: 'TARNALI was a Whisper composer who built a special harpsichord. When two tones are played, often a third "ghost" tone can be heard. By attaching the tuning pegs to crystals and runes, Tarnali built a harpsichord that could interact with the Ghost Field through calculated progressions of played tones.',
        narrative: "This effort is intensely interesting to those who want to find doors hidden in the Ghost Field, draw or repel what lurks Behind the Mirror, or develop more portable tonal energies for non-Whispers ."
      },
      {
        name: "Dyvik's Chaser Mask",
        category: "Weird Artifact",
        desc: "This silvery face mask has the word “Elekthiaron” etched along its inner edge. When the word is spoken, the personality of the one touching the mask is pulled into it. The personality that was in the mask goes in the body. If the one in the body doesn't touch the mask once a week, madness threatens.",
        narrative: "Has someone been using the mask to pose as someone else? How long has that been going on? Is there someone in the mask that needs rescuing? Was the mask used to cheat biological death?"
      },
      {
        name: "Evardian's Song Folios",
        category: "Weird Scholarship",
        desc: 'Four leather-bound volumes, full of musical notation with heavily annotated margins. The "music" is supposed to be transcribed and translated leviathan song. Legend suggests if the music is played correctly, it can drive humans insane with visions of the demon-haunted deep.',
        narrative: "Aristocrats will collect anything. Scholars go to great lengths for research material. Cultists may find religious significance in the folios. (Owning the folios is against the law.)"
      },
      {
        name: "Falheim's Prod",
        category: "Historical Curiosity",
        desc: "This ragged pole with a spear and a silver-cable loop was the first prototype of what became the lightning hook. It doesn't work very well, but it was the first historically known charged object that could consistently interact with the Ghost Field.",
        narrative: "Apparently this bit of history is an important prestige piece in the turbulent intrigues of a number of underground cults led by Whispers. The city government would also like to display it in a museum."
      },
      {
        name: "Fang of Ibiria",
        category: "Religious Object",
        desc: "This brutal stiletto has a green stone in the pommel, and a runic symbol on the blade. The blade transforms electroplasm into a mutagen. The longer the blade is in a victim, the more monstrous the victim becomes. A cut gives nightmares, minutes give mutations, hours or days create a real monster.",
        narrative: "Cultists want this blade so they can make or become monsters."
      },
      {
        name: "Goblet of Eletrachtian",
        category: "Weird Artifact",
        desc: "The silver and gold cup is big enough to hold with two hands, crusted with obsidian stones. The owner puts a drop of a demon's blood in the goblet with certain other liquids, and conducts a ritual. For days afterwards (maybe longer) the owner can see anything the demon uses remote vision to view, just by watching the surface's illusory reflections.",
        narrative: "There are many legends about the creation of the goblet, and the fate of the Whisper who first energized it. Rumor suggests the Duskwall Council entrusted the goblet to a certain family for safekeeping."
      },
      {
        name: "Hollow Shroud",
        category: "Religious Object",
        desc: "The Church of the Ecstasy of the Flesh clergy wrapped the funeral shroud around a heretic, then conducted a ritual that severed the heretic's connection to the body, cutting the spirit loose as a ghost. The shroud transferred the spirit of a faithful but sickly member into the heretic's body. New life!",
        narrative: "The Shroud was stolen almost twenty years ago, and rumors suggest it has been used in debased rituals to summon demons or enflesh echoes of the Forgotten Gods."
      },
      {
        name: "Idol of the Sleeping Lion",
        category: "Religious Object",
        desc: "The hefty iron statue depicts a devilfish-headed humanoid, cloaked in wings. Its presence influences human dreams, so they drift through the ink-black sea but can perceive their surroundings. Sacrificing to the statue gives a cultist a cosmic infection, involving psychic ability and mutations.",
        narrative: "The statue has been retrieved by officers of the law several times, and destroyed several times more. Again and again, it emerges in the heart of fresh tragedy, baleful and singular."
      },
      {
        name: "Ink Fleece",
        category: "Family Heirloom",
        desc: "Long ago, Captain Manarill claimed he could prove that leviathans had fur, or fleece. He brought back a swatch of curling fur as big as a bedspread. He claimed to have harvested it from a leviathan's skin. The mantle served as a symbol of the Manarill family's heritage of exploration and danger. But it was stolen.",
        narrative: "Does it do more than represent heritage? What dreams might one have while wrapped in it? Might a wealthy Whisper pay more for it than the family that owned it? Who took it?"
      },
      {
        name: "Kasavaraya Tea Set",
        category: "Family Heirloom",
        desc: "When the Immortal Emperor visited Akoros four centuries ago, he used this tea set with the patriarch of the Kasavaraya family. They are still one of the most decorated and entrenched military families in Duskwall. Their tea set is a symbol of Duskwall's prominence. However, a saucer and a cup are missing.",
        narrative: "This stuff is priceless, literally, so negotiating a price for its return is tricky. If you could find the missing pieces, or forge them adequately, they would be great hostages to ajfed the family's behavior."
      },
      {
        name: "Kidnap The Heir",
        category: "Secret Dirty Work",
        desc: "People are keys that fit into estate locks. They can be turned to open the way to lots of money. You might be taking a child to ransom back to the guardian, or you might be getting someone out of the way so a more distant heir can inherit. This is about controlling where the money goes.",
        narrative: "How harsh does the employer want this to be? Kid gloves treatment, or is the plan to kill the heir when it is all over? How much input will the employer accept from the hired help? Is the plan already in place?"
      },
      {
        name: "Krogs Broken Heart",
        category: "Misplaced Fortune",
        desc: "Krog was a savage from the Dagger Isles, pressed into service on a hunting ship. He eventually owned a small fleet. He was old when he fell in love with a young woman who robbed him. Heartbroken, he took the rest of his treasure aboard his last hunting ship, Heartsong, and scuttled her in the harbor.",
        narrative: "Whispers like to brag they found a way under the waves to find the wealth. Gracmaas the Pirate claimed to have recovered it all to his hidden lair—before he was killed."
      },
      {
        name: "Limptwitch's Stash",
        category: "Misplaced Fortune",
        desc: "Limptwitch was a Whisper who interrogated ghosts to find the location of hidden treasure. He was famous for his Grotto, the place where he stored all his salvaged wealth. Many factions tried to get his treasure, but he never gave up the secret. Then he was jailed and hanged. The Grotto was never found.",
        narrative: "Did a cellmate in prison hear muttered hints as to its location? Maybe a Whisper has clues based on where he left his mark in the sewers. Has someone finally found a real lead?"
      },
      {
        name: "Mark of the Void",
        category: "Religious Object",
        desc: "It is an eerie black disk of leviathan bone, about the size of a dinner plate but five times as thick. The bone is carved with a strange circular pattern with rays cutting through it. The primitive artwork was polished, and silver inlaid in the pattern, by a decadent nobleman.",
        narrative: "Impressionable people admit the disk whispers to them, they hear the Back of the Mirror when it the disk is near. Many cults see this disk as a conduit to clearer communication with their supernatural patrons."
      },
      {
        name: "Naladicha's Cartography",
        category: "Historical Curiosity",
        desc: "The famous cartographer Naladicha died, and his ghost was woven into a spirit anchor connected to a pen on a wire. The drooping pen scribbled nonstop, dipping to indicate a page turn. Two books were filled with scribbles before the pen stilled. These lines and shapes may be maps of the Ghost Field.",
        narrative: "One consulting Whisper reported that when she attuned to the books using an expensive and difficult ritual, the maps became luminous and four dimensional, revealing lost secrets in Duskwall."
      },
      {
        name: "Norscye's Lament",
        category: "Famous Jewel",
        desc: "This ruby has been set in a series of weapons for the last three centuries. One estimate was that the gem had participated in upwards of a thousand deaths. Legend suggests that the ruby can hold a single ghost, surviving the destruction of the body, bound to the gem until it chooses another guest.",
        narrative: "While the gemstone is priceless because of its unnatural clarity, it is also possible that an important ghost might be inside, and might choose to speak to a Whisper or a blood relative."
      },
      {
        name: "Orb Of Sellivas",
        category: "Weird Artifact",
        desc: "This fist-sized golden orb tunes to one bearer at a time, though it may respond to others. If commanded, it can release a steady light that radiates in the material world and the Ghost Field, revealing what is hidden. The radiation can also draw or repel ghosts and demons.",
        narrative: 'The Sellivas order of witches wrote their research journals in an ink that can only be read by the light of the Orb. If someone had the Orb and the "blank" book, they could crack ancient secrets.'
      },
      {
        name: "Plant Evidence",
        category: "Secret Dirty Work",
        desc: "Someone needs to be found guilty of doing something. For that to work out, you need evidence, put in the wrong place at the wrong time. To manage that, you need proper scoundrels.",
        narrative: "Do you know what the target will be accused of doing? Are you to lead the authorities to the evidence? Must someone be seduced before a hidden witness? Are the scoundrels making evidence, or using what they're given? What if they could do better? Must the evidence fool a court, or a powerful individual?"
      },
      {
        name: "Plasmic Blade Flail",
        category: "Weird Artifact",
        desc: "This weapon can slay ghosts and demons. It appears to be a gladius stitched with runes. Once the bearer attunes to the weapon, it can disconnect into vertebrate-like wedges connected by a steely central cable. The blade-whip is flexible and simmering with energy. It can reform into a straight blade at will.",
        narrative: "Only five of these flails ever existed. One is carried by the Spirit Warden assigned to the Immortal Emperor's defense. The rest are the stuff of legends."
      },
      {
        name: "Remote Writer",
        category: "Weird Artifact",
        desc: "This little book has a peculiar occult symbol on the cover. If an object is placed between the covers for a full 24 hours, then the book will transcribe any conversation happening in earshot of the object until reset. When the book reaches the end, the writing starts over on the first page, clearing pages as it goes.",
        narrative: "The book provides remote reading, eavesdropping of a sort. A target's favorite pen or lucky coin can become the broadcaster, and determined spies can copy the magic book writing so they don't lose it."
      },
      {
        name: "Rylaria's Shield",
        category: "Family Heirloom",
        desc: "Rylaria Graefwold was a soldier who gained title and wealth. She wrote her life's story on the back of the shield she used to save a general. Later generations added to the family story. The shield represents the family's honor. It was lost at sea when their first leviathan hunting ship was wrecked. Or was it?",
        narrative: "Now the family is wealthy, and this artifact would be important to them. Does it have a secret in code?"
      },
      {
        name: "Skovlan Scrip",
        category: "Misplaced Fortune",
        desc: "A dense lockbox filled with paper money issued by the Akorosian government to pay soldiers quelling the Skovlander Insurrection. The scrip can be exchanged for coins or services in Duskwall. Scrip is basically untraceable.",
        narrative: "Some of the military supply that got lost during the war. Does the stashs location implicate a corrupt official or other thief?"
      },
      {
        name: "Sonurian Ghost Key",
        category: "Family Heirloom",
        desc: "The Sonuria family had mansions in the area that is now the Seven Shallows slum. They created a vault for the protected dead, and for their mundane treasures. The only way in is for a family member to present the Sonurian Ghost Key before the hidden location of the vault in the Ghost Field. The key has been lost for decades.",
        narrative: "That key could be hidden anywhere. If it were found, either a family member could be recruited to open the door, or the key could be sold to the family. What does the key look like? What is inside the vault?"
      },
      {
        name: "Soultrap Carnelian",
        category: "Famous Jewel",
        desc: "This semi-precious stone was carved by the Whisper Ichralia. She suffocated people with hot wax and bound their fresh ghosts in wax seals on scrolls or letters with the Soultrap. When the seal was broken, the insane ghost attacked the opener and anyone nearby.",
        narrative: "The Spirit Wardens destroyed this object decades ago. Didn't they? Maybe someone else made another one, or maybe the original survived."
      },
      {
        name: "Steal Blackmail",
        category: "Secret Dirty Work",
        desc: "Secrets must be protected. If they come out, people can get hurt, ruined, killed, and so on. You are hired to adjust the circle of people who can prove something. Will it be bigger? Or smaller?",
        narrative: "Do you know what information you're after, or is that secret from you? If you have a chance, will you peek at it? Are you targeting a blackmailer to remove their hold, or getting evidence to give a blackmailer? Is the evidence to be destroyed? Do you plan to do as you are told?"
      },
      {
        name: "Terrorize",
        category: "Secret Dirty Work",
        desc: "People can be stubborn, to the point where only fear can unseat their decision. Maybe they feel independent and need to reminded that they need protection. Maybe they feel safe and need to be reminded they are not untouchable.",
        narrative: "Are you supposed to be someone in particular, like a random street thug or rival's employee or bluecoat? How far can the terror go? Do you need to trash a home, or maybe converse with a loved one?"
      },
      {
        name: "The Emerald Well",
        category: "Famous Jewel",
        desc: "This depthless gem is a chilly pinhole between the material world and the Ghost Field. It provides energy to Whispers and attracts ghosts. The Emerald Well was protected by the Church of the Ecstasy of the Flesh, but a thief stole it decades ago. It is a hotspot for supernatural activity. Disaster flows in its wake.",
        narrative: "This is one of the few objects pursued by demons, Whispers, inspectors, clergy, and collectors. Scholars suggest demons may be able to turn it inside out, creating a fresh gate to incarnate more demons."
      },
      {
        name: "The Hellwhisper Ring",
        category: "Weird Scholarship",
        desc: `The ring is made of tiny bits of bone wired together. It must be worn for at least a day per year of the bearer's life before it begins to work. When placed on a source of information, the ring sifts it until the ring speaks the information's "language." The bearer can see through riddles, read arcane texts, and break code with ease.`,
        narrative: "Legend says 32 demons voluntarily gave some of their bone to be part of this ring, and it was released among humans to cause chaos through greater understanding."
      },
      {
        name: "The Helsman Inheritance",
        category: "Misplaced Fortune",
        desc: "The final will and testament of the clan's patriarch included a 24 hour locked-house condition. Survivors would split the inheritance. Darayl Helsman left the house at the end of the time with a small bag. Explorers found nothing but corpses in the house, the inheritance was gone. Darayl was found dead the next day, the bag gone. The city locked the house and guards against trespassers.",
        narrative: "Surely Darayl hid the inheritance in the Ghost Field. Find the ghost key and lock in the house, and get it all! Or, did someone else already get it?"
      },
      {
        name: "The Key Lens",
        category: "Weird Scholarship",
        desc: 'The round frame has forty special lenses hinged on its rim. The lenses can layer over each other, flip out past the frame, rotate to take advantage of the angles inside the ground crystal, and take translucent colored filters. Their inventor, VLAS HALDAK, said he had found "the key." He died of shock, the lens on his work table.',
        narrative: "Legends vary. It can see into the Ghost Field, it can see into people, it allows reading demonic texts, it can see the way into ghost neighborhoods, etc. Needs a Whisper to use properly."
      },
      {
        name: "The Leviathan's Eye",
        category: "Famous Jewel",
        desc: "This sapphire turns impossibly black if dipped in leviathan blood. If the still-bloody stone is pressed against a seer's forehead, the sensitive can see what the ocean sees, looking above the waves or probing the deeps. The gem used to be passed around between leviathan hunter captains, but has since been lost.",
        narrative: "One expert said using the Eye was as close as a human could get to a demon seeing through its elemental affinity, and that it began a slow change in the individual who was exposed to its power."
      },
      {
        name: "The Tabissera Diary",
        category: "Weird Scholarship",
        desc: "Warden Khalana Uress was the Head Confessor of the Spirit Wardens. She recorded secrets that were only for the use of the order using a book code, coordinates that pointed to words in a specific book. Without that book, the code cannot be cracked. Daring thieves took the book, then lost it.",
        narrative: "Fakes come on the market all the time. Only the Spirit Warden leadership know what the book looked like, and they aren't telling. What is the Diary about?"
      },
      {
        name: "The Thousand Facet Diamond",
        category: "Famous Jewel",
        desc: "This gem is the elegant centerpiece on the back of a peculiar clockwork gauntlet. A seer can use the gauntlet to travel into the Ghost Field while retaining physical presence, or possibly even other dimensions. Each use burns out some of the diamond facets. The device is reported to have a mind of its own.",
        narrative: "Ever since its theft from the Adelairde family, the gauntlet has surfaced only in rumors of especially daring heists or mind-shattering experiments."
      },
      {
        name: "Whitecrown Signet Ring",
        category: "Family Heirloom",
        desc: "The Whitecrown family schismed in the wake of the theft of the matriarch's signet ring over two centuries ago. They fell from being players in the intrigues around the throne to bickering over dwindling family holdings. Their wealth and influence is low, but not beyond recall.",
        narrative: "If the ring resurfaced, elements of the feud might put aside their differences and reunite. Besides, legends suggest a ghost matriarch is bound to the ring, and she knows their secrets."
      }
    ]
  }
};
const ClockKey_SVGDATA = {
  1: {
    height: 836,
    width: 230,
    paths: [
      "M217.017,123.52c-1.6-0.8-2.84-1.44-4.1-2.04c-1.12-0.53-2.26-1.04-3.42-1.51 c-1.05-0.43-2.18-0.68-3.18-1.19c-0.89-0.45-1.23-1.23-1.2-2.36c0.09-4.48-0.07-8.97,0.05-13.45c0.08-3.31-0.83-6.47-1.14-9.72 c-0.01-0.14-0.09-0.28-0.14-0.42c-0.57-2.01-1.2-4.01-1.69-6.04c-0.45-1.85-0.75-3.74-1.11-5.61 c-0.012-0.043-0.023-0.085-0.035-0.127c-0.6-1.69-1.348-3.353-1.825-5.083c-0.46-1.66-0.68-3.38-1.03-5.07 c-0.04-0.24-0.16-0.47-0.25-0.7c-0.49-1.32-0.98-2.65-1.47-3.97c-0.55-1.44-0.93-2.97-1.69-4.28c-0.79-1.35-0.65-3.03,0.61-4.19 c0.43-0.39,0.85-0.85,1.08-1.36c0.57-1.3,1.35-2.62,1.44-3.97c0.08-1.11-0.46-3.08-1.14-3.29c-1.58-0.47-3.49-0.42-5.1,0.03 c-1.41,0.4-2.59,1.63-4.07,2.62c-1.15-1.18-2.43-2.41-3.6-3.75c-0.41-0.47-0.43-1.29-0.82-1.78c-0.67-0.84-1.56-1.5-2.23-2.33 c-0.18-0.22-0.08-0.9,0.13-1.16c0.85-1.02,1.78-1.97,2.71-2.92c2.18-2.22,4.37-4.45,6.57-6.65c0.85-0.86,1.78-1.64,2.63-2.5 c1.16-1.17,2.38-2.29,3.37-3.59c0.66-0.88,0.89-2.07,1.42-3.06c0.86-1.63,0.01-3.02-0.68-4.31c-0.23-0.43-1.4-0.4-2.15-0.48 c-0.69-0.08-1.4,0.02-2.09-0.02c-1.71-0.11-3.14,0.17-4.52,1.47c-1.22,1.14-2.96,1.74-4.44,2.62c-0.98,0.59-1.89,1.31-2.88,1.88 c-2.02,1.17-4.2,2.11-6.07,3.47c-1.12,0.81-2.16,1.18-3.49,1.4c-1.28,0.22-2.44,1.1-3.7,1.59c-0.58,0.23-1.72,0.49-1.82,0.3 c-0.91-1.63-2.75-1.79-4.03-2.77c-0.33-0.25-0.58-0.62-0.93-0.82c-1.11-0.64-2.26-1.22-3.38-1.85c-1.48-0.83-2.94-1.7-4.42-2.53 c-0.93-0.53-1.83-1.24-2.84-1.5c-1.37-0.35-2.24-1.96-3.89-1.5c-0.08,0.03-0.19-0.02-0.29-0.04c-1.97-0.58-3.94-1.16-5.91-1.73 c-0.28-0.08-0.76-0.02-0.84-0.18c-0.89-1.7-2.8-1.2-4.1-1.6c-2.83-0.87-5.94-0.87-8.94-1.22c-0.39-0.04-1.05,0.06-1.14-0.13 c-0.79-1.56-2.21-1.01-3.4-1.05c-2.09-0.08-2.68-0.62-2.72-2.65c-0.01-0.84-0.1-1.69-0.24-2.51c-0.16-0.88-0.54-1.72-0.62-2.59 c-0.13-1.24-0.03-2.49-0.11-3.73c-0.06-0.88-0.61-1.45-1.5-1.13c-0.79,0.28-1.59,0.72-2.21,1.28c-1.48,1.36-2.85,2.84-4.29,4.25 c-1.1,1.08-2.08,2.06-3.81,2.55c-1.54,0.44-2.99,1.69-4.63,2.42c-1.79,0.8-3.28,2.25-5.44,2.13c-0.44-0.02-1.16-0.02-1.28,0.22 c-0.7,1.36-1.94,0.82-2.98,0.97c-0.49,0.07-0.99,0.11-1.47,0.24c-1.92,0.49-3.84,0.98-5.75,1.52c-1.74,0.49-3.51,0.95-5.19,1.61 c-1.92,0.74-3.67,1.99-5.63,2.46c-1.64,0.38-3.01,1.13-4.51,1.72c-0.99,0.39-2.52,0.38-3.43-0.13c-1.93-1.09-4.28-1.09-6.03-2.54 c-0.22-0.19-0.67-0.12-1.02-0.13c-0.9-0.02-1.79-0.02-2.69-0.02c-1.37,0.01-2.19,0.72-2.36,2.15c-0.09,0.78-0.06,1.59-0.09,2.38 c-0.01,0.35,0.11,0.87-0.06,1.02c-1.68,1.35-0.89,3.24-1.18,4.9c-0.16,0.88-0.56,1.8-1.1,2.51c-0.75,0.99-1.76,1.79-2.61,2.72 c-1.02,1.1-1.99,2.26-2.99,3.39c-1.49,1.67-2.96,3.37-4.5,5c-1.36,1.45-2.81,2.83-4.2,4.25c-0.16,0.17-0.19,0.46-0.31,0.67 c-0.74,1.29-1.39,2.64-2.25,3.84c-0.89,1.25-2.63,1.86-2.72,3.75c-0.02,0.38-0.57,0.73-0.86,1.11c-0.37,0.49-0.79,0.96-1.07,1.5 c-0.73,1.39-1.26,2.89-2.1,4.21c-1.08,1.71-2.25,3.34-2.65,5.38c-0.07,0.32-0.39,0.6-0.57,0.91c-0.21,0.34-0.45,0.67-0.59,1.05 c-0.43,1.21-0.72,2.48-1.24,3.65c-0.79,1.76-1.75,3.45-2.6,5.19c-1.27,2.6-2.74,5.13-3.69,7.85c-0.5,1.45-0.18,3.23-0.08,4.85 c0.05,0.7,0.68,1.37,0.69,2.06c0.06,6.07,0.06,12.15,0.01,18.23c0,0.71-0.37,1.44-0.63,2.13c-0.35,0.95-1.04,1.85-1.09,2.8 c-0.07,1.31-1.04,1.92-1.62,2.82c-0.91,1.43-2.71,1.9-3.59,3.51c-1.01,1.85-0.94,3.91,0.46,5.41c1.17,1.24,2.59,0.75,3.93,0.97 c1.41,0.22,3.01,0.26,4.12,0.99c1.11,0.74,1.87,2.16,2.5,3.43c0.77,1.56,1.35,3.24,1.8,4.92c0.67,2.5,0.94,5.12,2.32,7.4 c0.56,0.92,1.03,1.9,1.52,2.87c0.51,1.03,0.96,2.09,1.48,3.11c0.56,1.09,1.13,2.18,1.77,3.22c0.29,0.48,0.84,0.8,1.16,1.26 c0.61,0.87,1.11,1.82,1.71,2.69c0.32,0.47,0.83,0.81,1.16,1.27c0.93,1.3,1.79,2.65,2.73,3.95c0.31,0.43,0.83,0.69,1.15,1.11 c0.52,0.69,0.89,1.51,1.44,2.16c0.41,0.48,1.1,0.72,1.54,1.18c1.57,1.66,3,3.46,4.65,5.03c1.3,1.26,2.91,2.18,4.25,3.4 c1.99,1.84,3.82,3.85,5.81,5.7c0.51,0.47,1.42,0.47,1.99,0.9c0.95,0.71,1.78,1.59,2.88,2.59c-0.72,0.66-1.63,1.5-2.55,2.33 c-0.78,0.7-1.61,1.34-2.34,2.07c-1.54,1.55-3.05,3.13-4.54,4.73c-1.24,1.32-2.6,2.56-3.6,4.05c-0.6,0.91-1.1,1.85-1.89,2.63 c-1.23,1.21-1.21,4.03,0.24,4.66c1.03,0.45,2.61,0.53,3.57,0.03c1.41-0.72,2.76-0.5,4.14-0.57c1.93-0.09,3.89,0.02,5.8-0.21 c1.19-0.14,2.33-0.75,3.46-1.2c0.49-0.19,0.89-0.6,1.38-0.76c0.46-0.16,1.13,0.06,1.45-0.21c2.19-1.82,5.18-1.79,7.53-3.48 c1.41-1.01,3.25-2.21,5.36-2.06c0.28,0.02,0.58-0.29,0.88-0.44c0.42-0.22,0.85-0.61,1.29-0.62c3.43-0.04,6.86,0,10.3,0.03 c0.38,0,0.99-0.01,1.11,0.21c0.64,1.13,1.69,0.85,2.63,0.91c1.1,0.06,2.24-0.13,3.27,0.14c2.96,0.79,5.9,1.59,9,1.58 c6.02-0.03,12.05,0.27,18.01-0.93c0.82-0.17,1.69-0.08,2.52-0.24c1.04-0.2,2.05-0.52,3.14-0.81c0.13,0.6,0.21,0.79,0.21,0.98 c0.01,8.226,0.03,16.462,0.01,24.699c-0.001,0.368-0.217,0.882-0.515,1.099c-0.676,0.493-1.572,0.71-2.176,1.273 c-1.37,1.26-2.6,2.68-3.92,4c-0.73,0.73-1.61,1.32-2.31,2.08c-0.98,1.06-0.96,2.42-0.9,3.78c0.07,1.95,0.64,2.62,2.59,2.67 c1.712,0.061,3.434,0.019,5.146,0.03c1.112,0.007,2.014,0.908,2.024,2.02c0.06,6.72,0.08,13.44,0.15,20.16 c0.019,1.205-0.537,1.936-1.437,2.533c-0.23,0.153-0.451,0.318-0.644,0.516c-1.605,1.643-3.165,3.308-4.789,4.931 c-0.63,0.64-1.57,1.05-2.01,1.79c-1.29,2.14-3.22,3.55-5.3,4.69c-2.51,1.38-2.76,1.58-2.61,4.33c0.09,1.65,1.84,3.48,3.41,3.17 c1.82-0.35,3.74-0.85,5.26-1.85c0.77-0.51,1.38-0.68,2.16-0.71c0.95-0.04,1.9-0.01,2.84-0.01c2.59,0.01,3.03,0.46,3.03,3.1 c-0.01,31.18-0.02,62.36-0.04,93.55c0,2.88-0.13,5.78,0.03,8.66c0.16,2.8,0.67,5.58,0.91,8.39c0.15,1.83,0.08,3.68,0.15,5.52 c0.02,0.42,0.14,0.85,0.29,1.25c0.23,0.58,0.66,1.12,0.75,1.72c0.13,0.93-0.34,2.21,0.13,2.78c1.82,2.18-0.35,4.04-0.21,6.04 c0.01,0.2-0.21,0.41-0.31,0.62c-0.53,1.08-1.43,2.14-1.49,3.24c-0.21,4.27-0.19,8.56-0.19,12.84 c-0.01,51.9,0.01,103.81-0.05,155.71c0,4.36-0.54,8.71-0.84,13.06c-0.03,0.34-0.19,0.66-0.31,0.98c-0.25,0.69-0.73,1.36-0.74,2.05 c-0.12,5.68-0.07,11.36-0.23,17.03c-0.11,3.65-0.78,7.31-0.68,10.95c0.12,4.59-0.27,9.16,0.58,13.82 c0.85,4.63,0.19,9.53,0.21,14.31c0.01,1-0.27,2.32,0.24,2.92c1.2,1.39,0.69,2.89,0.79,4.35c0.03,0.33-0.22,0.7-0.37,1.03 c-0.25,0.55-0.55,1.06-0.76,1.62c-0.17,0.44-0.2,0.93-0.36,1.38c-0.47,1.36-0.97,2.72-1.45,4.08c-0.11,0.31-0.11,0.7-0.3,0.94 c-1.58,2-2.33,4.36-2.52,6.8c-0.23,3.07-0.06,6.17-0.08,9.26c-0.02,3.62,0.05,7.24,0.93,10.78c0.07,0.3,0.39,0.56,0.42,0.86 c0.13,1.29,0.2,2.59,0.29,3.88c-0.91,0.05-1.84,0.23-2.72,0.09c-0.66-0.1-1.24-0.71-1.91-0.9c-1.83-0.53-3.81,1.69-3.74,3.17 c0.1,2.16,0.3,4.33,1.59,6.15c1.14,1.6,2.44,3.09,3.73,4.57c1.18,1.36,2.64,2.45,2.25,4.66c-0.47,2.6-0.66,5.25-1.01,8.26 c-4.52,0.25-8.9,0.65-13.3,0.72c-8.65,0.13-17.32,0.08-25.98,0.13c-0.58,0-1.24-0.02-1.74,0.22c-1.03,0.49-1.92,1.28-2.97,1.7 c-1.85,0.75-3.77,1.31-5.65,1.96c-0.22,0.07-0.42,0.22-0.63,0.32c-1.16,0.57-2.28,1.38-3.51,1.64c-1.03,0.21-1.79,0.61-2.49,1.28 c-0.2,0.19-0.4,0.5-0.62,0.51c-1.14,0.08-2.03,0.39-2.85,1.34c-0.63,0.73-1.75,1.04-2.67,1.49c-1.72,0.84-3.48,1.61-5.18,2.49 c-1.48,0.77-3.04,1.49-4.33,2.53c-1.49,1.21-2.68,2.8-4.09,4.14c-0.84,0.79-1.75,1.75-2.79,2.02c-1.46,0.39-2.97,0.34-4.52,0.83 c-2.05,0.64-4.39,0.08-6.57,0.95c-1.38,0.54-3.25-0.48-4.4,1.21c-0.07,0.1-0.38,0.03-0.58,0.05c-2.5,0.25-4.95-0.04-7.53,0.73 c-3.19,0.97-6.74,0.74-10.14,1.08c-0.59,0.06-1.36,0.23-1.7,0.63c-0.83,1.02-0.42,3.75,0.69,4.4c0.91,0.54,2,0.82,3.05,1.07 c0.66,0.15,1.4-0.06,2.08,0.05c1.68,0.29,3.67-0.91,5.01,1.05c0.07,0.1,0.38,0.06,0.58,0.07c4.87,0.2,9.72,0.09,14.61,0.8 c4.38,0.64,8.94-0.01,13.42,0.18c3.03,0.13,5.86-0.88,8.82-1.09c0.14-0.01,0.35-0.06,0.4-0.15c0.61-1.3,1.84-0.85,2.85-1.06 c0.57-0.11,1.2-0.3,1.65-0.65c0.83-0.64,1.45-1.63,2.35-2.1c2.5-1.32,4.56-3.31,7.19-4.45c1-0.43,1.58-0.43,2.51,0.04 c0.62,0.31,1.68,0.25,2.33-0.08c1.06-0.53,1.88-0.64,2.74,0.22c0.76,0.76,1.53,1.51,2.34,2.23c1.14,1.02,2.41,1.91,3.46,3.02 c1.04,1.08,1.85,2.38,2.78,3.56c1.11,1.4,4.49,1.72,5.94,0.58c1.29-1.01,1.57-2.52,1.85-3.97c0.24-1.24,0.03-2.49,0.68-3.78 c0.9-1.75,1.39-2.39,3.41-2.36c2.29,0.02,4.58,0.1,6.87,0.11c1.04,0.01,1.62,0.52,1.84,1.5c0.31,1.31,0.45,2.68,0.96,3.9 c0.36,0.85,1.11,1.71,1.91,2.16c1.23,0.7,4.69-0.66,5.09-2.01c0.53-1.73,1.15-3.6,1-5.35c-0.24-2.82,1.44-4.54,2.89-6.43 c0.3-0.39,1.44-0.68,1.72-0.45c1.45,1.23,3.45,2.17,3.18,4.62c-0.06,0.64,0.09,1.3,0.02,1.94c-0.31,3.01-0.68,6.01-0.98,9.02 c-0.08,0.86-0.01,1.74-0.01,2.77c1.08-0.07,1.88-0.05,2.64-0.18c1.12-0.2,2.2-0.62,3.32-0.73c1.38-0.13,2.78-0.05,4.18-0.04 c1.86,0.01,2.13,0.24,1.82,2.07c-0.17,1-0.42,2.39-1.12,2.8c-1.1,0.65-0.86,1.44-0.87,2.24c-0.05,2.1-0.03,4.19-0.01,6.28 c0.01,0.44,0,1.19,0.2,1.26c1.41,0.53,0.81,1.71,0.98,2.64c0.17,0.9,0.34,1.81,0.64,2.66c0.39,1.08-0.23,3.51-1.19,3.75 c-1.67,0.43-3.39,0.66-5.09,0.99c-1.84,0.36-3.67,0.72-5.5,1.11c-0.22,0.05-0.4,0.28-0.61,0.39c-0.43,0.23-0.85,0.56-1.3,0.63 c-0.594,0.081-1.208,0.05-1.82,0.036c-1.386-0.033-2.643-0.905-3.075-2.222c-0.613-1.87-0.822-3.704-0.936-5.614 c-0.03-0.33-0.6-0.59-0.79-0.96c-0.43-0.85-1.13-1.77-1.07-2.62c0.07-0.98,1.05-1.44,2.19-1.38c0.81,0.04,1.64-0.21,2.44-0.43 c0.59-0.16,1.12-0.55,1.72-0.69c0.52-0.12,1.09-0.06,1.63-0.02c1.25,0.08,1.8-0.43,1.76-1.72c-0.05-1.89,0.01-3.78-0.01-5.68 c-0.01-1.66-0.83-2.55-2.56-2.57c-3.84-0.04-7.67-0.02-11.5,0.02c-1.16,0.01-1.74,0.7-1.85,1.83c-0.05,0.54-0.08,1.09-0.24,1.6 c-0.48,1.6-1.38,3.17-1.45,4.78c-0.08,1.83-0.74,3.01-2.08,4.1c-0.83,0.67-1.56,0.79-2.23,0.04c-1.08-1.22-2.09-2.51-3.04-3.83 c-1.06-1.48-1.88-3.17-3.08-4.51c-0.91-1.03-1.92-2.41-3.7-1.84c-0.51,0.17-0.93,0.69-1.44,0.79c-2.58,0.46-4.33,2.33-6.35,3.7 c-2.13,1.45-4.2,2.53-6.93,2.33c-3.17-0.24-6.37-0.07-9.55-0.09c-0.4,0-0.93,0.1-1.16-0.1c-1.75-1.51-4.32-2.07-5.29-4.5 c-0.06-0.13-0.33-0.24-0.5-0.25c-2.1-0.1-3.95-1.56-6.16-1.07c-0.31,0.07-0.68-0.08-1.02-0.17c-0.9-0.25-1.8-0.73-2.71-0.75 c-4.62-0.08-9.25-0.03-13.88-0.05c-0.46,0-0.94-0.13-1.38-0.29c-0.63-0.24-1.23-0.8-1.85-0.81c-6.97-0.06-13.94-0.01-20.91-0.06 c-1.47-0.01-2.4,0.9-3.11,1.81c-1.58,2.02,0.43,5.8,3.19,6.29c1.71,0.31,3.41,0.64,5.12,0.96c0.19,0.04,0.49,0.05,0.55,0.17 c0.65,1.18,1.78,0.83,2.77,0.94c2.9,0.31,5.78,0.66,8.67,1c0.103,0.019,0.206,0.038,0.308,0.057c2.154,0.545,4.296,1.193,6.481,1.6 c1.241,0.232,2.507,0.15,3.769,0.183c0.284,0.007,0.568,0.119,0.821,0.24c0.62,0.28,1.22,0.6,1.83,0.9 c1.33,0.65,2.68,1.25,3.98,1.96c0.4,0.22,0.6,0.76,0.96,1.06c1.45,1.23,2.93,2.41,4.37,3.64c0.97,0.82,1.92,1.67,2.84,2.54 c1.98,1.86,3.98,3.71,5.89,5.64c1.72,1.72,3.46,3.45,4.97,5.36c1.54,1.93,3.34,2.52,5.79,2.51c18.47-0.08,36.94-0.01,55.4,0.02 c2.17,0,4.19,0.14,5.7-2.14c1.09-1.64,2.99-2.73,4.39-4.2c0.74-0.77,1.1-1.87,1.77-2.73c0.68-0.88,1.47-1.69,2.3-2.45 c1.56-1.45,2.81-3.12,3.91-4.94c0.46-0.76,1.51-1.22,1.86-2.01c0.76-1.74,1.56-3.38,3.08-4.61c0.42-0.34,0.88-0.97,0.86-1.44 c-0.08-1.47,0.99-2.28,1.57-3.39c0.75-1.42,1.61-2.73,1.52-4.59c-0.21-4.42-0.08-8.86-0.05-13.29c0-0.61,0.19-1.23,0.35-1.83 c0.14-0.49,0.55-0.98,0.49-1.43c-0.39-3,0.95-5.77,1.1-8.7c0.01-0.2,0.23-0.39,0.34-0.59c0.26-0.47,0.56-0.92,0.78-1.41 c0.59-1.37,1.1-2.77,1.75-4.11c0.19-0.39,0.85-0.54,1.1-0.93c1.25-1.87,2.56-3.71,3.58-5.7c0.73-1.41,1.8-2.83,1.37-4.6 c-0.1-0.41-0.44-1.03-0.73-1.07c-2.3-0.28-4.43-1.46-6.87-1.09c-1.41,0.21-2.88,0.03-4.32,0.03c-2.22,0-2.56-0.51-2.76-2.74 c-0.2-2.19,1.03-4.66-1.1-6.53c-0.08-0.07-0.02-0.29-0.04-0.44c-0.26-2.65,0.17-5.27-0.75-7.99c-0.82-2.44,0.02-5.23-0.93-7.92 c-0.87-2.51,0.15-5.31-1.06-8.11c-1.14-2.64-0.76-5.92-1.16-8.91c-0.31-2.31,0.38-4.77-0.96-6.94c-0.31-0.5-0.91-0.93-1-1.46 c-0.41-2.24-0.68-4.5-1.01-6.76c-0.32-2.2-0.65-4.4-0.99-6.6c-0.03-0.19-0.09-0.47-0.23-0.53c-1.21-0.55-0.86-1.61-0.88-2.55 c-0.25-12.95,0.26-25.89-0.76-38.84c-0.645-8.159-0.207-16.407-0.21-24.606c0-0.326,0.03-0.655,0.132-0.964 c0.498-1.505,1.628-2.909,1.808-4.439c0.32-2.74,0.57-5.52,0.82-8.26c0.521-5.744,0.168-11.569,0.15-17.363 c-0.001-0.411-0.054-0.823-0.201-1.207c-0.519-1.358-1.356-2.643-1.619-4.039c-0.5-2.67-0.7-5.39-1.02-8.09 c-0.04-0.39-0.08-0.79-0.07-1.19c0.07-3.15-0.3-6.32,0.69-9.42c0.41-1.29-0.17-2.87,1.22-3.88c0.1-0.07,0.06-0.37,0.06-0.57 c0.04-8.32,0.08-16.64,0.08-24.96c0-0.43-0.28-0.88-0.45-1.31c-0.19-0.46-0.56-0.9-0.58-1.36c-0.48-11.05,0.53-22.1-0.75-33.17 c-0.77-6.68-0.15-13.52-0.19-20.29c-0.02-4.13-0.15-8.26-0.15-12.39c-0.01-44.063-0.01-88.115,0-132.178 c0-0.883,0.011-1.77,0.117-2.647c0.323-2.687-0.394-5.417,0.813-8.095c0.54-1.2,0.09-2.85,0.14-4.29c0.01-0.42,0.12-0.86,0.28-1.25 c0.26-0.62,0.63-1.2,0.88-1.82c0.14-0.36,0.1-0.78,0.19-1.16c0.48-2.02,1-4.03,1.44-6.05c0.25-1.17-0.47-2.63,1.09-3.39 c0.11-0.05,0.1-0.36,0.11-0.56c0.28-4.51,0.31-9,0.88-13.53c0.7-5.49,0.44-11.15,0.13-16.71c-0.31-5.55,1.18-10.95,0.94-16.46 c-0.02-0.62,0-1.25,0-1.92c0.98-0.1,1.74-0.1,2.45-0.27c0.7-0.17,1.35-0.53,2.03-0.75c1.92-0.62,2.45-1.33,2.42-3.39 c0-0.43-0.07-0.86-0.12-1.48h-4.97c-1.98-0.01-2.64-0.7-2.65-2.73c-0.01-0.75,0.05-1.5-0.01-2.25c-0.53-6.86,1.3-13.97-2.06-20.55 c0.49-2.24-1.35-4.79,0.96-6.8c1.23-1.08,2.27-2.42,3.62-3.33c1.23-0.83,2.52-1.47,3.3-2.84c0.8-1.42,2.89-2.31,4.31-1.95 c1.05,0.28,2.12,0.53,3.13,0.92c2.26,0.86,4.46,1.89,6.75,2.65c0.94,0.32,2.23,0.47,3.05,0.06c1.77-0.89,2.89-2.77,3.34-4.51 c0.76-2.92,0-5.91-1.12-8.69c-0.5-1.24-0.4-1.92,0.76-2.43c1.71-0.75,3.37-1.59,5.07-2.37c2.07-0.95,3.93-2.43,6.34-2.56 c0.29-0.02,0.55-0.33,0.84-0.5c0.37-0.23,0.78-0.65,1.14-0.63c1.59,0.13,3.06-0.23,4.74,0.92c1.61,1.11,4.13,0.99,6.27,1.19 c1.93,0.17,2.82-0.82,3-2.78c0.04-0.43,0.26-0.88,0.47-1.28c0.39-0.75,1.16-1.46,1.2-2.22c0.07-1.42,0.75-3-1.6-3.85 c-1.72-0.61-2.93-2.52-4.52-3.62c-1.38-0.96-2.98-1.6-4.73-2.51c0.24-0.6,0.46-1.24,0.75-1.85c0.82-1.72,1.67-3.42,2.49-5.13 c0.34-0.73,0.5-1.6,1.01-2.17c1.42-1.63,1.98-3.64,2.79-5.55c0.36-0.87,0.45-1.99,1.06-2.59c1.09-1.06,1.52-2.34,1.98-3.69 c0.29-0.85,0.66-1.68,1.09-2.46c0.51-0.93,1.33-1.73,1.67-2.7c0.81-2.39,2.14-3.18,4.45-2.38c0.31,0.1,0.7,0.11,1.03,0.04 c1.17-0.22,2.36-0.41,3.5-0.76c1.24-0.38,2.44-0.9,3.62-1.43c0.21-0.08,0.37-0.5,0.37-0.77 C217.026,126.28,217.017,124.66,217.017,123.52z M143.507,186.1c-0.82,0.65-1.72,0.95-2.7,1.06c-9.15,3.4-19.04,5.26-29.37,5.26 c-46.57,0-84.32-37.75-84.32-84.32c0-46.56,37.75-84.31,84.32-84.31c46.56,0,84.31,37.75,84.31,84.31 C195.747,143.31,174.167,173.48,143.507,186.1z",
      "M214.327,133.65c-1.07-0.77-2.58-1.24-3.21-2.27c-2.25-3.6-6.31-7.65-5.88-11.05 c1.52-12.04-0.33-23.52-2.8-35.1c-1.17-5.49-2.18-10.99,4.72-14.06c1.08-0.48,1.88-3.13,1.63-4.57c-0.19-1.07-2.16-2.19-3.55-2.64 c-6.7-2.14-12.98-4.88-17.4-10.69c-8.86-11.65-19.24-21.69-32.64-27.85c-6.64-3.05-11.86-6.24-11.09-14.54 c0.07-0.78-0.31-1.64-0.64-2.4c-1.25-2.84-2.56-5.66-3.84-8.48c-2.09,2.6-4.15,5.23-6.27,7.81c-1.41,1.73-2.68,4.5-4.41,4.85 c-5.32,1.1-10.85,1.76-16.28,1.67c-10.63-0.18-20.99,1.14-30.97,4.67c-7.85,2.78-15.14,3.77-22.72-1.31 c-3.42-2.29-8.09-2.69-13.48-4.35c1.1,3.41,1.68,5.25,2.3,7.08c2.66,7.87,2.9,14.94-4.11,21.28c-9.76,8.83-16.78,19.74-21.74,31.96 c-3.43,8.43-7.09,16.77-10.4,25.25c-0.69,1.77-0.76,4.07-0.31,5.93c1.61,6.58,3.4,13.13,5.43,19.59c3.09,9.77,5.6,19.86,9.93,29.08 c3.68,7.83,9.58,14.63,14.68,22.14c-0.79,0.96-2.1,2.1-2.8,3.53c-1.36,2.82-2.37,5.81-3.53,8.72c3.12,0.11,6.55,1.11,9.29,0.15 c8.09-2.86,14.4-0.35,20.54,4.73c2.39,1.98,2.05,3.36,0.46,5.32c-5.83,7.15-10.71,15.15-18.99,20.06 c-0.98,0.57-0.82,3.05-1.18,4.65c1.4,0.24,3.08,1.12,4.16,0.63c10.45-4.67,20.76-9.67,31.2-14.38c6.31-2.84,12.43-5.88,19.84-5.85 c10.42,0.05,20.84-1.07,31.26-1.7c1.76-0.11,3.51-0.28,5.42-0.43c0.16,1.54,0.36,2.51,0.36,3.49 c-0.02,59.51,0.09,119.02-0.28,178.52c-0.04,6.76-2.01,13.66-6.63,19.46c-5.78,7.26-11.13,14.88-16.46,22.49 c-0.72,1.03-0.2,2.93-0.26,4.43c1.3-0.02,2.66,0.24,3.87-0.09c5.76-1.56,11.47-3.28,18.14-5.22c0.62,6.25,1.49,10.98,1.5,15.73 c0.13,47,0.21,94.01,0.09,141.01c-0.02,9.45-0.81,18.9-1.43,28.34c-0.51,7.62-1.87,15.22-1.81,22.82 c0.09,11.27,1.35,22.52,1.59,33.8c0.11,4.87-1.07,9.77-1.69,14.65c-0.95,7.5-2.36,14.98-2.73,22.51c-0.3,6.1,1.55,12.38,0.78,18.37 c-0.97,7.49-5.01,14.53-11.46,18.32c-5.29,3.13-12.04,4.52-18.29,5.09c-7.23,0.66-14.61-0.47-21.92-0.75 c-7.56-0.29-13.36-5.01-15.18-12.31c-0.24-0.97-0.97-2.04-1.79-2.6c-3.54-2.44-7.19-4.7-11.02-7.17 c-6.83,8.88-7.82,11.33-7.65,21.13c0.27,15.78,1.28,31.58,0.87,47.34c-0.19,7.12-0.36,13.84,2.91,20.27 c0.57,1.13,1.4,2.86,2.29,2.97c6.4,0.82,12.69,3.55,19.18-1.16c3.35-2.42,8.23-3.21,12.54-3.72c7.41-0.88,14.92-0.84,22.37-1.43 c4.08-0.32,7.49-1.9,7.64-6.78c0.16-4.95,2.49-7.46,7.41-7.25c1.26,3.22,2.35,6.35,3.73,9.34c0.48,1.05,1.56,2.34,2.55,2.54 c3.24,0.62,6.57,0.74,9.86,1.16c3.38,0.42,5.09-0.92,6.01-4.3c1.78-6.56,3.92-13.02,6.08-19.47c1.92-5.71,2.31-11.28-0.26-16.93 c-0.69-1.51-0.6-3.37-1.02-5.99c2.46,0.64,3.97,1.18,5.52,1.41c2.3,0.33,4.62,0.44,6.93,0.65c-0.07-2.7,0.5-5.64-0.37-8.06 c-1.39-3.88-4.05-7.3-5.6-11.14c-2.34-5.79-5.86-11.75-5.96-17.69c-0.58-35.66-0.34-71.34-0.33-107.01c0-1.81,0.12-3.68,0.57-5.42 c3.38-13.1,3.56-26.5,1.68-39.63c-1.53-10.75-1.54-20.97,1.15-31.44c1.09-4.23,1.29-8.84,1.02-13.23 c-1.21-19.88-3.7-39.73-3.94-59.61c-0.62-50.99-0.29-102-0.34-153.01c0-1.66-0.07-3.35,0.18-4.98c1.91-12.43,4.96-24.78,5.62-37.26 c1.28-24.01,3.36-48.15-1.87-72.06c-0.27-1.25,0.73-3.34,1.8-4.23c9.73-8.05,9.78-8,20.31-1.11c0.7,0.46,1.39,1.05,2.17,1.23 c2.36,0.55,6.51,1.85,6.85,1.21c1.35-2.54,2.6-5.99,1.92-8.6c-2.38-9.22-2.43-17.78,3.82-25.59c2.88-3.6,5.07-8.11,8.66-10.71 c4.75-3.45,10.65-5.28,15.88-8.13c2.41-1.3,5.32-2.92,6.4-5.17C220.707,136.36,216.637,135.31,214.327,133.65z M111.437,192.42 c-46.57,0-84.32-37.75-84.32-84.32c0-46.56,37.75-84.31,84.32-84.31c46.56,0,84.31,37.75,84.31,84.31 C195.747,154.67,157.997,192.42,111.437,192.42z",
      "M216.086,109.69c-0.08-0.48,0.02-1-0.02-1.5c-0.07-0.95,0.16-2.22-0.36-2.76 c-0.73-0.76-2.03-0.97-3.07-1.46c-0.63-0.3-1.24-0.67-1.83-1.05c-0.53-0.33-1.08-0.65-1.53-1.07c-0.8-0.74-1.92-0.81-2.57-2.09 c-1.13-2.22-0.49-4.7-1.75-6.94c-1-1.8,0.07-4.32-0.91-6.51c-0.3-0.67,0.89-2,1.37-3.04c0.65-1.39,2.31-2.03,2.57-3.75 c0.12-0.81,0.64-1.61,1.15-2.28c1.78-2.38,1.16-5.33-1.31-6.02c-1.49-0.42-2.55-1.16-3.72-2.06c-1.21-0.92-2.77-1.49-4.25-1.92 c-1.54-0.44-2.15-1.61-2.84-2.79c-0.59-1.02-1.09-2.11-1.76-3.08c-0.71-1.02-1.59-1.93-2.47-2.98c0.35-0.13,0.74-0.16,0.86-0.35 c1.27-2.02,3.25-2,5.28-1.95c1.15,0.02,2.4,0.21,3.44-0.16c1.28-0.45,2.71-1.16,3.49-2.19c1.24-1.65-0.42-4.48-2.46-4.74 c-1.98-0.25-3.94-0.58-5.91-0.89c-0.18-0.03-0.34-0.15-0.51-0.22c-0.77-0.33-1.52-0.72-2.32-0.95c-0.57-0.16-1.22,0.01-1.79-0.13 c-2.14-0.53-4.24-1.43-6.41-1.61c-1.69-0.14-2.87-0.66-4.02-1.8c-1.28-1.26-2.82-2.26-4.1-3.52c-0.3-0.29-0.23-1.24,0-1.73 c0.44-0.91,1.54-0.97,2.32-1.44c1.74-1.05,3.29-2.45,4.89-3.74c0.52-0.42,1.31-0.9,1.38-1.42c0.19-1.46,0.06-2.96,0.06-4.5 c-2.54-0.33-4.95-0.67-7.38-0.94c-0.89-0.1-1.81-0.01-2.71-0.03c-0.34-0.01-0.68-0.07-1.01-0.16c-0.89-0.23-1.76-0.69-2.64-0.7 c-4.02-0.08-8.04-0.03-12.07-0.05c-0.42,0-1.11,0-1.23-0.23c-1.12-2.09-3.02-1.96-4.92-1.88c-1.14,0.04-1.8-0.46-2.06-1.62 c-0.27-1.22-0.34-2.76-1.12-3.54c-1.17-1.16-0.68-2.45-1.05-3.64c-0.33-1.08-0.81-2.76-1.52-2.93c-2.01-0.5-4.21-0.87-6.23,0.31 c-0.93,0.54-1.88,1.05-2.87,1.44c-1.21,0.48-2.61,0.61-3.7,1.27c-1.77,1.08-3.79,0.89-5.3,0.34c-1.38-0.5-2.66-0.56-4-0.68 c-0.75-0.06-1.5-0.02-2.23-0.16c-0.94-0.18-1.87-0.77-2.76-0.69c-1.9,0.18-3.03-0.91-3.97-2.14c-1.29-1.72-2.14-3.79-3.53-5.41 c-1.31-1.54-1.8-3.71-3.74-4.73c-0.49-0.26-0.96-0.67-1.48-0.73c-0.94-0.12-1.92-0.14-2.85,0c-0.59,0.08-1.26,0.41-1.66,0.85 c-0.55,0.59-0.75,1.49-1.3,2.07c-1.44,1.55-2.99,3-4.48,4.5c-0.13,0.12-0.12,0.38-0.22,0.55c-0.46,0.75-0.9,1.52-1.42,2.22 c-0.5,0.67-1.12,1.24-1.62,1.91c-0.48,0.62-0.79,1.38-1.31,1.96c-1.39,1.54-3.54,0.54-5.35,1.73c-2.13,1.39-5.14,1.6-7.81,1.92 c-2.43,0.29-4.97,0.32-7.37-0.06c-1.44-0.23-2.84-1.32-4.04-2.3c-1.44-1.18-2.57-2.71-4.77-2.47c-0.61,0.06-1.27-0.43-2.23-0.78 c-0.27,0.91-0.79,1.91-0.83,2.92c-0.13,3.22-0.1,6.44-0.1,9.66c0,0.72-0.13,1.16-0.84,1.66c-1.79,1.24-3.39,2.74-5.12,4.08 c-0.33,0.26-0.9,0.26-1.36,0.33c-0.69,0.1-1.75-0.09-2.02,0.28c-0.84,1.21-1.97,0.84-3.05,0.96c-0.53,0.06-1.05,0.27-1.56,0.43 c-1.41,0.44-2.79,0.98-4.23,1.32c-1.4,0.33-3.13-0.6-4.16,1.16c-0.06,0.1-0.38,0.07-0.58,0.08c-1.15,0.07-2.3,0.17-3.45,0.2 c-2.18,0.07-2.94,0.91-2.47,2.97c0.12,0.55,0.55,1.09,0.97,1.51c0.85,0.82,1.83,1.51,2.67,2.35c1.09,1.09,2.1,2.27,2.99,3.24 c-0.99,1.5-1.8,2.84-2.73,4.09c-0.62,0.83-1.51,1.47-2.09,2.32c-1.11,1.6-2.09,3.3-3.12,4.96c-0.31,0.5-0.73,0.96-0.93,1.51 c-0.5,1.33-2.38,2.73-3.8,2.76c-1.15,0.03-2.49-0.24-3.4,0.26c-1.3,0.71-2.55,0.65-3.86,0.66c-2.14,0.01-4.03,0.57-5.36,2.35 c-0.3,0.41-0.32,1.02-0.56,1.48c-0.7,1.31-0.46,3.54,0.67,4.44c0.88,0.71,1.97,1.17,2.86,1.87c0.75,0.58,1.24,1.6,2.06,1.97 c1.26,0.57,1.85,1.38,1.54,2.64c-0.41,1.68,0.4,3.44-0.77,5.14c-0.67,1,0.34,2.85-1.26,3.76c-0.08,0.04-0.05,0.28-0.06,0.43 c-0.07,1.2-0.32,2.3-0.72,3.49c-0.69,2.08-1.06,4.24-2.44,6.06c-1.06,1.41-1.99,2.97-2.99,4.37c-1.47,2.05-3.91,3.38-5.93,5.04 c-0.77,0.63-1.44,1.4-2.26,1.94c-2.24,1.47-2.4,4.44-0.52,6.31c1.02,1.02,2.11,0.63,3.19,0.81c0.52,0.08,1.08,0.08,1.56,0.28 c1.37,0.58,2.71,1.21,4.05,1.87c0.66,0.33,1.54,0.63,1.86,1.2c0.54,0.99,0.73,2.18,1.06,3.29c0.11,0.38,0.15,0.8,0.33,1.14 c0.54,0.96,1.26,1.84,1.67,2.85c1.1,2.69,0.84,5.73,2.18,8.41c0.66,1.31,0.76,2.91,1.15,4.37c0.3,1.13,0.34,2.53,1.05,3.3 c0.9,0.97,0.77,1.95,0.91,3c0.09,0.63,0.37,1.24,0.6,1.95c-0.55,0.45-1.38,0.87-1.82,1.55c-0.96,1.47-1.52,3.18-2.98,4.34 c-1.33,1.06-0.8,2.64-0.82,4.03c-0.02,1.27,1.61,3.18,2.84,3.32c3.02,0.36,6.04,0.64,9.06,0.96c0.33,0.04,0.81,0.04,0.95,0.24 c1,1.45,2.98,2.44,2.17,4.75c-0.11,0.31,0.39,0.78,0.39,1.18c0.02,1.32,0.11,2.68-0.17,3.95c-0.22,1.01-1.1,1.86-1.41,2.87 c-0.54,1.71,0.41,3.02,1.55,4.15c1.28,1.27,1.94,1.24,3.66,0.26c0.96-0.55,1.99-1.12,3.06-1.32c1.94-0.35,3.1,1.4,4.64,2.13 c1.17,0.55,2.17,1.43,3.34,1.98c1.51,0.72,3.1,1.19,4.05,2.8c0.33,0.57,1.26,0.78,1.9,1.19c0.6,0.38,1.4,0.7,1.69,1.26 c0.51,1.03,0.69,2.23,1.05,3.34c0.14,0.4,0.35,0.83,0.65,1.11c0.69,0.66,0.82,3.4,0.13,4.02c-1.03,0.92-1,1.59,0.01,2.49 c0.82,0.73,1.45,1.79,2.39,2.23c0.75,0.36,1.85,0.05,2.78-0.07c0.31-0.04,0.58-0.53,0.9-0.55c3.1-0.24,5.89-1.34,8.58-2.84 c0.3-0.16,0.95-0.17,1.14,0.03c0.76,0.82,2.02,1.28,1.69,2.88c-0.33,1.67,0.2,3.38-1.17,4.99c-1.23,1.45-2.01,3.39-2.64,5.23 c-0.38,1.12-0.54,2.67-0.05,3.67c1.2,2.45,4.7,2.61,6.65,0.57c0.81-0.86,1.69-1.67,2.6-2.42c0.67-0.55,1.47-0.95,2.18-1.46 c0.32-0.22,0.58-0.52,0.85-0.79c0.92-0.91,1.79-1.88,3.23-1.91c0.07-0.01,0.12-0.25,0.21-0.36c0.47-0.55,0.87-1.23,1.45-1.62 c1.52-1.02,3.11-1.93,4.71-2.83c0.26-0.15,0.74-0.13,1.03,0.01c0.92,0.44,2.1,0.77,2.65,1.53c1.27,1.72,2.45,3.58,3.25,5.55 c0.83,2.06,3.35,3.48,5.17,2.57c1.67-0.83,2.63-2.52,4.53-3.18c1.48-0.51,2.62-2,3.93-3.03c0.29-0.22,0.64-0.44,0.98-0.49 c2.46-0.4,4.93-0.75,7.39-1.13c0.2-0.03,0.4-0.06,0.58-0.14c2.21-1.02,3.32-0.31,3.32,2.12c0,14.19-0.05,28.38,0.05,42.57 c0.01,1.86-0.96,2.7-2.18,3.62c-1.74,1.29-3.51,2.55-5.17,3.94c-1.03,0.85-1.73,2.36-2.86,2.77c-2.07,0.74-3.5,2.3-5.3,3.36 c-0.78,0.46-2.38,1.3-1.52,2.46c0.73,0.98,1.51,2.42,3.29,2.29c1.75-0.12,3.52-0.01,5.28,0.04c0.36,0.01,0.79,0.11,1.07,0.32 c0.62,0.47,1.08,1.3,1.76,1.51c2.45,0.76,2.94,2.75,3.4,4.84c0.09,0.38,0.22,0.9,0.49,1.05c1.71,0.98,1.74,2.53,1.65,4.2 c-0.06,1.3,0.03,2.61,0.03,3.92c0,29.84,0.04,59.67-0.06,89.5c-0.01,2.31,0.88,4.73-0.96,7.07c-0.87,1.09-0.54,3.2-0.94,4.86 c-0.58,2.45-0.57,4.95-2.05,7.23c-0.78,1.21-0.76,2.94-1.11,4.44c-0.34,1.49-0.68,2.98-1.03,4.46c-0.03,0.13-0.14,0.34-0.23,0.35 c-1.15,0.18-0.88,1.09-0.84,1.76c0.05,0.94-0.27,1.83,0.87,2.72c0.82,0.63,0.83,2.35,1.12,3.6c0.4,1.74,0.73,3.51,1.09,5.26 c0.03,0.15,0.05,0.32,0.13,0.42c1.29,1.52,1.66,3.35,1.96,5.25c0.2,1.27,0.59,2.51,0.92,3.76c0.03,0.12,0.2,0.2,0.26,0.33 c0.28,0.55,0.77,1.11,0.79,1.68c0.09,3.17,0.09,6.34,0.08,9.51c-0.01,53.22-0.02,106.45-0.08,159.68c0,1.51,0.78,3.34-1.06,4.47 c-0.08,0.05-0.06,0.29-0.07,0.43c-0.29,3.58-0.58,7.16-0.86,10.73c-0.32,4.15-0.63,8.3-0.97,12.45c-0.03,0.37-0.26,0.73-0.4,1.09 c-0.22,0.55-0.64,1.11-0.63,1.66c0.01,2.21,0.17,4.31,0.9,6.56c0.95,2.95,0.48,6.31,0.89,9.51c0.6,4.76,0.19,9.64,0.22,14.47 c0,0.5-0.1,1.11,0.14,1.48c1.42,2.19,0.48,4.57,0.54,6.84c0.04,1.47-0.44,2.98-0.84,4.43c-0.28,0.99-0.67,2.02-1.29,2.82 c-0.83,1.08-1.77,2.01-1.64,3.52c0.05,0.49,0.15,1.21-0.11,1.46c-1.13,1.09-0.65,2.44-0.83,3.69c-0.31,2.06,0.16,4.04-0.82,6.24 c-0.96,2.19-0.26,5.14-0.16,7.75c0.02,0.5,0.87,0.95,0.93,1.47c0.29,2.77-0.03,5.53,0.85,8.32c0.65,2.07,0.26,4.49,0.21,6.75 c-0.04,2.22,0.51,4.38,0.15,6.66c-0.41,2.56-0.2,5.21-0.29,7.83c-0.01,0.43-0.02,1.12-0.27,1.26c-1.4,0.77-2.83,1.57-4.34,2.04 c-1.7,0.53-3.51,0.72-5.26,1.07c-0.15,0.02-0.35,0.06-0.42,0.16c-1.05,1.6-2.96,1.06-4.42,1.69c-1.82,0.79-3.98,0.8-5.99,1.16 c-0.29,0.05-0.67,0.1-0.83,0.3c-1.07,1.37-2.9,1.4-4.18,1.54c-2.35,0.25-4.8-0.49-7.21-0.82c-0.14-0.02-0.32-0.1-0.39-0.21 c-1.13-1.76-2.78-0.72-4.19-0.71c-0.45,0-0.86,0.75-1.36,0.9c-1.49,0.44-3.02,0.74-4.53,1.14c-0.22,0.06-0.35,0.43-0.57,0.58 c-0.67,0.47-1.36,1.26-2.06,1.29c-3.56,0.13-7.14,0.07-10.71,0.04c-0.34,0-0.71-0.21-1.04-0.37c-0.54-0.26-1.05-0.56-1.58-0.84 c-0.82-0.43-1.69-0.79-2.43-1.32c-0.47-0.34-0.64-1.1-1.12-1.39c-1.87-1.14-3.1-2.75-4.11-4.66c-0.29-0.55-1.05-1.17-1.64-1.22 c-2.71-0.22-5.54-0.58-7.69,1.72c-0.83,0.9-1.8,1.06-2.92,1.04c-0.38,0-0.87,0.04-1.14,0.26c-1.57,1.29-3.5,1.51-5.38,1.82 c-2.39,0.39-4.78,0.67-7.17,1.02c-0.22,0.03-0.39,0.29-0.61,0.39c-1.11,0.5-2.2,1.26-3.35,1.41c-2.09,0.25-3.01,0.98-2.64,3.04 c0.19,1.07,0.64,2.49,1.43,2.95c1.21,0.72,2.83,0.7,4.26,1.06c1.65,0.43,3.28,0.93,4.92,1.42c1.01,0.3,2.01,0.63,3.03,0.92 c1.88,0.54,3.74,1.35,5.66,1.53c3.04,0.28,6.13,0.18,9.19,0.18c13.52,0.02,27.05,0,40.57,0.04c1.41,0.01,3.03-0.62,4.13,0.94 c0.1,0.14,0.48,0.07,0.73,0.09c5.48,0.4,11.03-0.61,16.46,0.99c1.95,0.58,4.05,0.68,6.11,1c0.07,1.26,0.61,2.47-0.7,3.3 c-0.85,0.54-1.65,1.22-2.57,1.58c-2.2,0.85-4.44,1.57-6.68,2.32c-0.99,0.34-2.02,0.59-3.01,0.94c-1.67,0.58-3.32,1.21-4.98,1.82 c-0.23,0.09-0.44,0.21-0.66,0.31c-0.53,0.24-1.04,0.64-1.58,0.69c-5.18,0.48-10.35-0.17-15.61,0.68 c-5.76,0.93-11.79-0.18-17.64,1.1c-0.82,0.18-1.73-0.09-2.55,0.08c-1.8,0.37-3.61,0.77-5.32,1.42c-0.58,0.21-1.08,1.13-1.26,1.82 c-0.66,2.45,1.02,5.29,4.03,5.07c1.83-0.13,3.72,0.54,5.59,0.87c0.12,0.02,0.22,0.18,0.34,0.24c0.72,0.31,1.43,0.85,2.17,0.88 c2.51,0.11,5.03,0.09,7.54,0.03c1.18-0.03,2.56,0.41,3.33-1.08c0.07-0.15,0.56-0.11,0.86-0.11c5.22,0.01,10.44,0.02,15.66,0.05 c0.34,0,0.79,0,1,0.19c1.32,1.25,2.86,1.82,4.67,1.79c1.63-0.02,3.26,0.01,4.6,1.25c0.06,0.99-0.12,1.83-1.41,1.95 c-0.23,0.02-0.46,0.31-0.66,0.5c-1.32,1.33-2.56,2.77-3.99,3.98c-1.06,0.89-2.34,2.07-3.56,2.12c-2.5,0.1-4.06,2.03-6.3,2.6 c-1.31,0.34-2.46,1.45-3.98,1.52c-0.29,0.01-0.67,0.07-0.83,0.26c-1.11,1.31-2.62,1.66-4.2,1.76c-1.8,0.12-3.76-0.26-5.37,0.33 c-1.58,0.59-3.07,0.54-4.61,0.59c-1.96,0.05-3.92,0.02-5.88,0c-0.39,0-0.79-0.07-1.16-0.17c-0.83-0.22-1.64-0.59-2.48-0.71 c-2.61-0.36-5.24-0.64-7.85-0.96c-0.15-0.02-0.38-0.06-0.41-0.14c-0.54-1.36-1.74-0.98-2.71-0.99c-4.02-0.06-8.04-0.04-12.07-0.05 c-0.4,0-0.81,0-1.19-0.08c-1.18-0.25-2.34-0.57-3.51-0.81c-0.49-0.09-1.19,0.17-1.47-0.09c-1.49-1.32-3.25-0.64-4.88-0.82 c-0.45-0.05-1.2,0.06-1.3-0.14c-0.68-1.42-1.93-1.03-3.02-1.06c-2.06-0.05-5.27-2.58-6.24-4.39c-0.87-1.64-2.23-3.05-3.48-4.46 c-1.04-1.17-2.36-2.08-3.33-3.29c-0.87-1.07-1.16-2.84-2.21-3.49c-1.93-1.2-2.76-3.77-5.53-3.92c-0.11,0.08-0.58,0.28-0.75,0.63 c-0.28,0.54-0.63,1.29-0.45,1.77c0.48,1.3,1.57,2.45,1.78,3.76c0.36,2.21,2.01,3.73,2.59,5.88c0.45,1.67,1.26,3.48,2.41,5.08 c1.14,1.56,1.41,3.74,2.13,5.63c0.43,1.16,0.89,2.33,1.51,3.4c0.36,0.63,1.01,1.13,1.61,1.59c0.67,0.5,1.52,0.79,2.13,1.35 c0.78,0.7,1.25,1.83,2.11,2.32c1.81,1.02,4.06,1.07,5.77,2.38c0.07,0.06,0.21,0.06,0.3,0.04c2.43-0.53,4.36,1.08,6.06,2.12 c2,1.24,4.52,2.12,5.74,4.61c0.47,0.95,1.67,1.55,3.12,0.54c0.9-0.62,2.18-0.69,3.18-1.48c1.15-0.91,2.59-1.45,3.89-2.16 c0.34-0.18,0.65-0.55,0.97-0.56c2.21-0.07,4.53-0.5,6.59,0.05c1.65,0.44,3.29,0.44,4.91,0.75c3.34,0.63,6.68,1.23,10.11,1.01 c0.19-0.02,0.47-0.04,0.58,0.07c1.69,1.69,4.5-0.27,6.04,1.88c2.64-0.06,5.21,0.33,7.75,1.05c1.35,0.38,2.74,0.65,4.1,0.98 c0.13,0.03,0.21,0.2,0.34,0.27c1.18,0.58,2.33,1.28,3.57,1.7c1.36,0.47,2.81,0.68,4.22,1.01c0.12,0.03,0.22,0.16,0.34,0.24 c0.93,0.58,1.82,1.22,2.8,1.71c1.03,0.51,2.68,0.57,3.1,1.35c1.03,1.92,2.93,2.76,4.5,3.64c1.3,0.73,3.45,0.26,5.09-0.18 c0.46-0.12,0.44-2.05,0.6-3.16c0.06-0.34-0.03-0.71,0.02-1.05c0.29-1.88-1.12-3-1.84-4.46c-0.7-1.42-2.24-1.12-3.03-2.13 c-0.57-0.71-1.11-1.52-1.85-1.99c-1.99-1.26-4.2-2.07-5.98-3.79c-1.42-1.38-3.36-2.21-5.05-3.33c-0.53-0.36-0.97-0.86-1.6-1.43 c1.59-0.28,2.79-0.38,3.91-0.73c1.33-0.42,2.56-1.15,3.88-1.59c1.23-0.41,2.52-0.08,3.86-0.73c1.07-0.51,2.44-1.28,3.54-1.27 c4.9,0.06,9.87-1.42,14.74,0.77c1.85,0.84,4.1,0.89,6.19,1.08c2.2,0.2,4.42,0.08,6.63,0.19c1.39,0.07,2.87-0.36,3.15-1.52 c0.35-1.43-0.11-3.07-0.31-4.61c-0.05-0.35-0.43-0.86-0.75-0.94c-1.89-0.45-3.03-2.61-5.28-2.29c-0.29,0.05-0.76-0.44-0.98-0.79 c-0.55-0.87-1.04-1.78-1.46-2.72c-0.72-1.58-1.07-3.47-2.15-4.72c-1.03-1.21-1.01-2.65-1.64-3.91c-0.95-1.9,1.19-4.82,3.55-5.51 c1.64-0.47,2.56-1.92,3.11-3.23c0.56-1.3,1.48-2.16,2.47-2.65c1.95-1,3.13-2.23,2.85-4.48c-0.15-1.19,0.35-1.95,1.04-2.38 c1,0.29,1.75,0.57,2.54,0.71c0.68,0.12,1.65-0.21,2.05,0.15c1.42,1.25,3.06,0.73,4.59,0.79c1.64,0.07,2.82-1.17,2.72-2.83 c-0.14-2.32,0.71-4.76-1.17-6.9c-1.23-1.41-2.02-3.2-3.05-4.79c-0.22-0.34-0.72-0.52-0.87-0.87c-0.46-1.06-0.77-2.19-1.23-3.25 c-0.29-0.71-0.68-1.39-1.13-2.01c-1.1-1.56-2.04-3.14-1.53-5.37c1.49-0.04,2.78-0.09,3.89-1.32c1.1-1.21,1.2-2.49,1.25-3.92 c0.01-0.23,0.11-0.48,0.24-0.67c1.24-1.84,0.48-3.88,0.58-5.83c0.01-0.15-0.29-0.35-0.49-0.46c-1-0.56-2.03-1.05-3-1.64 c-0.5-0.3-0.84-0.89-1.35-1.13c-1-0.46-2.14-0.66-3.09-1.2c-0.51-0.28-0.94-1-1.07-1.59c-0.43-2.04-0.69-4.12-1.08-6.17 c-0.08-0.39-0.55-0.7-0.63-1.08c-0.19-0.93-0.56-2-0.26-2.78c0.2-0.56,1.73-1.24,2.07-1c1.34,0.91,2.76,0.55,4.13,0.75 c0.3,0.04,0.57,0.28,0.87,0.41c0.5,0.23,0.99,0.58,1.52,0.65c3.46,0.48,6.98-0.42,10.48,0.84c1.88,0.67,4.18,0.23,6.29,0.19 c0.47-0.01,1.28-0.37,1.34-0.69c0.2-1.06,0.29-2.2,0.09-3.25c-0.08-0.41-1.04-0.65-1.59-1c-0.18-0.12-0.3-0.34-0.49-0.47 c-1.59-1.12-3.47-1.86-4.58-3.59c-0.05-0.07-0.2-0.06-0.28-0.11c-0.71-0.43-1.45-0.81-2.11-1.31c-0.61-0.47-1.1-1.11-1.72-1.57 c-0.68-0.5-1.49-0.82-2.16-1.33c-0.65-0.49-1.14-1.21-1.81-1.67c-1.57-1.08-3.21-2.06-4.83-3.08c-0.55-0.35-1.1-0.73-1.69-1.01 c-0.82-0.38-1.8-0.53-2.49-1.06c-0.53-0.41-0.95-1.22-1.04-1.91c-0.29-2.18,0.44-4.47-0.96-6.53c-0.53-0.79-1.11-1.77-1.11-2.66 c-0.06-20.73-0.05-41.46-0.03-62.18c0-0.42,0.15-0.86,0.31-1.25c0.21-0.5,0.64-0.94,0.74-1.45c0.29-1.62,0.18-3.22,0.78-4.9 c0.83-2.34,0.88-4.99,1.09-7.52c0.17-1.95,0.05-3.92,0.11-5.88c0.01-0.47,0.2-0.93,0.37-1.38c0.2-0.51,0.68-0.99,0.69-1.49 c0.05-4.08,0.04-8.15,0.01-12.23c0-0.48-0.04-1.25-0.32-1.39c-0.99-0.49-0.7-1.33-0.78-2.08c-0.35-3.05-0.31-6.21-1.2-9.09 c-0.7-2.29-0.69-4.49-0.62-6.72c0.12-3.64-0.46-7.31,0.67-10.95c0.71-2.26,0.78-4.71,1.14-7.07c0.04-0.24,0.05-0.53,0.19-0.72 c1.27-1.67,1.08-3.79,1.66-5.67c0.44-1.39,0.1-3,0.26-4.5c0.1-0.93,0.2-2.16,0.8-2.68c1.42-1.23,1.05-2.71,1.11-4.18 c0.02-0.75,0.08-1.5,0.08-2.26c0-7.94,0-15.89-0.03-23.84c0-0.4-0.25-0.81-0.42-1.2c-0.21-0.5-0.6-0.97-0.64-1.48 c-0.1-1.3,0.06-2.63-0.09-3.92c-0.13-1.03-0.9-2.06-0.78-3.02c0.31-2.47-0.9-4.62-1.12-6.95c-0.02-0.22-0.23-0.41-0.33-0.63 c-0.25-0.52-0.62-1.03-0.7-1.58c-0.19-1.34,0.04-2.8-0.39-4.03c-0.8-2.24-1.62-4.42-1.62-6.84c0.01-17.65,0.01-35.31,0.01-52.97 c0-0.35,0.01-0.7,0-1.05c-0.02-1.05,0.41-1.5,1.54-1.48c2.96,0.07,5.93,0.14,8.89-0.02c1.36-0.08,2.79-0.5,3.99-1.12 c0.75-0.39,1.46-1.39,1.62-2.23c0.27-1.36,0.17-2.82,0.01-4.2c-0.06-0.53-0.66-1.12-1.16-1.45c-0.95-0.62-2-1.08-3.02-1.6 c-0.99-0.5-1.96-1.06-2.98-1.47c-1.78-0.73-3.61-1.35-5.4-2.06c-0.43-0.18-0.73-0.7-1.16-0.84c-2.24-0.68-2.37-0.81-2.37-3.03 c0.01-25.61,0-51.21,0.02-76.82c0-3.07,0.14-6.13,0.21-9.2c0.01-0.24,0.02-0.5,0.07-0.74c0.27-1.22,0.63-2.42,0.81-3.66 c0.37-2.55,0.64-5.13,0.97-7.69c0.02-0.18,0.12-0.4,0.26-0.51c1.25-1.01,1.6-2.31,1.7-3.89c0.22-3.29,0.67-6.56,1.04-9.84 c0.02-0.18,0.11-0.47,0.23-0.51c1.12-0.39,0.81-1.36,0.9-2.16c0.05-0.55-0.08-1.13,0.06-1.65c0.48-1.75,1.32-3.45,1.53-5.23 c0.29-2.37,0.65-4.96-0.01-7.16c-0.63-2.1-0.45-4.08-0.64-6.11c-0.06-0.75,0.14-1.67-0.22-2.22c-1.07-1.62-0.53-3.36-0.68-5.04 c-0.04-0.45,0-0.91,0-1.36c-0.04-11.77-0.07-23.54-0.12-35.32c0-0.74,0.31-1.64-0.76-2.05c-0.18-0.07-0.26-0.51-0.3-0.79 c-0.28-1.71-0.53-3.42-0.79-5.13c-0.02-0.14-0.04-0.34,0.04-0.43c0.85-1.09,1.42-2.52,3.18-2.48c0.48,0.01,1.01-0.1,1.45-0.3 c1.93-0.87,3.83-1.82,5.76-2.7c0.91-0.41,1.88-0.69,2.8-1.06c0.79-0.32,1.87-0.46,2.28-1.06c1.04-1.51,2.94-0.65,4.08-1.75 c0.2-0.2,0.94-0.09,1.27,0.13c1.02,0.68,1.91,1.57,2.95,2.21c0.97,0.6,2.05,1.01,3.11,1.45c0.77,0.32,1.57,0.54,2.6,0.88 c0.08-0.06,0.43-0.5,0.88-0.68c1.99-0.8,2.28-1.19,2.32-3.33c0.02-0.8-0.16-2.05,0.24-2.3c1.05-0.65,0.8-1.53,0.84-2.37 c0.1-1.85,0.1-3.71,0.2-5.57c0.02-0.46,0.14-1,0.42-1.35c1.19-1.48,2.43-2.92,3.72-4.33c1.85-2.02,3.76-3.98,5.62-5.99 c1.2-1.3,2.41-2.58,3.51-3.96c0.91-1.15,2.34-1.82,2.73-3.48c0.22-0.96,1.04-1.77,1.58-2.66c1.01-1.68,2.08-3.34,2.99-5.07 c0.86-1.63,1.53-3.36,2.33-5.01c0.12-0.24,0.55-0.48,0.82-0.47c0.85,0.06,1.7,0.23,2.56,0.36c1.64-0.37,3.34-0.64,5.04-0.61 c2.2,0.04,4.18-0.16,5.25-2.55c-0.42-0.66-0.75-1.53-1.37-2.07c-1.26-1.13-2.64-2.08-2.54-4.07c0.02-0.43-0.29-0.97-0.6-1.32 c-0.98-1.09-1.88-2.23-2.27-3.68c-0.25-0.92-0.45-1.85-0.7-2.92c0.1-0.16,0.47-0.49,0.53-0.87c0.41-2.81,0.64-5.66,1.19-8.44 c0.36-1.78,1.14-3.48,1.81-5.19c0.13-0.33,0.58-0.58,0.92-0.78c1.21-0.7,2.72-1.11,3.58-2.1c0.87-1,1.89-1.43,2.93-2.05 C215.346,112.2,216.377,111.28,216.086,109.69z M111.437,192.42c-46.57,0-84.32-37.75-84.32-84.32c0-46.56,37.75-84.31,84.32-84.31 c46.56,0,84.31,37.75,84.31,84.31C195.747,154.67,157.997,192.42,111.437,192.42z",
      "M220.041,157.85c-0.55-1.59-1.99-2.91-3.19-4.22c-1.44-1.55-3.06-2.93-4.54-4.44 c-0.94-0.97-2.09-1.91-2.57-3.1c-0.71-1.75-2.03-2.69-3.39-3.77c-0.82-0.65-1.45-1.6-2.05-2.48c-0.5-0.74-0.65-1.96-1.31-2.31 c-1.12-0.62-0.92-1.41-0.84-2.26c0.08-0.9-0.07-2.1,0.44-2.6c0.78-0.78,0.7-1.59,0.82-2.45c0.08-0.56-0.1-1.25,0.16-1.69 c1.35-2.35-0.12-5.35,1.81-7.52c0.27-4.36,0.77-8.72,0.74-13.07c-0.02-4.6-0.55-9.19-0.86-13.78c-0.02-0.23-0.04-0.6-0.18-0.67 c-1.2-0.58-0.74-1.69-0.88-2.62c-0.3-2.03-0.62-4.06-0.94-6.09c-0.03-0.17-0.16-0.32-0.24-0.49c-0.24-0.54-0.6-1.06-0.69-1.62 c-0.13-0.75,0.01-1.54-0.06-2.3c-0.14-1.56,0.39-3.22-0.79-4.65c-0.22-0.28-0.2-1.14,0.05-1.36c1.19-1.08,1.96-2.58,3.68-3.18 c0.9-0.32,1.87-1.42,2.11-2.35c0.36-1.38,0.09-2.92,0.09-4.59c-1.73,0-3.3,0.02-4.87,0c-0.36-0.01-0.98-0.02-1.05-0.2 c-0.46-1.09-1.43-0.72-2.21-0.93c-0.6-0.16-1.47-0.3-1.69-0.73c-0.65-1.26-1.95-1.91-2.51-3.35c-0.54-1.39-1.94-2.48-3.06-3.6 c-1.57-1.58-3.29-3.01-4.82-4.63c-0.9-0.96-1.45-2.23-2.3-3.24c-1.37-1.63-3.13-2.84-3.93-5.04c-0.75-2.04-0.93-2.28,0.91-3.34 c1.13-0.65,2.46-1.26,3.14-2.27c0.61-0.91,1.38-1.33,2.18-1.58c1.22-0.36,1.87-1.27,2.04-2.22c0.26-1.52,0.07-3.12,0.07-4.65 c-0.7-0.18-1.53-0.16-1.73-0.5c-0.54-0.93-1.34-0.88-2.1-0.8c-2.26,0.22-4.43-0.1-6.81,0.91c-2.5,1.06-5.7,0.06-8.58,0.97 c-1.39,0.44-3.04,0.01-4.63-0.49c-1.72-0.54-3.23-1.39-4.81-2.12c-0.53-0.24-0.86-0.92-1.39-1.21c-1.65-0.91-3.34-1.75-5.03-2.58 c-1.13-0.55-2.27-1.12-3.46-1.5c-1.3-0.42-2.67-0.64-4.01-0.96c-0.12-0.03-0.2-0.18-0.32-0.25c-0.49-0.28-0.96-0.69-1.5-0.81 c-1.58-0.38-3.18-0.64-4.78-0.96c-0.14-0.02-0.31-0.04-0.39-0.13c-1.28-1.53-3.33-0.93-4.88-1.77c-0.54-0.3-1.16-0.25-1.76-0.8 c-0.74-0.69-1.95-0.86-2.95-1.27c-0.31-0.13-0.57-0.36-0.88-0.52c-1.82-0.91-2.44-3.41-4.85-3.63c-0.37-0.03-0.84-0.97-0.93-1.54 c-0.16-0.97-0.04-2-0.04-2.77c-1.29-1.4-2.71-1.66-4.31-1.5c-1.04,0.1-3.26,1.89-3.77,2.79c-0.68,1.21-0.49,3.06-2.5,3.4 c-0.54,0.1-1.02,0.85-1.41,1.39c-0.58,0.82-1.24,1.27-2.3,1.24c-2.01-0.06-4.03-0.04-6.04,0.02c-0.52,0.02-1.03,0.31-1.53,0.51 c-0.4,0.16-0.75,0.5-1.15,0.55c-3.09,0.4-6.2,0.74-9.3,1.11c-0.14,0.02-0.31,0.01-0.41,0.1c-1.74,1.46-4.05,1.26-6.01,1.52 c-2.02,0.27-3.57,1.32-5.4,1.82c-1.27,0.35-2.45,1.02-3.69,1.51c-2.06,0.82-4.13,1.61-6.2,2.4c-0.64,0.24-1.35,0.37-1.91,0.73 c-1.46,0.94-2.83,2.01-4.28,2.97c-1.07,0.72-2.2,1.37-3.31,2.04c-0.98,0.59-1.98,1.14-2.94,1.76c-0.49,0.32-0.89,0.79-1.38,1.11 c-0.56,0.35-1.41,0.47-1.71,0.95c-0.49,0.79-1.09,1.06-1.92,1.26c-0.56,0.14-1.09,0.61-1.52,1.04c-0.91,0.91-1.7,1.92-2.6,2.84 c-1.47,1.52-3.01,2.96-4.47,4.49c-1.04,1.1-1.94,2.34-2.99,3.42c-1.05,1.07-2.23,2.02-3.34,3.03c-0.16,0.15-0.42,0.34-0.42,0.49 c0.1,1.74-2.06,1.97-2.29,3.47c-1.95,0.29-1.67,2.42-2.79,3.49c-1.16,1.11-1.61,2.94-2.39,4.45c-0.36,0.68-0.62,1.51-1.17,1.98 c-0.96,0.81-1.45,1.74-1.52,2.96c-0.02,0.38-0.02,0.81-0.2,1.11c-0.84,1.45-1.74,2.87-2.62,4.29c-0.4,0.63-1.03,1.22-1.16,1.9 c-0.25,1.29-0.94,1.6-2.14,1.73c-2.53,0.27-5.17-0.85-7.62,0.97c-0.78,0.57-1.29,0.9-1.28,1.82c0.02,1.15,0.04,2.3,0.09,3.45 c0.01,0.28,0.02,0.64,0.18,0.82c0.91,1.01,1.87,1.99,2.82,2.97c0.3,0.31,0.66,0.56,0.92,0.89c0.54,0.7,0.91,1.58,1.57,2.11 c1.32,1.05,1.76,2.7,0.91,4.16c-0.19,0.32-0.31,0.7-0.37,1.07c-0.33,2.36-0.19,4.68-0.93,7.12c-1.04,3.39-0.76,7.19-0.99,10.82 c-0.084,1.3-0.028,2.609-0.004,3.91c0.006,0.347,0.042,0.913,0.113,1.253c0.215,1.031,0.607,2.038,0.712,3.077 c0.13,1.18,0.02,2.39,0.08,3.59c0.02,0.39,0.24,0.77,0.39,1.15c0.19,0.5,0.5,0.97,0.6,1.49c0.36,1.88,0.66,3.78,0.98,5.67 c0.02,0.14,0.04,0.36,0.12,0.39c1.31,0.58,0.79,1.78,0.95,2.74c0.08,0.47-0.04,1.09,0.21,1.4c1.07,1.27,0.76,2.98,1.64,4.41 c0.92,1.49,0.83,3.53,1.95,5.15c1.07,1.53,1.11,3.52,2.09,5.23c1.14,2,1.76,4.33,3.12,6.29c0.99,1.43,1.86,2.94,2.81,4.39 c0.43,0.64,1.05,1.17,1.38,1.86c0.32,0.66,0.52,1.46,0.46,2.17c-0.02,0.21-1.11,0.37-1.72,0.47c-0.89,0.14-2.03-0.1-2.64,0.37 c-1.27,0.99-2.58,1.6-4.16,1.75c-0.27,0.02-0.66,0.12-0.78,0.31c-0.74,1.2-2.18,0.94-3.19,1.62c-0.9,0.6-1.97,0.95-2.95,1.45 c-0.13,0.06-0.15,0.33-0.22,0.5c-0.29,0.61-0.57,1.22-0.88,1.88c0.22,0.14,0.66,0.26,0.73,0.49c0.44,1.56,1.62,1.71,2.95,1.69 c6-0.1,12,0.28,17.98-0.6c2.02-0.3,2.35-0.04,2.27,1.87c-0.01,0.33,0.33,0.65,0.42,1c0.28,1.08,0.93,2.18-0.3,3.18 c-0.72,0.59-1.28,1.39-1.97,2.04c-0.57,0.55-1.16,1.13-1.84,1.51c-1.53,0.85-3.29,1.33-4.37,2.87c-0.11,0.16-0.38,0.21-0.57,0.32 c-1.53,0.89-3.3,1.54-4.54,2.74c-1.67,1.63-4.03,1.83-5.72,3.3c-0.62,0.53-1.4,0.9-2.1,1.34c-0.35,0.22-0.68,0.57-1.05,0.64 c-1.67,0.33-2.61,1.81-2.12,3.47c0.38,1.29,2.05,1.63,3.29,1.08c1.5-0.67,2.83-2,4.72-1.6c0.23,0.05,0.48-0.03,0.71,0.01 c3.29,0.59,6.38-0.81,9.6-0.9c0.14,0,0.37-0.02,0.4-0.09c0.59-1.47,1.9-0.82,2.92-1.07c1.08-0.27,2.31-0.48,3.12-1.14 c1.34-1.1,3.01-1.42,4.43-1.52c2.07-0.14,3.55-1.64,5.54-1.71c0.53-0.02,1.04-0.3,1.55-0.46c0.45-0.14,0.92-0.22,1.33-0.43 c0.95-0.49,1.87-1.48,2.8-1.47c2.17,0.03,4.33,0.51,6.5,0.83c0.1,0.02,0.16,0.24,0.27,0.29c0.56,0.28,1.11,0.61,1.7,0.78 c1.28,0.37,2.98,0.25,3.8,1.06c1.41,1.37,3.24,0.88,4.73,1.73c0.92,0.53,2.42-0.25,3.25,1.05c0.11,0.17,0.55,0.21,0.82,0.18 c3.28-0.45,5.4,2.03,8.05,3.18c1.02,0.44,1.9,1.2,2.94,1.6c2.28,0.87,4.77,0.75,7.12,1.85c2.1,0.99,4.76,1.09,7.16,1.03 c6.72-0.19,13.49,0.95,20.17-0.71c1.13-0.28,2.39-0.08,3.58-0.17c0.39-0.02,0.78-0.21,1.15-0.37c0.47-0.21,0.91-0.6,1.39-0.67 c1.14-0.15,2.49,0.21,3.39-0.3c1.52-0.84,2.91-0.42,4.47-0.47c0.03,0.81,0.09,1.47,0.09,2.13v170.39c0,1.92,0.01,3.84-0.01,5.76 c0,0.42,0.03,1.13-0.17,1.22c-1.48,0.66-0.88,1.94-0.93,2.97c-0.1,1.67-0.15,3.36-0.02,5.03c0.14,1.95-0.76,4.1,1,5.79 c0.14,0.13,0.07,0.46,0.13,0.69c0.32,1.16,0.64,2.31,1,3.45c0.05,0.18,0.32,0.33,0.52,0.42c1.35,0.57,1.68,1.45,1.02,2.81 c-0.14,0.29-0.42,0.71-0.31,0.88c1.11,1.81,0.69,3.83,0.63,5.73c-0.1,2.98-0.59,5.94-0.76,8.93c-0.14,2.43-0.03,4.89-0.08,7.33 c-0.01,0.6,0.23,1.41-0.8,1.57c-0.12,0.02-0.28,0.37-0.29,0.57c-0.16,3.08-0.36,6.15-0.72,9.24c-0.59,4.97-0.21,10.05-0.21,15.09 c0,44.18,0.01,88.36,0,132.54c0,6.23-0.02,12.47-0.12,18.7c-0.03,1.37,0.13,2.67-0.79,4.12c-0.92,1.43-0.93,3.56-1.02,5.39 c-0.16,3.11-0.07,6.24-0.11,9.36c-0.01,0.51-0.02,1.4-0.24,1.47c-1.21,0.4-0.8,1.35-0.89,2.13c-0.08,0.62-0.03,1.28-0.26,1.84 c-1.03,2.54-0.86,5.31-0.25,7.71c0.44,1.74,0.41,3.39,0.61,5.08c0.09,0.71-0.17,1.75,0.22,2.08c1.12,0.97,0.85,2.16,0.86,3.3 c0.05,10.08,0.08,20.15,0.07,30.22c0,1.21,0.33,2.59-1.03,3.45c-0.18,0.11-0.18,0.53-0.24,0.8c-0.3,1.45-0.59,2.91-0.92,4.36 c-0.04,0.18-0.32,0.29-0.45,0.47c-0.23,0.34-0.53,0.68-0.61,1.06c-0.36,1.69-0.64,3.38-0.96,5.08c-0.02,0.13-0.03,0.36-0.11,0.39 c-1.37,0.57-0.82,1.77-0.87,2.73c-0.07,1.48,0.09,2.98-0.06,4.45c-0.07,0.64-0.56,1.58-1.07,1.74c-1.53,0.48-3.39-0.22-4.66,1.28 c-6.11,0.05-12.2-0.04-18.29,0.83c-3.57,0.51-7.27,0.09-10.91,0.11c-0.52,0-1.34-0.08-1.52,0.2c-0.88,1.4-2.2,0.79-3.34,0.85 c-1.68,0.09-3.36,0.01-5.03,0.03c-2.22,0.03-2.87,0.61-2.88,2.52c-0.01,1.74,1.56,3.66,3.06,3.67c2.44,0.02,4.89-0.03,7.33,0.03 c0.54,0.01,1.1,0.29,1.59,0.56c0.66,0.35,1.23,1.13,1.88,1.17c2.77,0.19,5.5,0.3,8.27,0.8c3.4,0.62,6.97,0.26,10.46,0.39 c1.31,0.04,2.77-0.51,3.81,0.86c0.13,0.16,0.55,0.11,0.83,0.16c1.98,0.31,3.97,0.57,5.93,0.94c1.09,0.21,2.13,0.61,3.19,0.93 c0.13,0.04,0.23,0.15,0.35,0.21c0.62,0.31,1.25,0.59,1.87,0.9c0.71,0.37,1.79,0.59,2.05,1.17c0.56,1.23,0.85,2.64,0.96,4.01 c0.19,2.53,0.15,5.07,0.25,7.61c0.01,0.38,0.22,0.77,0.39,1.12c0.21,0.43,0.67,0.83,0.68,1.24c0.06,2.54,0.03,5.08,0.03,8.02 c-1.66,0.18-3.24,0.45-4.82,0.5c-2.92,0.07-5.85,0-8.77,0.03c-0.79,0-1.59,0.13-2.49,0.22c0.04,1.62-0.73,3.04,0.83,4.49 c1.37,1.26,2.42,2.7,4.52,2.55c0.429-0.031,0.861,0.057,1.262,0.211c2.119,0.81,4.149,1.889,6.518,1.859 c2.647-0.022,3.007,0.673,2.932,3.776c-0.017,0.708,0.025,1.415,0.061,2.122c0.065,1.295-0.44,1.831-1.823,1.812 c-3.69-0.07-7.38-0.03-11.07,0c-0.56,0.01-1.42-0.02-1.62,0.29c-0.74,1.16-1.8,0.84-2.78,0.84c-2.78,0.02-5.56,0.01-8.34,0.01 c-2.64,0-5.27,0.06-7.9-0.01c-1.15-0.03-2.08,0.55-2.33,1.39c-0.7,2.4,0.27,5.56,3.59,5.63c1.2,0.02,2.77-0.38,3.51,0.22 c1.4,1.15,2.84,0.75,4.28,0.95c1.97,0.27,3.93,0.57,5.9,0.89c0.17,0.03,0.3,0.3,0.46,0.45c0.91,0.82,1.76,1.71,3.21,1.47 c0.49-0.09,1.07,0.16,1.57,0.35c0.51,0.19,0.95,0.66,1.45,0.73c3.2,0.43,6.4,0.78,9.69,1.16c0.04,0.17,0.13,0.39,0.14,0.62 c0.03,1.82,0.03,3.65,0.06,5.47c0.01,0.76-0.1,1.57,0.11,2.28c0.5,1.64,0.12,2.28-1.61,2.28c-4.12,0-8.24-0.01-12.36,0.02 c-0.7,0.01-1.77,0-2.02,0.4c-0.59,0.96-1.36,0.7-2.11,0.73c-1.81,0.07-3.64,0.04-5.44,0.19c-1.13,0.1-2.23,0.64-3.35,0.64 c-8.67,0.06-17.35,0.03-26.02,0.05c-0.66,0-1.71-0.04-1.89,0.3c-0.55,1.03-1.38,0.79-2.18,0.88c-1.31,0.17-2.07,1-2.12,2.29 c-0.1,2.71,1.38,4.42,4.05,4.64c0.66,0.06,1.34,0.06,2.01,0.06c11.59,0,23.19-0.04,34.79,0.04c2.11,0.01,4.23,0.53,6.34,0.84 c0.16,0.02,0.3,0.17,0.46,0.26c0.46,0.24,0.9,0.61,1.38,0.7c2.05,0.38,4.12,0.68,6.18,1.02c0.17,0.02,0.32,0.14,0.49,0.22 c0.59,0.27,1.16,0.71,1.77,0.77c1.78,0.18,2.26,0.55,2.18,2.39c-0.13,2.89,0.3,5.79-0.56,8.69c-0.54,1.82,0.44,4.02-1.28,5.61 c-1.07,0.99-1.03,2.72-2.45,3.52c-0.6,0.33-1.11,0.94-1.49,1.53c-0.84,1.31-1.52,2.72-2.37,4.02c-0.39,0.59-1.08,0.97-1.53,1.53 c-0.82,1.05-1.77,2.07-2.29,3.27c-0.73,1.7,0.72,3.6,2.56,3.61c1.2,0,2.39-0.07,3.59-0.14c0.28-0.01,0.76-0.06,0.79-0.18 c0.37-1.48,1.9-1.22,2.79-1.6c1.47-0.63,2.91-1.2,4.18-2.2c0.6-0.47,1.56-0.65,1.91-1.24c0.65-1.1,0.98-2.39,1.44-3.6 c0.17-0.43,0.37-0.84,0.5-1.28c0.4-1.41,0.82-2.81,1.14-4.24c0.15-0.69,0.22-1.46,0.08-2.14c-0.28-1.36,0.93-1.72,1.44-2.55 c0.84-1.38,1.53-1.33,2.36-0.08c0.04,0.06,0.18,0.09,0.27,0.09h5.12c-0.27-2.27,0.54-4.2-0.94-6.39c-1.18-1.72-2.35-3.95-2.25-6.37 c0.02-0.28-0.07-0.57-0.13-0.85c-0.31-1.36-0.62-2.72-0.98-4.33c4.5,0,8.43-0.01,12.35,0.02c0.27,0,0.59,0.24,0.78,0.46 c0.82,0.96,1.75,1.44,3.09,1.4c2.73-0.08,5.46,0.06,8.19,0.06c14.24,0.01,28.47,0,42.7,0c0.67,0,1.35,0.02,2.01-0.07 c0.32-0.05,0.75-0.28,0.88-0.55c0.69-1.38,1.24-2.78,1.07-4.42c-0.22-2-0.91-2.79-2.91-2.81c-2.59-0.03-5.17,0-7.76-0.03 c-0.4,0-0.82-0.09-1.21-0.22c-0.79-0.28-1.56-0.86-2.35-0.87c-4.08-0.1-8.15-0.05-12.22-0.06c-0.39,0-0.91,0.14-1.13-0.05 c-1.49-1.3-3.27-0.63-4.92-0.82c-1.42-0.16-3.03,0.59-4.17-0.93c-0.17-0.22-0.72-0.18-1.1-0.18c-1.29-0.03-2.58-0.02-3.86-0.03 c-0.63,0-1.49,0.23-1.83-0.09c-1.49-1.41-3.58-0.43-5.29-1.62c-1.47-1.03-3.79-0.13-5.71-1.05c-1.26-0.6-2.87,0.1-4.29-1.07 c-1.64-1.35-3.9-1.12-5.98-1.07c-1.17,0.02-1.96-0.78-2.01-1.96c-0.02-0.61,0-1.22,0-1.93c0.7-0.04,1.27-0.05,1.83-0.12 c0.31-0.04,0.62-0.16,0.9-0.3c0.48-0.24,0.93-0.73,1.42-0.78c3.66-0.32,7.33-0.56,10.99-0.82c0.05-0.01,0.1-0.01,0.15-0.01 c1.17-0.12,2.41-1.19,2.51-2.35c0.1-1.23,0.02-2.47,0.02-3.7c-1.73-0.36-3.3-0.9-4.9-0.98c-3.01-0.13-6.03,0-9.05,0.03 c-0.43,0-0.99-0.06-1.25,0.17c-1.07,0.95-2.32,0.59-3.51,0.66c-1.57,0.08-2.62-0.97-2.97-2.16c-0.34-1.18-0.19-2.67,0.24-3.85 c0.41-1.13,3.21-1.2,4.42-0.44c0.97,0.61,2.01,1.16,3.09,1.52c0.79,0.26,1.7,0.21,2.56,0.22c2.42,0.05,3.28-0.79,3.32-3.21 c0.02-1.15,0.11-2.31-0.02-3.45c-0.11-0.94-0.49-1.85-0.77-2.77c-0.35-1.1-0.72-2.18-1.14-3.45c0.69-0.05,0.96-0.09,1.24-0.09 c4.31-0.08,8.62-0.14,12.93-0.23c0.51-0.01,1.03-0.12,1.52-0.26c0.68-0.19,1.33-0.66,1.99-0.67c6.85-0.05,13.71-0.02,20.56-0.04 c0.71,0,1.61,0.13,2.1-0.23c1.18-0.87,2.44-0.56,3.67-0.62c1.29-0.05,2.6,0.05,3.87-0.13c0.76-0.11,1.42-0.83,2.18-0.93 c2.31-0.3,4.64,0.04,6.98-0.78c1.36-0.48,1.89-0.92,1.89-2.21c-0.01-1.05,0-2.09,0-3.07c-1.98-0.4-3.74-0.82-5.52-1.07 c-1.03-0.15-2.1-0.02-3.15-0.04c-0.33,0-0.87,0.04-0.95-0.13c-0.68-1.28-1.88-0.93-2.9-0.94c-4.36-0.05-8.72-0.02-13.08-0.03 c-0.42,0-0.84-0.06-1.25-0.16c-0.85-0.21-1.69-0.65-2.53-0.66c-3.74-0.08-7.48-0.04-11.22-0.07c-0.39,0-0.81-0.11-1.19-0.25 c-0.65-0.26-1.27-0.76-1.93-0.82c-1.661-0.151-3.335-0.019-5.007-0.073c-0.629-0.021-1.638-0.204-2.243-0.375 c-0.66-0.186-1.321-0.376-1.99-0.432c-1.57-0.13-3.16-0.02-4.74-0.05c-0.36,0-0.73-0.1-1.06-0.22c-0.75-0.28-1.46-0.83-2.21-0.87 c-2.29-0.12-4.62,0.13-6.89-0.13c-1-0.11-2.34-0.9-2.73-1.74c-0.4-0.87-0.13-2.37,0.4-3.27c0.641-1.095,1.837-1.878,2.791-2.802 c0.176-0.17,0.314-0.377,0.406-0.604c0.418-1.034,0.692-2.09,1.883-2.644c0.49-0.22,0.73-0.96,1.09-1.46 c0.58-0.8,1.01-1.83,1.79-2.34c1.34-0.86,2.7-1.8,4.39-2.05c0.94-0.14,2.19-0.41,2.65-1.07c0.83-1.21,2.16-0.98,3.16-1.63 c1.45-0.94,3.1-1.57,4.65-2.39c0.2-0.1,0.36-0.48,0.37-0.73c0.03-1.66,0.02-3.32,0.02-5.1c-1.93,0-3.73-0.2-5.46,0.05 c-1.77,0.26-3.54,0.82-5.19,1.53c-0.95,0.41-1.55,0.46-2.52,0.01c-1.67-0.76-3.21-2.09-5.31-1.62c-0.77,0.17-1.62,0.05-2.43,0.02 c-1.31-0.03-2.01-0.77-2.04-2.07c-0.03-1.1,0.24-2.39-0.24-3.26c-0.82-1.47-0.5-2.93-0.57-4.4c-0.07-1.35,0.57-1.94,1.93-1.96 c1.81-0.04,3.65,0.03,5.45-0.16c1.45-0.15,2.85-0.78,4.3-0.91c2.1-0.2,4.21-0.09,6.32-0.19c5.64-0.27,11.27-0.58,16.91-0.89 c0.29-0.01,0.59-0.18,0.87-0.31c0.46-0.22,0.9-0.66,1.36-0.68c2.87-0.12,5.74-0.18,8.61-0.21c1.86-0.01,3.49-0.46,4.72-1.98 c0.73-0.91,0.33-3.4-0.5-3.95c-1.54-1.02-3.21-0.87-4.89-0.91c-0.4-0.01-0.81-0.11-1.19-0.25c-0.76-0.27-1.48-0.83-2.23-0.85 c-3.214-0.102-6.428-0.038-9.642-0.061c-0.354-0.003-0.711-0.029-1.053-0.122c-0.859-0.234-1.683-0.63-2.544-0.697 c-1.48-0.12-2.97-0.01-4.46-0.04c-0.35,0-0.72-0.1-1.05-0.23c-0.7-0.28-1.36-0.79-2.07-0.87c-1.37-0.14-2.78,0.05-4.16-0.06 c-4.36-0.36-8.78,0.74-13.14-0.72c-1.01-0.34-1.88-0.84-2.7-1.35c-0.51-0.31-0.85-1.41-0.73-2.06c0.1-0.55,0.9-1.24,1.51-1.38 c1.69-0.39,3.52,0.23,5.11-1.2c0.68-0.6,1.73-0.79,2.03-1.87c0.46-1.59,0.03-3.2-1.02-4.15c-1.15-1.05-2.8-1.57-4.3-2.17 c-0.95-0.37-1.49-0.84-1.48-1.89c0.03-1.58,0.02-3.17-0.01-4.75c-0.01-0.57,0.08-1.42-0.24-1.65c-1.34-0.97-1.03-2.35-1.03-3.6 c-0.03-12.57-0.2-25.14,0.09-37.7c0.09-4.05-0.94-8.2,0.93-12.27c0.93-2.02,0.71-4.58,1.03-6.89c0.16-1.24-0.47-2.69,1-3.6 c0.14-0.09,0.09-0.54,0.09-0.83c0-4.12,0.01-8.25-0.02-12.37c0-0.41-0.16-0.82-0.29-1.22c-0.19-0.59-0.54-1.16-0.6-1.77 c-0.36-3.45-0.65-6.9-0.98-10.35c-0.03-0.31-0.24-0.6-0.38-0.89c-0.22-0.51-0.58-1-0.66-1.53c-0.24-1.69,0.47-3.51-0.81-5.07 c-0.19-0.23-0.19-0.89,0-1.1c1.13-1.21,0.66-2.69,0.81-4.07c0.03-0.33-0.01-0.85,0.17-0.94c1.18-0.61,0.78-1.71,0.9-2.64 c0.31-2.41,0.6-4.82,0.92-7.23c0.02-0.17,0.16-0.32,0.24-0.48c0.28-0.64,0.56-1.28,0.85-1.91c0.32-0.7,0.59-1.93,1-1.98 c1.63-0.19,2.43-1.42,3.43-2.35c1.11-1.02,1.99-2.29,3.34-3.88c1.88-0.27,4.43-0.62,6.97-0.99c0.244-0.035,0.634-0.127,0.864-0.214 c1.441-0.546,2.865-1.399,4.326-1.486c2.42-0.16,3.88-1.4,5.1-3.21c0.42-0.63,0.74-1.32,1.14-1.95c0.73-1.13,0.46-2.45-0.7-3.13 c-1.06-0.64-2.14-1.26-3.22-1.86c-0.79-0.43-1.66-0.72-2.39-1.23c-1.235-0.87-2.388-1.874-3.593-2.814 c-0.497-0.388-1.371-0.934-1.933-1.221c-0.971-0.497-1.952-0.974-2.934-1.465c-1-0.5-2.02-0.97-3.01-1.5 c-1.6-0.84-3.21-1.67-4.75-2.6c-0.37-0.23-0.71-0.84-0.72-1.29c-0.12-4.45-0.14-8.91-0.24-13.37c-0.01-0.63-0.24-1.27-0.47-1.87 c-0.4-1.04-1.01-2.01-1.27-3.07c-0.41-1.62-0.52-3.32-0.9-4.95c-0.19-0.8-1.03-1.52-1.04-2.28c-0.03-2.59-1.5-4.95-1.05-7.62 c0.23-1.35,0.07-2.78,0.01-4.17c-0.02-0.49-0.22-0.99-0.41-1.46c-0.18-0.47-0.63-0.91-0.64-1.37c-0.1-5.89-0.19-11.79-0.2-17.69 c-0.01-43.36-0.01-86.72,0.01-130.09c0-3.59,0.1-7.19,0.18-10.78c0-0.35,0.13-0.72,0.28-1.04c0.23-0.52,0.69-0.98,0.75-1.51 c0.14-1.13-0.01-2.31,0.15-3.44c0.21-1.41,0.24-3.06,1.01-4.12c1.23-1.69,0.93-3.66,1.6-5.44c0.86-2.26-0.54-4.93,1.14-7.29 c1.15-1.62,1.74-3.65,2.56-5.5c0.27-0.59,0.41-1.24,0.72-1.81c0.54-1.02,1.19-1.98,1.75-2.99c0.58-1.04,1.14-2.09,1.63-3.17 c0.67-1.52,2.22-1.88,3.43-2.66c0.92-0.59,2.03-0.89,3.04-1.36c1.51-0.69,3.02-1.38,4.5-2.12c0.5-0.26,1.18-0.59,1.33-1.04 c0.46-1.4,0.79-2.85,1.02-4.31c0.13-0.82-0.4-1.39-1.27-1.39c-3.26,0-6.51,0.03-9.77,0.06c-0.24,0-0.51,0-0.7,0.11 c-2.29,1.29-4.7,0.26-7.06,0.66c-0.05-0.53-0.1-0.81-0.1-1.1c0-8.53,0.13-17.08-0.04-25.61c-0.18-8.49,0.86-17.02-0.84-25.46 c-0.17-0.87-0.26-1.75-0.48-2.61c-0.13-0.53-0.56-0.99-0.63-1.51c-0.16-1.28,0.11-2.69-0.33-3.83c-0.93-2.37-0.35-3.87,2.08-4.61 c1.47-0.44,2.09-2.42,3.94-2.27c0.03,0,0.06-0.17,0.13-0.23c0.85-0.86,1.58-2.12,2.61-2.47c1.65-0.55,2.44-1.96,3.72-2.84 c0.98-0.67,1.86-1.5,2.82-2.2c0.62-0.46,1.31-0.81,1.96-1.23c0.66-0.42,1.31-0.86,1.95-1.31c0.27-0.2,0.49-0.46,0.76-0.67 c0.8-0.63,1.65-1.2,2.4-1.88c1.08-0.97,2.05-2.05,3.13-3.03c1.21-1.1,2.77-1.94,3.64-3.25c1.25-1.87,2.53-3.64,4.13-5.24 c1.47-1.47,2.88-3.08,3.97-4.84c0.72-1.18,2.37-1.65,2.4-3.29c0-0.06,0.14-0.14,0.22-0.16c1.32-0.35,2.61-0.84,3.95-1 c1.36-0.16,2.93-0.39,3.93,0.85c1.2,1.51,2.76,0.97,4.22,1.05c0.96,0.06,1.93,0.15,2.88,0.04c2.29-0.27,4.18,0.69,6.06,1.78 c0.68,0.4,1.4,0.75,2.09,1.13c0.92,0.51,1.83,1.03,2.85,1.6c0-0.01,0.07-0.17,0.19-0.27c0.97-0.86,2.45-1.54,2.79-2.6 C220.411,161.37,220.561,159.38,220.041,157.85z M111.437,192.42c-43.96,0-80.06-33.63-83.96-76.57c-0.27-0.72-0.3-1.53-0.18-2.4 c-0.12-1.77-0.18-3.55-0.18-5.35c0-46.56,37.75-84.31,84.32-84.31c46.56,0,84.31,37.75,84.31,84.31 C195.747,154.67,157.997,192.42,111.437,192.42z",
      "M230.071,128.64c-0.15-1.08-0.7-2.04-2.08-2.04c-0.28,0-0.57-0.25-0.84-0.39 c-0.47-0.25-0.92-0.61-1.42-0.73c-1.45-0.36-2.93-0.61-4.39-0.92c-0.12-0.03-0.22-0.18-0.34-0.23c-0.69-0.31-1.37-0.67-2.09-0.89 c-0.5-0.15-1.09,0.01-1.58-0.15c-1.59-0.49-3.12-1.21-4.73-1.56c-0.84-0.18-1.56-0.25-1.9-1.1c-0.26-0.64-0.44-1.3-0.58-1.71 c-0.72-0.61-1.66-1-1.81-1.59c-0.47-1.97-0.84-4-0.92-6.01c-0.17-4.38-0.13-8.76-0.19-13.14c0-0.39,0.08-0.98-0.12-1.13 c-1.52-1.11-0.88-2.72-1.05-4.13c-0.09-0.72-0.04-1.47-0.24-2.16c-0.52-1.81-1.24-3.58-1.68-5.41c-0.47-1.99-0.71-4.03-1.05-6.05 c-0.02-0.15-0.03-0.35-0.12-0.41c-1.51-0.98-1.28-2.82-1.53-4.12c-0.44-2.32-1.97-4.02-2.61-6.16c-0.4-1.34-1.17-2.57-1.71-3.87 c-0.68-1.62-1.18-3.32-1.99-4.86c-0.81-1.54-2.08-2.85-2.84-4.42c-0.66-1.35-0.85-2.94-2.05-4.04c-0.1-0.09-0.05-0.51,0.07-0.66 c0.56-0.66,1.05-1.5,1.78-1.88c1.3-0.68,1.3-1.76,1.31-2.91c0.01-1.17-0.04-2.34,0.01-3.51c0.07-1.48-0.62-2.06-2.07-2.04 c-3.26,0.04-6.52,0.06-9.78-0.01c-0.7-0.02-1.46-0.33-2.05-0.72c-1.1-0.72-2.12-1.56-3.13-2.4c-0.54-0.45-0.96-1.03-1.48-1.5 c-0.43-0.39-0.99-0.65-1.4-1.06c-1.1-1.08-2.85-1.27-3.64-2.8c-0.26-0.51-0.8-0.93-1.31-1.26c-1.904-1.241-3.992-2.242-5.711-3.712 c-0.881-0.754-1.89-1.335-2.86-1.97c-0.607-0.397-1.054-1.111-1.699-1.348c-2.2-0.8-3.28-2.91-5.09-4.15 c-1.33-0.92-1.84-2.72-3.74-3.11c-0.83-0.18-1.88-1.09-2.14-1.89c-0.88-2.71-2.14-5.37-1.84-8.36c0.05-0.48,0.01-0.96,0.01-1.34 c-1.25-1.09-2.38-0.97-3.36,0.1c-0.89,0.97-1.57,2.15-2.54,3.02c-1.43,1.29-2.97,2.51-4.61,3.52c-0.69,0.42-1.38,0.67-2.02,1.31 c-0.9,0.89-2.2,1.64-3.43,1.85c-1.8,0.3-3.69,0.07-5.53,0.05c-0.18,0-0.48-0.07-0.53-0.18c-0.47-1.14-1.47-0.93-2.36-0.94 c-6.56-0.01-13.14-0.04-19.7,0.04c-1.54,0.02-3.04-0.25-4.58,0.97c-1.14,0.9-3.14,0.73-4.76,1.02c-2.09,0.36-4.19,0.69-6.29,1.07 c-0.19,0.03-0.33,0.28-0.53,0.39c-0.37,0.22-0.74,0.54-1.14,0.59c-2.19,0.29-4.26,0.71-6.23,1.94c-1.53,0.96-3.44,1.68-5.22,1.77 c-1.75,0.09-2.67,1.41-4.14,1.82c-1.55,0.42-2.99,0.65-4.48-0.1c-0.81-0.405-1.626-0.816-2.452-1.201 c-0.68-0.317-1.835-0.735-2.558-0.934c-1.54-0.425-3.106-0.796-4.66-1.225c-0.36-0.1-0.75-0.28-1-0.54 c-1.13-1.22-3.97-1.95-5.53-1.35c-0.17,0.06-0.44,0.21-0.43,0.31c0.02,1.69-0.44,3.69,0.31,4.96c0.62,1.05,0.67,1.93,0.85,2.94 c0.3,1.71,0.65,3.4,0.99,5.1c0.03,0.13,0.11,0.31,0.22,0.36c1.21,0.52,0.68,1.35,0.48,2.21c-2.65,0-5.23,0-7.8-0.01 c-0.24,0-0.59,0.01-0.69-0.13c-1.25-1.66-3.02-0.97-4.53-0.83c-0.67,0.07-1.56,1.09-1.79,1.86c-0.3,0.97-0.07,2.11,0.02,3.18 c0.03,0.3,0.32,0.68,0.6,0.85c0.79,0.49,1.63,0.88,2.41,1.29c0,1.61-0.25,3.18,0.06,4.61c0.44,1.98-0.79,3.3-1.41,4.84 c-0.37,0.91-1.12,1.68-1.74,2.48c-0.65,0.86-1.47,1.62-1.97,2.56c-1.056,1.961-2.123,3.875-3.665,5.518 c-0.045,0.048-0.085,0.103-0.115,0.162c-0.62,1.2-1.26,2.38-1.81,3.61c-0.52,1.15-0.65,2.41-1.51,3.5c-0.8,1-1.09,2.41-1.63,3.63 c-0.4,0.91-0.89,1.79-1.23,2.73c-0.65,1.77-0.53,3.74-1.91,5.36c-0.96,1.12-1.31,2.75-2.03,4.1c-0.74,1.37-1.69,2.45-3.49,2.5 c-1.86,0.04-3.37,1.92-3.6,3.77c-0.44,3.62,2.49,5.16,4.33,7.38c0.29,0.36,0.73,0.77,0.74,1.17c0.06,1.95,0,3.9-0.04,5.84 c0,0.27-0.16,0.53-0.27,0.79c-0.22,0.58-0.62,1.14-0.66,1.73c-0.1,1.31-0.05,2.63-0.02,3.94c0,0.38,0.07,0.77,0.19,1.13 c0.27,0.77,0.78,1.51,0.84,2.29c0.15,1.79,0.08,3.6,0.11,5.4c0.01,0.78-0.28,1.79,0.1,2.29c1.42,1.91,0.12,4.44,1.72,6.36 c0.72,0.86,0.64,2.41,0.9,3.65c0.5,2.35,1.18,4.66,1.83,6.96c0.68,2.41,2.51,4.36,2.52,7.02c0,0.81,0.91,1.59,1.32,2.43 c0.52,1.07,0.95,2.19,1.43,3.28c0.11,0.24,0.28,0.45,0.41,0.68c0.56,1,1.12,1.99,1.67,2.99c0.32,0.59,0.48,1.5,0.98,1.75 c1.39,0.69,1.07,2.22,1.83,3.18c0.47,0.6,0.82,1.29,1.25,1.92c0.26,0.37,0.56,0.71,0.83,1.08c0.52,0.72,1.09,1.41,1.54,2.17 c0.52,0.89,1.47,2.02,1.24,2.71c-0.31,0.91-1.5,1.63-2.46,2.18c-1.59,0.9-3.29,1.6-4.94,2.38c-0.45,0.21-0.9,0.41-1.35,0.63 c-0.95,0.47-1.92,0.92-2.85,1.45c-0.71,0.42-1.35,0.98-2.05,1.42c-0.99,0.63-2.06,1.14-3,1.82c-0.81,0.58-1.46,1.39-2.27,1.98 c-0.53,0.4-1.41,0.43-1.81,0.9c-0.87,1.04-1.78,2-2.43,3.31c-0.93,1.85-0.62,3.28,0.36,4.67c0.71,1,1.81,1.7,3.22,1.44 c2.79-0.51,5.68,0.59,8.47-0.8c1.08-0.54,2.59-0.18,3.9-0.27c0.42-0.02,1.09-0.02,1.21-0.26c0.52-1.03,1.44-0.76,2.26-0.9 c1.76-0.28,3.52-0.6,5.28-0.92c0.13-0.02,0.33-0.1,0.37-0.21c0.43-1.07,1.39-0.83,2.22-0.9c0.63-0.06,1.27-0.03,1.88-0.15 c2.21-0.43,4.39-1,6.61-1.36c1.77-0.29,3.57-0.02,5.09,0.93c1.33,0.83,2.43,2.06,4.19,1.92c0.07,0,0.14,0.24,0.25,0.32 c0.96,0.71,1.94,1.41,3.11,2.26c-0.03,0.78,0.72,2.01-0.9,2.62c-0.11,0.05-0.12,0.35-0.21,0.52c-0.68,1.31-1.35,2.63-2.06,3.93 c-0.41,0.75-0.86,1.47-1.32,2.17c-0.52,0.79-1.16,1.5-1.6,2.33c-0.46,0.86-0.7,1.84-1.11,2.73c-0.56,1.22-1.46,2.35-1.74,3.63 c-0.31,1.34-0.12,2.81-0.03,4.22c0.08,1.17,0.87,1.95,2,2.03c1.38,0.09,2.83,0.58,4.1-0.64c0.75-0.73,1.82-1.11,2.66-1.76 c0.66-0.5,1.45-1.08,1.73-1.8c0.87-2.3,2.93-3.51,4.48-5.18c0.47-0.51,1.29-0.68,1.83-1.15c1.39-1.22,2.56-2.77,4.1-3.71 c1.46-0.88,3.26-1.31,4.97-1.65c1.24-0.24,2.38,0.18,3.64,0.89c2.31,1.31,5.28,0.57,7.75,2.06c1.12,0.68,2.84,0.67,4.2,0.82 c2.23,0.25,4.29,0.73,6.53,1.79c-0.24,0.43-0.46,0.94-0.77,1.4c-0.4,0.57-0.99,1.05-1.28,1.67c-0.79,1.67-1.35,3.39-1.07,5.31 c0.19,1.25,2.23,3.39,3.42,3.12c1.23-0.27,2.54-0.81,3.48-1.62c1.48-1.28,2.63-2.93,4.01-4.33c1.1-1.12,2.36-2.08,3.53-3.12 c0.71-0.64,1.3-1.64,2.12-1.89c1.76-0.52,3.64-0.61,5.45-0.97c1.79-0.35,3.55,0.17,5.46-0.91c1.89-1.06,4.51-0.98,6.82-1.09 c2.82-0.13,2.63-0.62,2.63,2.59c0,57.42,0.02,114.83-0.06,172.25c0,4.23,0.83,8.54-0.79,12.73c-0.62,1.6-0.25,3.38-1,5.17 c-0.81,1.94-0.89,4.43-1.01,6.62c-0.34,6.56-0.12,13.14-0.11,19.72c0,0.48-0.12,1.18,0.15,1.41c1.43,1.27-0.05,3.62,1.8,4.67 c0.34,3.04,0.98,6.08,0.99,9.12c0.06,52.79,0.04,105.58,0.04,158.37c0,3.16,0,6.33-0.03,9.49c0,0.57-0.12,1.14-0.26,1.69 c-0.19,0.72-0.64,1.41-0.66,2.11c-0.11,3.56-0.11,7.11-0.16,10.67c-0.01,0.42-0.1,0.85-0.21,1.27c-0.2,0.8-0.52,1.58-0.66,2.4 c-0.17,0.95-0.16,1.93-0.31,2.89c-0.16,1.01-0.64,2.01-0.6,2.99c0.16,3.93,0.47,7.84,0.73,11.76c0.01,0.09,0.01,0.19,0.03,0.29 c0.02,0.09,0.03,0.25,0.09,0.26c1.53,0.52,1.01,1.83,1.01,2.84c0.04,8.82,0.12,17.63-0.03,26.45c-0.05,2.65,0.87,5.42-0.97,8.02 c-0.8,1.12-0.72,2.87-1.05,4.32c-0.05,0.23-0.17,0.43-0.26,0.64c-0.55,1.3-1.35,2.55-1.59,3.9c-0.47,2.59-1.33,5.12-1.07,7.86 c0.22,2.37-0.05,4.78,0.08,7.16c0.1,1.83,0.58,3.64,0.72,5.47c0.11,1.56-0.68,2.28-2.23,2.29c-2.87,0.02-5.74-0.01-8.61,0.03 c-0.6,0.01-1.54,0.04-1.74,0.4c-0.54,0.93-1.29,0.71-2.03,0.74c-1.89,0.09-3.92-0.26-5.63,0.33c-1.64,0.56-3.18,0.44-4.77,0.55 c-0.77,0.05-1.56,0-2.33,0.04c-0.39,0.03-0.99,0.03-1.1,0.25c-0.72,1.33-1.93,0.77-2.95,0.89c-0.68,0.07-1.56-0.12-1.99,0.24 c-1.51,1.3-3.91-0.13-5.14,1.79c-2.12-0.02-4.15,0.22-6.23,0.82c-1.96,0.56-2.12,0.32-2.18,2.44c-0.01,0.34-0.01,0.69,0,1.03 c0.06,1.68,2.24,2.98,3.84,2.46c2.01-0.65,4.08-1.5,6.15-1.56c7.1-0.21,14.21-0.12,21.31-0.12c0.47-0.01,0.99,0.07,1.4,0.28 c1.67,0.85,3.32,1.62,5.27,1.47c0.64-0.05,1.32,0.15,1.95,0.35c0.64,0.19,1.22,0.71,1.84,0.75c3.19,0.16,3.22,0.16,3.33,3.45 c0.02,0.47,0.05,1.22,0.31,1.34c2.07,0.98,1.89,2.8,1.64,4.51c-0.1,0.64-0.81,1.33-1.41,1.69c-0.29,0.17-1-0.36-1.53-0.56 c-0.43-0.16-0.87-0.4-1.32-0.42c-1.21-0.07-2.43-0.01-3.65-0.06c-0.4-0.01-0.97-0.03-1.18-0.29c-1.01-1.21-2.46-2.07-2.96-3.72 c-0.12-0.39-0.73-0.77-1.18-0.88c-0.64-0.15-1.36,0-2.03-0.08c-3.01-0.39-4.31,2.14-4.4,4.43c-0.18,4.77-0.13,9.54-0.14,14.31 c-0.01,2.82,2.03,4.69,4.86,4.52c0.33-0.03,0.71,0,1-0.14c0.39-0.2,0.79-0.49,1.05-0.84c0.57-0.81,0.87-2.08,1.62-2.43 c1.73-0.79,3.65-1.22,5.52-1.65c1.12-0.26,2.33-0.11,3.44-0.37c0.5-0.12,0.83-1.12,1.47-0.21c0.36,0.51,0.86,1.02,0.95,1.59 c0.16,0.95,0.03,1.94,0.06,2.91c0.02,0.73-0.3,1.6,0.72,2.02c0.1,0.04,0.07,0.87-0.06,0.92c-0.9,0.37-1.84,0.86-2.77,0.87 c-4.38,0.09-8.76-0.08-13.14,0.08c-4.25,0.15-8.48,0.6-12.73,0.93c-0.14,0.01-0.29,0.04-0.42,0.1c-0.18,0.06-0.46,0.13-0.49,0.24 c-0.27,1.05-1.1,0.74-1.78,0.78c-1.26,0.07-2.71-0.25-3.73,0.27c-1.56,0.79-3.07,0.49-4.61,0.6c-0.83,0.06-1.66-0.02-2.48,0.05 c-0.46,0.04-0.92,0.23-1.36,0.4c-0.57,0.22-1.11,0.68-1.66,0.69c-5.74,0.12-11.48,0.25-17.22,0.19c-2.94-0.03-5.8,0.32-8.66,0.89 c-1.92,0.38-3.87,0.56-5.81,0.84c-0.14,0.02-0.37,0.03-0.41,0.11c-0.64,1.38-1.89,0.79-2.91,0.91c-0.67,0.07-1.58-0.17-1.99,0.19 c-1.16,1-2.45,0.58-3.69,0.69c-0.83,0.07-1.68,0-2.47,0.2c-0.46,0.12-0.79,0.86-1.24,0.91c-2.91,0.37-5.84,0.62-8.76,0.91 c-0.15,0.01-0.35-0.02-0.43,0.06c-0.65,0.68-1.53,1.29-1.85,2.11c-0.31,0.78,0.21,1.51,0.84,2.36c1.3,1.76,2.87,2,4.54,1.69 c2.76-0.49,5.54,0.64,8.38-0.92c1.96-1.08,4.67-0.8,7.06-1.06c1.06-0.12,2.14-0.03,3.21-0.09c0.36-0.02,0.71-0.16,1.05-0.3 c0.57-0.23,1.13-0.71,1.7-0.71c7.2-0.09,14.42,0.25,21.57-0.98c0.95-0.16,1.86-0.79,2.8-0.8c8.27-0.06,16.54-0.03,24.81-0.02 c0.44,0,1.03-0.11,1.28,0.12c1.16,1.09,2.55,0.69,3.86,0.72c2.62,0.06,5.26-0.04,7.88,0.09c3.92,0.2,7.83,0.57,11.75,0.79 c0.98,0.06,1.1,0.61,1.1,1.33c0.03,2.39,0.05,4.78,0.05,7.16c-0.01,2.02-1.87,3.14-3.77,2.39c-0.95-0.37-1.99-0.7-2.98-0.7 c-10.76-0.06-21.51-0.02-32.27-0.07c-1.58-0.01-3.37,0.66-4.65-0.97c-0.08-0.09-0.27-0.11-0.41-0.13 c-2.93-0.32-5.86-0.62-8.79-0.95c-0.4-0.04-0.8-0.18-1.18-0.33c-0.57-0.24-1.13-0.77-1.69-0.77c-7.35-0.03-14.69,0-22.04,0.04 c-0.95,0-2.27,1.35-2.31,2.29c-0.03,0.86-0.1,1.62,1.01,2.08c0.65,0.27,0.96,1.53,1.59,1.68c1.92,0.48,3.91,0.63,5.87,0.93 c1.04,0.15,2.37-0.55,2.94,1.01c0.04,0.1,0.36,0.11,0.55,0.12c3.51,0.33,7.01,0.67,10.52,0.95c1.16,0.1,2.34,0.02,3.5,0.08 c0.4,0.02,0.79,0.25,1.19,0.39c0.5,0.18,1.01,0.52,1.52,0.53c2.43,0.06,4.86,0.01,7.3,0.06c0.65,0.01,1.3,0.23,1.94,0.4 c0.48,0.13,0.93,0.46,1.4,0.46c7.84,0.09,15.67,0.05,23.5,0.23c5.81,0.13,11.61,0.48,17.4,0.86c0.64,0.05,1.54,0.85,1.76,1.49 c0.49,1.43,1.55,2.76,1.15,4.45c-0.06,0.27,0.33,0.63,0.48,0.97c0.55,1.25,1.09,2.51,1.63,3.77c-0.137,0.184-0.17,0.23-0.307,0.414 c-0.944-0.093-1.899-0.132-2.823-0.294c-0.59-0.1-1.13-0.53-1.7-0.54c-6.96-0.1-13.91-0.14-20.87-0.22 c-1.08-0.01-2.29,0.4-3.09-0.88c-0.16-0.27-0.9-0.25-1.38-0.26c-1.6-0.03-3.21-0.01-4.82-0.01c-0.33-0.01-0.83,0.09-0.99-0.09 c-0.91-1.09-2.14-0.72-3.26-0.77c-1.26-0.05-2.53,0.01-3.79-0.02c-0.36-0.01-0.72-0.14-1.05-0.29c-0.58-0.25-1.11-0.75-1.7-0.82 c-2.88-0.32-5.74-0.13-8.66-0.74c-3.27-0.68-6.78-0.21-10.19-0.18c-0.48,0-1.14,0.2-1.4,0.55c-0.9,1.21,0.09,4.17,1.51,4.44 c2.01,0.39,4.05,0.6,6.08,0.87c0.72,0.1,1.84-0.1,2.09,0.29c0.78,1.21,1.85,0.74,2.83,0.84c0.92,0.1,2.04-0.16,2.7,0.29 c1.05,0.71,2.08,0.6,3.16,0.65c1.06,0.05,2.18-0.07,3.19,0.21c1.63,0.45,3.16,1.3,4.8,1.72c1.71,0.45,3.48,0.08,5.27,1.06 c1.43,0.78,3.44,0.32,5.23,0.91c2.13,0.71,4.5-0.02,6.83,0.88c2.46,0.95,5.22,0.01,8.01,1.07c3.13,1.19,6.86,0.81,10.33,1.12 c0.57,0.05,1.18,0.03,1.68,0.26c0.64,0.3,1.17,0.82,1.75,1.24c0.15-0.02,0.31-0.05,0.46-0.08c-0.1,1.18,0.17,2.59-0.39,3.5 c-0.86,1.38-2.53,1.97-4.19,2.02c-3.25,0.08-6.51,0.02-9.76,0.07c-1.86,0.03-2.68,0.94-2.66,2.81c0.01,0.93,1.47,3.14,2.4,3.36 c1.65,0.4,3.33,0.82,5.01,0.9c3.06,0.14,6.13,0.03,9.19,0.05c1.58,0,2.3,0.73,2.31,2.34c0.02,3.12,0.22,6.25-0.07,9.34 c-0.2,2.13,1.22,2.97,2.27,4.19c0.09,0.1,0.56,0.01,0.73-0.14c0.99-0.82,1.37-1.83,1.28-3.18c-0.06-1.03,0.45-2.08,0.6-3.13 c0.26-1.95-0.25-4.06,1.26-5.73c0.28-5.74,0.56-11.48,0.85-17.22c0.04-0.83,0.14-1.66,0.12-2.48c-0.08-3.46,0.65-6.86,0.83-10.28 c0.13-2.46-0.51-4.96-0.75-7.44c-0.12-1.26,0.28-2.76-0.28-3.74c-0.87-1.54-0.47-3.05-0.63-4.58c-0.05-0.53,0.01-1.07-0.06-1.6 c-0.05-0.37-0.12-0.96-0.36-1.06c-0.97-0.44-0.73-1.24-0.75-1.98c-0.04-1.8,0.39-3.78-0.24-5.34c-0.66-1.64-0.54-3.17-0.62-4.76 c-0.07-1.22-0.02-2.44-0.04-3.65c-0.01-0.44,0.04-1.1-0.2-1.26c-1.41-0.94-0.74-2.36-0.95-3.57c-0.24-1.44-0.63-2.87-0.69-4.32 c-0.07-1.59-0.67-3.32,0.58-4.74c0.21-0.24,0.92-0.42,1-0.32c0.42,0.54,0.88,1.15,1.01,1.8c0.31,1.52-0.14,3.06,1.03,4.58 c1.02,1.3,1.22,3.22,1.85,4.85c0.34,0.86,0.86,1.64,1.25,2.49c0.27,0.58,0.43,1.22,0.69,1.82c0.46,1.07,0.96,2.13,1.45,3.19 c0.52,1.12,1.04,2.24,1.56,3.35c0.41,0.87,1.05,1.69,1.2,2.59c0.41,2.58,0.73,5.18,0.87,7.78c0.17,3.21,0.12,6.43,0.19,9.64 c0.01,0.43-0.01,1.08,0.24,1.23c1.04,0.66,0.84,1.66,0.91,2.6c0.27,3.54-0.37,7.08,0.66,10.64c0.5,1.72,1.74,2.57,2.66,3.79 c0.16,0.21,0.75,0.19,1.12,0.12c0.62-0.12,2.42-2.53,2.46-3.18c0.51-8.75-0.35-17.53,0.71-26.29c0.41-3.38-0.31-6.91-0.58-10.36 c-0.09-1.15,0.49-2.57-1.1-3.24c-0.11-0.04-0.11-0.35-0.13-0.54c-0.3-2.81-0.59-5.62-0.9-8.42c-0.05-0.47-0.11-1.21-0.38-1.33 c-1.02-0.43-0.73-1.26-0.78-1.97c-0.08-1.11,0.3-2.53-0.25-3.27c-0.83-1.1-0.52-2.02-0.49-3.05c1.99-0.43,3.75-1.81,5.74-0.95 c0.39,2.88,0.85,5.69,1.14,8.52c0.23,2.29,1.01,4.26,2.89,5.63c0.45,0.33,1.22,0.47,1.77,0.35c0.76-0.15,1.45-0.63,2.3-1.03 c0-2.53-0.02-5.15,0.02-7.78c0.01-0.86-0.14-1.96,0.31-2.53c0.91-1.16,0.53-1.98-0.12-2.77c0.48-1.75,1.76-1.6,3.07-1.64 c6.71-0.25,13.42-0.57,20.13-0.87c0.19,0,0.39-0.03,0.58-0.06c2.915-0.587,5.795-1.362,8.816-1.146 c1.388,0.099,2.779,0.185,4.166,0.067c1.583-0.135,3.2,0.101,4.658-0.921c0.97-0.68,1.69-1.88,1.18-3.28 c-0.25-0.68-1.16-1.55-1.81-1.58c-5.95-0.3-11.92-0.12-17.83-1.11c-0.37-0.06-0.98-0.04-1.06-0.23c-0.47-1.12-1.42-0.85-2.25-0.88 c-1.79-0.07-3.78,0.4-5.34-0.22c-1.54-0.62-2.97-0.51-4.46-0.69c-4.45-0.53-9.09,1.2-13.37-1.14c-0.57-0.31-1.22-0.55-1.66-0.99 c-1.16-1.18-2.18-2.5-3.35-3.68c-1.89-1.9-3.88-3.71-5.77-5.62c-1.11-1.1-1.9-2.74-3.21-3.36c-1.71-0.81-2.94-1.96-4.27-3.2 c-1.45-1.36-3.25-2.35-5.13-3.67v-1.37c2.39,0.23,4.78-0.38,6.81,1.6c0.74,0.73,2.1,1.17,3.17,1.15c2.07-0.06,2.81-1.1,2.83-3.22 c0.012-1.029,0.105-2.072-0.135-3.065c-0.126-0.522-0.594-1.242-0.983-1.612c-0.994-0.944-2.204-1.718-2.982-2.803 c-1.18-1.62-2.71-2.7-4.3-3.8c-0.66-0.45-1.27-1.04-1.77-1.68c-0.62-0.77-1.01-1.75-1.67-2.48c-0.7-0.79-1.07-1.55-1.07-2.66 c0.04-25.52,0.02-51.03,0.09-76.55c0.01-2.45,0.54-4.89,0.86-7.33c0.02-0.2,0.28-0.36,0.38-0.56c0.51-1.02,1.37-2.03,1.42-3.07 c0.2-4.67,0.37-9.36,0.15-14.02c-0.23-4.6,0.89-9.24-0.91-13.86c-0.97-2.5-0.76-5.45-1.08-8.2c-0.06-0.53-0.12-1.06-0.22-1.59 c-0.17-0.92-0.53-1.84-0.54-2.75c0-1.6-0.1-3.16,0.52-4.8c0.54-1.42,0.41-3.2,0.21-4.77c-0.37-2.8,0.82-5.35,0.97-8.05 c0.01-0.14,0.05-0.36,0.14-0.4c1.26-0.61,0.84-1.8,0.99-2.79c0.06-0.43-0.11-1.04,0.12-1.27c1.46-1.45,0.73-3.5,1.61-5.25 c1.1-2.2-0.12-5.19,1.07-7.68c0.04-9.5,0.1-18.99,0.12-28.49c0-1.74,0.34-3.72-0.35-5.18c-0.85-1.83-0.55-3.56-0.74-5.33 c-0.04-0.36-0.16-0.73-0.31-1.07c-0.25-0.56-0.68-1.08-0.79-1.67c-0.37-2.01-0.64-4.05-0.95-6.07 c-0.018-0.064-0.035-0.126-0.053-0.19c-0.547-1.29-1.442-2.513-1.707-3.87c-0.47-2.46-0.88-4.98-0.88-7.47 c-0.04-51.72-0.02-103.44-0.05-155.15c0-2.24,0.68-3.89,2.54-5.13c0.81-0.53,1.5-1.26,2.19-1.96c1.11-1.12,2.13-2.32,3.27-3.39 c0.39-0.36,1.19-0.28,1.57-0.64c1.32-1.26,2.51-2.66,3.81-3.95c1.03-1.02,2.18-1.94,3.2-2.97c1.34-1.36,2.58-2.82,3.92-4.18 c1.21-1.22,2.62-2.26,3.72-3.58c1.17-1.4,2.28-2.77,4.14-3.27c0.14-0.04,0.24-0.28,0.35-0.43c1.26-1.87,1.11-3.98,0.97-6.07 c-0.02-0.38-0.44-0.97-0.78-1.06c-2.42-0.64-4.68,0.12-6.93,0.92c-0.29,1.52-1.89,1.12-2.8,1.7c-1.15,0.74-2.85,0.01-4.3,1.16 c-0.88,0.7-2.61,0.58-3.96,0.92c-1.74,0.44-3.32,1.03-4.92,2.07c-0.1-0.55-0.25-1.01-0.25-1.47c0-2.48-0.03-4.97,0.07-7.45 c0.23-5.62,0.14-11.24,0.73-16.88c0.56-5.39-0.01-10.89-0.04-16.34c-0.03-6.04,0.03-12.08-0.03-18.12 c-0.03-2.15,0.05-4.26-0.48-6.46c-0.76-3.17-0.78-6.51-1.2-9.77c-0.11-0.84-0.54-1.64-0.8-2.46c-0.06-0.22-0.15-0.54-0.04-0.67 c0.72-0.89,1.46-1.75,2.24-2.59c1.82-1.97,3.8-3.81,5.45-5.92c1.33-1.69,2.58-3.28,4.76-3.9c0.76-0.21,1.55-0.62,2.13-1.15 c1.19-1.11,2.12-2.36,3.81-3.06c1.74-0.72,3.12-2.32,4.64-3.56c0.41-0.33,0.73-0.78,1.16-1.07c2.04-1.42,4.11-2.79,6.15-4.21 c0.29-0.2,0.44-0.61,0.73-0.8c1.46-0.91,3.01-1.69,4.41-2.68c1.16-0.81,2.17-1.83,3.2-2.8c0.46-0.44,0.86-0.97,1.18-1.51 c0.4-0.68,0.54-1.55,1.06-2.09c1.159-1.21,1.822-2.544,1.82-4.222c0-0.258,0.046-0.516,0.159-0.747c0.97-1.97,2.06-3.9,2.95-5.92 c1.15-2.6,2.08-5.3,3.24-7.89c1.04-2.33,2.44-4.52,3.34-6.89c0.61-1.59,1.59-2.02,3.03-2.03c3.99-0.03,7.99-0.22,11.96,0.02 c2.25,0.14,3.79-1.49,5.85-1.66c0.717-0.051,1.424-0.522,2.077-0.886c0.846-0.472,1.672-0.976,2.476-1.516 c0.646-0.434,1.381-0.838,1.917-1.398C230.441,131.98,230.311,130.27,230.071,128.64z M111.437,192.42 c-46.57,0-84.32-37.75-84.32-84.32c0-46.56,37.75-84.31,84.32-84.31c46.56,0,84.31,37.75,84.31,84.31 C195.747,154.67,157.997,192.42,111.437,192.42z"
    ],
    clocks: {
      size: 169,
      0: { x: 111.011, y: 108.5 }
    }
  },
  2: {
    height: 625.438,
    width: 197.009,
    path: "M193.86,271.21c-2.234-2.626-5.64-4.792-8.929-5.835c-6.793-2.153-11.841,2.196-17.463,7.369 c-5.009-25.727-17.583-43.987-38.477-54.246l-18.909-21.56v-12l20.773-23.686c19.55-10.446,31.402-28.304,36.229-53.096 c5.622,5.174,10.67,9.523,17.463,7.369c3.289-1.043,6.695-3.208,8.929-5.835c4.877-5.734,3.879-14.302-1.542-19.605 c-6.442-6.301-13.569-5.549-24.852,3.382c-4.816-25.231-17.183-43.587-38.409-54.031h0.158c-1.506-0.732-3.056-1.394-4.625-2.025 c-2.997-1.25-6.144-2.365-9.463-3.327c0,0-0.527-0.089-1.457-0.217c-2.421-0.731-4.757-2.02-7.743-3.273 c2.103-2.282,3.255-3.455,4.321-4.703c5.176-6.057,4.821-14.978-0.792-20.538c-5.647-5.594-14.543-5.829-20.352-0.539 c-6.101,5.556-6.808,14.49-1.648,20.831c4.153,5.103,3.905,5.403-2.49,8.055c-1.793,0.744-3.604,1.465-5.417,2.187 c-10.281,3.032-16.092,6.929-22.875,12.001c-12.415,9.284-19.739,22.385-23.521,37.515c-0.673,2.693-2.08,5.2-3.437,8.492 c-2.262-2.122-3.424-3.284-4.661-4.36c-6.003-5.222-14.845-4.864-20.356,0.799c-5.544,5.698-5.778,14.673-0.534,20.534 c5.507,6.156,14.361,6.869,20.646,1.662c5.058-4.19,5.355-3.94,7.984,2.512c3.394,8.33,6.292,17.054,10.972,24.62 c6.032,9.752,14.303,16.873,24.096,21.915l21.601,23.357v12l-20.223,21.867c-10.232,5.068-18.855,12.348-25.091,22.43 c-4.68,7.566-7.578,16.29-10.972,24.62c-2.629,6.452-2.926,6.702-7.984,2.512c-6.285-5.206-15.139-4.493-20.646,1.662 c-5.243,5.861-5.01,14.837,0.534,20.534c5.511,5.663,14.352,6.021,20.356,0.799c1.237-1.076,2.399-2.238,4.661-4.36 c1.356,3.292,2.764,5.799,3.437,8.492c3.782,15.13,11.106,28.232,23.521,37.515c7.877,5.89,14.425,10.198,28.206,13.404 c1.38,0.321,2.787,0.579,4.201,0.789c0.031,27.796,0.06,69.604,0.085,105.236c0.009,13.829,0.018,26.73,0.026,37.518 c0,0.826-0.08,1.652-0.121,2.436c-3.447,0.597-4.58-0.495-4.682-4.511c-0.072-2.822-0.002-5.649-0.016-8.473 c-0.024-4.802-0.891-5.97-4.609-5.976c-14.432-0.022-28.864-0.01-43.295-0.009c-4.627,0-9.255,0.084-13.881-0.022 c-3.054-0.07-4.428,1.698-4.326,5.623c0.079,3.039,0.085,6.08-0.001,9.119c-0.111,3.933,1.27,5.674,4.317,5.646 c8.372-0.076,16.745-0.038,25.118-0.024c4.14,0.007,4.933,1.055,4.947,6.397c0.024,9.702,0.024,9.702-7.67,9.702 c-7.381-0.001-14.762-0.025-22.143,0.006c-3.558,0.015-4.54,1.209-4.551,5.611c-0.035,13.947-0.943,13.109,10.004,13.035 c6.61-0.045,13.22-0.032,19.83,0.002c3.528,0.018,4.463,1.226,4.534,5.638c0.17,10.455,0.17,10.455-8.056,10.455 c-7.271,0-14.542-0.024-21.813,0.01c-3.492,0.016-4.48,1.263-4.503,5.672c-0.067,12.642-0.701,12.243,9.397,12.129 c6.83-0.077,13.661-0.04,20.491-0.004c3.466,0.018,4.419,1.281,4.484,5.702c0.154,10.39,0.154,10.39-8.106,10.39 c-7.271,0-14.542-0.026-21.813,0.01c-3.447,0.017-4.439,1.296-4.452,5.736c-0.039,13.671-0.908,12.955,9.772,12.916 c17.076-0.063,34.152-0.012,51.227-0.02c4.329-0.002,5.098-1.02,5.1-6.63c0.001-1.977-0.037-3.956,0.007-5.931 c0.094-4.282,1.178-5.371,4.197-4.937c1.031,10.07,1.909,19.99,3.129,29.842c0.425,3.429,1.312,6.98,2.695,9.93 c1.2,2.56,3.388,5.993,5.16,6.013c1.744,0.02,4.469-3.383,5.098-5.954c2.029-8.292,4.037-16.802,4.667-25.395 c0.85-11.612,0.501-23.379,0.517-35.079c0.042-30.977,0.078-68.798,0.115-106.572c0.037-37.246,0.075-74.445,0.121-104.988 c3.105-0.304,5.045-0.635,5.045-0.635c29.872-8.658,46.55-29.062,52.338-59.383c11.283,8.931,18.409,9.683,24.852,3.382 C197.739,285.512,198.737,276.945,193.86,271.21z M44.186,100.381c0-29.823,24.177-54,54-54s54,24.177,54,54 c0,29.823-24.177,54-54,54S44.186,130.205,44.186,100.381z M98.186,334.381c-29.823,0-54-24.177-54-54c0-29.823,24.177-54,54-54 s54,24.177,54,54C152.186,310.205,128.009,334.381,98.186,334.381z",
    clocks: {
      size: 108,
      0: { x: 98.579, y: 280 },
      1: { x: 98.579, y: 100 }
    }
  },
  3: {
    height: 915.936,
    width: 277.634,
    path: "M263.752,257.836c-13.719,1.508,3.345-15.515,3.955-23.109l-0.113,0.113 c8.127-22.574,2.75-46.079-10.802-65.608c14.365-1.735,19.981-6.287,20.122-15.339c0.118-7.617-5.228-14.388-12.762-14.963 c-3.451-0.263-7.412,0.636-10.496,2.245c-6.369,3.324-6.896,10.001-7.248,17.67c-12.146-8.157-24.329-12.988-36.575-14.34 c-2.94-2.54-4.264-6.236-3.879-10.997c0.451-5.587,0.239-11.066-0.572-16.359c0.828-2.872,1.549-5.847,2.156-8.934 c5.672,5.174,10.766,9.523,17.62,7.369c3.319-1.043,6.755-3.208,9.009-5.835c4.921-5.734,3.914-14.302-1.556-19.605 c-6.5-6.301-13.69-5.549-25.075,3.382c-5.055-30.578-25.967-51.62-54.619-60.047c-2.447-0.732-4.807-2.023-7.825-3.278 c2.125-2.286,3.29-3.461,4.367-4.71c11.938-14.551-7.15-33.181-21.367-21.111c-6.165,5.565-6.879,14.513-1.665,20.864 c4.197,5.111,3.946,5.411-2.516,8.068c-1.812,0.745-3.642,1.467-5.474,2.19c-24.645,7.648-40.948,25.21-46.886,49.595 c-0.68,2.698-2.102,5.208-3.473,8.505c-2.286-2.125-3.461-3.29-4.71-4.367c-14.552-11.938-33.18,7.152-21.111,21.367 c5.565,6.165,14.513,6.879,20.864,1.665c4.71-3.867,5.338-3.944,7.487,1.123c-1.309,6.465-1.74,13.174-1.396,20.102 c0.3,6.03-1.497,10.097-5.356,12.617c-8.889,2.044-17.148,6.132-25.567,9.656c-6.448,2.691-6.837,2.656-7.484-3.926 c-0.804-8.178-7.636-14-15.931-13.576c-18.581,1.516-18.918,28.187-0.181,30.036c1.645,0.122,3.299,0.129,6.419,0.243 c-1.366,3.319-2.113,5.992-3.558,8.47c-3.428,5.74-6.123,11.683-7.912,17.811c-4.722,16.154-2.533,34.602,5.996,50.411 c1.801,5.691,8.569,13.392-1.603,12.903c-40,12.971,18.416,54.114,16.704,9.691c34.782,3.225,46.692,41.92,80.447,49.674 c7.963,2.791,11.179,6.671,12.046,13.724c0.012,3.241,0.01,6.503,0,9.829h-0.223c0,2.086,0,5.309,0,5.309s0.065,0.184-0.069,0.268 c-7.211-0.002-14.005-0.041-20.79,0.015c-4.483,0.037-6.154,1.09-6.592,4.667c-0.352,4.638-0.043,9.45-0.131,14.122 c0.062,5.274,1.49,6.69,6.861,6.724c6.999,0.045,13.998,0.011,21.721,0.011v5.671c-7.723,0-14.722-0.034-21.721,0.011 c-5.372,0.035-6.799,1.45-6.861,6.724c0.087,4.671-0.221,9.484,0.131,14.122c0.438,3.577,2.109,4.63,6.592,4.667 c6.785,0.056,13.579,0.017,20.79,0.015c0.134,0.084,0.279,0.175,0.069,0.268v5.406h0.599c0.031,3.784,0.031,7.619,0,12h-0.599 v4.809c0,0,0.065,0.184-0.069,0.268c-7.211-0.002-14.005-0.041-20.79,0.015c-4.483,0.037-6.154,1.09-6.592,4.667 c-0.352,4.638-0.043,9.45-0.131,14.122c0.062,5.274,1.49,6.69,6.861,6.724c6.999,0.045,13.998,0.011,21.721,0.011v5.671 c-7.723,0-14.722-0.034-21.721,0.011c-5.372,0.035-6.799,1.45-6.861,6.724c0.087,4.671-0.221,9.484,0.131,14.122 c0.438,3.577,2.109,4.63,6.592,4.667c6.785,0.056,13.579,0.017,20.79,0.015c0.134,0.084,0.279,0.175,0.069,0.268v4.906h0.599 c0.031,4.284,0.031,8.119,0,12h-0.599v5.309c0.211,0.092,0.065,0.184-0.069,0.268c-7.211-0.002-14.005-0.041-20.79,0.015 c-4.483,0.037-6.154,1.09-6.592,4.667c-0.352,4.638-0.043,9.45-0.131,14.122c0.062,5.274,1.49,6.69,6.861,6.724 c6.999,0.045,21.721,0.011,21.721,0.011v5.671c0,0-14.722-0.034-21.721,0.011c-5.372,0.035-6.799,1.45-6.861,6.724 c0.087,4.671-0.221,9.484,0.131,14.122c0.438,3.577,2.109,4.63,6.592,4.667c6.785,0.056,13.579,0.017,20.79,0.015 c0.134,0.084,0.279,0.175,0.457,0.268c0,1.594,4.559,168.228,4.51,209.286c-0.005,4.1,0.442,9.128,0.442,10.259 c-3.396,0-6.234,0.133-9.054-0.034c-3.499-0.206-5.37,1.456-6.735,4.558c-1.281,2.913-2.803,5.866-4.843,8.27 c-6.58,7.751-16.578,7.84-23.206,0.144c-2.209-2.565-3.736-5.81-5.169-8.932c-1.239-2.699-2.939-4.083-5.916-4.024 c-3.712,0.073-7.428,0.078-11.14-0.009c-3.163-0.074-4.936,1.432-6.143,4.306c-1.141,2.716-2.476,5.469-4.285,7.764 c-8.725,11.281-23.01,6.923-27.966-5.357c-1.496-5.628-5.039-7.274-10.521-6.767c-4.485,0.415-6.285,1.937-6.286,6.612 c-0.001,15.755-0.002,31.511-0.003,47.266c-0.001,16.376-0.012,32.752,0.006,49.127c0.004,3.646,2.039,5.706,5.586,5.765 c4.244-0.151,7.724,1.078,9.747-3.72c1.63-3.566,3.31-7.297,5.811-10.239c5.927-6.969,15.25-7.396,21.596-0.827 c2.91,3.012,4.885,7.078,6.716,10.936c1.245,2.623,2.748,3.896,5.573,3.857c3.96-0.055,7.925-0.102,11.882,0.027 c3.041,0.099,4.629-1.359,5.914-4.011c1.386-2.861,3.016-5.766,5.166-8.063c10.107-10.412,22.254-3.718,27.139,8.037 c1.337,2.907,3.18,4.141,6.281,4.034c3.442-0.119,6.891-0.027,10.523-0.027c1.065,5.652,2.167,11.021,3.856,16.453 c1.228,3.675,2.407,8.536,7.056,8.594c4.923,0.061,6.042-4.987,7.307-8.743c1.456-4.322,2.867-8.847,3.125-13.35 c0.728-12.721,1.152-25.477,1.174-38.219c0.19-111.404,0.292,50.177,0.366-61.227c0.003-5.129,0.201-18.49,0.201-22.46 c0-41.693,4.098-203.286,4.098-209.558c8.112,0,15.82-0.053,23.528,0.021c5.544,0.13,6.64-3.323,6.288-8.201 c0.033-3.547,0.038-7.095-0.007-10.642c-0.066-5.278-1.476-6.669-6.885-6.701c-7.529-0.044-23.121-0.011-23.121-0.011v-5.671 c0,0,15.592,0.033,23.121-0.011c5.408-0.032,6.819-1.423,6.885-6.701c0.044-3.547,0.04-7.095,0.007-10.642 c0.351-4.882-0.742-8.33-6.288-8.201c-7.707,0.073-15.416,0.021-22.724,0.021v-22.76c7.308,0,15.017-0.053,22.724,0.021 c5.544,0.13,6.64-3.323,6.288-8.201c0.033-3.547,0.038-7.095-0.007-10.642c-0.066-5.278-1.476-6.669-6.885-6.701 c-7.529-0.044-15.059-0.011-23.121-0.011v-5.671c8.062,0,15.592,0.033,23.121-0.011c5.408-0.032,6.819-1.423,6.885-6.701 c0.044-3.547,0.04-7.095,0.007-10.642c0.351-4.882-0.742-8.33-6.288-8.201c-7.707,0.073-15.416,0.021-22.724,0.021v-22.76 c7.308,0,15.017-0.053,22.724,0.021c5.544,0.13,6.64-3.323,6.288-8.201c0.033-3.547,0.038-7.095-0.007-10.642 c-0.066-5.278-1.476-6.669-6.885-6.701c-7.529-0.044-15.059-0.011-23.121-0.011v-5.671c8.062,0,15.592,0.033,23.121-0.011 c5.408-0.032,6.819-1.423,6.885-6.701c0.044-3.547,0.04-7.095,0.007-10.642c0.351-4.882-0.742-8.33-6.288-8.201 c-7.707,0.073-15.416,0.021-22.724,0.021v-13.831c0.379-7.638,5.186-13.149,13.162-15.825 c28.456-7.104,41.808-33.352,64.888-48.287c17.492-10.743,9.354,22.937,28.518,19.129 C282.127,286.309,282.455,259.681,263.752,257.836z M105.697,839.074c0.498,2.38,0.15,4.934-3.302,4.884 c-2.295-0.033-3.176,1.042-3.702,3.217c-0.26,1.076-1.713,2.383-2.793,2.559c-0.723,0.118-2.36-1.479-2.505-2.467 c-0.409-2.804-2.004-3.344-4.385-3.299c-3.709,0.07-7.424,0.116-11.131-0.006c-3.83-0.126-3.945,2.278-3.981,5.13 c-0.038,2.976,0.755,4.826,4.142,4.589c1.477-0.103,2.968,0.015,4.451-0.025c2.202-0.059,4.543-0.006,4.579,2.901 c0.039,3.187-2.477,3.119-4.78,3.068c-1.36-0.03-2.728,0.082-4.08-0.025c-3.258-0.257-4.5,1.312-4.272,4.425 c-0.041,4.353,1.027,8.028-4.883,7.506c-7.022,0.039-7.951,0.802-7.543-7.405c0.169-3.39-1.192-4.855-4.554-4.524 c-0.857,0.085-1.922,0.329-2.555-0.056c-1.2-0.729-2.156-1.861-3.213-2.825c1.006-1.017,1.944-2.121,3.057-3.004 c0.38-0.301,1.199-0.042,1.817-0.044c5.007-0.022,7.131-2.986,5.196-7.646c-0.392-0.945-1.974-1.785-3.11-1.944 c-3.651-0.437-7.442,0.158-11.117-0.121c-3.786-0.387-5.894,0.721-5.698,5.061c0.045,0.996-1.78,2.077-2.744,3.119 c-0.848-1.038-2.451-2.105-2.412-3.108c0.153-3.932-1.445-5.27-5.269-5.225c-1.017,0.012-2.491-1.899-2.973-3.215 c-0.52-1.421-0.127-3.18-0.126-4.791c0-5.24-0.002-5.268,5.3-5.954c2.366-0.306,3.023-1.787,2.927-3.889 c-0.098-2.143,0.268-4.425,2.848-4.073c1.034,0.141,2.342,2.528,2.49,3.998c0.282,2.788,1.314,4.039,4.131,3.976 c3.956-0.088,7.919-0.125,11.873,0.011c3.063,0.105,4.168-1.204,4.13-4.212c-0.036-2.816-0.326-5.041-3.916-4.755 c-2.559,0.203-4.468-0.474-4.367-3.527c0.095-2.865,2.016-3.344,4.358-3.173c2.898,0.212,3.849-1.243,3.979-4.019 c0.085-1.821,0.73-5.002,1.563-5.153c3.046-0.553,6.308-0.31,9.408,0.165c0.646,0.099,1.284,2.453,1.345,3.795 c0.224,4.967,0.374,5.207,5.401,5.214c1.361,0.002,2.929-0.422,4.027,0.116c1.271,0.623,2.94,2.09,2.942,3.194 c0.002,1.125-1.621,2.815-2.876,3.241c-1.665,0.565-3.667,0.223-5.518,0.132c-3.18-0.157-3.971,1.57-3.952,4.398 c0.019,2.703,0.495,4.64,3.783,4.569c3.956-0.085,7.916-0.055,11.873-0.012c2.165,0.024,3.322-0.763,3.826-3.068 c0.241-1.105,1.771-1.927,2.718-2.877c0.905,0.971,2.333,1.814,2.605,2.939c0.545,2.256,1.757,2.7,3.843,3.111 C108.401,831.102,105.035,835.914,105.697,839.074z M139.108,46c29.823,0,54,24.177,54,54c0,29.823-24.177,54-54,54 s-54-24.177-54-54C85.108,70.176,109.285,46,139.108,46z M19.108,212c0-29.823,24.177-54,54-54s54,24.177,54,54 c0,29.823-24.177,54-54,54S19.108,241.823,19.108,212z M144.944,857.898c-2.09,2.578-1.865,5.176-1.942,7.953 c-0.024,0.854,0.131,1.914-0.302,2.509c-2.403,3.147-3.159,2.809-5.436-0.185c-0.264-0.306-0.178-0.948-0.184-1.437 c-0.041-3.271,0.536-6.657-2.369-9.253c-0.531-0.475-0.479-1.605-0.957-3.425c1.21-1.271,2.47-3.306,4.294-4.333 c2.379-1.339,5.236-0.58,6.441,1.819C145.405,853.367,145.95,856.658,144.944,857.898z M144.996,807.941 c-2.224,2.677-1.877,5.438-1.992,8.318c-0.086,2.146-0.2,4.578-2.99,4.544c-2.765-0.034-2.874-2.475-2.933-4.614 c-0.08-2.895,0.543-5.919-2.179-8.193c-0.631-0.527-0.645-1.797-1.234-3.633c1.265-1.382,2.48-3.465,4.292-4.5 c2.341-1.338,5.233-0.649,6.476,1.731C145.382,803.404,145.991,806.744,144.996,807.941z M80.062,279.694 c17.171-3.582,56.234-25.446,59.296-50.487c5.518,22.114,30,48.729,61,48.729C162.77,319.773,120.431,321.28,80.062,279.694z M205.108,266c-29.823,0-54-24.177-54-54c0-29.823,24.177-54,54-54s54,24.177,54,54C259.108,241.823,234.932,266,205.108,266z",
    clocks: {
      size: 108,
      0: { x: 138.892, y: 100 },
      1: { x: 72.892, y: 212 },
      2: { x: 204.892, y: 212 }
    }
  },
  4: {
    height: 1041,
    width: 368.697,
    path: "M365.949,178.882c-2.159-2.705-5.464-5.038-8.725-6.201c-7.211-2.57-12.634,1.794-18.155,7.261 c-1.008-3.182-1.811-5.292-2.346-7.468c-7.207-29.311-25.676-46.993-55.052-53.142c-3.565-0.746-4.337-2.365-5.721-5.525 c-10.917-24.928-15.917-32.928-31.863-49.408c-1.625-1.679-3.453-3.192-5.144-4.761c-15.909-14.758-20.909-17.758-43.492-26.71 c-1.882-0.746-3.781-1.782-6.866-3.302c2.349-1.876,3.694-2.659,4.662-3.772c4.695-5.397,4.837-13.436,0.452-19.014 c-5.3-6.742-15-7.806-21.456-2.354c-6.714,5.67-7.304,15.417-1.328,21.919c3.617,3.935,3.297,5.361-1.725,7.153 c-2.044,0.73-4.17,1.226-6.237,1.896c-12.766,4.137-23.255,11.604-31.918,21.798c-2.372,2.791-4.778,5.622-7.539,8.002 c-15.564,13.413-26.166,29.895-31.108,49.904c-0.68,2.752-1.741,4.084-4.825,4.54c-29.053,4.299-51.461,25.809-57.16,54.556 c-0.307,1.549-0.792,3.062-1.25,4.806c-11.35-8.302-18-8.998-24.401-2.862c-5.321,5.101-6.467,13.398-1.935,19.203 c2.036,2.608,5.192,4.836,8.302,6.005c7.137,2.683,12.59-1.579,17.735-6.353c0.583,1.299,1.01,1.874,1.096,2.496 c4.046,29.315,27.997,53.277,57.825,57.393c2.223,0.307,4.062,1.874,4.644,4.041c1.308,4.861,2.891,9.682,4.787,14.345 c9.432,23.198,28.811,38.203,45.823,55.084c5.104,5.065,11.204,9.197,17.156,13.308c5.563,3.842,7.792,8.391,7.788,15.456 c-0.129,188.254-0.004,308.508,0.065,496.762c0,0.102-0.005,0.205-0.006,0.307v41.241c-2.701,0.026-5.102,0.092-7.461-0.047 c-3.499-0.206-5.37,1.456-6.735,4.558c-1.282,2.913-2.803,5.866-4.844,8.27c-6.581,7.751-16.578,7.84-23.206,0.144 c-2.254-2.617-3.797-5.94-5.255-9.119c-1.087-2.369-3.472-3.882-6.078-3.833c-3.63,0.068-7.263,0.071-10.893-0.013 c-3.163-0.074-4.936,1.432-6.143,4.306c-1.141,2.716-2.476,5.469-4.285,7.764c-8.725,11.281-23.01,6.923-27.966-5.357 c-1.496-5.628-5.039-7.274-10.521-6.767c-4.485,0.415-6.285,1.937-6.286,6.612c-0.001,15.755-0.002,31.511-0.003,47.266 c-0.001,16.376-0.012,32.752,0.006,49.127c0.004,3.646,2.039,5.706,5.586,5.765c4.244-0.151,7.724,1.078,9.747-3.72 c1.63-3.566,3.31-7.297,5.811-10.239c5.927-6.969,15.25-7.396,21.596-0.827c2.91,3.012,4.885,7.078,6.716,10.936 c1.457,3.071,3.269,4.292,7.14,3.723c2.897-0.426,5.844-0.506,8.73-0.009c4.108,0.708,6.007-0.762,7.499-3.84 c1.386-2.861,3.016-5.766,5.166-8.063c10.107-10.412,22.254-3.718,27.139,8.037c1.337,2.907,3.181,4.141,6.281,4.034 c2.715-0.094,5.446-0.058,8.257-0.038v2.091c0.319,0.001,0.631,0.004,0.951,0.004c0.362,2.11,0.473,3.786,0.947,5.352 c2.41,7.972,4.19,16.244,7.596,23.773c3.168,7.005,9.289,6.901,12.709-0.011c2.932-5.925,5.134-12.395,6.525-18.868 c4.01-18.662,2.675-37.664,2.696-56.567c0.133-118.853,0.314,0.295,0.392-118.558c0.068-103.934,0.013-377.867,0.064-481.801 c0.001-2.781-0.281-6.125,1.073-8.24c4.886-7.634,8.978-15.851,18.168-20.058c5.139-2.352,9.257-7.045,13.652-10.893 c4.267-3.736,8.16-7.904,12.459-11.599c15.452-13.278,26.023-29.619,30.885-49.451c0.909-3.707,2.926-4.598,6.161-5.73 c8.764-3.067,17.943-5.775,25.742-10.598c14.82-9.164,23.822-23.162,28.263-40.071c0.703-2.678,1.909-5.223,2.991-8.122 c11.076,8.596,18.006,9.328,24.489,3.223C369.187,192.953,370.464,184.538,365.949,178.882z M146.765,952.539 c0.498,2.38,0.15,4.934-3.302,4.884c-2.294-0.033-3.176,1.042-3.702,3.217c-0.26,1.076-1.713,2.383-2.793,2.559 c-0.723,0.118-2.36-1.479-2.504-2.467c-0.409-2.804-2.004-3.344-4.384-3.299c-3.709,0.07-7.424,0.116-11.131-0.006 c-3.83-0.126-3.945,2.278-3.981,5.13c-0.038,2.976,0.755,4.826,4.142,4.589c1.477-0.103,2.968,0.015,4.451-0.025 c2.202-0.059,4.543-0.006,4.579,2.901c0.04,3.187-2.477,3.119-4.78,3.068c-1.36-0.03-2.728,0.082-4.08-0.025 c-3.258-0.257-4.5,1.312-4.272,4.425c-0.041,4.353,1.027,8.028-4.883,7.506c-7.022,0.039-7.951,0.802-7.542-7.405 c0.168-3.39-1.192-4.855-4.555-4.524c-0.857,0.085-1.922,0.329-2.555-0.056c-1.2-0.729-2.156-1.861-3.213-2.825 c1.006-1.017,1.944-2.121,3.057-3.004c0.379-0.301,1.199-0.042,1.817-0.044c5.007-0.022,7.131-2.986,5.197-7.646 c-0.393-0.945-1.975-1.785-3.11-1.944c-3.651-0.437-7.442,0.158-11.117-0.121c-3.786-0.387-5.894,0.721-5.698,5.061 c0.045,0.996-1.78,2.077-2.744,3.119c-0.848-1.038-2.451-2.105-2.412-3.108c0.153-3.932-1.445-5.27-5.269-5.225 c-1.017,0.012-2.491-1.899-2.973-3.215c-0.52-1.422-0.127-3.18-0.126-4.791c0.001-5.24-0.002-5.268,5.3-5.954 c2.366-0.306,3.023-1.787,2.927-3.889c-0.098-2.143,0.268-4.425,2.848-4.073c1.034,0.141,2.342,2.528,2.49,3.998 c0.282,2.788,1.314,4.039,4.131,3.976c3.956-0.088,7.919-0.125,11.872,0.011c3.063,0.105,4.168-1.204,4.13-4.212 c-0.035-2.816-0.326-5.041-3.916-4.755c-2.559,0.203-4.468-0.474-4.367-3.527c0.095-2.865,2.016-3.344,4.358-3.173 c2.898,0.212,3.849-1.243,3.979-4.019c0.085-1.821,0.73-5.002,1.563-5.153c3.046-0.553,6.308-0.31,9.408,0.165 c0.646,0.099,1.284,2.453,1.345,3.795c0.224,4.967,0.375,5.207,5.402,5.214c1.361,0.002,2.928-0.423,4.027,0.116 c1.272,0.623,2.94,2.09,2.943,3.194c0.002,1.125-1.621,2.815-2.876,3.241c-1.666,0.565-3.668,0.223-5.518,0.132 c-3.18-0.157-3.971,1.57-3.952,4.398c0.019,2.703,0.495,4.64,3.783,4.569c3.957-0.085,7.916-0.055,11.874-0.012 c2.166,0.024,3.322-0.763,3.826-3.068c0.242-1.105,1.771-1.927,2.718-2.877c0.905,0.971,2.333,1.814,2.605,2.939 c0.545,2.256,1.757,2.7,3.843,3.111C149.469,944.566,146.104,949.379,146.765,952.539z M252.621,98.898 c0.287-0.167,0.574-0.334,0.861-0.502c2.841,6.521,5.683,13.042,8.739,20.056c-4.719,1.002-8.414,1.787-12.443,2.642 C250.758,113.446,251.689,106.172,252.621,98.898z M184.136,46.188c29.823,0,54,24.177,54,54c0,29.823-24.177,54-54,54 s-54-24.177-54-54C130.136,70.365,154.313,46.188,184.136,46.188z M162.097,165.903c14.218,3.796,27.946,4.565,42.414-0.072 c-3.942,14.414-4.001,28.063,0.302,42.583c-14.189-3.96-27.779-4.487-42.527-0.062C166.547,193.78,166.444,180.286,162.097,165.903 z M114.049,99.643c0.292,0.134,0.583,0.269,0.875,0.403c1.095,7.133,2.19,14.267,3.378,22.01 c-3.852-0.843-7.747-1.695-12.458-2.726C108.69,112.502,111.369,106.072,114.049,99.643z M114.09,275.17 c-2.992-7.299-5.446-13.283-8.044-19.622c4.192-0.951,7.557-1.714,11.303-2.564C116.293,260.174,115.314,266.84,114.09,275.17z  M97.136,240.188c-29.823,0-54-24.177-54-54c0-29.823,24.177-54,54-54s54,24.177,54,54 C151.136,216.012,126.96,240.188,97.136,240.188z M190.317,961.816c-2.889,3.631-2.59,7.316-2.675,11.229 c-0.063,2.929-0.301,6.185-4.102,6.083c-3.718-0.099-3.92-3.373-3.912-6.266c0.01-3.961,0.532-7.956-2.966-11.069 c-0.843-0.75-0.86-2.433-1.653-4.938c1.737-1.842,3.427-4.577,5.876-5.996c3.218-1.864,7.078-0.801,8.743,2.361 C190.908,955.651,191.666,960.12,190.317,961.816z M190.377,894.286c-2.75,3.639-2.754,7.277-2.731,11.231 c0.017,2.954-0.303,6.162-3.967,6.219c-3.722,0.058-4.036-3.156-4.069-6.118c-0.044-3.915,0.729-7.982-2.898-11.07 c-0.855-0.728-0.902-2.408-1.792-5.047c1.877-1.885,3.726-5.163,6.313-5.925c2.41-0.711,6.606,0.411,8.177,2.279 C190.999,887.744,191.681,892.56,190.377,894.286z M190.399,830.196c-3.107,3.329-2.592,6.926-2.795,10.682 c-0.086,1.597-0.323,3.33-1.04,4.717c-1.41,2.725-4.298,2.744-5.822,0.114c-0.63-1.087-1.04-2.453-1.075-3.706 c-0.125-4.43,0.653-9.009-3.304-12.472c-0.62-0.543-0.572-1.852-0.833-2.806c-0.315-0.34-0.629-0.679-0.944-1.019 c2.103-2.244,3.85-5.571,6.413-6.415c2.391-0.788,6.184,0.324,8.392,1.933C192.319,823.355,192.864,827.555,190.399,830.196z  M184.136,328.188c-29.823,0-54-24.177-54-54c0-29.823,24.177-54,54-54s54,24.177,54,54 C238.136,304.012,213.96,328.188,184.136,328.188z M252.789,277.752c-0.265-0.133-0.531-0.265-0.796-0.398 c-1.015-8.257-2.029-16.515-3.086-25.115c4.167,0.862,8.324,1.721,13.585,2.809C259.162,262.841,255.975,270.297,252.789,277.752z  M271.136,240.188c-29.823,0-54-24.177-54-54c0-29.823,24.177-54,54-54c29.823,0,54,24.177,54,54 C325.137,216.012,300.96,240.188,271.136,240.188z",
    clocks: {
      size: 108,
      0: { x: 184.245, y: 100 },
      1: { x: 97.245, y: 186 },
      2: { x: 271.245, y: 186 },
      3: { x: 184.245, y: 274 }
    }
  },
  5: {
    height: 1148.657,
    width: 368.698,
    path: "M364.919,177.185c-5.856-6.593-15.147-6.888-21.897-0.694c-3.717,3.411-4.299,3.242-5.541-1.587 c-0.25-0.972-0.571-1.926-0.803-2.901c-6.223-26.032-22.396-42.736-47.523-51.238c-2.474-0.837-4.808-2.72-6.666-4.641 c-6.618-6.844-12.426-14.598-19.638-20.709c-7.25-6.144-14.426-11.753-15.964-21.863c-0.145-0.952-0.81-1.83-1.262-2.728 c-10.14-20.142-26.293-32.5-48.2-37.503c-2.572-0.587-5.014-1.743-8.025-2.817c1.316-1.702,1.86-2.531,2.526-3.247 c6.502-6.986,6.698-15.783,0.465-21.94c-5.785-5.714-15.027-5.762-20.84-0.11c-6.368,6.191-6.436,15.084,0.239,21.857 c2.991,3.035,1.728,4.561-1.167,5.98c-1.334,0.654-2.844,0.952-4.281,1.387c-24.857,7.514-40.936,23.712-48.399,48.654 c-0.748,2.499-2.69,4.83-4.561,6.77c-8.684,9.004-17.485,17.897-26.377,26.695c-1.782,1.764-3.95,3.591-6.269,4.287 c-27.272,8.186-44.245,25.906-50.386,53.864c-0.306,1.391-0.752,2.75-1.182,4.299c-11.942-8.326-18.43-8.891-24.733-2.424 c-5.16,5.294-6.085,13.716-1.351,19.24c2.253,2.629,5.655,4.841,8.962,5.874c6.77,2.115,12.009-1.8,16.717-6.757 c0.647,1.364,1.068,1.923,1.182,2.539c5.495,29.672,22.939,48.289,51.806,56.504c1.891,0.538,3.666,2.056,5.112,3.503 c8.725,8.731,17.397,17.519,25.942,26.426c1.755,1.83,3.532,4.061,4.227,6.423c5.507,18.702,16.574,32.696,33.076,43.228 c6.667,4.255,11.428,11.52,16.987,17.48c0.5,0.535,0.688,1.544,0.692,2.334c0.044,10.877,0.03,21.753,0.03,32.638 c-1.577,0.516-2.845,0.932-4.113,1.346c-17.135,5.597-30.511,16.033-39.024,31.952c-3.426,6.407-5.333,13.646-7.754,20.57 c-1.76,5.033-3.129,5.54-6.907,2.08c-2.706-2.478-6.172-4.068-9.837-4.235c-8.598-0.392-15.176,6.223-15.67,13.97 c-0.384,6.021,2.865,11.744,8.198,14.44c5.638,2.851,12.01,2.021,16.818-2.189c2.562-2.243,5.668-1.656,6.923,1.51 c1.187,2.993,1.799,6.229,3.124,9.149c2.549,5.62,4.886,11.444,8.247,16.568c9.497,14.478,39.422,28.018,39.422,28.018v28.542 c0,0-0.496,0.466-0.788,0.469c-5.522,0.049-11.045,0.088-16.568,0.095c-9.805,0.013-10.191,0.382-10.188,9.959 c0.001,2.347-0.002,4.695,0,7.042c0.008,7.059,1.061,8.147,7.942,8.157c6.643,0.01,13.286,0.002,20.223,0.002 c-0.115,2.368-0.198,4.098-0.292,6.035c-7.528,0-14.546,0.054-21.562-0.02c-3.56-0.037-6.383,2.854-6.323,6.415 c0.064,3.826-0.011,7.654,0.01,11.481c0.033,5.918,1.364,7.248,7.324,7.269c6.815,0.024,21.22,0.006,21.22,0.006v7.044 c0,0-14.435-0.017-21.108,0.005c-6.069,0.02-7.373,1.289-7.434,7.19c-0.028,2.682,0.18,5.38-0.039,8.044 c-0.443,5.389,0.07,10.039,6.912,10.524c-3.015,31.457-2.572,62.398,2.234,93.196c2.98,19.097,7.19,37.854,16.599,55.063 c1.443,2.639,2.397,5.924,2.406,8.914c0.209,63.543,0.251,127.087,0.325,190.631c0.002,1.795,0,3.59,0,5.442 c-5.238,0.679-7.397-1.369-7.347-5.986c0.035-3.185,0.024-6.371,0.006-9.557c-0.034-5.945-1.325-7.274-7.309-7.285 c-17.074-0.032-34.148-0.022-51.222-0.026c-11.718-0.003-23.435-0.029-35.153,0.013c-5.235,0.019-6.699,1.54-6.756,6.814 c-0.038,3.521-0.04,7.042,0.004,10.563c0.066,5.255,1.516,6.725,6.823,6.744c11.215,0.04,22.431,0.01,33.646,0.013 c11.868,0.003,11.868,0.005,11.75,11.912c-0.059,5.922-1.3,7.16-7.407,7.176c-12.22,0.031-24.439,0.018-36.659,0.029 c-7.054,0.006-8.155,1.08-8.167,7.935c-0.004,2.18-0.006,4.359,0.001,6.539c0.021,6.383,1.222,7.644,7.439,7.655 c11.048,0.02,22.096,0.002,33.144,0.006c11.791,0.005,11.791,0.008,11.648,12.012c-0.067,5.703-1.367,7.062-7.047,7.083 c-10.378,0.04-20.758,0.096-31.135-0.002c-15.122-0.144-14.146-0.478-14.047,14.132c0.038,5.646,1.377,6.992,7.074,7.008 c11.048,0.031,22.096,0.007,33.144,0.01c12.19,0.003,12.19,0.005,12.011,12.153c-0.083,5.597-1.413,6.924-7.187,6.944 c-10.211,0.034-20.423,0.089-30.633-0.001c-15.773-0.139-14.465-0.577-14.406,14.774c0.024,6.173,1.313,7.37,7.73,7.375 c13.726,0.011,27.452,0.005,41.179,0.003c14.898-0.002,29.796,0.018,44.694-0.027c5.339-0.016,6.767-1.487,6.831-6.742 c0.033-2.682-0.046-5.366,0.02-8.047c0.126-5.106,1.839-6.469,8.044-5.697c0,5.722-0.455,11.611,0.097,17.404 c1.078,11.308,2.634,22.631,8.667,32.623c3.709,6.143,9.563,5.816,12.753-0.612c2.984-6.015,5.833-12.625,6.409-19.174 c1.579-17.969,2.543-36.045,2.614-54.083c0.36-91.878,0.35-183.757,0.553-275.636c0.005-2.049,0.733-4.214,1.576-6.124 c3.369-7.639,7.748-14.934,10.257-22.833c11.421-35.946,13.433-72.997,11.755-110.391c-0.269-5.99-0.801-11.968-1.209-17.909 c7.452-1.534,7.775-1.945,7.779-9.588c0.001-2.515,0.011-5.03,0.007-7.545c-0.013-7.75-0.894-8.656-8.46-8.663 c-7.141-0.007-22.406-0.001-22.406-0.001v-7.045c0,0,16.742-0.048,24.561,0.019c4.359,0.038,6.392-2,6.312-6.351 c-0.071-3.855,0.016-7.712-0.019-11.568c-0.053-5.938-1.345-7.219-7.35-7.242c-7.485-0.029-22.504-0.007-22.504-0.007v-6.035 c0,0,15.454,0.033,22.967-0.011c5.362-0.031,6.803-1.454,6.876-6.683c0.049-3.52,0.028-7.042,0.018-10.563 c-0.019-6.708-1.157-7.881-7.7-7.895c-7.319-0.016-21.161-0.004-21.161-0.004v-28.963c0,0,51.319-18.506,51.418-58.803 c13.274,8.8,19.828,9.143,25.982,1.96c4.843-5.653,4.919-13.758,0.181-19.362c-6.121-7.24-12.687-6.904-26.259,1.909 c-5.709-30.27-22.672-50.541-52.587-59.137c0-11.198-0.038-22.249,0.053-33.298c0.01-1.247,0.394-2.826,1.206-3.677 c5.143-5.394,9.736-11.741,15.851-15.695c15.582-10.074,26.618-23.168,32.069-40.997c0.628-2.052,2.154-4.251,3.897-5.472 c12.064-8.448,22.297-18.658,30.858-30.639c1.235-1.728,3.009-3,5.027-3.661c25.276-8.284,41.218-25.241,47.865-51.029 c0.549-2.129,1.536-4.145,2.62-7.008c2.028,1.88,3.182,3.03,4.418,4.083c5.813,4.951,14.202,4.893,19.761-0.107 C369.847,192.788,370.428,183.388,364.919,177.185z M252.394,107.492c4.098,3.415,7.887,6.574,11.677,9.733 c-0.404,0.395-0.807,0.791-1.211,1.186c-4.169,0.785-8.338,1.57-13.15,2.476C250.666,116.112,251.516,111.872,252.394,107.492z  M184.406,46c29.823,0,54,24.177,54,54c0,29.823-24.177,54-54,54s-54-24.177-54-54C130.406,70.177,154.583,46,184.406,46z  M162.373,165.581c14.357,4.18,28.096,4.578,42.513,0.199c-4.092,14.47-3.946,28.113,0.227,42.523 c-14.26-4.037-27.868-4.509-42.273-0.152C166.659,193.831,166.896,180.189,162.373,165.581z M115.827,107.593 c1.197,5.466,2.101,9.598,3.149,14.382c-4.547-0.964-8.521-1.806-13.675-2.899C108.835,115.221,111.958,111.814,115.827,107.593z  M43.406,186c0-29.823,24.177-54,54-54s54,24.177,54,54c0,29.823-24.177,54-54,54S43.406,215.823,43.406,186z M115.278,265.909 c-3.402-3.626-6.248-6.661-9.67-10.309c4.662-1.06,8.192-1.862,12.324-2.801C117.071,257.051,116.27,261.011,115.278,265.909z  M238.406,453c0,29.823-24.177,54-54,54s-54-24.177-54-54s24.177-54,54-54S238.406,423.177,238.406,453z M184.406,328 c-29.823,0-54-24.177-54-54c0-29.823,24.177-54,54-54s54,24.177,54,54C238.406,303.823,214.23,328,184.406,328z M251.958,267.927 c-1.167-5.669-2.154-10.46-3.262-15.84c5.154,0.97,9.935,1.87,14.716,2.77c0.446,0.541,0.892,1.082,1.338,1.623 C260.673,260.129,256.595,263.778,251.958,267.927z M271.406,240c-29.823,0-54-24.177-54-54c0-29.823,24.177-54,54-54 c29.823,0,54,24.177,54,54C325.406,215.823,301.23,240,271.406,240z",
    clocks: {
      size: 108,
      0: { x: 184.245, y: 100 },
      1: { x: 97.245, y: 186 },
      2: { x: 271.245, y: 186 },
      3: { x: 184.245, y: 274 },
      4: { x: 184.245, y: 453 }
    }
  },
  6: {
    height: 1148.98,
    width: 370.141,
    path: "M365.84,176.489c-5.689-5.831-14.774-6.109-20.983-0.642c-4.677,4.118-4.976,4.085-6.414-2.269 c-6.187-27.333-22.732-44.97-49.412-53.347c-1.887-0.593-3.769-2.168-4.983-3.788c-8.33-11.115-18.008-20.785-29.318-28.894 c-1.84-1.32-3.239-3.825-3.948-6.065c-8.013-25.306-24.804-41.278-50.453-47.985c-1.299-0.34-2.628-0.562-3.93-0.89 c-6.029-1.519-6.346-2.456-2.44-7.102c5.378-6.396,4.93-15.201-1.065-20.921c-5.702-5.442-14.806-5.447-20.582-0.013 c-6.006,5.651-6.507,14.545-1.066,20.88c0.962,1.12,2.36,1.865,5.102,3.969c-3.997,1.969-6.466,3.647-9.192,4.455 c-21.058,6.239-37.094,18.816-44.941,39.357c-3.899,10.207-9.562,17.625-17.758,24.394c-6.646,5.489-11.704,12.883-17.615,19.294 c-1.38,1.497-3.203,3.002-5.097,3.546c-28.343,8.127-45.563,26.507-51.567,55.389c-0.195,0.941-0.595,1.84-1.211,3.697 c-4.56-5.357-9.738-8.928-16.367-7.261c-3.226,0.811-6.599,2.778-8.897,5.184c-5.104,5.343-4.779,13.776,0.038,19.336 c6.068,7.004,12.02,6.721,25.619-1.458c0.72,3.007,1.322,5.896,2.106,8.735c7.133,25.831,23.797,42.127,49.404,49.659 c2.498,0.735,4.874,2.61,6.784,4.488c8.593,8.445,17.053,17.028,25.427,25.692c1.767,1.828,3.636,4.007,4.323,6.356 c5.597,19.138,16.997,33.318,33.994,43.913c6.567,4.094,11.118,11.439,16.51,17.374c0.48,0.528,0.534,1.578,0.536,2.386 c0.033,10.743,0.022,21.486,0.022,30.697c-9.552,5.427-18.816,9.569-26.776,15.469c-12.547,9.299-19.949,22.422-23.771,37.578 c-0.68,2.698-2.102,5.208-3.473,8.506c-2.286-2.126-3.461-3.29-4.711-4.367c-6.067-5.231-15.003-4.872-20.573,0.801 c-5.603,5.707-5.839,14.698-0.54,20.569c5.565,6.166,14.515,6.88,20.866,1.665c5.112-4.197,5.412-3.946,8.069,2.516 c3.43,8.344,6.359,17.082,11.089,24.661c8.379,13.426,21.019,21.894,36.078,26.785c1.434,0.466,3.551,2,3.587,3.097 c0.294,8.853,0.165,17.72,0.165,27.124c-7.476,0-14.485-0.043-21.493,0.014c-5.306,0.044-6.687,1.494-6.735,6.878 c-0.033,3.697-0.03,7.394-0.004,11.091c0.042,5.943,1.284,7.157,7.436,7.185c6.702,0.031,13.405,0.007,20.448,0.007 c0,2.034,0,5.598,0,5.598s-13.784-0.034-20.783,0.011c-5.372,0.035-6.799,1.45-6.861,6.724c-0.047,4.026,0.044,8.054-0.023,12.079 c-0.072,4.325,1.898,6.385,6.299,6.345c6.876-0.063,13.753,0.049,20.629,0.113c0.289,0.003,1.739,0.534,1.739,0.534v6.407 c0,0-14.692-0.032-21.682,0.01c-5.652,0.034-7.334,1.395-6.872,7.119c0.694,8.601-1.289,15.249-8.006,21.638 c-8.605,8.185-13.036,19.34-15.463,31.089c-1.309,6.335-2.096,6.555-6.889,2.398c-6.287-5.453-15.195-5.103-20.871,0.819 c-5.657,5.902-5.624,15.003,0.076,20.896c5.702,5.895,14.51,6.153,20.855,0.613c1.117-0.975,2.238-1.945,4.238-3.682 c1.129,2.807,2.274,4.924,2.843,7.186c4.769,18.938,15.137,33.728,31.864,44.051c1.736,1.072,3.27,3.377,3.775,5.392 c3.397,13.548,7.363,26.834,14.685,38.904c0.804,1.325,1.03,3.177,1.033,4.786c0.118,64.926,0.18,129.852,0.239,194.778 c0.001,0.981-0.122,1.963-0.184,2.894c-5.249,0.709-6.974-0.588-7.13-5.358c-0.109-3.352-0.003-6.71-0.024-10.065 c-0.036-5.705-1.357-7.092-7.019-7.099c-21.978-0.026-43.956-0.012-65.933-0.011c-7.046,0-14.094,0.1-21.138-0.026 c-4.635-0.083-6.728,2.003-6.589,6.633c0.109,3.639,0.121,7.278-0.002,10.917c-0.157,4.646,1.947,6.703,6.575,6.67 c12.75-0.09,25.501-0.045,38.251-0.028c6.305,0.008,7.513,1.253,7.533,7.599c0.038,11.525,0.038,11.526-11.68,11.525 c-11.24-0.001-22.481-0.03-33.722,0.007c-5.418,0.018-6.914,1.437-6.931,6.666c-0.053,16.568-1.437,15.572,15.235,15.484 c10.066-0.053,20.132-0.038,30.198,0.002c5.373,0.021,6.796,1.457,6.905,6.697c0.259,12.419,0.259,12.42-12.268,12.419 c-11.073,0-22.146-0.028-33.218,0.011c-5.319,0.019-6.822,1.501-6.857,6.738c-0.102,15.018-1.068,14.544,14.31,14.408 c10.401-0.092,20.803-0.047,31.205-0.005c5.279,0.022,6.729,1.522,6.828,6.773c0.234,12.342,0.234,12.342-12.345,12.342 c-11.073,0-22.146-0.031-33.218,0.012c-5.25,0.02-6.76,1.539-6.779,6.814c-0.06,16.24-1.382,15.39,14.882,15.343 c26.004-0.075,52.009-0.015,78.013-0.024c6.592-0.002,7.763-1.211,7.767-7.876c0.001-2.349-0.056-4.699,0.01-7.046 c0.144-5.087,1.794-6.38,6.391-5.865c1.57,11.962,2.907,23.747,4.765,35.449c0.647,4.073,1.998,8.292,4.104,11.797 c1.828,3.041,5.159,7.119,7.859,7.143c2.656,0.024,6.805-4.019,7.763-7.073c3.09-9.85,6.148-19.959,7.106-30.167 c1.295-13.794,0.763-27.772,0.787-41.671c0.158-91.433,0.238-182.866,0.46-274.299c0.006-2.499,0.844-5.29,2.131-7.444 c7.151-11.972,11.314-25.021,14.283-38.502c0.767-3.483,2.275-5.895,5.318-7.958c14.472-9.809,23.801-23.321,28.184-40.279 c0.711-2.753,1.981-5.361,3.281-8.798c2.096,1.947,3.257,3.114,4.508,4.173c6.274,5.312,15.319,4.747,20.867-1.276 c5.371-5.83,5.28-14.718-0.209-20.541c-5.593-5.933-14.657-6.313-20.861-0.875c-4.91,4.304-5.502,4.183-6.871-2.32 c-2.843-13.501-9.129-25.091-18.636-35.051c-1.059-1.109-1.624-3.064-1.703-4.662c-0.225-4.519-0.177-9.058-0.049-13.584 c0.13-4.584-1.863-6.712-6.52-6.641c-7.688,0.117-23.46,0.032-23.46,0.032v-7.081c0,0,15.513,0.035,23.187-0.012 c5.264-0.032,6.699-1.51,6.757-6.834c0.042-3.858,0.047-7.718-0.001-11.576c-0.066-5.278-1.476-6.669-6.885-6.701 c-7.529-0.044-22.059-0.011-22.059-0.011v-6.073c0,0,14.421,0.036,22.088-0.012c5.373-0.034,6.792-1.451,6.855-6.73 c0.048-4.026-0.055-8.054,0.028-12.079c0.089-4.361-1.944-6.374-6.308-6.332c-7.707,0.073-23.662,0.021-23.662,0.021 s0-18.743,0-28.6c29.397-8.459,46.462-28.621,52.535-59.535c5.681,5.182,10.784,9.539,17.649,7.382 c3.324-1.045,6.767-3.214,9.025-5.845c4.929-5.744,3.921-14.326-1.559-19.637c-6.511-6.312-13.714-5.558-25.117,3.388 c-5.85-30.371-22.706-50.809-52.896-59.482c0-11.328-1.021-22.855,0.356-34.088c0.927-7.564,7.385-13.291,13.943-17.092 c17.546-10.17,29.776-24.263,35.419-43.925c0.495-1.726,2.182-3.403,3.745-4.482c12.023-8.304,22.113-18.494,30.667-30.315 c1.255-1.734,3.402-3.24,5.446-3.923c25.095-8.384,41.101-25.168,47.682-50.873c0.553-2.159,1.517-4.212,2.638-7.26 c1.992,1.814,3.143,2.911,4.345,3.949c6.307,5.446,15.194,5.081,20.928-0.844C371.579,191.607,371.538,182.33,365.84,176.489z M253.55,107.072c4.157,3.613,7.747,6.732,11.337,9.852c-0.326,0.501-0.652,1.003-0.979,1.504 c-4.182,0.798-8.365,1.596-13.163,2.512C251.718,116.132,252.577,111.882,253.55,107.072z M185.289,45.98c29.823,0,54,24.177,54,54 c0,29.823-24.177,54-54,54s-54-24.177-54-54C131.289,70.157,155.466,45.98,185.289,45.98z M164.151,165.773 c13.581,4.334,27.363,4.22,41.777,0.199c-4.474,14.48-3.87,28.139,0.027,42.429c-14.232-4.098-27.748-4.399-41.531-0.444 c0.777-7.312,2.093-14.066,2.044-20.809C166.419,180.244,165.032,173.349,164.151,165.773z M116.538,107.809 c1.209,5.322,2.145,9.436,3.252,14.311c-4.762-1.06-8.731-1.943-13.791-3.07C109.65,115.157,112.775,111.823,116.538,107.809z M98.289,239.98c-29.823,0-54-24.177-54-54c0-29.823,24.177-54,54-54s54,24.177,54,54 C152.289,215.804,128.113,239.98,98.289,239.98z M115.949,265.97c-3.407-3.594-6.205-6.546-9.77-10.308 c5.012-1.059,8.587-1.815,12.604-2.664C117.803,257.484,116.976,261.266,115.949,265.97z M239.289,683.98c0,29.823-24.177,54-54,54 s-54-24.177-54-54s24.177-54,54-54S239.289,654.157,239.289,683.98z M239.289,452.98c0,29.823-24.177,54-54,54s-54-24.177-54-54 s24.177-54,54-54S239.289,423.157,239.289,452.98z M185.289,327.98c-29.823,0-54-24.177-54-54c0-29.823,24.177-54,54-54 s54,24.177,54,54C239.289,303.804,215.113,327.98,185.289,327.98z M253.079,268.69c-1.271-6.405-2.241-11.297-3.279-16.525 c5.356,1.047,10.057,1.966,16.634,3.251C261.644,260.177,257.764,264.034,253.079,268.69z M272.289,239.98 c-29.823,0-54-24.177-54-54c0-29.823,24.177-54,54-54c29.823,0,54,24.177,54,54C326.289,215.804,302.113,239.98,272.289,239.98z",
    clocks: {
      size: 108,
      0: { x: 185.128, y: 100 },
      1: { x: 98.128, y: 186 },
      2: { x: 272.128, y: 186 },
      3: { x: 185.128, y: 274 },
      4: { x: 185.128, y: 453 },
      5: { x: 185.128, y: 684 }
    }
  }
};
const SVGDATA = {
  teeth: {
    tall: {
      viewBox: "0 0 512 1540",
      paths: {
        frame: "M0,0v1540l512-244.2V0H0z M451,1263.5l-390,186V61h390V1263.5z",
        half: "M0,0v748l512-244.2V0H0z",
        full: "M0,0v1540l512-244.2V0H0z"
      }
    },
    med: {
      viewBox: "0 0 512 1540",
      paths: {
        frame: "M0,0v1388l512-395.6V0H0z M458,965.7L54,1278V53h404V965.7z",
        full: "M0,0v1540l512-244.2V0H0z"
      }
    },
    short: {
      viewBox: "0 0 512 1540",
      paths: {
        frame: "M0,0v991l511.4-247L512,0H0z M470.5,715.2L41,922.6V40h430L470.5,715.2z",
        full: "M0,0v991l511.4-247L512,0H0z"
      }
    }
  },
  armor: {
    viewBox: "0 0 512 512",
    paths: {
      heavy: "M157.5,80.7c-20.6,13.7-46,22.5-69.4,26c6.8,48.9,26.1,84.1,46,97.8 c10.5,7.3,20.4,9,30.4,5.6c8.9-3.1,18.6-11,27.8-25.6C165.3,154.3,160.6,113.5,157.5,80.7L157.5,80.7z M354.5,80.8 c-3.1,32.8-7.8,73.6-34.7,103.8c9.1,14.6,18.9,22.5,27.8,25.6c10,3.4,19.8,1.7,30.4-5.6c19.8-13.7,39.1-48.8,45.9-97.7 C399.3,103.7,376,95.5,354.5,80.8L354.5,80.8z M254.4,67.9c-37.1,0-69.8,8.3-89.6,21c1.2,6.5,2.6,13,4.2,19.3 c19.2-8.2,50.3-16.7,85.4-16.7c35.2,0,66.3,8.5,85.4,16.7c1.7-6.3,3.1-12.8,4.2-19.3C324.2,76.2,291.5,67.9,254.4,67.9z M64.9,127.9l-47.7,45.5c29.8,37.2,63,56.8,86.5,58.7c1.1,0.1,2.3,0.1,3.3,0.2c1.8-7.6,4-15.1,6.5-22.3 C91.7,194.9,74.4,166.1,64.9,127.9L64.9,127.9z M447.1,127.9c-9.6,38.3-26.9,67-48.6,82c0,0-0.1,0-0.1,0.1 c2.5,7.3,4.7,14.7,6.5,22.3c1.1,0,2.2-0.1,3.4-0.2c23.4-1.9,56.8-21.5,86.5-58.7L447.1,127.9L447.1,127.9z M176,139.4 c5.7,12.2,13.1,23.3,22.9,32.8l6.4,6.2l-4.3,7.8c-2.3,4.1-4.6,8-7,11.7c40.8,15,85,14,124-0.2c-2.4-3.6-4.6-7.4-6.9-11.4l-4.3-7.8 l6.4-6.2c9.4-9.1,16.7-19.9,22.3-31.5C280.8,153.8,228.5,151.3,176,139.4L176,139.4z M401.7,243.6c0,0-3.7,38.1-22.9,76.1 l-121.7-32.7l-1.8-0.4l-1.8,0.4l-120.3,32.7c-19-38-22.7-76.1-22.7-76.1s12,3.8,19.5-18.7c10.7,3.2,22,3.3,32.8-0.4 c9.2-3.2,17.8-8.8,25.8-16.9c21.6,8.9,44.2,13.1,66.7,13.1c22.7,0,45.6-4.2,67.4-13.1c8,8,16.8,13.7,26.1,16.9 c10.9,3.7,22.3,3.6,33.1,0.4C389.6,247.4,401.7,243.6,401.7,243.6z M486.1,210.7c-25.4,24.2-52.1,38-76.2,40c-0.4,0-0.9,0-1.3,0.1 c1.2,8.1,2,16.2,2.3,24.4c22.8,3.8,54.7,0.1,90-14.3L486.1,210.7L486.1,210.7z M25.9,210.8l-14.8,50.1c35.3,14.4,67.2,18.1,90,14.3 c0.3-8.2,1.1-16.3,2.3-24.4c-0.4,0-0.9,0-1.3-0.1C78,248.7,51.3,234.9,25.9,210.8L25.9,210.8z M256,305.2l-114.8,28.1 c1.9,7.7,10.1,17.6,15.4,23.8c31.8-7.3,59.3-11.4,94.7-11.6c2.6,0,5.3,0,7.9,0c38.2,0.3,64.9,4.3,95.9,11.6 c5.1-6.2,15.2-15.8,16.8-23.6L256,305.2L256,305.2z M254.1,347.8l-79.3,22.1c5.8,4.8,16,8.5,23.2,13.3c18-5,33.5-7.8,53.5-7.9 c1.5,0,3,0,4.5,0c21.6,0.2,36.6,3,54.1,7.9c9.9-1.8,16.8-6.8,25.5-12.3L254.1,347.8L254.1,347.8z M373.3,377.7 c-68.3,55.6-166.9,55.7-235.3,0.3l-1.8,35.9c4.7,7.9,18.3,17,38,23c21,6.4,48,9.9,75.6,10.2c27.6,0.3,55.8-2.6,79.4-8.7 c21.6-5.6,39.3-14.2,48.8-23.9L373.3,377.7L373.3,377.7z",
      light: "M254.9,88c-23.1,0-44.1,2.8-59.8,8.8c-7.9,3-14.5,6.8-19.5,11.9c-5,5.1-8.4,12.1-8.4,19.9 c0,3.2,0.5,6.2,1.5,9.1c2,37.1-20.9,83.9-46,107.5c5.9,35.9,19.4,72.7,39.6,106.3c23.8,23,54.6,35.4,85.9,37.1v-24 c-9.6-0.1-19-0.5-26.5-1.1l0.8-13.2c7.1,0.6,16.2,1,25.7,1.1v-28.3c-9.1,0.4-17.9,1.8-24.4,4.2l-3.3-12.7 c8.1-2.9,17.8-4.6,27.7-5.1v-23.8c-2.9,0.2-5.8,0.5-8.7,1c-17.2,1-31.8,3.6-45.2,7.5l-0.1-0.2c16.7-14.8,38.1-22.2,59.6-22.2 c21.4,0,42.9,7.4,59.6,22.2l-0.1,0.1c-13.4-3.9-28.1-6.5-45.4-7.5c-2.8-0.5-5.7-0.8-8.5-1v23.8c10,0.5,19.7,2.1,27.7,5.1l-3.3,12.7 c-6.6-2.4-15.4-3.8-24.5-4.2v28.3c9.4-0.1,18.6-0.4,25.7-1.1l0.8,13.2c-7.5,0.7-16.9,1-26.5,1.1v24.1c32.4-0.8,64.6-13,89.4-36.5 c21.1-33.6,34.9-69.9,40.8-105.3c-26.2-23.2-50.7-72.5-47.8-110.7c0.7-2.5,1-5,1-7.7c0-7.8-3.4-14.8-8.4-19.9 c-5-5.1-11.7-8.9-19.6-11.9C298.9,90.8,278,88,254.9,88L254.9,88z M254.9,101.3c22.3,0,42.5,2.9,56.4,8.2c7,2.7,12.4,6,15.7,9.3 c3.3,3.4,4.5,6.3,4.5,9.9c0,1.8-0.3,3.6-1.1,5.5c-21.9-11.9-49.3-17.9-76.7-17.9c-26.6,0-53.2,5.6-74.7,16.8 c-0.5-1.5-0.7-2.9-0.7-4.4c0-3.5,1.2-6.5,4.5-9.9c3.3-3.4,8.7-6.7,15.7-9.3C212.4,104.1,232.6,101.3,254.9,101.3L254.9,101.3z M253.7,130c24.6,0,49.2,4.8,68.6,14.3c-3.1,2.6-6.9,5.1-11.4,7.3c-13.9,7-33.9,11.5-56,11.5s-42-4.5-56-11.5 c-4.9-2.4-9-5.2-12.2-8C205.8,134.5,229.7,130,253.7,130z M232.3,174.9c3.7,0.5,7.5,0.9,11.4,1.2c0.5,3.6,1,7.5,1.6,11.8 c1.6,13,3.3,27.9,3.3,37.5c0,10.8-3.5,20.6-9.5,28.1c-6.1,7.5-14.5,13-24.6,16.5c-11.2,3.9-24.5,5.6-39.3,4.8 c-14.2-2.5-25.1-9.3-35.7-19.6c29.1,8.3,54.5,8.2,71.9,2.1c8.7-3.1,15.4-7.6,19.7-13c4.3-5.4,6.5-11.4,6.5-18.9 c0-7.7-1.6-22.8-3.1-35.6C233.6,184.1,232.9,179,232.3,174.9L232.3,174.9z M275,175.2c-0.6,4-1.3,9-2,14.6 c-1.6,12.7-3.1,27.9-3.1,35.6c0,7.5,2.1,13.6,6.5,18.9c4.3,5.4,11,9.9,19.7,13c17.3,6.1,42.6,6.2,71.6-2.1 c-10.6,10.3-21.5,17.1-35.7,19.6c-14.8,0.8-28-0.9-39.1-4.8c-10.1-3.5-18.5-9-24.6-16.5s-9.5-17.3-9.5-28.1 c0-9.7,1.7-24.6,3.3-37.5c0.5-4.3,1.1-8.2,1.5-11.7C267.4,176,271.2,175.7,275,175.2L275,175.2z M347.1,370.2 c-52.9,43.1-129.3,43.2-182.3,0.3l-1.4,27.8c3.6,6.1,14.2,13.2,29.4,17.8c16.3,4.9,37.2,7.7,58.5,7.9c21.4,0.2,43.2-2,61.5-6.7 c16.8-4.3,30.4-11,37.8-18.5L347.1,370.2L347.1,370.2z",
      special: "M256,14.2c-65.6,98.3-131.1,90.2-196.7,106.5c0,262.3,65.6,327.8,196.7,377 c131.1-49.2,196.7-114.7,196.7-377C387.1,104.4,321.6,112.6,256,14.2z M256,47c5.1,0,9.2,4.1,9.2,9.2s-4.1,9.2-9.2,9.2 s-9.2-4.1-9.2-9.2S250.9,47,256,47z M70.6,138.2c0-5.1,4.1-9.2,9.2-9.2s9.2,4.1,9.2,9.2s-4.1,9.2-9.2,9.2S70.6,143.3,70.6,138.2z M92.1,301.1c-5.1,0-9.2-4.1-9.2-9.2c0-5.1,4.1-9.2,9.2-9.2s9.2,4.1,9.2,9.2C101.3,296.9,97.2,301.1,92.1,301.1z M157.7,432.2 c-5.1,0-9.2-4.1-9.2-9.2c0-5.1,4.1-9.2,9.2-9.2s9.2,4.1,9.2,9.2C166.9,428.1,162.7,432.2,157.7,432.2z M256,483.4 c-5.1,0-9.2-4.1-9.2-9.2s4.1-9.2,9.2-9.2s9.2,4.1,9.2,9.2S261.1,483.4,256,483.4z M354.3,432.2c-5.1,0-9.2-4.1-9.2-9.2 c0-5.1,4.1-9.2,9.2-9.2c5.1,0,9.2,4.1,9.2,9.2C363.6,428.1,359.4,432.2,354.3,432.2z M314.4,426.7c-15.8,11.1-33.7,18.7-51.1,26.8 c-6.7,4.7-14-0.5-20.7-2.5c-44.7-18.3-86.5-49.8-107.6-94.5c-29.8-63.5-33.8-135-36.7-204.3c58.8-9,115.3-28.5,156.2-72.1l1.9-2.1 c4.5,5,9.3,9.8,14.2,14.5c35.8,36.3,85,47,133.9,57.8c2.8,1.2,6.8,0.5,9.1,2c-2.7,66.4-5.7,134.9-33.1,196.4 C367.3,380.9,343.2,407.7,314.4,426.7z M419.9,301.1c-5.1,0-9.2-4.1-9.2-9.2c0-5.1,4.1-9.2,9.2-9.2s9.2,4.1,9.2,9.2 C429.1,296.9,425,301.1,419.9,301.1z M432.2,147.4c-5.1,0-9.2-4.1-9.2-9.2s4.1-9.2,9.2-9.2s9.2,4.1,9.2,9.2 S437.3,147.4,432.2,147.4z M301.1,154.9c0.2,23.3,0.3,46.6,0.5,69.9c0,1,0.4,2.2,0.9,3.1c4.9,8.4,9.8,16.9,15,25.1 c1.6,2.6,0.8,5.1,0.6,7.6c-0.7,9.5-1.7,19-2.6,28.5c-1,10.5-2,21-3,31.6c-0.8,9-1.6,17.9-2.4,26.9c-0.8,9-1.7,17.9-2.5,26.9 c-0.7,7.3-1.3,14.6-2,22c-0.1,1.2-0.6,2.7-1.4,3.6c-12,12-24.1,23.9-36.2,35.9c-0.2,0.2-0.5,0.5-1.1,1c0-1.1,0-1.8,0-2.5 c0.1-66.5,0.3-133,0.5-199.5c0-1.5,0.8-3.2,1.7-4.4c2.2-2.9,2.8-6,2.8-9.6c0-28.5,0.1-57.1,0.2-85.6c0-0.7,0-1.5,0-2.5 c0.8,0,1.5-0.1,2.3-0.1c13.9,0.1,27.8,0.1,41.7,0.1c1.2,0,1.9,0.3,2.3,1.5c0.8,2.2,1.7,4.3,2.7,6.6c-6.2,3.9-12.2,7.6-18.2,11.3 C301.6,152.6,301.1,153.4,301.1,154.9z M245.2,433.7c0,0.9,0,1.7,0,2.6c-0.2,0.1-0.4,0.2-0.6,0.3c-1.4-1.5-2.8-3.1-4.3-4.5 c-10.7-10.6-21.5-21.2-32.2-31.9c-0.9-0.9-1.6-2.5-1.7-3.9c-1-9.2-1.8-18.4-2.6-27.5c-0.7-7.2-1.3-14.3-2-21.5 c-0.8-9.2-1.7-18.4-2.6-27.5c-0.7-7.1-1.3-14.2-1.9-21.3c-0.9-9.3-1.7-18.5-2.6-27.8c-0.5-4.9-1-9.9-1.3-14.8 c-0.1-0.7,0.4-1.6,0.8-2.2c5.1-8.6,10.2-17.1,15.2-25.7c0.5-0.9,0.9-2.1,0.9-3.1c0.2-23.2,0.3-46.4,0.5-69.6c0-1.6-0.5-2.5-1.9-3.4 c-6-3.6-11.9-7.3-18-11.2c1-2.5,2-4.9,3.1-7.4c0.2-0.3,0.8-0.6,1.2-0.6c14.6-0.1,29.3-0.1,43.9-0.1c0.1,0,0.3,0.1,0.6,0.3 c0,0.7,0.1,1.5,0.1,2.3c0.1,29.2,0.2,58.4,0.3,87.7c0,2.1,0.3,4,1.7,5.6c2.5,2.9,3,6.2,3,10C244.9,303.4,245.1,368.5,245.2,433.7z",
      specialBg: "M316.9,432.4c-16.5,11.6-35,19.4-53.1,27.8c-7,4.9-14.6-0.5-21.6-2.6 c-46.5-19-90-51.8-111.9-98.3c-31-66.1-35.1-140.5-38.2-212.4c61.2-9.4,119.9-29.6,162.4-75l2-2.1c4.7,5.2,9.6,10.2,14.7,15.1 c37.2,37.7,88.4,48.9,139.2,60.1c2.9,1.3,7.1,0.5,9.4,2.1c-2.9,69.1-5.9,140.3-34.4,204.3C372,384.8,346.8,412.7,316.9,432.4z"
    }
  },
  [
    "ReducedEffect"
    /* ReducedEffect */
  ]: {
    viewBox: "0 0 512 512",
    paths: {
      main: "M260.7,487.55C133,487.55,28.39,382.92,28.39,255.23S133,24.45,260.7,24.45A230.5,230.5,0,0,1,491.49,255.23c0,127.69-103.1,232.32-230.78,232.32Zm-1.06-82L377,287.58l-23.94-25.1-65.41,37.94V128a167.28,167.28,0,0,1,103.6,268.91,193.71,193.71,0,0,0,61.22-141.63A191.18,191.18,0,0,0,260.7,63.45c-106.39,0-193.31,85.39-193.31,191.78A192.9,192.9,0,0,0,128,395.55,167.3,167.3,0,0,1,231,128.2V296.92l-62.5-35.62-25.09,26.28Z"
    },
    classes: {
      main: "fill-linear"
    }
  },
  [
    "ComplicationMinor"
    /* ComplicationMinor */
  ]: {
    viewBox: "0 0 512 512",
    paths: {
      main: "M345.58,263.18l39.74-8.31,73.29-15.3,22.83-4.79,2.81-.58,9.56-2V213.1l-6.33,1.33-79.55,16.62-26.49,5.54-55.93,11.69c-13-11.18-20-24.73-27.16-39.89l-1.67-3.53,34.18-46.76,57.87-79.18,3-4.1,41.19-56.33H409.77L375.26,65.7l-4.09,5.59-60.51,82.78-32.91,45c-15.06-6.36-26.14-17.76-38.57-30.33l-2.34-2.37-4.59-30.28L216.72,33.5l-1-6.47-1.29-8.54h-18.9l2.84,18.75-.11-4.41,15.2,104.1,5.59,37c-11.18,7.5-24.44,12.15-39,15.49l-22.9-28.89L93.8,80.58,44.58,18.49H20.74l53,66.83,4.18,5.26,66.54,84,19.15,24.16-.08.7c-1.93,17.37-8.88,29.63-16.65,43.07L115.3,234.2,25.49,210.61,23.08,210l-4.31-1.14v19.32l2.56.67L112,252.65l27.61,7.25.56,1.4c6.1,15.15,5.39,31.77,2.9,49.71l-30.31,14.2L23.15,367.14l-4.38,2.06v20.62l9.18-4.3,67.92-31.77,17.13-8,28.92-13.54,1.52,1.53c5.85,5.86,10,10.29,11.22,20.75l-31.14,31.3L56.27,453.39l-37.5,37.69v2.43h24l20.91-21h0l77.94-78.36,24.11-24.24,1-.23c23.75-5.79,59.86-6.75,80.11-6.78,4,0,6.81,0,9.35.08l10.4,32.29L293,477.73l1.54,4.78,3.54,11h19.63l-5.19-16.14-2.24-6.95-25.77-80.06-11-34.32c3.55-3.17,8.73-7.63,15-12.42,11.42-8.73,26.21-17.7,35.68-19.62l4.24-.87,25.37,10L442,368.08l4.18,1.66,47.6,18.83V368.48l-37.78-15-5.21-2-82.75-32.74-36.59-14.48c0-13.16,1.4-22.85,9.12-33.93Zm-61.35-41.29c5.12,10.41,11.11,21.1,19.66,30.91l-31.15,6.52a39.69,39.69,0,0,0-6.93-12.22Zm-62.13-28,6,39.74a39.25,39.25,0,0,0-10.25,3.48l-25.18-31.77A132,132,0,0,0,222.1,193.9Zm-43.39,23.92,24.91,31.43a38.6,38.6,0,0,0-4.08,7.07l-33.92-8.92C170.58,238.65,175.45,229.15,178.71,217.82Zm17.49,56.93a39.32,39.32,0,0,0,2.08,10.45L163,301.7c1.05-11.91.92-24.05-2-36.2ZM160,324.27l.09-.55,47.15-22.07h0L169.55,339.5A54.79,54.79,0,0,0,160,324.27Zm28.37,22.85,36.61-36.8a39.43,39.43,0,0,0,10.6,1.45,35.54,35.54,0,0,0,4-.2L250,344.11C236.7,344,212.41,344.2,188.33,347.12ZM250.78,236a35.39,35.39,0,0,0-3.61-1.32L241.46,197a109.45,109.45,0,0,0,25.15,17.38Zm26.37,92.76c-3.9,3-7.1,5.61-9.88,8l-10.1-31.4a39.81,39.81,0,0,0,8.16-7.16l36.5,14.44A169,169,0,0,0,277.15,328.76Zm36-31.76L273.9,281.47c.26-1.14.47-2.29.64-3.44l45.58-9.53C315.5,277.93,313.74,287.39,313.17,297Z"
    },
    classes: {
      main: "fill-radial"
    }
  },
  [
    "ComplicationMajor"
    /* ComplicationMajor */
  ]: {
    viewBox: "0 0 512 512",
    paths: {
      main: "M458.26,239.57l22.83-4.78,2.81-.59,9.56-2v-19.1l-6.33,1.33-79.55,16.62-26.49,5.54-55.93,11.69c-13-11.18-20-24.73-27.16-39.89l-1.67-3.53,34.18-46.76.58-.79c9.76,28.37,24.84,58.48,51.36,78.35l24.6-5,1.83-.54L407.07,229c-37.27-19.15-50.45-51.64-61.94-88.83l-.44-1.43,43.69-59.78,3-4.1,41.19-56.34H409.42L374.91,65.7l-4.09,5.6-46.71,63.9c-34.73.23-70.42-3-95.76-22.5l-12-79.19-1-6.47-1.29-8.55H195.2L198,37.24l-.11-4.4,12.18,83.44c-17,16.89-39.15,28.73-67.39,26.48L93.45,80.59,44.23,18.49H20.39l53,66.83,4.18,5.27L129,155.51c-3.16,27.24-16.63,53.33-32.88,73.74l-71-18.63L22.73,210l-4.31-1.13v19.32l2.56.67,71.38,18.74c8.29,26.73,6.3,57.28,2.12,86L22.8,367.15l-4.38,2.05v20.63l9.18-4.3,67.92-31.78,1.09-.51A190.52,190.52,0,0,1,104.47,382c1.33,7.25,2.58,14.68,3.19,19.36l-51.74,52-37.5,37.69v2.43H42.37l20.91-21h0l58.27-58.57c10.1-.83,33.7-2.28,59.06-3.17,7.9-.28,16.15-.45,24.46-.47,23.47-.05,49.4,1.12,67.34,4.45l20.27,63,1.54,4.79,3.54,11h19.63l-5.19-16.14L310,470.43,291.2,412.17c23.43-27.05,48.62-54.87,86-69.58l64.45,25.5,4.18,1.65,47.6,18.84v-20.1l-37.78-15-5.21-2.06-62.74-24.82c-3.11-24.21,8.64-50.64,20.2-76.57ZM266.92,336.72l-10.1-31.4a39.76,39.76,0,0,0,8.16-7.15l36.5,14.44a169,169,0,0,0-24.68,16.16C272.9,331.76,269.7,334.38,266.92,336.72Zm-71.07-62a39.17,39.17,0,0,0,2.08,10.44l-35.27,16.5c1.05-11.9.92-24-2-36.19Zm-30.58-27.35c5-8.75,9.83-18.25,13.09-29.59l24.91,31.43a39.28,39.28,0,0,0-4.08,7.07Zm41.58,54.25h0L169.2,339.51a54.79,54.79,0,0,0-9.59-15.23l.09-.56Zm17.74,8.67a39.43,39.43,0,0,0,10.6,1.45,38,38,0,0,0,4-.2l10.47,32.54c-13.32-.16-37.61.08-61.69,3Zm22.23-75.64L241.11,197a109.17,109.17,0,0,0,25.15,17.39L250.43,236A37.88,37.88,0,0,0,246.82,234.69Zm26.73,46.78c.26-1.13.47-2.28.64-3.43l45.58-9.53c-4.62,9.43-6.38,18.89-6.95,28.5Zm30-28.66-31.15,6.51a39.53,39.53,0,0,0-6.93-12.21l18.42-25.21C289,232.31,295,243,303.54,252.81ZM232.78,136.13c23.18,13.26,50.47,17.92,77,18.68l-32.37,44.3c-15.06-6.37-26.14-17.76-38.57-30.33l-2.34-2.37-4.59-30.28,0-.12Zm-5,97.52a39.25,39.25,0,0,0-10.25,3.48l-25.18-31.77a132,132,0,0,0,29.42-11.45Zm-14.52-96,5.48,36.25c-11.18,7.5-24.44,12.15-39.05,15.49l-22.46-28.34C178.25,159.21,198.58,149.44,213.24,137.65Zm-69.67,36.28.5.63,19.15,24.15-.08.71c-1.93,17.37-8.88,29.63-16.65,43.06L115,234.2l-.07,0C127,217.56,138.38,195.1,143.57,173.93ZM123.4,385.56c-.42-2.17-1.06-4.9-1.43-6.92-1.84-10-4.7-23.39-8.85-33.12l28.45-13.32,1.52,1.53c5.85,5.87,10,10.3,11.22,20.75Zm15.89-125.65.56,1.4c6.1,15.14,5.39,31.77,2.9,49.71l-29,13.58c2.87-22.76,3.42-48.28-2.06-71.93h0Zm72.18,131.64h-6.55c-8.5.05-16.9.25-25,.53-15.57.55-28,1.33-37.85,2.07l.07-.07a7.94,7.94,0,0,1-.82-.06l24-24.11,1-.23c23.75-5.79,59.86-6.75,80.11-6.78,4,0,6.81,0,9.35.07l10.29,32C249.77,392.55,229.58,391.66,211.47,391.55Zm73.59-1.18-.71.53-.17-.53-11-34.32c3.55-3.17,8.73-7.63,15-12.42,11.42-8.73,26.21-17.7,35.68-19.63l4.24-.86,25.37,10C324.89,348,303.58,369.47,285.06,390.37ZM368.49,319l-.77-.31-36.59-14.48c0-13.15,1.4-22.84,9.12-33.92l5-7.14L385,254.88l.12,0C376.44,274.07,368.18,297,368.49,319Z"
    },
    classes: {
      main: "fill-radial"
    }
  },
  [
    "ComplicationSerious"
    /* ComplicationSerious */
  ]: {
    viewBox: "0 0 512 512",
    paths: {
      main: "M21.42,17.34,78.56,89.45c-2.73,48.59-23.75,85.79-52.39,120l-6.72-1.76V227l2.56.67C37.36,272.78,31.1,318.54,23.83,366l-4.38,2.05v20.63l9.18-4.29c6.52,10.7,13.66,27,19.06,41.33,4.29,11.33,7.48,21,9.26,26.53l-37.5,37.69v2.43h24L72,463.67c9.27-.36,41.77-1.47,82.7-.75,46.74.83,102.61,4.3,139,13.67l5.08,15.78h19.63L311,469.28c35.94-41.51,71.91-80.52,131.73-102.34l51.78,20.49v-20.1l-43-17c-6.37-39.21,12.76-76.67,30.62-116.68l12.37-2.59V212l-6.33,1.32-5.45-2.8c-56.09-28.83-76.33-78-93.3-132.7L433.6,17.34H410.45l-38.6,52.81c-58.28,1.26-112.48-2.46-154.45-37.79l-2.27-15h-18.9l2.83,18.75c-27.13,29-57.56,48-104.58,43.36L45.26,17.34Zm199.92,41c40.6,26.3,88.49,30.89,136.75,30.63L325,134.32c-36.59.39-69.86-3-95.85-24.64l-7.76-51.33Zm-18.84.44,8.29,54.77c-17.81,18.62-37.29,30.18-68,26.86L109.72,98.68c38.59-.74,68.36-17.15,92.78-39.89ZM375.83,96.38c15.53,47,37.05,92.69,84.55,122.72l-51.77,10.82-.82-.42c-37.27-19.14-50.44-51.64-61.93-88.83l-.72-2.31,30.68-42ZM95.09,110.3l34.39,43.39c-2.52,29.59-15.41,52.66-33.14,74.21L45.93,214.67c23.72-29.78,42.64-63.39,49.16-104.37ZM232.93,135c23.94,13.69,51.05,17.4,78.41,17.94l-32.91,45c-15.06-6.36-26.14-17.75-38.57-30.32l-2.35-2.37L232.93,135Zm-18.77.81,5.59,36.95c-11.18,7.5-24.44,12.15-39.05,15.49l-22.9-28.89c22.71-1.4,41.09-10.68,56.36-23.55ZM331.54,157c9.74,29.15,23.14,58,50.58,78.49l-55.93,11.69c-13-11.18-20-24.74-27.16-39.89l-1.67-3.53ZM145.1,173.41l19.15,24.16-.08.71c-1.93,17.36-8.88,29.63-16.65,43.06L116,233.06c13.21-17.36,23.94-36.83,29.12-59.65Zm77.68,19.35,6,39.75A38.88,38.88,0,0,0,218.54,236l-25.18-31.77a132.49,132.49,0,0,0,29.42-11.45Zm19.36,3.05a109.17,109.17,0,0,0,25.15,17.39l-15.83,21.66c-1.18-.49-2.38-.94-3.61-1.32l-5.71-37.73Zm-62.75,20.86L204.3,248.1a39.37,39.37,0,0,0-4.08,7.07l-33.92-8.9c5-8.76,9.83-18.25,13.09-29.6Zm105.52,4.08c5.12,10.42,11.11,21.1,19.66,30.92l-31.15,6.5A39.64,39.64,0,0,0,266.49,246l18.42-25.21ZM43.14,233.26,92,246.09c9.23,28.21,5.8,57.08,1.2,87.45l-49.07,23c6-40.15,10.29-81.42-1-123.24Zm416.14,5.16c-14.93,32.63-30.11,66.73-27.43,104.13l-43.74-17.31c-3.6-25,8.78-49.44,20.72-76.28l50.45-10.54Zm-346.57,13.1,27.61,7.25.56,1.4c6.1,15.13,5.39,31.77,2.9,49.71l-30.32,14.18c3.22-23.51,5-47.81-.75-72.54ZM386,253.74c-9,19.81-17.8,40.8-17.25,63.84l-36.59-14.47c0-13.15,1.4-22.84,9.12-33.92l5-7.15,39.74-8.3ZM161.64,264.36l35.24,9.26A39.33,39.33,0,0,0,199,284.06l-35.27,16.5c1.05-11.9.92-24.05-2.05-36.2Zm159.16,3c-4.62,9.44-6.38,18.89-6.95,28.5l-39.27-15.54c.26-1.12.47-2.27.64-3.43l45.58-9.53ZM266,297l36.5,14.44a169,169,0,0,0-24.68,16.16c-3.9,3-7.1,5.6-9.88,7.94l-10.11-31.4A39.76,39.76,0,0,0,266,297Zm-58.12,3.48-37.66,37.86a54.85,54.85,0,0,0-9.59-15.24l.09-.55,47.15-22.07Zm17.73,8.67a39.43,39.43,0,0,0,10.6,1.46c1.35,0,2.69-.07,4-.2L250.7,343c-13.32-.16-37.62.07-61.7,3l36.61-36.81ZM329.1,322l25.36,10c-29.4,14.92-50.37,35.89-69.25,57.2l-11-34.32c3.55-3.18,8.73-7.63,15-12.43,11.42-8.73,26.21-17.7,35.68-19.63l4.24-.86Zm-186.5,9.07,1.52,1.52c5.85,5.88,10,10.31,11.22,20.75L124.2,384.64c-.35-2.27-.74-4.63-1.2-7.14-2-10.95-4.45-22.94-9.32-32.9l28.92-13.54Zm235.93,10.49,39.22,15.52c-49.42,22.5-82.92,56.68-113.45,91.47l-12.44-38.65c24.11-27.84,47.68-53.61,86.67-68.34Zm-282,11.06c3,6.84,6.22,18.17,8.07,28.26,1.58,8.61,2.5,16.08,3,20.45L71.72,437.4c-1.68-5-3.78-11-6.55-18.29-5.37-14.22-12-30-19.61-42.64l51-23.86Zm150.86,9.15c4,0,6.81,0,9.35.06l10.39,32.3c-26.25-4.15-58.63-4.19-87-3.18-15.58.55-28,1.32-37.86,2.06l24.11-24.24,1-.23C191,362.74,227.16,361.79,247.41,361.76Zm-42.19,47.39c24.92-.06,50.36,1.26,68.41,5.1L287.06,456c-38.71-8.23-89-11-132.09-11.74-27.22-.48-49.23-.19-63.87.17l30.8-31c7.77-.76,30.71-2.84,58.86-3.84,7.9-.28,16.15-.45,24.46-.47Z"
    },
    classes: {
      main: "fill-radial"
    }
  },
  [
    "LostOpportunity"
    /* LostOpportunity */
  ]: {
    viewBox: "0 0 512 512",
    paths: {
      main: "M373.33,52.76A234.57,234.57,0,0,0,52.77,138.67C-12,250.93,26.41,394.41,138.67,459.23s255.75,26.36,320.56-85.91S485.59,117.58,373.33,52.76Zm-211.87,367A189.1,189.1,0,0,1,81,184.37L327.62,431A188.73,188.73,0,0,1,161.46,419.76Zm211.18-14.87L107.14,139.38a187.3,187.3,0,0,1,32.24-32.29L404.89,372.6A187.71,187.71,0,0,1,372.64,404.89ZM431,327.6,184.41,81A189.12,189.12,0,0,1,431,327.6Z"
    },
    classes: {
      main: "fill-linear"
    }
  },
  [
    "WorsePosition"
    /* WorsePosition */
  ]: {
    viewBox: "0 0 512 512",
    paths: {
      horizon: "M18.36,227.8v18.68h86.37a98.45,98.45,0,0,0-4.43-18.68Zm379.4,0a110.51,110.51,0,0,1,9.44,18.68h86.44V227.8H397.76Z",
      boot: "M218.67,18.73a162.14,162.14,0,0,0-20,1.32C164,24.39,123.5,39.4,91.23,67.36L124.7,257.55l.35,10.12c42.26,15.79,100.82,24.55,152.87,24.25,27.19-.15,52.64-2.74,73-7.78s35.2-12.82,41.81-20.94l.44.35a113,113,0,0,0-6.53-17.06h.19a95.88,95.88,0,0,0-4.85-8.66c-.09-.14-.16-.3-.25-.44l-.31-.47c-21.46-34.89-63.5-55.87-124.28-29.37l-.16.06a215.37,215.37,0,0,0-34,20.19h-.81c11-15.72,23.26-28.12,35.91-37.28l1.12-11.16c-14.68-4-38.08-4.06-53.53-.09L201,161.14a130.33,130.33,0,0,1,30.34-3.84c1.5,0,3,0,4.5,0a117.66,117.66,0,0,1,25.25,3.12l3.19-32c-21.06-8.07-42.12-6.6-64.57-1.59l-4.06-18.25A170.07,170.07,0,0,1,231,104.17c1.72,0,3.44,0,5.16.07a107,107,0,0,1,30.06,5.12l3.16-31.47c-25.6-7.69-51-8.1-76.91-2.78l-3.78-18.28A188.53,188.53,0,0,1,221.52,53c1.14,0,2.29-.05,3.43-.06A167.36,167.36,0,0,1,271.23,59l.47-4.6c5-23.31-18.75-35.71-53-35.65ZM397.26,284.45c-10.84,8.13-25.26,13.7-41.87,17.82-22.37,5.54-49.07,8.18-77.38,8.34a526.46,526.46,0,0,1-65.09-3.75L225.36,329c80.16,9.44,141.5-1.19,172-21.78a113.13,113.13,0,0,0-.13-22.75ZM125.7,287.77l1,30.47,58.6,8.43,9.59-22.31c-24.55-3.82-48.21-9.37-69.19-16.59Z",
      ice: "M92.61,309.3C82.3,312.37,74,315.76,68,319.36l-.21.12L37.58,334.2,18.36,322v22.16L32,352.8l4.41,2.81,4.72-2.31,22-10.72c11.71,9.8,40.46,18.23,79.4,23.87l-60,28.25,26.63,21L18.36,454.23v39H145.14L188.86,447l51,46.28h27.84L159.11,394.8l35.06-23c20,1.37,41.34,2.15,63.56,2.15,20.7,0,40.66-.67,59.44-1.87l39.06,24.69-66.9,35.71,62.28,60.75H475.52L385,440.64l51.32-39.78-71.5-33.28c45.88-6,79.18-15.67,89.81-27l18,6.43,21.06,22.57V342.17l-8.94-9.56L483.17,331l-2.15-.78L439.8,315.42a141.57,141.57,0,0,0-16.66-6c5.37,3.24,8.28,6.7,8.28,10.28,0,18.59-77.73,33.66-173.62,33.66S84.14,338.29,84.14,319.7c0-3.63,3-7.13,8.47-10.4Z"
    },
    classes: {
      horizon: "fill-dark",
      boot: "fill-bright",
      ice: "fill-radial"
    }
  },
  [
    "InsightHarm1"
    /* InsightHarm1 */
  ]: {
    viewBox: "0 0 512 512",
    paths: {
      eye: "M406.09,282.69V352.6c4.19,8.54,8.53,16.73,8.53,27.56,0,13.24-8.75,22.78-18.09,22.78-9.13,0-18.69-10-18.69-23.94,0-12.22,5.1-20.64,9.56-29.59V289.63c-6.51-19.32-16.22-25.45-26.54-21.72V226.24A401.64,401.64,0,0,0,409.07,204h45.2C435.64,222.23,417,244.72,406.09,282.69ZM494.83,158.8c-33,49.83-80.77,87.12-134,108.82a291.28,291.28,0,0,1-90,21.07q-7.2.51-14.42.62a256.33,256.33,0,0,1-89-14,239,239,0,0,1-25.35-10.52A239.65,239.65,0,0,1,82.64,223.9C74.76,216.85,66,208.81,57.89,200c-11.54-12.52-21.66-26.51-25.72-41.23,20.19-37.74,48.7-69.38,84.66-92.29C241.41-14.68,416.3,37.68,494.83,158.8Zm-29.17-.36C373.78,11.86,140.41,12.08,57.19,160.28l.46.39-.46.39a353,353,0,0,0,54.67,42.55c45.21,28.32,92.77,42.1,140.82,42.29h.22C324.81,246.14,397.81,215.94,465.66,158.44Z",
      iris: "M303.7,99.51a65,65,0,0,0-45-18h0a65.26,65.26,0,1,0,45,18Zm-45.4,68.13a23.4,23.4,0,1,1,23.39-23.41A23.42,23.42,0,0,1,258.3,167.64Zm45.4-68.13a65,65,0,0,0-45-18h0a65.26,65.26,0,1,0,45,18Zm-45.4,68.13a23.4,23.4,0,1,1,23.39-23.41A23.42,23.42,0,0,1,258.3,167.64Zm45.4-68.13a65,65,0,0,0-45-18h0a65.26,65.26,0,1,0,45,18Zm-45.4,68.13a23.4,23.4,0,1,1,23.39-23.41A23.42,23.42,0,0,1,258.3,167.64Z"
    },
    classes: {
      eye: "fill-dark",
      iris: "fill-med"
    }
  },
  [
    "InsightHarm2"
    /* InsightHarm2 */
  ]: {
    viewBox: "0 0 512 512",
    paths: {
      eye: "M305.51,89.71A78.5,78.5,0,0,0,251.22,68h0a78.81,78.81,0,1,0,54.29,21.71ZM250.71,172a28.25,28.25,0,1,1,28.23-28.27A28.28,28.28,0,0,1,250.71,172Zm54.8-82.26A78.5,78.5,0,0,0,251.22,68h0a78.81,78.81,0,1,0,54.29,21.71ZM250.71,172a28.25,28.25,0,1,1,28.23-28.27A28.28,28.28,0,0,1,250.71,172Zm54.8-82.26A78.5,78.5,0,0,0,251.22,68h0a78.81,78.81,0,1,0,54.29,21.71ZM250.71,172a28.25,28.25,0,1,1,28.23-28.27A28.28,28.28,0,0,1,250.71,172Z",
      iris: "M398.59,282.69V352.6c4.19,8.54,8.53,16.73,8.53,27.56,0,13.24-8.75,22.78-18.09,22.78-9.13,0-18.69-10-18.69-23.94,0-12.22,5.1-20.64,9.56-29.59V289.63c-6.51-19.32-16.22-25.45-26.54-21.72V226.24A401.64,401.64,0,0,0,401.57,204h45.2C428.14,222.23,409.46,244.72,398.59,282.69Zm-264-17.94A239.65,239.65,0,0,1,75.14,223.9c-7.88-7.05-16.67-15.09-24.75-23.86,11.79,18.34,22,39.48,27.42,60.27v50c-4.76,10.14-12.06,17.21-12.06,28.41,0,9.09,11.63,18.09,21,18.09,9.2,0,21.6-9.67,21.59-19.25,0-11.36-7.31-17.81-11.87-27V278.22C103,265.1,117.78,261.12,134.61,264.75ZM487.33,158.8c-33,49.83-80.77,87.12-134,108.82a291.28,291.28,0,0,1-90,21.07q-7.2.51-14.42.62a256.33,256.33,0,0,1-88.95-14,239,239,0,0,1-25.35-10.52A239.65,239.65,0,0,1,75.14,223.9c-7.88-7.05-16.67-15.09-24.75-23.86-11.54-12.52-21.66-26.51-25.72-41.23,20.19-37.74,48.7-69.38,84.66-92.29C233.91-14.68,408.8,37.68,487.33,158.8Zm-29.17-.36C366.28,11.86,132.91,12.08,49.69,160.28l.46.39-.46.39a353,353,0,0,0,54.67,42.55c45.21,28.32,92.77,42.1,140.82,42.29h.22C317.31,246.14,390.31,215.94,458.16,158.44Z"
    },
    classes: {
      eye: "fill-med",
      iris: "fill-med"
    }
  },
  [
    "InsightHarm3"
    /* InsightHarm3 */
  ]: {
    viewBox: "0 0 512 512",
    paths: {
      eye: "M398.31,282.69V352.6c4.19,8.54,8.53,16.73,8.53,27.56,0,13.24-8.75,22.78-18.09,22.78-9.13,0-18.69-10-18.69-23.94,0-12.22,5.1-20.64,9.56-29.59V289.63c-6.51-19.32-16.22-25.45-26.54-21.72V226.24A401.64,401.64,0,0,0,401.29,204h45.2C427.86,222.23,409.18,244.72,398.31,282.69Zm-264-17.94A239.65,239.65,0,0,1,74.86,223.9C67,216.85,58.19,208.81,50.11,200c11.79,18.34,22,39.48,27.42,60.27v50c-4.76,10.14-12.06,17.21-12.06,28.41,0,9.09,11.63,18.09,21,18.09,9.2,0,21.6-9.67,21.59-19.25,0-11.36-7.31-17.81-11.87-27V278.22C102.75,265.1,117.5,261.12,134.33,264.75Zm114.3,24.56a256.33,256.33,0,0,1-88.95-14,109.79,109.79,0,0,1,42.38,48.58v80.59c-6.36,10.47-13.62,16.95-13.62,28.87,0,17.89,11.76,24.5,23.93,24.5,11.91,0,21.6-5.66,21.6-24.5,0-9.3-7.44-16.63-13.22-31.06V324.1C227.16,309.18,237.5,294.45,248.63,289.31ZM487.05,158.8c-33,49.83-80.77,87.12-134,108.82a291.28,291.28,0,0,1-90,21.07q-7.2.51-14.42.62a256.33,256.33,0,0,1-88.95-14,239,239,0,0,1-25.35-10.52A239.65,239.65,0,0,1,74.86,223.9C67,216.85,58.19,208.81,50.11,200c-11.54-12.52-21.66-26.51-25.72-41.23,20.19-37.74,48.7-69.38,84.66-92.29C233.63-14.68,408.52,37.68,487.05,158.8Zm-29.17-.36C366,11.86,132.63,12.08,49.41,160.28l.46.39-.46.39a353,353,0,0,0,54.67,42.55c45.21,28.32,92.77,42.1,140.82,42.29h.22C317,246.14,390,215.94,457.88,158.44Z",
      iris: "M314.46,80a91.84,91.84,0,0,0-63.52-25.39h0A92.2,92.2,0,1,0,314.46,80Zm-64.12,96.24a33.05,33.05,0,1,1,33-33.07A33.08,33.08,0,0,1,250.34,176.25ZM314.46,80a91.84,91.84,0,0,0-63.52-25.39h0A92.2,92.2,0,1,0,314.46,80Zm-64.12,96.24a33.05,33.05,0,1,1,33-33.07A33.08,33.08,0,0,1,250.34,176.25ZM314.46,80a91.84,91.84,0,0,0-63.52-25.39h0A92.2,92.2,0,1,0,314.46,80Zm-64.12,96.24a33.05,33.05,0,1,1,33-33.07A33.08,33.08,0,0,1,250.34,176.25Z"
    },
    classes: {
      eye: "fill-med",
      iris: "fill-bright"
    }
  },
  [
    "InsightHarm4"
    /* InsightHarm4 */
  ]: {
    viewBox: "0 0 512 512",
    paths: {
      eye: "M244,27.44c-46.86,0-93.53,12.25-134.7,39.08-36,22.91-64.47,54.55-84.66,92.29,4.06,14.72,14.18,28.71,25.72,41.23,8.08,8.77,16.87,16.81,24.75,23.86a239.65,239.65,0,0,0,59.47,40.85A239,239,0,0,0,160,275.27a256.33,256.33,0,0,0,88.95,14q7.22-.1,14.42-.62a291.28,291.28,0,0,0,90-21.07A299.94,299.94,0,0,0,430.12,222a286.46,286.46,0,0,0,57.21-63.16C434.75,77.71,339,27.44,244,27.44ZM245.4,245.9h-.22c-48.05-.19-95.61-14-140.82-42.29a353,353,0,0,1-54.67-42.55l.46-.39-.46-.39c83.22-148.2,316.59-148.42,408.47-1.84C390.31,215.94,317.31,246.14,245.4,245.9Zm17.93,42.79c7.16,3,14.11,11.57,20,28.08,3.54,9.85,6.71,22.54,9.33,38.58v74.84C287.27,440.69,281,449.64,281,462.5s10,22.19,21,22.19c10.74,0,22.18-9.73,22.18-23.34,0-14.45-7.09-23.42-12.81-34.57V342.22h-.22a223.26,223.26,0,0,1,7.48-25.45c9.57-26.37,22.57-44.47,34.73-48.86v-.29A291.28,291.28,0,0,1,263.33,288.69Zm-38.82,28.08c6.37-12.19,15.11-23.17,24.4-27.46a256.33,256.33,0,0,1-88.95-14,109.62,109.62,0,0,1,38.91,41.5q1.84,3.45,3.47,7.08v80.59c-6.36,10.47-13.62,16.95-13.62,28.87,0,17.89,11.76,24.5,23.93,24.5,11.91,0,21.6-5.66,21.6-24.5,0-9.3-7.44-16.63-13.22-31.06V324.1C222.09,321.64,223.26,319.18,224.51,316.77Zm-89.9-52A239.65,239.65,0,0,1,75.14,223.9c-7.88-7.05-16.67-15.09-24.75-23.86,11.79,18.34,22,39.48,27.42,60.27v50c-1.08,2.29-2.28,4.43-3.51,6.49-4.18,7.06-8.55,13.25-8.55,21.92,0,9.09,11.63,18.09,21,18.09,9.2,0,21.6-9.67,21.59-19.25,0-8.63-4.22-14.43-8.25-20.76a67,67,0,0,1-3.62-6.27V278.22C103,265.1,117.78,261.12,134.61,264.75Zm267-60.78a401.64,401.64,0,0,1-48.21,22.27v41.67c10.32-3.73,20,2.4,26.54,21.72v59.78c-4.46,8.95-9.56,17.37-9.56,29.59,0,13.94,9.56,23.94,18.69,23.94,9.34,0,18.09-9.54,18.09-22.78,0-10.83-4.34-19-8.53-27.56V282.69c7.59-26.52,19-45.48,31.53-60.73a225.7,225.7,0,0,1,16.65-18Z",
      iris: "M326.5,67.65a108.84,108.84,0,0,0-75.28-30.08h0A109.22,109.22,0,1,0,326.5,67.65Zm-76,114.06a39.17,39.17,0,1,1,39.15-39.19A39.2,39.2,0,0,1,250.51,181.71Zm76-114.06a108.84,108.84,0,0,0-75.28-30.08h0A109.22,109.22,0,1,0,326.5,67.65Zm-76,114.06a39.17,39.17,0,1,1,39.15-39.19A39.2,39.2,0,0,1,250.51,181.71Zm76-114.06a108.84,108.84,0,0,0-75.28-30.08h0A109.22,109.22,0,1,0,326.5,67.65Zm-76,114.06a39.17,39.17,0,1,1,39.15-39.19A39.2,39.2,0,0,1,250.51,181.71Z"
    },
    classes: {
      eye: "fill-bright",
      iris: "fill-med"
    }
  },
  [
    "ProwessHarm1"
    /* ProwessHarm1 */
  ]: {
    viewBox: "0 0 512 512",
    paths: {
      scar: "M443.44,434.53Q408.7,409.87,376,383.64c-20-11.91-31.49.3-44.26,16.86,8.8-18.17,13.38-36.95,3.24-50.86l-4.46-3.84-44.85-35.35L237.9,336.93l17.19-25.34c7.31-12.4,3.43-27.17-5.65-41.14q-16.37-16.32-32.22-33c-1.66-1.23-3.31-2.38-4.95-3.5l-66.44,18.87L167.59,227c10.57-17.62,0-41.59-9.84-55.7q-8.4-9.81-16.62-19.75l-43.67,7.29c18.43-7.3,31.37-22.38,16.85-40l2.06,2.33Q91.79,90.29,68.44,58.49q43,32.32,83.86,67.06L188.92,116l-22.11,22q23.38,20.3,46.09,41.39l71.86-30.46L266,178l.3-.24c-21.55,27.54,18.77,86,46,78.42l31.91-17.7L319.4,275l36.88,52.71c.26.3.53.59.79.9,13.64,12.5,31.23,1.71,43.05-14.53l-19.59,42Q412.66,394.28,443.44,434.53Z"
    },
    classes: {
      scar: "fill-dark"
    }
  },
  [
    "ProwessHarm2"
    /* ProwessHarm2 */
  ]: {
    viewBox: "0 0 512 512",
    paths: {
      scarTissue: "M399,355.08c-15-32.31-18.67-65.87-6.23-94.7-47.19,58.41-76.14,4.41-4.09-70.72-101.67,62.7-147.78,31.47-14-88.26-103,54.66-182.49,69.22-130.93,15.19-37.19,10.63-58.21,5.21-76-2.43A643.42,643.42,0,0,0,55.28,58.49a789.14,789.14,0,0,0,47,77.56c7,18.27,3,38.71-31.46,63.44,124.85-33.45,88.52,47-9.36,104.92,166.21-61.68,207.52-47.41,100.64,78,84-61.07,150.14-44.57,122.89,31.29,31.63-24.51,57.9-29.74,78-20.87q43.39,30.7,90.32,59C436.25,418.27,418.25,386,399,355.08ZM352.11,362c-16.61-9.9-26.17.25-36.79,14,7.32-15.11,11.12-30.72,2.69-42.28l-3.7-3.19L277,301.11l-39.68,22,14.29-21.06c6.08-10.31,2.85-22.58-4.7-34.2q-13.6-13.56-26.78-27.46c-1.38-1-2.75-2-4.11-2.91l-55.23,15.68,18.09-21.41c8.78-14.64,0-34.57-8.18-46.3q-7-8.15-13.82-16.42l-36.3,6.06c15.32-6.06,26.08-18.6,14-33.28l-1.89-2.13c.69.72,1.31,1.42,1.89,2.13l1.71,1.94q-20.43-25.65-39.84-52.09,35.76,26.88,69.71,55.75l30.44-7.93-18.38,18.27q19.44,16.88,38.31,34.41l59.73-25.32L260.68,191l.25-.2c-17.91,22.9,15.6,71.52,38.24,65.19l26.52-14.71-20.6,30.37,30.65,43.82.66.74c11.34,10.39,26,1.42,35.79-12.07L355.9,339q26.72,31.78,52.3,65.24Q379.31,383.76,352.11,362Z"
    },
    classes: {
      scarTissue: "fill-med"
    }
  },
  [
    "ProwessHarm3"
    /* ProwessHarm3 */
  ]: {
    viewBox: "0 0 512 512",
    paths: {
      scar: "M447.44,434.53Q412.7,409.87,380,383.64c-20-11.91-31.49.3-44.26,16.86,8.8-18.17,13.38-36.95,3.24-50.86l-4.46-3.84-44.85-35.35L241.9,336.93l17.19-25.34c7.31-12.4,3.43-27.17-5.65-41.14q-16.37-16.32-32.22-33c-1.66-1.23-3.31-2.38-4.95-3.5l-66.44,18.87L171.59,227c10.57-17.62,0-41.59-9.84-55.7q-8.4-9.81-16.62-19.75l-43.67,7.29c18.43-7.3,31.37-22.38,16.85-40l2.06,2.33Q95.79,90.29,72.44,58.49q43,32.32,83.86,67.06L192.92,116l-22.11,22q23.38,20.3,46.09,41.39l71.86-30.46L270,178l.3-.24c-21.55,27.54,18.77,86,46,78.42l31.91-17.7L323.4,275l36.88,52.71c.26.3.53.59.79.9,13.64,12.5,31.23,1.71,43.05-14.53l-19.59,42Q416.66,394.28,447.44,434.53Z",
      scarTissue: "M436.33,375.37c-18.07-38.87-22.46-79.24-7.49-113.92-56.77,70.27-91.6,5.3-4.93-85.08C301.61,251.8,246.13,214.23,407,70.19,283.18,136,187.5,153.46,249.53,88.47c-44.75,12.79-70,6.27-91.47-2.93a773.7,773.7,0,0,0-135.18-67,949.58,949.58,0,0,0,56.49,93.31c8.39,22,3.6,46.57-37.84,76.32C191.72,148,148,244.71,30.26,314.42c200-74.2,249.65-57,121.08,93.78C252.42,334.73,332,354.59,299.17,445.84c38.06-29.48,69.66-35.77,93.87-25.1q52.21,36.94,108.66,70.93C481.19,451.39,459.54,412.52,436.33,375.37ZM380,383.64c-20-11.91-31.49.3-44.26,16.86,8.8-18.17,13.38-36.95,3.24-50.86l-4.46-3.84-44.85-35.35L241.9,336.93l17.19-25.34c7.31-12.4,3.43-27.17-5.65-41.14q-16.37-16.32-32.22-33c-1.66-1.23-3.31-2.38-4.95-3.5l-66.44,18.87L171.59,227c10.57-17.62,0-41.59-9.84-55.7q-8.4-9.81-16.62-19.75l-43.67,7.29c18.43-7.3,31.37-22.38,16.85-40L116,116.26c.83.86,1.57,1.71,2.27,2.56l2.06,2.33Q95.79,90.29,72.44,58.49q43,32.32,83.86,67.06L192.92,116l-22.11,22q23.38,20.3,46.09,41.39l71.86-30.46L270,178l.3-.24c-21.55,27.54,18.77,86,46,78.42l31.91-17.7L323.4,275l36.88,52.71c.26.3.53.59.79.9,13.64,12.5,31.23,1.71,43.05-14.53l-19.59,42q32.13,38.23,62.91,78.49Q412.7,409.87,380,383.64Z"
    },
    classes: {
      scar: "fill-dark",
      scarTissue: "fill-med"
    }
  },
  [
    "ProwessHarm4"
    /* ProwessHarm4 */
  ]: {
    viewBox: "0 0 512 512",
    paths: {
      scar: "M441.44,434.53Q406.7,409.87,374,383.64c-20-11.91-31.49.3-44.26,16.86,8.8-18.17,13.38-36.95,3.24-50.86l-4.46-3.84-44.85-35.35L235.9,336.93l17.19-25.34c7.31-12.4,3.43-27.17-5.65-41.14q-16.37-16.32-32.22-33c-1.66-1.23-3.31-2.38-4.95-3.5l-66.44,18.87L165.59,227c10.57-17.62,0-41.59-9.84-55.7q-8.4-9.81-16.62-19.75l-43.67,7.29c18.43-7.3,31.37-22.38,16.85-40l2.06,2.33Q89.79,90.29,66.44,58.49q43,32.32,83.86,67.06L186.92,116l-22.11,22q23.38,20.3,46.09,41.39l71.86-30.46L264,178l.3-.24c-21.55,27.54,18.77,86,46,78.42l31.91-17.7L317.4,275l36.88,52.71c.26.3.53.59.79.9,13.64,12.5,31.23,1.71,43.05-14.53l-19.59,42Q410.66,394.28,441.44,434.53Z",
      scarTissue: "M430.33,375.37c-18.07-38.87-22.46-79.24-7.49-113.92-56.77,70.27-91.6,5.3-4.93-85.08C295.61,251.8,240.13,214.23,401,70.19,277.18,136,181.5,153.46,243.53,88.47c-44.75,12.79-70,6.27-91.47-2.93a773.7,773.7,0,0,0-135.18-67,949.58,949.58,0,0,0,56.49,93.31c8.39,22,3.6,46.57-37.84,76.32C185.72,148,142,244.71,24.26,314.42c200-74.2,249.65-57,121.08,93.78C246.42,334.73,326,354.59,293.17,445.84c38.06-29.48,69.66-35.77,93.87-25.1q52.21,36.94,108.66,70.93C475.19,451.39,453.54,412.52,430.33,375.37ZM374,383.64c-20-11.91-31.49.3-44.26,16.86,8.8-18.17,13.38-36.95,3.24-50.86l-4.46-3.84-44.85-35.35L235.9,336.93l17.19-25.34c7.31-12.4,3.43-27.17-5.65-41.14q-16.37-16.32-32.22-33c-1.66-1.23-3.31-2.38-4.95-3.5l-66.44,18.87L165.59,227c10.57-17.62,0-41.59-9.84-55.7q-8.4-9.81-16.62-19.75l-43.67,7.29c18.43-7.3,31.37-22.38,16.85-40L110,116.26c.83.86,1.57,1.71,2.27,2.56l2.06,2.33Q89.79,90.29,66.44,58.49q43,32.32,83.86,67.06L186.92,116l-22.11,22q23.38,20.3,46.09,41.39l71.86-30.46L264,178l.3-.24c-21.55,27.54,18.77,86,46,78.42l31.91-17.7L317.4,275l36.88,52.71c.26.3.53.59.79.9,13.64,12.5,31.23,1.71,43.05-14.53l-19.59,42q32.13,38.23,62.91,78.49Q406.7,409.87,374,383.64Z",
      welts: "M414.13,84.19a39.5,39.5,0,1,0,39.57,39.5,39.2,39.2,0,0,0-39.57-39.5ZM308.33,29.83A28.66,28.66,0,1,0,337,58.51a28.51,28.51,0,0,0-28.67-28.68ZM90.17,322.56a49.51,49.51,0,1,0,49.53,49.52A49.36,49.36,0,0,0,90.17,322.56Zm258-171.24A22.79,22.79,0,1,0,371,174.11a22.61,22.61,0,0,0-22.83-22.79ZM261.49,89.88a16.72,16.72,0,1,0,16.73,16.73,16.63,16.63,0,0,0-16.73-16.73ZM91.15,187.65a21.18,21.18,0,1,0,21.18,21.18,21,21,0,0,0-21.18-21.18Zm77.51,94.54a32.09,32.09,0,1,0,32.07,32.1,32,32,0,0,0-32.07-32.1ZM391.6,243.05a16.51,16.51,0,1,0,16.49,16.52,16.41,16.41,0,0,0-16.49-16.52ZM238.11,374.85a48.43,48.43,0,1,0,48.44,48.45A48.29,48.29,0,0,0,238.11,374.85Zm137,59.88A22.86,22.86,0,1,0,398,457.59a22.69,22.69,0,0,0-22.86-22.86Z"
    },
    classes: {
      scar: "fill-bright",
      scarTissue: "fill-dark",
      welts: "fill-bright"
    }
  },
  [
    "ResolveHarm1"
    /* ResolveHarm1 */
  ]: {
    viewBox: "0 0 512 512",
    paths: {
      spikes: "M256.09,19.1A237.5,237.5,0,0,0,197,27.22C70.63,61.08-4.36,191,29.5,317.31,62.59,440.8,187.39,515.21,311,486.92A132.35,132.35,0,0,1,279.74,475,207,207,0,0,1,122,417.49l-13.48-14.55L94.89,385.42a205.62,205.62,0,0,1-24-47.36l-7.2-17.33L60.71,296.5a205.83,205.83,0,0,1-.18-54.37l3-24.36,7.67-19.51a208.28,208.28,0,0,1,29.16-53.84l105,60.61-68.63-98a205.85,205.85,0,0,1,63.68-34.49l27.24-8.18,23.18-1.89q6.46-.48,12.89-.54a205.54,205.54,0,0,1,61.66,8.84l23.65,11,22,9.09A207.05,207.05,0,0,1,428.2,140.9l13.1,14.44L448.93,173a208,208,0,0,1,16.41,42.22,205.89,205.89,0,0,1,2.52,96.73,133,133,0,0,1,7.74,38.31,235.8,235.8,0,0,0,11.48-155.53C458.51,88.09,361.59,18.05,256.09,19.1Z",
      eyeball: "M344.58,242.53a45.61,45.61,0,0,1,8.95,6.95c12.22,12.21,16.07,29.9,13.26,47.35S354.74,332,340,346.82s-32.54,24-50,26.83-35.13-1-47.35-13.26a48,48,0,0,1-13-24.74,114.74,114.74,0,1,0,114.92-93.12Z",
      iris: "M316.24,254a50.56,50.56,0,0,0-7.08.66c-13,2.09-27.56,9.39-39.76,21.59S249.91,303,247.81,316s.75,23.89,8,31.16S274,357.3,287,355.2s27.56-9.39,39.76-21.59,19.5-26.76,21.59-39.76-.75-23.89-8-31.16c-5.45-5.45-12.94-8.42-21.83-8.68-.74,0-1.49,0-2.25,0Zm-13.81,20.35a16,16,0,0,1,11.86,4.38c7.49,7.5,5.16,22-5.22,32.37s-24.88,12.72-32.38,5.23-5.16-22,5.22-32.38c6.17-6.16,13.78-9.49,20.52-9.6Z"
    },
    classes: {
      spikes: "fill-dark",
      eyeball: "fill-dark",
      iris: "fill-med"
    }
  },
  [
    "ResolveHarm2"
    /* ResolveHarm2 */
  ]: {
    viewBox: "0 0 512 512",
    paths: {
      spikes: "M261.25,19.1a237.64,237.64,0,0,0-59.11,8.12C75.79,61.08.8,191,34.66,317.31,67.75,440.8,192.55,515.21,316.15,486.92A132.59,132.59,0,0,1,284.89,475a207,207,0,0,1-157.72-57.52l-11.44-12.15-15.68-19.92a205.62,205.62,0,0,1-24-47.36l-7.32-17.33L65.87,296.5a205.41,205.41,0,0,1-.18-54.37l91.84,19.32L76.38,198.26a208,208,0,0,1,29.16-53.84L259.93,252.78,141.87,107a205.79,205.79,0,0,1,63.67-34.49L263.45,141,256,62.45q6.46-.48,12.89-.54a205.54,205.54,0,0,1,61.66,8.84l22.84,8.32,22.83,11.78a207,207,0,0,1,57.17,50.05l13.41,16.85L454.08,173a207.52,207.52,0,0,1,18.93,139,132.67,132.67,0,0,1,7.75,38.31,235.92,235.92,0,0,0,11.48-155.53C463.67,88.09,366.74,18.05,261.25,19.1Z",
      eyeball: "M349.74,242.53a45.61,45.61,0,0,1,8.95,6.95c12.21,12.21,16.07,29.9,13.26,47.35s-12.05,35.21-26.83,50-32.54,24-50,26.83-35.14-1-47.35-13.26a48,48,0,0,1-13-24.74,116.19,116.19,0,0,0-2,21.58,114.73,114.73,0,1,0,117-114.7Z",
      iris: "M321.4,254a50.42,50.42,0,0,0-7.08.66c-13,2.09-27.56,9.39-39.76,21.59S255.06,303,253,316s.75,23.89,8,31.16,18.16,10.12,31.16,8,27.56-9.39,39.76-21.59,19.49-26.76,21.59-39.76-.75-23.89-8-31.16c-5.46-5.45-13-8.42-21.83-8.68-.74,0-1.49,0-2.25,0Zm-13.81,20.35a16,16,0,0,1,11.85,4.38c7.5,7.5,5.16,22-5.22,32.37s-24.87,12.72-32.37,5.23-5.16-22,5.22-32.38c6.16-6.16,13.78-9.49,20.52-9.6Z"
    },
    classes: {
      spikes: "fill-med",
      eyeball: "fill-dark",
      iris: "fill-bright"
    }
  },
  [
    "ResolveHarm3"
    /* ResolveHarm3 */
  ]: {
    viewBox: "0 0 512 512",
    paths: {
      spikes: "M261.31,19.1a237.51,237.51,0,0,0-59.11,8.12C75.84,61.08.86,191,34.71,317.31,67.8,440.8,192.61,515.21,316.2,486.92A132.35,132.35,0,0,1,285,475a207,207,0,0,1-157.72-57.52l-13.81-16.37-13.31-15.7a206,206,0,0,1-24.06-47.36l83.63-17.33L65.93,296.5a205.41,205.41,0,0,1-.18-54.37l164.66,47.21-154-91.08a208,208,0,0,1,29.15-53.84L260,252.78,141.92,107A205.85,205.85,0,0,1,205.6,72.52l95.49,158.21L256,62.45q6.47-.48,12.9-.54a205.43,205.43,0,0,1,61.65,8.84L353.08,169l23.17-78.14a206.76,206.76,0,0,1,57.16,50.05l13.08,22.41,7.65,9.67a207.52,207.52,0,0,1,18.93,139,132.33,132.33,0,0,1,7.74,38.31,235.8,235.8,0,0,0,11.48-155.53C463.73,88.09,366.8,18.05,261.31,19.1Z",
      eyeball: "M349.79,242.53a45.38,45.38,0,0,1,9,6.95c12.21,12.21,16.07,29.9,13.25,47.35s-12,35.21-26.82,50-32.54,24-50,26.83-35.13-1-47.34-13.26a48,48,0,0,1-13-24.74,116.19,116.19,0,0,0-2,21.58,114.73,114.73,0,1,0,117-114.7Z",
      iris: "M321.45,254a50.56,50.56,0,0,0-7.08.66c-13,2.09-27.55,9.39-39.75,21.59S255.12,303,253,316s.75,23.89,8,31.16,18.16,10.12,31.16,8,27.56-9.39,39.76-21.59,19.49-26.76,21.59-39.76-.75-23.89-8-31.16c-5.45-5.45-12.94-8.42-21.83-8.68-.74,0-1.49,0-2.25,0Zm-13.81,20.35a16,16,0,0,1,11.86,4.38c7.5,7.5,5.16,22-5.22,32.37s-24.88,12.72-32.37,5.23-5.16-22,5.22-32.38c6.16-6.16,13.78-9.49,20.51-9.6Z"
    },
    classes: {
      spikes: "fill-bright",
      eyeball: "fill-med",
      iris: "fill-bright"
    }
  },
  [
    "ResolveHarm4"
    /* ResolveHarm4 */
  ]: {
    viewBox: "0 0 512 512",
    paths: {
      spikes: "M261.14,19.1A237.51,237.51,0,0,0,202,27.22C75.67,61.08.69,191,34.54,317.31,67.63,440.8,192.44,515.21,316,486.92A132.35,132.35,0,0,1,284.78,475a207,207,0,0,1-157.72-57.52l89.22-30-116.34-2a206,206,0,0,1-24.06-47.36L214,333.21,65.76,296.5a205.41,205.41,0,0,1-.18-54.37l164.66,47.21-154-91.08a208,208,0,0,1,29.15-53.84l154.4,108.36L141.75,107a205.85,205.85,0,0,1,63.68-34.49l95.49,158.21L255.85,62.45q6.47-.48,12.9-.54a205.43,205.43,0,0,1,61.65,8.84L359.77,223.5,376.08,90.85a206.76,206.76,0,0,1,57.16,50.05L415.61,243.13,454,173a207.52,207.52,0,0,1,18.93,139,132.33,132.33,0,0,1,7.74,38.31,235.8,235.8,0,0,0,11.48-155.53C463.55,88.09,366.63,18.05,261.14,19.1Z",
      eyeball: "M349.62,242.53a45.38,45.38,0,0,1,9,6.95c12.21,12.21,16.07,29.9,13.25,47.35s-12,35.21-26.82,50-32.55,24-50,26.83-35.13-1-47.34-13.26a48,48,0,0,1-13-24.74,116.19,116.19,0,0,0-2,21.58,114.73,114.73,0,1,0,117-114.7Z",
      iris: "M321.28,254a50.56,50.56,0,0,0-7.08.66c-13,2.09-27.55,9.39-39.75,21.59S255,303,252.86,316s.75,23.89,8,31.16S279,357.3,292,355.2s27.55-9.39,39.76-21.59,19.49-26.76,21.59-39.76-.75-23.89-8-31.16c-5.45-5.45-12.94-8.42-21.83-8.68-.74,0-1.49,0-2.25,0Zm-13.81,20.35a16,16,0,0,1,11.86,4.38c7.5,7.5,5.16,22-5.22,32.37s-24.88,12.72-32.37,5.23-5.16-22,5.22-32.38c6.16-6.16,13.78-9.49,20.51-9.6Z"
    },
    classes: {
      spikes: "fill-bright",
      eyeball: "fill-bright",
      iris: "fill-bright"
    }
  }
};
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
var tagify_min = { exports: {} };
(function(module, exports) {
  !function(t, e) {
    module.exports = e();
  }(commonjsGlobal, function() {
    function t(t2, e2) {
      var i2 = Object.keys(t2);
      if (Object.getOwnPropertySymbols) {
        var s2 = Object.getOwnPropertySymbols(t2);
        e2 && (s2 = s2.filter(function(e3) {
          return Object.getOwnPropertyDescriptor(t2, e3).enumerable;
        })), i2.push.apply(i2, s2);
      }
      return i2;
    }
    function e(e2) {
      for (var s2 = 1; s2 < arguments.length; s2++) {
        var a2 = null != arguments[s2] ? arguments[s2] : {};
        s2 % 2 ? t(Object(a2), true).forEach(function(t2) {
          i(e2, t2, a2[t2]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(a2)) : t(Object(a2)).forEach(function(t2) {
          Object.defineProperty(e2, t2, Object.getOwnPropertyDescriptor(a2, t2));
        });
      }
      return e2;
    }
    function i(t2, e2, i2) {
      return (e2 = function(t3) {
        var e3 = function(t4, e4) {
          if ("object" != typeof t4 || null === t4)
            return t4;
          var i3 = t4[Symbol.toPrimitive];
          if (void 0 !== i3) {
            var s2 = i3.call(t4, e4 || "default");
            if ("object" != typeof s2)
              return s2;
            throw new TypeError("@@toPrimitive must return a primitive value.");
          }
          return ("string" === e4 ? String : Number)(t4);
        }(t3, "string");
        return "symbol" == typeof e3 ? e3 : String(e3);
      }(e2)) in t2 ? Object.defineProperty(t2, e2, { value: i2, enumerable: true, configurable: true, writable: true }) : t2[e2] = i2, t2;
    }
    const s = (t2, e2, i2, s2) => (t2 = "" + t2, e2 = "" + e2, s2 && (t2 = t2.trim(), e2 = e2.trim()), i2 ? t2 == e2 : t2.toLowerCase() == e2.toLowerCase()), a = (t2, e2) => t2 && Array.isArray(t2) && t2.map((t3) => n(t3, e2));
    function n(t2, e2) {
      var i2, s2 = {};
      for (i2 in t2)
        e2.indexOf(i2) < 0 && (s2[i2] = t2[i2]);
      return s2;
    }
    function o(t2) {
      var e2 = document.createElement("div");
      return t2.replace(/\&#?[0-9a-z]+;/gi, function(t3) {
        return e2.innerHTML = t3, e2.innerText;
      });
    }
    function r(t2) {
      return new DOMParser().parseFromString(t2.trim(), "text/html").body.firstElementChild;
    }
    function l(t2, e2) {
      for (e2 = e2 || "previous"; t2 = t2[e2 + "Sibling"]; )
        if (3 == t2.nodeType)
          return t2;
    }
    function d(t2) {
      return "string" == typeof t2 ? t2.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/`|'/g, "&#039;") : t2;
    }
    function h(t2) {
      var e2 = Object.prototype.toString.call(t2).split(" ")[1].slice(0, -1);
      return t2 === Object(t2) && "Array" != e2 && "Function" != e2 && "RegExp" != e2 && "HTMLUnknownElement" != e2;
    }
    function g(t2, e2, i2) {
      function s2(t3, e3) {
        for (var i3 in e3)
          if (e3.hasOwnProperty(i3)) {
            if (h(e3[i3])) {
              h(t3[i3]) ? s2(t3[i3], e3[i3]) : t3[i3] = Object.assign({}, e3[i3]);
              continue;
            }
            if (Array.isArray(e3[i3])) {
              t3[i3] = Object.assign([], e3[i3]);
              continue;
            }
            t3[i3] = e3[i3];
          }
      }
      return t2 instanceof Object || (t2 = {}), s2(t2, e2), i2 && s2(t2, i2), t2;
    }
    function p() {
      const t2 = [], e2 = {};
      for (let i2 of arguments)
        for (let s2 of i2)
          h(s2) ? e2[s2.value] || (t2.push(s2), e2[s2.value] = 1) : t2.includes(s2) || t2.push(s2);
      return t2;
    }
    function c(t2) {
      return String.prototype.normalize ? "string" == typeof t2 ? t2.normalize("NFD").replace(/[\u0300-\u036f]/g, "") : void 0 : t2;
    }
    var u = () => /(?=.*chrome)(?=.*android)/i.test(navigator.userAgent);
    function m() {
      return ("10000000-1000-4000-8000" + -1e11).replace(/[018]/g, (t2) => (t2 ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> t2 / 4).toString(16));
    }
    function v(t2) {
      return t2 && t2.classList && t2.classList.contains(this.settings.classNames.tag);
    }
    function f(t2, e2) {
      var i2 = window.getSelection();
      return e2 = e2 || i2.getRangeAt(0), "string" == typeof t2 && (t2 = document.createTextNode(t2)), e2 && (e2.deleteContents(), e2.insertNode(t2)), t2;
    }
    function T(t2, e2, i2) {
      return t2 ? (e2 && (t2.__tagifyTagData = i2 ? e2 : g({}, t2.__tagifyTagData || {}, e2)), t2.__tagifyTagData) : (console.warn("tag element doesn't exist", t2, e2), e2);
    }
    function w(t2) {
      if (t2 && t2.parentNode) {
        var e2 = t2, i2 = window.getSelection(), s2 = i2.getRangeAt(0);
        i2.rangeCount && (s2.setStartAfter(e2), s2.collapse(true), i2.removeAllRanges(), i2.addRange(s2));
      }
    }
    function b(t2, e2) {
      t2.forEach((t3) => {
        if (T(t3.previousSibling) || !t3.previousSibling) {
          var i2 = document.createTextNode("​");
          t3.before(i2), e2 && w(i2);
        }
      });
    }
    var y = { delimiters: ",", pattern: null, tagTextProp: "value", maxTags: 1 / 0, callbacks: {}, addTagOnBlur: true, addTagOn: ["blur", "tab", "enter"], onChangeAfterBlur: true, duplicates: false, whitelist: [], blacklist: [], enforceWhitelist: false, userInput: true, keepInvalidTags: false, createInvalidTags: true, mixTagsAllowedAfter: /,|\.|\:|\s/, mixTagsInterpolator: ["[[", "]]"], backspace: true, skipInvalid: false, pasteAsTags: true, editTags: { clicks: 2, keepInvalid: true }, transformTag: () => {
    }, trim: true, a11y: { focusableTags: false }, mixMode: { insertAfterTag: " " }, autoComplete: { enabled: true, rightKey: false, tabKey: false }, classNames: { namespace: "tagify", mixMode: "tagify--mix", selectMode: "tagify--select", input: "tagify__input", focus: "tagify--focus", tagNoAnimation: "tagify--noAnim", tagInvalid: "tagify--invalid", tagNotAllowed: "tagify--notAllowed", scopeLoading: "tagify--loading", hasMaxTags: "tagify--hasMaxTags", hasNoTags: "tagify--noTags", empty: "tagify--empty", inputInvalid: "tagify__input--invalid", dropdown: "tagify__dropdown", dropdownWrapper: "tagify__dropdown__wrapper", dropdownHeader: "tagify__dropdown__header", dropdownFooter: "tagify__dropdown__footer", dropdownItem: "tagify__dropdown__item", dropdownItemActive: "tagify__dropdown__item--active", dropdownItemHidden: "tagify__dropdown__item--hidden", dropdownInital: "tagify__dropdown--initial", tag: "tagify__tag", tagText: "tagify__tag-text", tagX: "tagify__tag__removeBtn", tagLoading: "tagify__tag--loading", tagEditing: "tagify__tag--editable", tagFlash: "tagify__tag--flash", tagHide: "tagify__tag--hide" }, dropdown: { classname: "", enabled: 2, maxItems: 10, searchKeys: ["value", "searchBy"], fuzzySearch: true, caseSensitive: false, accentedSearch: true, includeSelectedTags: false, escapeHTML: true, highlightFirst: true, closeOnSelect: true, clearOnSelect: true, position: "all", appendTarget: null }, hooks: { beforeRemoveTag: () => Promise.resolve(), beforePaste: () => Promise.resolve(), suggestionClick: () => Promise.resolve(), beforeKeyDown: () => Promise.resolve() } }, x = { events: { binding() {
      let t2 = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
      var e2 = this.dropdown.events.callbacks, i2 = this.listeners.dropdown = this.listeners.dropdown || { position: this.dropdown.position.bind(this, null), onKeyDown: e2.onKeyDown.bind(this), onMouseOver: e2.onMouseOver.bind(this), onMouseLeave: e2.onMouseLeave.bind(this), onClick: e2.onClick.bind(this), onScroll: e2.onScroll.bind(this) }, s2 = t2 ? "addEventListener" : "removeEventListener";
      "manual" != this.settings.dropdown.position && (document[s2]("scroll", i2.position, true), window[s2]("resize", i2.position), window[s2]("keydown", i2.onKeyDown)), this.DOM.dropdown[s2]("mouseover", i2.onMouseOver), this.DOM.dropdown[s2]("mouseleave", i2.onMouseLeave), this.DOM.dropdown[s2]("mousedown", i2.onClick), this.DOM.dropdown.content[s2]("scroll", i2.onScroll);
    }, callbacks: { onKeyDown(t2) {
      if (this.state.hasFocus && !this.state.composing) {
        var e2 = this.settings, i2 = this.DOM.dropdown.querySelector(e2.classNames.dropdownItemActiveSelector), s2 = this.dropdown.getSuggestionDataByNode(i2), a2 = "mix" == e2.mode;
        e2.hooks.beforeKeyDown(t2, { tagify: this }).then((n2) => {
          switch (t2.key) {
            case "ArrowDown":
            case "ArrowUp":
            case "Down":
            case "Up":
              t2.preventDefault();
              var o2 = this.dropdown.getAllSuggestionsRefs(), r2 = "ArrowUp" == t2.key || "Up" == t2.key;
              i2 && (i2 = this.dropdown.getNextOrPrevOption(i2, !r2)), i2 && i2.matches(e2.classNames.dropdownItemSelector) || (i2 = o2[r2 ? o2.length - 1 : 0]), this.dropdown.highlightOption(i2, true);
              break;
            case "Escape":
            case "Esc":
              this.dropdown.hide();
              break;
            case "ArrowRight":
              if (this.state.actions.ArrowLeft)
                return;
            case "Tab": {
              let n3 = !e2.autoComplete.rightKey || !e2.autoComplete.tabKey;
              if (!a2 && i2 && n3 && !this.state.editing) {
                t2.preventDefault();
                var l2 = this.dropdown.getMappedValue(s2);
                return this.input.autocomplete.set.call(this, l2), false;
              }
              return true;
            }
            case "Enter":
              t2.preventDefault(), e2.hooks.suggestionClick(t2, { tagify: this, tagData: s2, suggestionElm: i2 }).then(() => {
                if (i2)
                  return this.dropdown.selectOption(i2), i2 = this.dropdown.getNextOrPrevOption(i2, !r2), void this.dropdown.highlightOption(i2);
                this.dropdown.hide(), a2 || this.addTags(this.state.inputText.trim(), true);
              }).catch((t3) => console.warn(t3));
              break;
            case "Backspace": {
              if (a2 || this.state.editing.scope)
                return;
              const t3 = this.input.raw.call(this);
              "" != t3 && 8203 != t3.charCodeAt(0) || (true === e2.backspace ? this.removeTags() : "edit" == e2.backspace && setTimeout(this.editTag.bind(this), 0));
            }
          }
        });
      }
    }, onMouseOver(t2) {
      var e2 = t2.target.closest(this.settings.classNames.dropdownItemSelector);
      this.dropdown.highlightOption(e2);
    }, onMouseLeave(t2) {
      this.dropdown.highlightOption();
    }, onClick(t2) {
      if (0 == t2.button && t2.target != this.DOM.dropdown && t2.target != this.DOM.dropdown.content) {
        var e2 = t2.target.closest(this.settings.classNames.dropdownItemSelector), i2 = this.dropdown.getSuggestionDataByNode(e2);
        this.state.actions.selectOption = true, setTimeout(() => this.state.actions.selectOption = false, 50), this.settings.hooks.suggestionClick(t2, { tagify: this, tagData: i2, suggestionElm: e2 }).then(() => {
          e2 ? this.dropdown.selectOption(e2, t2) : this.dropdown.hide();
        }).catch((t3) => console.warn(t3));
      }
    }, onScroll(t2) {
      var e2 = t2.target, i2 = e2.scrollTop / (e2.scrollHeight - e2.parentNode.clientHeight) * 100;
      this.trigger("dropdown:scroll", { percentage: Math.round(i2) });
    } } }, refilter(t2) {
      t2 = t2 || this.state.dropdown.query || "", this.suggestedListItems = this.dropdown.filterListItems(t2), this.dropdown.fill(), this.suggestedListItems.length || this.dropdown.hide(), this.trigger("dropdown:updated", this.DOM.dropdown);
    }, getSuggestionDataByNode(t2) {
      var e2 = t2 && t2.getAttribute("value");
      return this.suggestedListItems.find((t3) => t3.value == e2) || null;
    }, getNextOrPrevOption(t2) {
      let e2 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
      var i2 = this.dropdown.getAllSuggestionsRefs(), s2 = i2.findIndex((e3) => e3 === t2);
      return e2 ? i2[s2 + 1] : i2[s2 - 1];
    }, highlightOption(t2, e2) {
      var i2, s2 = this.settings.classNames.dropdownItemActive;
      if (this.state.ddItemElm && (this.state.ddItemElm.classList.remove(s2), this.state.ddItemElm.removeAttribute("aria-selected")), !t2)
        return this.state.ddItemData = null, this.state.ddItemElm = null, void this.input.autocomplete.suggest.call(this);
      i2 = this.dropdown.getSuggestionDataByNode(t2), this.state.ddItemData = i2, this.state.ddItemElm = t2, t2.classList.add(s2), t2.setAttribute("aria-selected", true), e2 && (t2.parentNode.scrollTop = t2.clientHeight + t2.offsetTop - t2.parentNode.clientHeight), this.settings.autoComplete && (this.input.autocomplete.suggest.call(this, i2), this.dropdown.position());
    }, selectOption(t2, e2) {
      var i2 = this.settings, s2 = i2.dropdown, a2 = s2.clearOnSelect, n2 = s2.closeOnSelect;
      if (!t2)
        return this.addTags(this.state.inputText, true), void (n2 && this.dropdown.hide());
      e2 = e2 || {};
      var o2 = t2.getAttribute("value"), r2 = "noMatch" == o2, l2 = "mix" == i2.mode, d2 = this.suggestedListItems.find((t3) => (t3.value ?? t3) == o2);
      if (this.trigger("dropdown:select", { data: d2, elm: t2, event: e2 }), o2 && (d2 || r2)) {
        if (this.state.editing) {
          let t3 = this.normalizeTags([d2])[0];
          d2 = i2.transformTag.call(this, t3) || t3, this.onEditTagDone(null, g({ __isValid: true }, d2));
        } else
          this[l2 ? "addMixTags" : "addTags"]([d2 || this.input.raw.call(this)], a2);
        (l2 || this.DOM.input.parentNode) && (setTimeout(() => {
          this.DOM.input.focus(), this.toggleFocusClass(true);
        }), n2 && setTimeout(this.dropdown.hide.bind(this)), t2.addEventListener("transitionend", () => {
          this.dropdown.fillHeaderFooter(), setTimeout(() => t2.remove(), 100);
        }, { once: true }), t2.classList.add(this.settings.classNames.dropdownItemHidden));
      } else
        n2 && setTimeout(this.dropdown.hide.bind(this));
    }, selectAll(t2) {
      this.suggestedListItems.length = 0, this.dropdown.hide(), this.dropdown.filterListItems("");
      var e2 = this.dropdown.filterListItems("");
      return t2 || (e2 = this.state.dropdown.suggestions), this.addTags(e2, true), this;
    }, filterListItems(t2, e2) {
      var i2, s2, a2, n2, o2, r2 = this.settings, l2 = r2.dropdown, d2 = (e2 = e2 || {}, []), g2 = [], p2 = r2.whitelist, u2 = l2.maxItems >= 0 ? l2.maxItems : 1 / 0, m2 = l2.searchKeys, v2 = 0;
      if (!(t2 = "select" == r2.mode && this.value.length && this.value[0][r2.tagTextProp] == t2 ? "" : t2) || !m2.length)
        return d2 = l2.includeSelectedTags ? p2 : p2.filter((t3) => !this.isTagDuplicate(h(t3) ? t3.value : t3)), this.state.dropdown.suggestions = d2, d2.slice(0, u2);
      function f2(t3, e3) {
        return e3.toLowerCase().split(" ").every((e4) => t3.includes(e4.toLowerCase()));
      }
      for (o2 = l2.caseSensitive ? "" + t2 : ("" + t2).toLowerCase(); v2 < p2.length; v2++) {
        let t3, r3;
        i2 = p2[v2] instanceof Object ? p2[v2] : { value: p2[v2] };
        let u3 = !Object.keys(i2).some((t4) => m2.includes(t4)) ? ["value"] : m2;
        l2.fuzzySearch && !e2.exact ? (a2 = u3.reduce((t4, e3) => t4 + " " + (i2[e3] || ""), "").toLowerCase().trim(), l2.accentedSearch && (a2 = c(a2), o2 = c(o2)), t3 = 0 == a2.indexOf(o2), r3 = a2 === o2, s2 = f2(a2, o2)) : (t3 = true, s2 = u3.some((t4) => {
          var s3 = "" + (i2[t4] || "");
          return l2.accentedSearch && (s3 = c(s3), o2 = c(o2)), l2.caseSensitive || (s3 = s3.toLowerCase()), r3 = s3 === o2, e2.exact ? s3 === o2 : 0 == s3.indexOf(o2);
        })), n2 = !l2.includeSelectedTags && this.isTagDuplicate(h(i2) ? i2.value : i2), s2 && !n2 && (r3 && t3 ? g2.push(i2) : "startsWith" == l2.sortby && t3 ? d2.unshift(i2) : d2.push(i2));
      }
      return this.state.dropdown.suggestions = g2.concat(d2), "function" == typeof l2.sortby ? l2.sortby(g2.concat(d2), o2) : g2.concat(d2).slice(0, u2);
    }, getMappedValue(t2) {
      var e2 = this.settings.dropdown.mapValueTo;
      return e2 ? "function" == typeof e2 ? e2(t2) : t2[e2] || t2.value : t2.value;
    }, createListHTML(t2) {
      return g([], t2).map((t3, i2) => {
        "string" != typeof t3 && "number" != typeof t3 || (t3 = { value: t3 });
        var s2 = this.dropdown.getMappedValue(t3);
        return s2 = "string" == typeof s2 && this.settings.dropdown.escapeHTML ? d(s2) : s2, this.settings.templates.dropdownItem.apply(this, [e(e({}, t3), {}, { mappedValue: s2 }), this]);
      }).join("");
    } };
    function O() {
      this.dropdown = {};
      for (let t2 in this._dropdown)
        this.dropdown[t2] = "function" == typeof this._dropdown[t2] ? this._dropdown[t2].bind(this) : this._dropdown[t2];
      this.dropdown.refs();
    }
    var D = e(e({}, x), {}, { refs() {
      this.DOM.dropdown = this.parseTemplate("dropdown", [this.settings]), this.DOM.dropdown.content = this.DOM.dropdown.querySelector("[data-selector='tagify-suggestions-wrapper']");
    }, getHeaderRef() {
      return this.DOM.dropdown.querySelector("[data-selector='tagify-suggestions-header']");
    }, getFooterRef() {
      return this.DOM.dropdown.querySelector("[data-selector='tagify-suggestions-footer']");
    }, getAllSuggestionsRefs() {
      return [...this.DOM.dropdown.content.querySelectorAll(this.settings.classNames.dropdownItemSelector)];
    }, show(t2) {
      var e2, i2, a2, n2 = this.settings, o2 = "mix" == n2.mode && !n2.enforceWhitelist, r2 = !n2.whitelist || !n2.whitelist.length, l2 = "manual" == n2.dropdown.position;
      if (t2 = void 0 === t2 ? this.state.inputText : t2, !(r2 && !o2 && !n2.templates.dropdownItemNoMatch || false === n2.dropdown.enable || this.state.isLoading || this.settings.readonly)) {
        if (clearTimeout(this.dropdownHide__bindEventsTimeout), this.suggestedListItems = this.dropdown.filterListItems(t2), t2 && !this.suggestedListItems.length && (this.trigger("dropdown:noMatch", t2), n2.templates.dropdownItemNoMatch && (a2 = n2.templates.dropdownItemNoMatch.call(this, { value: t2 }))), !a2) {
          if (this.suggestedListItems.length)
            t2 && o2 && !this.state.editing.scope && !s(this.suggestedListItems[0].value, t2) && this.suggestedListItems.unshift({ value: t2 });
          else {
            if (!t2 || !o2 || this.state.editing.scope)
              return this.input.autocomplete.suggest.call(this), void this.dropdown.hide();
            this.suggestedListItems = [{ value: t2 }];
          }
          i2 = "" + (h(e2 = this.suggestedListItems[0]) ? e2.value : e2), n2.autoComplete && i2 && 0 == i2.indexOf(t2) && this.input.autocomplete.suggest.call(this, e2);
        }
        this.dropdown.fill(a2), n2.dropdown.highlightFirst && this.dropdown.highlightOption(this.DOM.dropdown.content.querySelector(n2.classNames.dropdownItemSelector)), this.state.dropdown.visible || setTimeout(this.dropdown.events.binding.bind(this)), this.state.dropdown.visible = t2 || true, this.state.dropdown.query = t2, this.setStateSelection(), l2 || setTimeout(() => {
          this.dropdown.position(), this.dropdown.render();
        }), setTimeout(() => {
          this.trigger("dropdown:show", this.DOM.dropdown);
        });
      }
    }, hide(t2) {
      var e2 = this.DOM, i2 = e2.scope, s2 = e2.dropdown, a2 = "manual" == this.settings.dropdown.position && !t2;
      if (s2 && document.body.contains(s2) && !a2)
        return window.removeEventListener("resize", this.dropdown.position), this.dropdown.events.binding.call(this, false), i2.setAttribute("aria-expanded", false), s2.parentNode.removeChild(s2), setTimeout(() => {
          this.state.dropdown.visible = false;
        }, 100), this.state.dropdown.query = this.state.ddItemData = this.state.ddItemElm = this.state.selection = null, this.state.tag && this.state.tag.value.length && (this.state.flaggedTags[this.state.tag.baseOffset] = this.state.tag), this.trigger("dropdown:hide", s2), this;
    }, toggle(t2) {
      this.dropdown[this.state.dropdown.visible && !t2 ? "hide" : "show"]();
    }, getAppendTarget() {
      var t2 = this.settings.dropdown;
      return "function" == typeof t2.appendTarget ? t2.appendTarget() : t2.appendTarget;
    }, render() {
      var t2, e2, i2, s2 = (t2 = this.DOM.dropdown, (i2 = t2.cloneNode(true)).style.cssText = "position:fixed; top:-9999px; opacity:0", document.body.appendChild(i2), e2 = i2.clientHeight, i2.parentNode.removeChild(i2), e2), a2 = this.settings, n2 = "number" == typeof a2.dropdown.enabled && a2.dropdown.enabled >= 0, o2 = this.dropdown.getAppendTarget();
      return n2 ? (this.DOM.scope.setAttribute("aria-expanded", true), document.body.contains(this.DOM.dropdown) || (this.DOM.dropdown.classList.add(a2.classNames.dropdownInital), this.dropdown.position(s2), o2.appendChild(this.DOM.dropdown), setTimeout(() => this.DOM.dropdown.classList.remove(a2.classNames.dropdownInital))), this) : this;
    }, fill(t2) {
      t2 = "string" == typeof t2 ? t2 : this.dropdown.createListHTML(t2 || this.suggestedListItems);
      var e2, i2 = this.settings.templates.dropdownContent.call(this, t2);
      this.DOM.dropdown.content.innerHTML = (e2 = i2) ? e2.replace(/\>[\r\n ]+\</g, "><").split(/>\s+</).join("><").trim() : "";
    }, fillHeaderFooter() {
      var t2 = this.dropdown.filterListItems(this.state.dropdown.query), e2 = this.parseTemplate("dropdownHeader", [t2]), i2 = this.parseTemplate("dropdownFooter", [t2]), s2 = this.dropdown.getHeaderRef(), a2 = this.dropdown.getFooterRef();
      e2 && (s2 == null ? void 0 : s2.parentNode.replaceChild(e2, s2)), i2 && (a2 == null ? void 0 : a2.parentNode.replaceChild(i2, a2));
    }, position(t2) {
      var e2 = this.settings.dropdown, i2 = this.dropdown.getAppendTarget();
      if ("manual" != e2.position && i2) {
        var s2, a2, n2, o2, r2, l2, d2, h2, g2, p2 = this.DOM.dropdown, c2 = e2.RTL, u2 = i2 === document.body, m2 = i2 === this.DOM.scope, v2 = u2 ? window.pageYOffset : i2.scrollTop, f2 = document.fullscreenElement || document.webkitFullscreenElement || document.documentElement, T2 = f2.clientHeight, w2 = Math.max(f2.clientWidth || 0, window.innerWidth || 0) > 480 ? e2.position : "all", b2 = this.DOM["input" == w2 ? "input" : "scope"];
        if (t2 = t2 || p2.clientHeight, this.state.dropdown.visible) {
          if ("text" == w2 ? (n2 = (s2 = function() {
            const t3 = document.getSelection();
            if (t3.rangeCount) {
              const e3 = t3.getRangeAt(0), i3 = e3.startContainer, s3 = e3.startOffset;
              let a3, n3;
              if (s3 > 0)
                return n3 = document.createRange(), n3.setStart(i3, s3 - 1), n3.setEnd(i3, s3), a3 = n3.getBoundingClientRect(), { left: a3.right, top: a3.top, bottom: a3.bottom };
              if (i3.getBoundingClientRect)
                return i3.getBoundingClientRect();
            }
            return { left: -9999, top: -9999 };
          }()).bottom, a2 = s2.top, o2 = s2.left, r2 = "auto") : (l2 = function(t3) {
            var e3 = 0, i3 = 0;
            for (t3 = t3.parentNode; t3 && t3 != f2; )
              e3 += t3.offsetTop || 0, i3 += t3.offsetLeft || 0, t3 = t3.parentNode;
            return { top: e3, left: i3 };
          }(i2), s2 = b2.getBoundingClientRect(), a2 = m2 ? -1 : s2.top - l2.top, n2 = (m2 ? s2.height : s2.bottom - l2.top) - 1, o2 = m2 ? -1 : s2.left - l2.left, r2 = s2.width + "px"), !u2) {
            let t3 = function() {
              for (var t4 = 0, i3 = e2.appendTarget.parentNode; i3; )
                t4 += i3.scrollTop || 0, i3 = i3.parentNode;
              return t4;
            }();
            a2 += t3, n2 += t3;
          }
          a2 = Math.floor(a2), n2 = Math.ceil(n2), h2 = ((d2 = e2.placeAbove ?? T2 - s2.bottom < t2) ? a2 : n2) + v2, g2 = `left: ${o2 + (c2 && s2.width || 0) + window.pageXOffset}px;`, p2.style.cssText = `${g2}; top: ${h2}px; min-width: ${r2}; max-width: ${r2}`, p2.setAttribute("placement", d2 ? "top" : "bottom"), p2.setAttribute("position", w2);
        }
      }
    } });
    const N = "@yaireo/tagify/";
    var M, I = { empty: "empty", exceed: "number of tags exceeded", pattern: "pattern mismatch", duplicate: "already exists", notAllowed: "not allowed" }, E = { wrapper: (t2, e2) => `<tags class="${e2.classNames.namespace} ${e2.mode ? `${e2.classNames[e2.mode + "Mode"]}` : ""} ${t2.className}"
                    ${e2.readonly ? "readonly" : ""}
                    ${e2.disabled ? "disabled" : ""}
                    ${e2.required ? "required" : ""}
                    ${"select" === e2.mode ? "spellcheck='false'" : ""}
                    tabIndex="-1">
            <span ${!e2.readonly && e2.userInput ? "contenteditable" : ""} tabIndex="0" data-placeholder="${e2.placeholder || "&#8203;"}" aria-placeholder="${e2.placeholder || ""}"
                class="${e2.classNames.input}"
                role="textbox"
                aria-autocomplete="both"
                aria-multiline="${"mix" == e2.mode}"></span>
                &#8203;
        </tags>`, tag(t2, e2) {
      let i2 = e2.settings;
      return `<tag title="${t2.title || t2.value}"
                    contenteditable='false'
                    spellcheck='false'
                    tabIndex="${i2.a11y.focusableTags ? 0 : -1}"
                    class="${i2.classNames.tag} ${t2.class || ""}"
                    ${this.getAttributes(t2)}>
            <x title='' class="${i2.classNames.tagX}" role='button' aria-label='remove tag'></x>
            <div>
                <span class="${i2.classNames.tagText}">${t2[i2.tagTextProp] || t2.value}</span>
            </div>
        </tag>`;
    }, dropdown(t2) {
      var e2 = t2.dropdown;
      return `<div class="${"manual" == e2.position ? "" : t2.classNames.dropdown} ${e2.classname}" role="listbox" aria-labelledby="dropdown" dir="${e2.RTL ? "rtl" : ""}">
                    <div data-selector='tagify-suggestions-wrapper' class="${t2.classNames.dropdownWrapper}"></div>
                </div>`;
    }, dropdownContent(t2) {
      var e2 = this.settings.templates, i2 = this.state.dropdown.suggestions;
      return `
            ${e2.dropdownHeader.call(this, i2)}
            ${t2}
            ${e2.dropdownFooter.call(this, i2)}
        `;
    }, dropdownItem(t2) {
      return `<div ${this.getAttributes(t2)}
                    class='${this.settings.classNames.dropdownItem} ${t2.class || ""}'
                    tabindex="0"
                    role="option">${t2.mappedValue || t2.value}</div>`;
    }, dropdownHeader(t2) {
      return `<header data-selector='tagify-suggestions-header' class="${this.settings.classNames.dropdownHeader}"></header>`;
    }, dropdownFooter(t2) {
      var e2 = t2.length - this.settings.dropdown.maxItems;
      return e2 > 0 ? `<footer data-selector='tagify-suggestions-footer' class="${this.settings.classNames.dropdownFooter}">
                ${e2} more items. Refine your search.
            </footer>` : "";
    }, dropdownItemNoMatch: null };
    var S = { customBinding() {
      this.customEventsList.forEach((t2) => {
        this.on(t2, this.settings.callbacks[t2]);
      });
    }, binding() {
      let t2 = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
      var e2, i2 = this.settings, s2 = this.events.callbacks, a2 = t2 ? "addEventListener" : "removeEventListener";
      if (!this.state.mainEvents || !t2) {
        for (var n2 in this.state.mainEvents = t2, t2 && !this.listeners.main && (this.events.bindGlobal.call(this), this.settings.isJQueryPlugin && jQuery(this.DOM.originalInput).on("tagify.removeAllTags", this.removeAllTags.bind(this))), e2 = this.listeners.main = this.listeners.main || { focus: ["input", s2.onFocusBlur.bind(this)], keydown: ["input", s2.onKeydown.bind(this)], click: ["scope", s2.onClickScope.bind(this)], dblclick: "select" != i2.mode && ["scope", s2.onDoubleClickScope.bind(this)], paste: ["input", s2.onPaste.bind(this)], drop: ["input", s2.onDrop.bind(this)], compositionstart: ["input", s2.onCompositionStart.bind(this)], compositionend: ["input", s2.onCompositionEnd.bind(this)] })
          e2[n2] && this.DOM[e2[n2][0]][a2](n2, e2[n2][1]);
        clearInterval(this.listeners.main.originalInputValueObserverInterval), this.listeners.main.originalInputValueObserverInterval = setInterval(s2.observeOriginalInputValue.bind(this), 500);
        var o2 = this.listeners.main.inputMutationObserver || new MutationObserver(s2.onInputDOMChange.bind(this));
        o2.disconnect(), "mix" == i2.mode && o2.observe(this.DOM.input, { childList: true });
      }
    }, bindGlobal(t2) {
      var e2, i2 = this.events.callbacks, s2 = t2 ? "removeEventListener" : "addEventListener";
      if (this.listeners && (t2 || !this.listeners.global))
        for (e2 of (this.listeners.global = this.listeners.global || [{ type: this.isIE ? "keydown" : "input", target: this.DOM.input, cb: i2[this.isIE ? "onInputIE" : "onInput"].bind(this) }, { type: "keydown", target: window, cb: i2.onWindowKeyDown.bind(this) }, { type: "blur", target: this.DOM.input, cb: i2.onFocusBlur.bind(this) }, { type: "click", target: document, cb: i2.onClickAnywhere.bind(this), useCapture: true }], this.listeners.global))
          e2.target[s2](e2.type, e2.cb, !!e2.useCapture);
    }, unbindGlobal() {
      this.events.bindGlobal.call(this, true);
    }, callbacks: { onFocusBlur(t2) {
      var _a2, _b;
      var e2 = this.settings, i2 = t2.target ? this.trim(t2.target.textContent) : "", s2 = (_b = (_a2 = this.value) == null ? void 0 : _a2[0]) == null ? void 0 : _b[e2.tagTextProp], a2 = t2.type, n2 = e2.dropdown.enabled >= 0, o2 = { relatedTarget: t2.relatedTarget }, r2 = this.state.actions.selectOption && (n2 || !e2.dropdown.closeOnSelect), l2 = this.state.actions.addNew && n2;
      if ("blur" == a2) {
        if (t2.relatedTarget === this.DOM.scope)
          return this.dropdown.hide(), void this.DOM.input.focus();
        this.postUpdate(), e2.onChangeAfterBlur && this.triggerChangeEvent();
      }
      if (!r2 && !l2)
        if (this.state.hasFocus = "focus" == a2 && +/* @__PURE__ */ new Date(), this.toggleFocusClass(this.state.hasFocus), "mix" != e2.mode) {
          if ("focus" == a2)
            return this.trigger("focus", o2), void (0 !== e2.dropdown.enabled && e2.userInput || this.state.dropdown.visible || this.dropdown.show(this.value.length ? "" : void 0));
          "blur" == a2 && (this.trigger("blur", o2), this.loading(false), "select" == e2.mode && s2 === i2 && (i2 = ""), i2 && !this.state.actions.selectOption && e2.addTagOnBlur && e2.addTagOn.includes("blur") && this.addTags(i2, true)), this.DOM.input.removeAttribute("style"), this.dropdown.hide();
        } else
          "focus" == a2 ? this.trigger("focus", o2) : "blur" == t2.type && (this.trigger("blur", o2), this.loading(false), this.dropdown.hide(), this.state.dropdown.visible = void 0, this.setStateSelection());
    }, onCompositionStart(t2) {
      this.state.composing = true;
    }, onCompositionEnd(t2) {
      this.state.composing = false;
    }, onWindowKeyDown(t2) {
      var e2, i2 = document.activeElement, s2 = v.call(this, i2) && this.DOM.scope.contains(document.activeElement), a2 = s2 && i2.hasAttribute("readonly");
      if (s2 && !a2)
        switch (e2 = i2.nextElementSibling, t2.key) {
          case "Backspace":
            this.settings.readonly || (this.removeTags(i2), (e2 || this.DOM.input).focus());
            break;
          case "Enter":
            setTimeout(this.editTag.bind(this), 0, i2);
        }
    }, onKeydown(t2) {
      var e2 = this.settings;
      if (!this.state.composing && e2.userInput) {
        "select" == e2.mode && e2.enforceWhitelist && this.value.length && "Tab" != t2.key && t2.preventDefault();
        var i2 = this.trim(t2.target.textContent);
        this.trigger("keydown", { event: t2 }), e2.hooks.beforeKeyDown(t2, { tagify: this }).then((s2) => {
          if ("mix" == e2.mode) {
            switch (t2.key) {
              case "Left":
              case "ArrowLeft":
                this.state.actions.ArrowLeft = true;
                break;
              case "Delete":
              case "Backspace":
                if (this.state.editing)
                  return;
                var a2 = document.getSelection(), n2 = "Delete" == t2.key && a2.anchorOffset == (a2.anchorNode.length || 0), r2 = a2.anchorNode.previousSibling, d2 = 1 == a2.anchorNode.nodeType || !a2.anchorOffset && r2 && 1 == r2.nodeType && a2.anchorNode.previousSibling;
                o(this.DOM.input.innerHTML);
                var h2, g2, p2, c2 = this.getTagElms(), m2 = 1 === a2.anchorNode.length && a2.anchorNode.nodeValue == String.fromCharCode(8203);
                if ("edit" == e2.backspace && d2)
                  return h2 = 1 == a2.anchorNode.nodeType ? null : a2.anchorNode.previousElementSibling, setTimeout(this.editTag.bind(this), 0, h2), void t2.preventDefault();
                if (u() && d2 instanceof Element)
                  return p2 = l(d2), d2.hasAttribute("readonly") || d2.remove(), this.DOM.input.focus(), void setTimeout(() => {
                    w(p2), this.DOM.input.click();
                  });
                if ("BR" == a2.anchorNode.nodeName)
                  return;
                if ((n2 || d2) && 1 == a2.anchorNode.nodeType ? g2 = 0 == a2.anchorOffset ? n2 ? c2[0] : null : c2[Math.min(c2.length, a2.anchorOffset) - 1] : n2 ? g2 = a2.anchorNode.nextElementSibling : d2 instanceof Element && (g2 = d2), 3 == a2.anchorNode.nodeType && !a2.anchorNode.nodeValue && a2.anchorNode.previousElementSibling && t2.preventDefault(), (d2 || n2) && !e2.backspace)
                  return void t2.preventDefault();
                if ("Range" != a2.type && !a2.anchorOffset && a2.anchorNode == this.DOM.input && "Delete" != t2.key)
                  return void t2.preventDefault();
                if ("Range" != a2.type && g2 && g2.hasAttribute("readonly"))
                  return void w(l(g2));
                "Delete" == t2.key && m2 && T(a2.anchorNode.nextSibling) && this.removeTags(a2.anchorNode.nextSibling), clearTimeout(M), M = setTimeout(() => {
                  var t3 = document.getSelection();
                  o(this.DOM.input.innerHTML), !n2 && t3.anchorNode.previousSibling, this.value = [].map.call(c2, (t4, e3) => {
                    var i3 = T(t4);
                    if (t4.parentNode || i3.readonly)
                      return i3;
                    this.trigger("remove", { tag: t4, index: e3, data: i3 });
                  }).filter((t4) => t4);
                }, 20);
            }
            return true;
          }
          var v2 = "manual" == e2.dropdown.position;
          switch (t2.key) {
            case "Backspace":
              "select" == e2.mode && e2.enforceWhitelist && this.value.length ? this.removeTags() : this.state.dropdown.visible && "manual" != e2.dropdown.position || "" != t2.target.textContent && 8203 != i2.charCodeAt(0) || (true === e2.backspace ? this.removeTags() : "edit" == e2.backspace && setTimeout(this.editTag.bind(this), 0));
              break;
            case "Esc":
            case "Escape":
              if (this.state.dropdown.visible)
                return;
              t2.target.blur();
              break;
            case "Down":
            case "ArrowDown":
              this.state.dropdown.visible || this.dropdown.show();
              break;
            case "ArrowRight": {
              let t3 = this.state.inputSuggestion || this.state.ddItemData;
              if (t3 && e2.autoComplete.rightKey)
                return void this.addTags([t3], true);
              break;
            }
            case "Tab": {
              let s3 = "select" == e2.mode;
              if (!i2 || s3)
                return true;
              t2.preventDefault();
            }
            case "Enter":
              if (this.state.dropdown.visible && !v2)
                return;
              t2.preventDefault(), setTimeout(() => {
                this.state.dropdown.visible && !v2 || this.state.actions.selectOption || !e2.addTagOn.includes(t2.key.toLowerCase()) || this.addTags(i2, true);
              });
          }
        }).catch((t3) => t3);
      }
    }, onInput(t2) {
      this.postUpdate();
      var e2 = this.settings;
      if ("mix" == e2.mode)
        return this.events.callbacks.onMixTagsInput.call(this, t2);
      var i2 = this.input.normalize.call(this, void 0, { trim: false }), s2 = i2.length >= e2.dropdown.enabled, a2 = { value: i2, inputElm: this.DOM.input }, n2 = this.validateTag({ value: i2 });
      "select" == e2.mode && this.toggleScopeValidation(n2), a2.isValid = n2, this.state.inputText != i2 && (this.input.set.call(this, i2, false), -1 != i2.search(e2.delimiters) ? this.addTags(i2) && this.input.set.call(this) : e2.dropdown.enabled >= 0 && this.dropdown[s2 ? "show" : "hide"](i2), this.trigger("input", a2));
    }, onMixTagsInput(t2) {
      var e2, i2, s2, a2, n2, o2, r2, l2, d2 = this.settings, h2 = this.value.length, p2 = this.getTagElms(), c2 = document.createDocumentFragment(), m2 = window.getSelection().getRangeAt(0), v2 = [].map.call(p2, (t3) => T(t3).value);
      if ("deleteContentBackward" == t2.inputType && u() && this.events.callbacks.onKeydown.call(this, { target: t2.target, key: "Backspace" }), b(this.getTagElms()), this.value.slice().forEach((t3) => {
        t3.readonly && !v2.includes(t3.value) && c2.appendChild(this.createTagElem(t3));
      }), c2.childNodes.length && (m2.insertNode(c2), this.setRangeAtStartEnd(false, c2.lastChild)), p2.length != h2)
        return this.value = [].map.call(this.getTagElms(), (t3) => T(t3)), void this.update({ withoutChangeEvent: true });
      if (this.hasMaxTags())
        return true;
      if (window.getSelection && (o2 = window.getSelection()).rangeCount > 0 && 3 == o2.anchorNode.nodeType) {
        if ((m2 = o2.getRangeAt(0).cloneRange()).collapse(true), m2.setStart(o2.focusNode, 0), s2 = (e2 = m2.toString().slice(0, m2.endOffset)).split(d2.pattern).length - 1, (i2 = e2.match(d2.pattern)) && (a2 = e2.slice(e2.lastIndexOf(i2[i2.length - 1]))), a2) {
          if (this.state.actions.ArrowLeft = false, this.state.tag = { prefix: a2.match(d2.pattern)[0], value: a2.replace(d2.pattern, "") }, this.state.tag.baseOffset = o2.baseOffset - this.state.tag.value.length, l2 = this.state.tag.value.match(d2.delimiters))
            return this.state.tag.value = this.state.tag.value.replace(d2.delimiters, ""), this.state.tag.delimiters = l2[0], this.addTags(this.state.tag.value, d2.dropdown.clearOnSelect), void this.dropdown.hide();
          n2 = this.state.tag.value.length >= d2.dropdown.enabled;
          try {
            r2 = (r2 = this.state.flaggedTags[this.state.tag.baseOffset]).prefix == this.state.tag.prefix && r2.value[0] == this.state.tag.value[0], this.state.flaggedTags[this.state.tag.baseOffset] && !this.state.tag.value && delete this.state.flaggedTags[this.state.tag.baseOffset];
          } catch (t3) {
          }
          (r2 || s2 < this.state.mixMode.matchedPatternCount) && (n2 = false);
        } else
          this.state.flaggedTags = {};
        this.state.mixMode.matchedPatternCount = s2;
      }
      setTimeout(() => {
        this.update({ withoutChangeEvent: true }), this.trigger("input", g({}, this.state.tag, { textContent: this.DOM.input.textContent })), this.state.tag && this.dropdown[n2 ? "show" : "hide"](this.state.tag.value);
      }, 10);
    }, onInputIE(t2) {
      var e2 = this;
      setTimeout(function() {
        e2.events.callbacks.onInput.call(e2, t2);
      });
    }, observeOriginalInputValue() {
      this.DOM.originalInput.parentNode || this.destroy(), this.DOM.originalInput.value != this.DOM.originalInput.tagifyValue && this.loadOriginalValues();
    }, onClickAnywhere(t2) {
      t2.target == this.DOM.scope || this.DOM.scope.contains(t2.target) || (this.toggleFocusClass(false), this.state.hasFocus = false, !this.settings.userInput && this.dropdown.hide());
    }, onClickScope(t2) {
      var i2 = this.settings, s2 = t2.target.closest("." + i2.classNames.tag), a2 = t2.target === this.DOM.scope, n2 = +/* @__PURE__ */ new Date() - this.state.hasFocus;
      if (a2 && "select" != i2.mode)
        this.DOM.input.focus();
      else {
        if (!t2.target.classList.contains(i2.classNames.tagX))
          return s2 && !this.state.editing ? (this.trigger("click", { tag: s2, index: this.getNodeIndex(s2), data: T(s2), event: t2 }), void (1 !== i2.editTags && 1 !== i2.editTags.clicks && "select" != i2.mode || this.events.callbacks.onDoubleClickScope.call(this, t2))) : void (t2.target == this.DOM.input && ("mix" == i2.mode && this.fixFirefoxLastTagNoCaret(), n2 > 500) ? this.state.dropdown.visible ? this.dropdown.hide() : 0 === i2.dropdown.enabled && "mix" != i2.mode && this.dropdown.show(this.value.length ? "" : void 0) : "select" != i2.mode || 0 !== i2.dropdown.enabled || this.state.dropdown.visible || (this.events.callbacks.onDoubleClickScope.call(this, e(e({}, t2), {}, { target: this.getTagElms()[0] })), !i2.userInput && this.dropdown.show()));
        this.removeTags(t2.target.parentNode);
      }
    }, onPaste(t2) {
      t2.preventDefault();
      var e2, i2, s2, a2 = this.settings;
      if ("select" == a2.mode && a2.enforceWhitelist || !a2.userInput)
        return false;
      a2.readonly || (i2 = t2.clipboardData || window.clipboardData, s2 = i2.getData("Text"), a2.hooks.beforePaste(t2, { tagify: this, pastedText: s2, clipboardData: i2 }).then((a3) => {
        void 0 === a3 && (a3 = s2), a3 && (this.injectAtCaret(a3, window.getSelection().getRangeAt(0)), "mix" == this.settings.mode ? this.events.callbacks.onMixTagsInput.call(this, t2) : this.settings.pasteAsTags ? e2 = this.addTags(this.state.inputText + a3, true) : (this.state.inputText = a3, this.dropdown.show(a3))), this.trigger("paste", { event: t2, pastedText: s2, clipboardData: i2, tagsElems: e2 });
      }).catch((t3) => t3));
    }, onDrop(t2) {
      t2.preventDefault();
    }, onEditTagInput(t2, e2) {
      var i2 = t2.closest("." + this.settings.classNames.tag), s2 = this.getNodeIndex(i2), a2 = T(i2), n2 = this.input.normalize.call(this, t2), o2 = { [this.settings.tagTextProp]: n2, __tagId: a2.__tagId }, r2 = this.validateTag(o2);
      this.editTagChangeDetected(g(a2, o2)) || true !== t2.originalIsValid || (r2 = true), i2.classList.toggle(this.settings.classNames.tagInvalid, true !== r2), a2.__isValid = r2, i2.title = true === r2 ? a2.title || a2.value : r2, n2.length >= this.settings.dropdown.enabled && (this.state.editing && (this.state.editing.value = n2), this.dropdown.show(n2)), this.trigger("edit:input", { tag: i2, index: s2, data: g({}, this.value[s2], { newValue: n2 }), event: e2 });
    }, onEditTagPaste(t2, e2) {
      var i2 = (e2.clipboardData || window.clipboardData).getData("Text");
      e2.preventDefault();
      var s2 = f(i2);
      this.setRangeAtStartEnd(false, s2);
    }, onEditTagClick(t2, e2) {
      this.events.callbacks.onClickScope.call(this, e2);
    }, onEditTagFocus(t2) {
      this.state.editing = { scope: t2, input: t2.querySelector("[contenteditable]") };
    }, onEditTagBlur(t2, e2) {
      if (v.call(this, e2.relatedTarget) && e2.relatedTarget.contains(e2.target))
        this.dropdown.hide();
      else if (this.state.editing && (this.state.hasFocus || this.toggleFocusClass(), this.DOM.scope.contains(t2))) {
        var i2, s2, a2 = this.settings, n2 = t2.closest("." + a2.classNames.tag), o2 = T(n2), r2 = this.input.normalize.call(this, t2), l2 = { [a2.tagTextProp]: r2, __tagId: o2.__tagId }, d2 = o2.__originalData, h2 = this.editTagChangeDetected(g(o2, l2)), p2 = this.validateTag(l2);
        if (r2)
          if (h2) {
            if (i2 = this.hasMaxTags(), s2 = g({}, d2, { [a2.tagTextProp]: this.trim(r2), __isValid: p2 }), a2.transformTag.call(this, s2, d2), true !== (p2 = (!i2 || true === d2.__isValid) && this.validateTag(s2))) {
              if (this.trigger("invalid", { data: s2, tag: n2, message: p2 }), a2.editTags.keepInvalid)
                return;
              a2.keepInvalidTags ? s2.__isValid = p2 : s2 = d2;
            } else
              a2.keepInvalidTags && (delete s2.title, delete s2["aria-invalid"], delete s2.class);
            this.onEditTagDone(n2, s2);
          } else
            this.onEditTagDone(n2, d2);
        else
          this.onEditTagDone(n2);
      }
    }, onEditTagkeydown(t2, e2) {
      if (!this.state.composing)
        switch (this.trigger("edit:keydown", { event: t2 }), t2.key) {
          case "Esc":
          case "Escape":
            this.state.editing = false, !!e2.__tagifyTagData.__originalData.value ? e2.parentNode.replaceChild(e2.__tagifyTagData.__originalHTML, e2) : e2.remove();
            break;
          case "Enter":
          case "Tab":
            t2.preventDefault();
            setTimeout(() => t2.target.blur(), 0);
        }
    }, onDoubleClickScope(t2) {
      var e2, i2, s2 = t2.target.closest("." + this.settings.classNames.tag), a2 = T(s2), n2 = this.settings;
      s2 && false !== a2.editable && (e2 = s2.classList.contains(this.settings.classNames.tagEditing), i2 = s2.hasAttribute("readonly"), n2.readonly || e2 || i2 || !this.settings.editTags || !n2.userInput || this.editTag(s2), this.toggleFocusClass(true), "select" != n2.mode && this.trigger("dblclick", { tag: s2, index: this.getNodeIndex(s2), data: T(s2) }));
    }, onInputDOMChange(t2) {
      t2.forEach((t3) => {
        t3.addedNodes.forEach((t4) => {
          var _a2;
          if ("<div><br></div>" == t4.outerHTML)
            t4.replaceWith(document.createElement("br"));
          else if (1 == t4.nodeType && t4.querySelector(this.settings.classNames.tagSelector)) {
            let e3 = document.createTextNode("");
            3 == t4.childNodes[0].nodeType && "BR" != t4.previousSibling.nodeName && (e3 = document.createTextNode("\n")), t4.replaceWith(e3, ...[...t4.childNodes].slice(0, -1)), w(e3);
          } else if (v.call(this, t4))
            if (3 != ((_a2 = t4.previousSibling) == null ? void 0 : _a2.nodeType) || t4.previousSibling.textContent || t4.previousSibling.remove(), t4.previousSibling && "BR" == t4.previousSibling.nodeName) {
              t4.previousSibling.replaceWith("\n​");
              let e3 = t4.nextSibling, i2 = "";
              for (; e3; )
                i2 += e3.textContent, e3 = e3.nextSibling;
              i2.trim() && w(t4.previousSibling);
            } else
              t4.previousSibling && !T(t4.previousSibling) || t4.before("​");
        }), t3.removedNodes.forEach((t4) => {
          t4 && "BR" == t4.nodeName && v.call(this, e2) && (this.removeTags(e2), this.fixFirefoxLastTagNoCaret());
        });
      });
      var e2 = this.DOM.input.lastChild;
      e2 && "" == e2.nodeValue && e2.remove(), e2 && "BR" == e2.nodeName || this.DOM.input.appendChild(document.createElement("br"));
    } } };
    function _(t2, e2) {
      if (!t2) {
        console.warn("Tagify:", "input element not found", t2);
        const e3 = new Proxy(this, { get: () => () => e3 });
        return e3;
      }
      if (t2.__tagify)
        return console.warn("Tagify: ", "input element is already Tagified - Same instance is returned.", t2), t2.__tagify;
      var i2;
      g(this, function(t3) {
        var e3 = document.createTextNode("");
        function i3(t4, i4, s2) {
          s2 && i4.split(/\s+/g).forEach((i5) => e3[t4 + "EventListener"].call(e3, i5, s2));
        }
        return { off(t4, e4) {
          return i3("remove", t4, e4), this;
        }, on(t4, e4) {
          return e4 && "function" == typeof e4 && i3("add", t4, e4), this;
        }, trigger(i4, s2, a2) {
          var n2;
          if (a2 = a2 || { cloneData: true }, i4)
            if (t3.settings.isJQueryPlugin)
              "remove" == i4 && (i4 = "removeTag"), jQuery(t3.DOM.originalInput).triggerHandler(i4, [s2]);
            else {
              try {
                var o2 = "object" == typeof s2 ? s2 : { value: s2 };
                if ((o2 = a2.cloneData ? g({}, o2) : o2).tagify = this, s2.event && (o2.event = this.cloneEvent(s2.event)), s2 instanceof Object)
                  for (var r2 in s2)
                    s2[r2] instanceof HTMLElement && (o2[r2] = s2[r2]);
                n2 = new CustomEvent(i4, { detail: o2 });
              } catch (t4) {
                console.warn(t4);
              }
              e3.dispatchEvent(n2);
            }
        } };
      }(this)), this.isFirefox = /firefox|fxios/i.test(navigator.userAgent) && !/seamonkey/i.test(navigator.userAgent), this.isIE = window.document.documentMode, e2 = e2 || {}, this.getPersistedData = (i2 = e2.id, (t3) => {
        let e3, s2 = "/" + t3;
        if (1 == localStorage.getItem(N + i2 + "/v", 1))
          try {
            e3 = JSON.parse(localStorage[N + i2 + s2]);
          } catch (t4) {
          }
        return e3;
      }), this.setPersistedData = ((t3) => t3 ? (localStorage.setItem(N + t3 + "/v", 1), (e3, i3) => {
        let s2 = "/" + i3, a2 = JSON.stringify(e3);
        e3 && i3 && (localStorage.setItem(N + t3 + s2, a2), dispatchEvent(new Event("storage")));
      }) : () => {
      })(e2.id), this.clearPersistedData = /* @__PURE__ */ ((t3) => (e3) => {
        const i3 = N + "/" + t3 + "/";
        if (e3)
          localStorage.removeItem(i3 + e3);
        else
          for (let t4 in localStorage)
            t4.includes(i3) && localStorage.removeItem(t4);
      })(e2.id), this.applySettings(t2, e2), this.state = { inputText: "", editing: false, composing: false, actions: {}, mixMode: {}, dropdown: {}, flaggedTags: {} }, this.value = [], this.listeners = {}, this.DOM = {}, this.build(t2), O.call(this), this.getCSSVars(), this.loadOriginalValues(), this.events.customBinding.call(this), this.events.binding.call(this), t2.autofocus && this.DOM.input.focus(), t2.__tagify = this;
    }
    return _.prototype = { _dropdown: D, placeCaretAfterNode: w, getSetTagData: T, helpers: { sameStr: s, removeCollectionProp: a, omit: n, isObject: h, parseHTML: r, escapeHTML: d, extend: g, concatWithoutDups: p, getUID: m, isNodeTag: v }, customEventsList: ["change", "add", "remove", "invalid", "input", "paste", "click", "keydown", "focus", "blur", "edit:input", "edit:beforeUpdate", "edit:updated", "edit:start", "edit:keydown", "dropdown:show", "dropdown:hide", "dropdown:select", "dropdown:updated", "dropdown:noMatch", "dropdown:scroll"], dataProps: ["__isValid", "__removed", "__originalData", "__originalHTML", "__tagId"], trim(t2) {
      return this.settings.trim && t2 && "string" == typeof t2 ? t2.trim() : t2;
    }, parseHTML: r, templates: E, parseTemplate(t2, e2) {
      return r((t2 = this.settings.templates[t2] || t2).apply(this, e2));
    }, set whitelist(t2) {
      const e2 = t2 && Array.isArray(t2);
      this.settings.whitelist = e2 ? t2 : [], this.setPersistedData(e2 ? t2 : [], "whitelist");
    }, get whitelist() {
      return this.settings.whitelist;
    }, generateClassSelectors(t2) {
      for (let e2 in t2) {
        let i2 = e2;
        Object.defineProperty(t2, i2 + "Selector", { get() {
          return "." + this[i2].split(" ")[0];
        } });
      }
    }, applySettings(t2, i2) {
      var _a2, _b;
      y.templates = this.templates;
      var s2 = g({}, y, "mix" == i2.mode ? { dropdown: { position: "text" } } : {}), a2 = this.settings = g({}, s2, i2);
      if (a2.disabled = t2.hasAttribute("disabled"), a2.readonly = a2.readonly || t2.hasAttribute("readonly"), a2.placeholder = d(t2.getAttribute("placeholder") || a2.placeholder || ""), a2.required = t2.hasAttribute("required"), this.generateClassSelectors(a2.classNames), void 0 === a2.dropdown.includeSelectedTags && (a2.dropdown.includeSelectedTags = a2.duplicates), this.isIE && (a2.autoComplete = false), ["whitelist", "blacklist"].forEach((e2) => {
        var i3 = t2.getAttribute("data-" + e2);
        i3 && (i3 = i3.split(a2.delimiters)) instanceof Array && (a2[e2] = i3);
      }), "autoComplete" in i2 && !h(i2.autoComplete) && (a2.autoComplete = y.autoComplete, a2.autoComplete.enabled = i2.autoComplete), "mix" == a2.mode && (a2.pattern = a2.pattern || /@/, a2.autoComplete.rightKey = true, a2.delimiters = i2.delimiters || null, a2.tagTextProp && !a2.dropdown.searchKeys.includes(a2.tagTextProp) && a2.dropdown.searchKeys.push(a2.tagTextProp)), t2.pattern)
        try {
          a2.pattern = new RegExp(t2.pattern);
        } catch (t3) {
        }
      if (a2.delimiters) {
        a2._delimiters = a2.delimiters;
        try {
          a2.delimiters = new RegExp(this.settings.delimiters, "g");
        } catch (t3) {
        }
      }
      a2.disabled && (a2.userInput = false), this.TEXTS = e(e({}, I), a2.texts || {}), ("select" != a2.mode || ((_a2 = i2.dropdown) == null ? void 0 : _a2.enabled)) && a2.userInput || (a2.dropdown.enabled = 0), a2.dropdown.appendTarget = ((_b = i2.dropdown) == null ? void 0 : _b.appendTarget) || document.body;
      let n2 = this.getPersistedData("whitelist");
      Array.isArray(n2) && (this.whitelist = Array.isArray(a2.whitelist) ? p(a2.whitelist, n2) : n2);
    }, getAttributes(t2) {
      var e2, i2 = this.getCustomAttributes(t2), s2 = "";
      for (e2 in i2)
        s2 += " " + e2 + (void 0 !== t2[e2] ? `="${i2[e2]}"` : "");
      return s2;
    }, getCustomAttributes(t2) {
      if (!h(t2))
        return "";
      var e2, i2 = {};
      for (e2 in t2)
        "__" != e2.slice(0, 2) && "class" != e2 && t2.hasOwnProperty(e2) && void 0 !== t2[e2] && (i2[e2] = d(t2[e2]));
      return i2;
    }, setStateSelection() {
      var t2 = window.getSelection(), e2 = { anchorOffset: t2.anchorOffset, anchorNode: t2.anchorNode, range: t2.getRangeAt && t2.rangeCount && t2.getRangeAt(0) };
      return this.state.selection = e2, e2;
    }, getCSSVars() {
      var t2 = getComputedStyle(this.DOM.scope, null);
      var e2;
      this.CSSVars = { tagHideTransition: ((t3) => {
        let e3 = t3.value;
        return "s" == t3.unit ? 1e3 * e3 : e3;
      })(function(t3) {
        if (!t3)
          return {};
        var e3 = (t3 = t3.trim().split(" ")[0]).split(/\d+/g).filter((t4) => t4).pop().trim();
        return { value: +t3.split(e3).filter((t4) => t4)[0].trim(), unit: e3 };
      }((e2 = "tag-hide-transition", t2.getPropertyValue("--" + e2)))) };
    }, build(t2) {
      var e2 = this.DOM, i2 = t2.closest("label");
      this.settings.mixMode.integrated ? (e2.originalInput = null, e2.scope = t2, e2.input = t2) : (e2.originalInput = t2, e2.originalInput_tabIndex = t2.tabIndex, e2.scope = this.parseTemplate("wrapper", [t2, this.settings]), e2.input = e2.scope.querySelector(this.settings.classNames.inputSelector), t2.parentNode.insertBefore(e2.scope, t2), t2.tabIndex = -1), i2 && i2.setAttribute("for", "");
    }, destroy() {
      this.events.unbindGlobal.call(this), this.DOM.scope.parentNode.removeChild(this.DOM.scope), this.DOM.originalInput.tabIndex = this.DOM.originalInput_tabIndex, delete this.DOM.originalInput.__tagify, this.dropdown.hide(true), clearTimeout(this.dropdownHide__bindEventsTimeout), clearInterval(this.listeners.main.originalInputValueObserverInterval);
    }, loadOriginalValues(t2) {
      var e2, i2 = this.settings;
      if (this.state.blockChangeEvent = true, void 0 === t2) {
        const e3 = this.getPersistedData("value");
        t2 = e3 && !this.DOM.originalInput.value ? e3 : i2.mixMode.integrated ? this.DOM.input.textContent : this.DOM.originalInput.value;
      }
      if (this.removeAllTags(), t2)
        if ("mix" == i2.mode)
          this.parseMixTags(t2), (e2 = this.DOM.input.lastChild) && "BR" == e2.tagName || this.DOM.input.insertAdjacentHTML("beforeend", "<br>");
        else {
          try {
            JSON.parse(t2) instanceof Array && (t2 = JSON.parse(t2));
          } catch (t3) {
          }
          this.addTags(t2, true).forEach((t3) => t3 && t3.classList.add(i2.classNames.tagNoAnimation));
        }
      else
        this.postUpdate();
      this.state.lastOriginalValueReported = i2.mixMode.integrated ? "" : this.DOM.originalInput.value;
    }, cloneEvent(t2) {
      var e2 = {};
      for (var i2 in t2)
        "path" != i2 && (e2[i2] = t2[i2]);
      return e2;
    }, loading(t2) {
      return this.state.isLoading = t2, this.DOM.scope.classList[t2 ? "add" : "remove"](this.settings.classNames.scopeLoading), this;
    }, tagLoading(t2, e2) {
      return t2 && t2.classList[e2 ? "add" : "remove"](this.settings.classNames.tagLoading), this;
    }, toggleClass(t2, e2) {
      "string" == typeof t2 && this.DOM.scope.classList.toggle(t2, e2);
    }, toggleScopeValidation(t2) {
      var e2 = true === t2 || void 0 === t2;
      !this.settings.required && t2 && t2 === this.TEXTS.empty && (e2 = true), this.toggleClass(this.settings.classNames.tagInvalid, !e2), this.DOM.scope.title = e2 ? "" : t2;
    }, toggleFocusClass(t2) {
      this.toggleClass(this.settings.classNames.focus, !!t2);
    }, triggerChangeEvent: function() {
      if (!this.settings.mixMode.integrated) {
        var t2 = this.DOM.originalInput, e2 = this.state.lastOriginalValueReported !== t2.value, i2 = new CustomEvent("change", { bubbles: true });
        e2 && (this.state.lastOriginalValueReported = t2.value, i2.simulated = true, t2._valueTracker && t2._valueTracker.setValue(Math.random()), t2.dispatchEvent(i2), this.trigger("change", this.state.lastOriginalValueReported), t2.value = this.state.lastOriginalValueReported);
      }
    }, events: S, fixFirefoxLastTagNoCaret() {
    }, setRangeAtStartEnd(t2, e2) {
      if (e2) {
        t2 = "number" == typeof t2 ? t2 : !!t2, e2 = e2.lastChild || e2;
        var i2 = document.getSelection();
        if (i2.focusNode instanceof Element && !this.DOM.input.contains(i2.focusNode))
          return true;
        try {
          i2.rangeCount >= 1 && ["Start", "End"].forEach((s2) => i2.getRangeAt(0)["set" + s2](e2, t2 || e2.length));
        } catch (t3) {
          console.warn("Tagify: ", t3);
        }
      }
    }, insertAfterTag(t2, e2) {
      if (e2 = e2 || this.settings.mixMode.insertAfterTag, t2 && t2.parentNode && e2)
        return e2 = "string" == typeof e2 ? document.createTextNode(e2) : e2, t2.parentNode.insertBefore(e2, t2.nextSibling), e2;
    }, editTagChangeDetected(t2) {
      var e2 = t2.__originalData;
      for (var i2 in e2)
        if (!this.dataProps.includes(i2) && t2[i2] != e2[i2])
          return true;
      return false;
    }, getTagTextNode(t2) {
      return t2.querySelector(this.settings.classNames.tagTextSelector);
    }, setTagTextNode(t2, e2) {
      this.getTagTextNode(t2).innerHTML = d(e2);
    }, editTag(t2, e2) {
      t2 = t2 || this.getLastTag(), e2 = e2 || {}, this.dropdown.hide();
      var i2 = this.settings, s2 = this.getTagTextNode(t2), a2 = this.getNodeIndex(t2), n2 = T(t2), o2 = this.events.callbacks, r2 = true;
      if (s2) {
        if (!(n2 instanceof Object && "editable" in n2) || n2.editable)
          return n2 = T(t2, { __originalData: g({}, n2), __originalHTML: t2.cloneNode(true) }), T(n2.__originalHTML, n2.__originalData), s2.setAttribute("contenteditable", true), t2.classList.add(i2.classNames.tagEditing), s2.addEventListener("click", o2.onEditTagClick.bind(this, t2)), s2.addEventListener("focus", o2.onEditTagFocus.bind(this, t2)), s2.addEventListener("blur", o2.onEditTagBlur.bind(this, this.getTagTextNode(t2))), s2.addEventListener("input", o2.onEditTagInput.bind(this, s2)), s2.addEventListener("paste", o2.onEditTagPaste.bind(this, s2)), s2.addEventListener("keydown", (e3) => o2.onEditTagkeydown.call(this, e3, t2)), s2.addEventListener("compositionstart", o2.onCompositionStart.bind(this)), s2.addEventListener("compositionend", o2.onCompositionEnd.bind(this)), e2.skipValidation || (r2 = this.editTagToggleValidity(t2)), s2.originalIsValid = r2, this.trigger("edit:start", { tag: t2, index: a2, data: n2, isValid: r2 }), s2.focus(), this.setRangeAtStartEnd(false, s2), 0 === i2.dropdown.enabled && this.dropdown.show(), this.state.hasFocus = true, this;
      } else
        console.warn("Cannot find element in Tag template: .", i2.classNames.tagTextSelector);
    }, editTagToggleValidity(t2, e2) {
      var i2;
      if (e2 = e2 || T(t2))
        return (i2 = !("__isValid" in e2) || true === e2.__isValid) || this.removeTagsFromValue(t2), this.update(), t2.classList.toggle(this.settings.classNames.tagNotAllowed, !i2), e2.__isValid = i2, e2.__isValid;
      console.warn("tag has no data: ", t2, e2);
    }, onEditTagDone(t2, e2) {
      var _a2;
      t2 = t2 || this.state.editing.scope, e2 = e2 || {};
      var i2, s2 = { tag: t2, index: this.getNodeIndex(t2), previousData: T(t2), data: e2 }, a2 = this.settings;
      this.trigger("edit:beforeUpdate", s2, { cloneData: false }), this.state.editing = false, delete e2.__originalData, delete e2.__originalHTML, t2 && ((i2 = e2[a2.tagTextProp]) ? (_a2 = i2.trim) == null ? void 0 : _a2.call(i2) : a2.tagTextProp in e2 ? void 0 : e2.value) ? (t2 = this.replaceTag(t2, e2), this.editTagToggleValidity(t2, e2), a2.a11y.focusableTags ? t2.focus() : w(t2)) : t2 && this.removeTags(t2), this.trigger("edit:updated", s2), this.dropdown.hide(), this.settings.keepInvalidTags && this.reCheckInvalidTags();
    }, replaceTag(t2, e2) {
      e2 && "" !== e2.value && void 0 !== e2.value || (e2 = t2.__tagifyTagData), e2.__isValid && 1 != e2.__isValid && g(e2, this.getInvalidTagAttrs(e2, e2.__isValid));
      var i2 = this.createTagElem(e2);
      return t2.parentNode.replaceChild(i2, t2), this.updateValueByDOMTags(), i2;
    }, updateValueByDOMTags() {
      this.value.length = 0, [].forEach.call(this.getTagElms(), (t2) => {
        t2.classList.contains(this.settings.classNames.tagNotAllowed.split(" ")[0]) || this.value.push(T(t2));
      }), this.update();
    }, injectAtCaret(t2, e2) {
      var _a2;
      if (!(e2 = e2 || ((_a2 = this.state.selection) == null ? void 0 : _a2.range)) && t2)
        return this.appendMixTags(t2), this;
      let i2 = f(t2, e2);
      return this.setRangeAtStartEnd(false, i2), this.updateValueByDOMTags(), this.update(), this;
    }, input: { set() {
      let t2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "", e2 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
      var i2 = this.settings.dropdown.closeOnSelect;
      this.state.inputText = t2, e2 && (this.DOM.input.innerHTML = d("" + t2)), !t2 && i2 && this.dropdown.hide.bind(this), this.input.autocomplete.suggest.call(this), this.input.validate.call(this);
    }, raw() {
      return this.DOM.input.textContent;
    }, validate() {
      var t2 = !this.state.inputText || true === this.validateTag({ value: this.state.inputText });
      return this.DOM.input.classList.toggle(this.settings.classNames.inputInvalid, !t2), t2;
    }, normalize(t2, e2) {
      var i2 = t2 || this.DOM.input, s2 = [];
      i2.childNodes.forEach((t3) => 3 == t3.nodeType && s2.push(t3.nodeValue)), s2 = s2.join("\n");
      try {
        s2 = s2.replace(/(?:\r\n|\r|\n)/g, this.settings.delimiters.source.charAt(0));
      } catch (t3) {
      }
      return s2 = s2.replace(/\s/g, " "), (e2 == null ? void 0 : e2.trim) ? this.trim(s2) : s2;
    }, autocomplete: { suggest(t2) {
      if (this.settings.autoComplete.enabled) {
        "object" != typeof (t2 = t2 || { value: "" }) && (t2 = { value: t2 });
        var e2 = this.dropdown.getMappedValue(t2);
        if ("number" != typeof e2) {
          var i2 = this.state.inputText.toLowerCase(), s2 = e2.substr(0, this.state.inputText.length).toLowerCase(), a2 = e2.substring(this.state.inputText.length);
          e2 && this.state.inputText && s2 == i2 ? (this.DOM.input.setAttribute("data-suggest", a2), this.state.inputSuggestion = t2) : (this.DOM.input.removeAttribute("data-suggest"), delete this.state.inputSuggestion);
        }
      }
    }, set(t2) {
      var e2 = this.DOM.input.getAttribute("data-suggest"), i2 = t2 || (e2 ? this.state.inputText + e2 : null);
      return !!i2 && ("mix" == this.settings.mode ? this.replaceTextWithNode(document.createTextNode(this.state.tag.prefix + i2)) : (this.input.set.call(this, i2), this.setRangeAtStartEnd(false, this.DOM.input)), this.input.autocomplete.suggest.call(this), this.dropdown.hide(), true);
    } } }, getTagIdx(t2) {
      return this.value.findIndex((e2) => e2.__tagId == (t2 || {}).__tagId);
    }, getNodeIndex(t2) {
      var e2 = 0;
      if (t2)
        for (; t2 = t2.previousElementSibling; )
          e2++;
      return e2;
    }, getTagElms() {
      for (var t2 = arguments.length, e2 = new Array(t2), i2 = 0; i2 < t2; i2++)
        e2[i2] = arguments[i2];
      var s2 = "." + [...this.settings.classNames.tag.split(" "), ...e2].join(".");
      return [].slice.call(this.DOM.scope.querySelectorAll(s2));
    }, getLastTag() {
      var t2 = this.DOM.scope.querySelectorAll(`${this.settings.classNames.tagSelector}:not(.${this.settings.classNames.tagHide}):not([readonly])`);
      return t2[t2.length - 1];
    }, isTagDuplicate(t2, e2, i2) {
      var a2 = 0;
      if ("select" == this.settings.mode)
        return false;
      for (let n2 of this.value) {
        s(this.trim("" + t2), n2.value, e2) && i2 != n2.__tagId && a2++;
      }
      return a2;
    }, getTagIndexByValue(t2) {
      var e2 = [], i2 = this.settings.dropdown.caseSensitive;
      return this.getTagElms().forEach((a2, n2) => {
        a2.__tagifyTagData && s(this.trim(a2.__tagifyTagData.value), t2, i2) && e2.push(n2);
      }), e2;
    }, getTagElmByValue(t2) {
      var e2 = this.getTagIndexByValue(t2)[0];
      return this.getTagElms()[e2];
    }, flashTag(t2) {
      t2 && (t2.classList.add(this.settings.classNames.tagFlash), setTimeout(() => {
        t2.classList.remove(this.settings.classNames.tagFlash);
      }, 100));
    }, isTagBlacklisted(t2) {
      return t2 = this.trim(t2.toLowerCase()), this.settings.blacklist.filter((e2) => ("" + e2).toLowerCase() == t2).length;
    }, isTagWhitelisted(t2) {
      return !!this.getWhitelistItem(t2);
    }, getWhitelistItem(t2, e2, i2) {
      e2 = e2 || "value";
      var a2, n2 = this.settings;
      return (i2 = i2 || n2.whitelist).some((i3) => {
        var o2 = "string" == typeof i3 ? i3 : i3[e2] || i3.value;
        if (s(o2, t2, n2.dropdown.caseSensitive, n2.trim))
          return a2 = "string" == typeof i3 ? { value: i3 } : i3, true;
      }), a2 || "value" != e2 || "value" == n2.tagTextProp || (a2 = this.getWhitelistItem(t2, n2.tagTextProp, i2)), a2;
    }, validateTag(t2) {
      var e2 = this.settings, i2 = "value" in t2 ? "value" : e2.tagTextProp, s2 = this.trim(t2[i2] + "");
      return (t2[i2] + "").trim() ? "mix" != e2.mode && e2.pattern && e2.pattern instanceof RegExp && !e2.pattern.test(s2) ? this.TEXTS.pattern : !e2.duplicates && this.isTagDuplicate(s2, e2.dropdown.caseSensitive, t2.__tagId) ? this.TEXTS.duplicate : this.isTagBlacklisted(s2) || e2.enforceWhitelist && !this.isTagWhitelisted(s2) ? this.TEXTS.notAllowed : !e2.validate || e2.validate(t2) : this.TEXTS.empty;
    }, getInvalidTagAttrs(t2, e2) {
      return { "aria-invalid": true, class: `${t2.class || ""} ${this.settings.classNames.tagNotAllowed}`.trim(), title: e2 };
    }, hasMaxTags() {
      return this.value.length >= this.settings.maxTags && this.TEXTS.exceed;
    }, setReadonly(t2, e2) {
      var i2 = this.settings;
      document.activeElement.blur(), i2[e2 || "readonly"] = t2, this.DOM.scope[(t2 ? "set" : "remove") + "Attribute"](e2 || "readonly", true), this.settings.userInput = true, this.setContentEditable(!t2);
    }, setContentEditable(t2) {
      this.settings.userInput && (this.DOM.input.contentEditable = t2, this.DOM.input.tabIndex = t2 ? 0 : -1);
    }, setDisabled(t2) {
      this.setReadonly(t2, "disabled");
    }, normalizeTags(t2) {
      var e2 = this.settings, i2 = e2.whitelist, s2 = e2.delimiters, a2 = e2.mode, n2 = e2.tagTextProp, o2 = [], r2 = !!i2 && i2[0] instanceof Object, l2 = Array.isArray(t2), d2 = l2 && t2[0].value, h2 = (t3) => (t3 + "").split(s2).filter((t4) => t4).map((t4) => ({ [n2]: this.trim(t4), value: this.trim(t4) }));
      if ("number" == typeof t2 && (t2 = t2.toString()), "string" == typeof t2) {
        if (!t2.trim())
          return [];
        t2 = h2(t2);
      } else
        l2 && (t2 = [].concat(...t2.map((t3) => null != t3.value ? t3 : h2(t3))));
      return r2 && !d2 && (t2.forEach((t3) => {
        var e3 = o2.map((t4) => t4.value), i3 = this.dropdown.filterListItems.call(this, t3[n2], { exact: true });
        this.settings.duplicates || (i3 = i3.filter((t4) => !e3.includes(t4.value)));
        var s3 = i3.length > 1 ? this.getWhitelistItem(t3[n2], n2, i3) : i3[0];
        s3 && s3 instanceof Object ? o2.push(s3) : "mix" != a2 && (null == t3.value && (t3.value = t3[n2]), o2.push(t3));
      }), o2.length && (t2 = o2)), t2;
    }, parseMixTags(t2) {
      var e2 = this.settings, i2 = e2.mixTagsInterpolator, s2 = e2.duplicates, a2 = e2.transformTag, n2 = e2.enforceWhitelist, o2 = e2.maxTags, r2 = e2.tagTextProp, l2 = [];
      t2 = t2.split(i2[0]).map((t3, e3) => {
        var d3, h2, g2, p2 = t3.split(i2[1]), c2 = p2[0], u2 = l2.length == o2;
        try {
          if (c2 == +c2)
            throw Error;
          h2 = JSON.parse(c2);
        } catch (t4) {
          h2 = this.normalizeTags(c2)[0] || { value: c2 };
        }
        if (a2.call(this, h2), u2 || !(p2.length > 1) || n2 && !this.isTagWhitelisted(h2.value) || !s2 && this.isTagDuplicate(h2.value)) {
          if (t3)
            return e3 ? i2[0] + t3 : t3;
        } else
          h2[d3 = h2[r2] ? r2 : "value"] = this.trim(h2[d3]), g2 = this.createTagElem(h2), l2.push(h2), g2.classList.add(this.settings.classNames.tagNoAnimation), p2[0] = g2.outerHTML, this.value.push(h2);
        return p2.join("");
      }).join(""), this.DOM.input.innerHTML = t2, this.DOM.input.appendChild(document.createTextNode("")), this.DOM.input.normalize();
      var d2 = this.getTagElms();
      return d2.forEach((t3, e3) => T(t3, l2[e3])), this.update({ withoutChangeEvent: true }), b(d2, this.state.hasFocus), t2;
    }, replaceTextWithNode(t2, e2) {
      if (this.state.tag || e2) {
        e2 = e2 || this.state.tag.prefix + this.state.tag.value;
        var i2, s2, a2 = this.state.selection || window.getSelection(), n2 = a2.anchorNode, o2 = this.state.tag.delimiters ? this.state.tag.delimiters.length : 0;
        return n2.splitText(a2.anchorOffset - o2), -1 == (i2 = n2.nodeValue.lastIndexOf(e2)) ? true : (s2 = n2.splitText(i2), t2 && n2.parentNode.replaceChild(t2, s2), true);
      }
    }, prepareNewTagNode(t2, e2) {
      e2 = e2 || {};
      var i2 = this.settings, s2 = [], a2 = {}, n2 = Object.assign({}, t2, { value: t2.value + "" });
      if (t2 = Object.assign({}, n2), i2.transformTag.call(this, t2), t2.__isValid = this.hasMaxTags() || this.validateTag(t2), true !== t2.__isValid) {
        if (e2.skipInvalid)
          return;
        if (g(a2, this.getInvalidTagAttrs(t2, t2.__isValid), { __preInvalidData: n2 }), t2.__isValid == this.TEXTS.duplicate && this.flashTag(this.getTagElmByValue(t2.value)), !i2.createInvalidTags)
          return void s2.push(t2.value);
      }
      return "readonly" in t2 && (t2.readonly ? a2["aria-readonly"] = true : delete t2.readonly), { tagElm: this.createTagElem(t2, a2), tagData: t2, aggregatedInvalidInput: s2 };
    }, postProcessNewTagNode(t2, e2) {
      var i2 = this.settings, s2 = e2.__isValid;
      s2 && true === s2 ? (this.value.push(e2), this.trigger("add", { tag: t2, index: this.value.length - 1, data: e2 })) : (this.trigger("invalid", { data: e2, index: this.value.length, tag: t2, message: s2 }), i2.keepInvalidTags || setTimeout(() => this.removeTags(t2, true), 1e3)), this.dropdown.position();
    }, selectTag(t2, e2) {
      if (!this.settings.enforceWhitelist || this.isTagWhitelisted(e2.value)) {
        this.state.actions.selectOption && setTimeout(() => this.setRangeAtStartEnd(false, this.DOM.input));
        var i2 = this.getLastTag();
        return i2 ? this.replaceTag(i2, e2) : this.appendTag(t2), this.value[0] = e2, this.update(), this.trigger("add", { tag: t2, data: e2 }), [t2];
      }
    }, addEmptyTag(t2) {
      var e2 = g({ value: "" }, t2 || {}), i2 = this.createTagElem(e2);
      T(i2, e2), this.appendTag(i2), this.editTag(i2, { skipValidation: true }), this.toggleFocusClass(true);
    }, addTags(t2, e2, i2) {
      var s2 = [], a2 = this.settings, n2 = [], o2 = document.createDocumentFragment();
      if (!t2 || 0 == t2.length)
        return s2;
      switch (t2 = this.normalizeTags(t2), a2.mode) {
        case "mix":
          return this.addMixTags(t2);
        case "select":
          e2 = false, this.removeAllTags();
      }
      return this.DOM.input.removeAttribute("style"), t2.forEach((t3) => {
        const e3 = this.prepareNewTagNode(t3, { skipInvalid: i2 || a2.skipInvalid }), r2 = e3.tagElm;
        if (t3 = e3.tagData, n2 = e3.aggregatedInvalidInput, s2.push(r2), "select" == a2.mode)
          return this.selectTag(r2, t3);
        o2.appendChild(r2), this.postProcessNewTagNode(r2, t3);
      }), this.appendTag(o2), this.update(), t2.length && e2 && (this.input.set.call(this, a2.createInvalidTags ? "" : n2.join(a2._delimiters)), this.setRangeAtStartEnd(false, this.DOM.input)), a2.dropdown.enabled && this.dropdown.refilter(), s2;
    }, addMixTags(t2) {
      if ((t2 = this.normalizeTags(t2))[0].prefix || this.state.tag)
        return this.prefixedTextToTag(t2[0]);
      var e2 = document.createDocumentFragment();
      return t2.forEach((t3) => {
        const i2 = this.prepareNewTagNode(t3);
        e2.appendChild(i2.tagElm), this.postProcessNewTagNode(tagElm, i2.tagData);
      }), this.appendMixTags(e2), e2;
    }, appendMixTags(t2) {
      var e2 = !!this.state.selection;
      e2 ? this.injectAtCaret(t2) : (this.DOM.input.focus(), (e2 = this.setStateSelection()).range.setStart(this.DOM.input, e2.range.endOffset), e2.range.setEnd(this.DOM.input, e2.range.endOffset), this.DOM.input.appendChild(t2), this.updateValueByDOMTags(), this.update());
    }, prefixedTextToTag(t2) {
      var _a2;
      var e2, i2, s2 = this.settings, a2 = (_a2 = this.state.tag) == null ? void 0 : _a2.delimiters;
      if (t2.prefix = t2.prefix || this.state.tag ? this.state.tag.prefix : (s2.pattern.source || s2.pattern)[0], i2 = this.prepareNewTagNode(t2), e2 = i2.tagElm, this.replaceTextWithNode(e2) || this.DOM.input.appendChild(e2), setTimeout(() => e2.classList.add(this.settings.classNames.tagNoAnimation), 300), this.value.push(i2.tagData), this.update(), !a2) {
        var n2 = this.insertAfterTag(e2) || e2;
        setTimeout(w, 0, n2);
      }
      return this.state.tag = null, this.postProcessNewTagNode(e2, i2.tagData), e2;
    }, appendTag(t2) {
      var e2 = this.DOM, i2 = e2.input;
      e2.scope.insertBefore(t2, i2);
    }, createTagElem(t2, i2) {
      t2.__tagId = m();
      var s2, a2 = g({}, t2, e({ value: d(t2.value + "") }, i2));
      return function(t3) {
        for (var e2, i3 = document.createNodeIterator(t3, NodeFilter.SHOW_TEXT, null, false); e2 = i3.nextNode(); )
          e2.textContent.trim() || e2.parentNode.removeChild(e2);
      }(s2 = this.parseTemplate("tag", [a2, this])), T(s2, t2), s2;
    }, reCheckInvalidTags() {
      var t2 = this.settings;
      this.getTagElms(t2.classNames.tagNotAllowed).forEach((e2, i2) => {
        var s2 = T(e2), a2 = this.hasMaxTags(), n2 = this.validateTag(s2), o2 = true === n2 && !a2;
        if ("select" == t2.mode && this.toggleScopeValidation(n2), o2)
          return s2 = s2.__preInvalidData ? s2.__preInvalidData : { value: s2.value }, this.replaceTag(e2, s2);
        e2.title = a2 || n2;
      });
    }, removeTags(t2, e2, i2) {
      var s2, a2 = this.settings;
      if (t2 = t2 && t2 instanceof HTMLElement ? [t2] : t2 instanceof Array ? t2 : t2 ? [t2] : [this.getLastTag()], s2 = t2.reduce((t3, e3) => {
        e3 && "string" == typeof e3 && (e3 = this.getTagElmByValue(e3));
        var i3 = T(e3);
        return e3 && i3 && !i3.readonly && t3.push({ node: e3, idx: this.getTagIdx(i3), data: T(e3, { __removed: true }) }), t3;
      }, []), i2 = "number" == typeof i2 ? i2 : this.CSSVars.tagHideTransition, "select" == a2.mode && (i2 = 0, this.input.set.call(this)), 1 == s2.length && "select" != a2.mode && s2[0].node.classList.contains(a2.classNames.tagNotAllowed) && (e2 = true), s2.length)
        return a2.hooks.beforeRemoveTag(s2, { tagify: this }).then(() => {
          function t3(t4) {
            t4.node.parentNode && (t4.node.parentNode.removeChild(t4.node), e2 ? a2.keepInvalidTags && this.trigger("remove", { tag: t4.node, index: t4.idx }) : (this.trigger("remove", { tag: t4.node, index: t4.idx, data: t4.data }), this.dropdown.refilter(), this.dropdown.position(), this.DOM.input.normalize(), a2.keepInvalidTags && this.reCheckInvalidTags()));
          }
          i2 && i2 > 10 && 1 == s2.length ? (function(e3) {
            e3.node.style.width = parseFloat(window.getComputedStyle(e3.node).width) + "px", document.body.clientTop, e3.node.classList.add(a2.classNames.tagHide), setTimeout(t3.bind(this), i2, e3);
          }).call(this, s2[0]) : s2.forEach(t3.bind(this)), e2 || (this.removeTagsFromValue(s2.map((t4) => t4.node)), this.update(), "select" == a2.mode && this.setContentEditable(true));
        }).catch((t3) => {
        });
    }, removeTagsFromDOM() {
      [].slice.call(this.getTagElms()).forEach((t2) => t2.parentNode.removeChild(t2));
    }, removeTagsFromValue(t2) {
      (t2 = Array.isArray(t2) ? t2 : [t2]).forEach((t3) => {
        var e2 = T(t3), i2 = this.getTagIdx(e2);
        i2 > -1 && this.value.splice(i2, 1);
      });
    }, removeAllTags(t2) {
      t2 = t2 || {}, this.value = [], "mix" == this.settings.mode ? this.DOM.input.innerHTML = "" : this.removeTagsFromDOM(), this.dropdown.refilter(), this.dropdown.position(), this.state.dropdown.visible && setTimeout(() => {
        this.DOM.input.focus();
      }), "select" == this.settings.mode && (this.input.set.call(this), this.setContentEditable(true)), this.update(t2);
    }, postUpdate() {
      var _a2, _b;
      this.state.blockChangeEvent = false;
      var t2 = this.settings, e2 = t2.classNames, i2 = "mix" == t2.mode ? t2.mixMode.integrated ? this.DOM.input.textContent : this.DOM.originalInput.value.trim() : this.value.length + this.input.raw.call(this).length;
      this.toggleClass(e2.hasMaxTags, this.value.length >= t2.maxTags), this.toggleClass(e2.hasNoTags, !this.value.length), this.toggleClass(e2.empty, !i2), "select" == t2.mode && this.toggleScopeValidation((_b = (_a2 = this.value) == null ? void 0 : _a2[0]) == null ? void 0 : _b.__isValid);
    }, setOriginalInputValue(t2) {
      var e2 = this.DOM.originalInput;
      this.settings.mixMode.integrated || (e2.value = t2, e2.tagifyValue = e2.value, this.setPersistedData(t2, "value"));
    }, update(t2) {
      clearTimeout(this.debouncedUpdateTimeout), this.debouncedUpdateTimeout = setTimeout((function() {
        var e2 = this.getInputValue();
        this.setOriginalInputValue(e2), this.settings.onChangeAfterBlur && (t2 || {}).withoutChangeEvent || this.state.blockChangeEvent || this.triggerChangeEvent();
        this.postUpdate();
      }).bind(this), 100);
    }, getInputValue() {
      var t2 = this.getCleanValue();
      return "mix" == this.settings.mode ? this.getMixedTagsAsString(t2) : t2.length ? this.settings.originalInputValueFormat ? this.settings.originalInputValueFormat(t2) : JSON.stringify(t2) : "";
    }, getCleanValue(t2) {
      return a(t2 || this.value, this.dataProps);
    }, getMixedTagsAsString() {
      var t2 = "", e2 = this, i2 = this.settings, s2 = i2.originalInputValueFormat || JSON.stringify, a2 = i2.mixTagsInterpolator;
      return function i3(o2) {
        o2.childNodes.forEach((o3) => {
          if (1 == o3.nodeType) {
            const r2 = T(o3);
            if ("BR" == o3.tagName && (t2 += "\r\n"), r2 && v.call(e2, o3)) {
              if (r2.__removed)
                return;
              t2 += a2[0] + s2(n(r2, e2.dataProps)) + a2[1];
            } else
              o3.getAttribute("style") || ["B", "I", "U"].includes(o3.tagName) ? t2 += o3.textContent : "DIV" != o3.tagName && "P" != o3.tagName || (t2 += "\r\n", i3(o3));
          } else
            t2 += o3.textContent;
        });
      }(this.DOM.input), t2;
    } }, _.prototype.removeTag = _.prototype.removeTags, _;
  });
})(tagify_min);
var tagify_minExports = tagify_min.exports;
const Tagify = /* @__PURE__ */ getDefaultExportFromCjs(tagify_minExports);
function _assertThisInitialized$1(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _inheritsLoose$1(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}
/*!
 * GSAP 3.12.5
 * https://gsap.com
 *
 * @license Copyright 2008-2024, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license or for
 * Club GSAP members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/
var _config = {
  autoSleep: 120,
  force3D: "auto",
  nullTargetWarn: 1,
  units: {
    lineHeight: ""
  }
}, _defaults = {
  duration: 0.5,
  overwrite: false,
  delay: 0
}, _suppressOverwrites, _reverting$2, _context$2, _bigNum$3 = 1e8, _tinyNum = 1 / _bigNum$3, _2PI = Math.PI * 2, _HALF_PI = _2PI / 4, _gsID = 0, _sqrt$1 = Math.sqrt, _cos$1 = Math.cos, _sin$1 = Math.sin, _isString$1 = function _isString(value) {
  return typeof value === "string";
}, _isFunction$1 = function _isFunction(value) {
  return typeof value === "function";
}, _isNumber$1 = function _isNumber(value) {
  return typeof value === "number";
}, _isUndefined$2 = function _isUndefined(value) {
  return typeof value === "undefined";
}, _isObject$1 = function _isObject(value) {
  return typeof value === "object";
}, _isNotFalse = function _isNotFalse2(value) {
  return value !== false;
}, _windowExists$2 = function _windowExists() {
  return typeof window !== "undefined";
}, _isFuncOrString = function _isFuncOrString2(value) {
  return _isFunction$1(value) || _isString$1(value);
}, _isTypedArray = typeof ArrayBuffer === "function" && ArrayBuffer.isView || function() {
}, _isArray$1 = Array.isArray, _strictNumExp = /(?:-?\.?\d|\.)+/gi, _numExp$2 = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g, _numWithUnitExp = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g, _complexStringNumExp = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi, _relExp = /[+-]=-?[.\d]+/, _delimitedValueExp = /[^,'"\[\]\s]+/gi, _unitExp = /^[+\-=e\s\d]*\d+[.\d]*([a-z]*|%)\s*$/i, _globalTimeline, _win$4, _coreInitted$3, _doc$4, _globals = {}, _installScope = {}, _coreReady, _install = function _install2(scope) {
  return (_installScope = _merge(scope, _globals)) && gsap$6;
}, _missingPlugin = function _missingPlugin2(property, value) {
  return console.warn("Invalid property", property, "set to", value, "Missing plugin? gsap.registerPlugin()");
}, _warn = function _warn2(message, suppress) {
  return !suppress && console.warn(message);
}, _addGlobal = function _addGlobal2(name, obj) {
  return name && (_globals[name] = obj) && _installScope && (_installScope[name] = obj) || _globals;
}, _emptyFunc$2 = function _emptyFunc() {
  return 0;
}, _startAtRevertConfig = {
  suppressEvents: true,
  isStart: true,
  kill: false
}, _revertConfigNoKill = {
  suppressEvents: true,
  kill: false
}, _revertConfig = {
  suppressEvents: true
}, _reservedProps = {}, _lazyTweens = [], _lazyLookup = {}, _lastRenderedFrame, _plugins = {}, _effects = {}, _nextGCFrame = 30, _harnessPlugins = [], _callbackNames = "", _harness = function _harness2(targets) {
  var target = targets[0], harnessPlugin, i;
  _isObject$1(target) || _isFunction$1(target) || (targets = [targets]);
  if (!(harnessPlugin = (target._gsap || {}).harness)) {
    i = _harnessPlugins.length;
    while (i-- && !_harnessPlugins[i].targetTest(target)) {
    }
    harnessPlugin = _harnessPlugins[i];
  }
  i = targets.length;
  while (i--) {
    targets[i] && (targets[i]._gsap || (targets[i]._gsap = new GSCache(targets[i], harnessPlugin))) || targets.splice(i, 1);
  }
  return targets;
}, _getCache = function _getCache2(target) {
  return target._gsap || _harness(toArray$1(target))[0]._gsap;
}, _getProperty = function _getProperty2(target, property, v) {
  return (v = target[property]) && _isFunction$1(v) ? target[property]() : _isUndefined$2(v) && target.getAttribute && target.getAttribute(property) || v;
}, _forEachName = function _forEachName2(names, func) {
  return (names = names.split(",")).forEach(func) || names;
}, _round$4 = function _round(value) {
  return Math.round(value * 1e5) / 1e5 || 0;
}, _roundPrecise$1 = function _roundPrecise(value) {
  return Math.round(value * 1e7) / 1e7 || 0;
}, _parseRelative = function _parseRelative2(start, value) {
  var operator = value.charAt(0), end = parseFloat(value.substr(2));
  start = parseFloat(start);
  return operator === "+" ? start + end : operator === "-" ? start - end : operator === "*" ? start * end : start / end;
}, _arrayContainsAny = function _arrayContainsAny2(toSearch, toFind) {
  var l = toFind.length, i = 0;
  for (; toSearch.indexOf(toFind[i]) < 0 && ++i < l; ) {
  }
  return i < l;
}, _lazyRender = function _lazyRender2() {
  var l = _lazyTweens.length, a = _lazyTweens.slice(0), i, tween;
  _lazyLookup = {};
  _lazyTweens.length = 0;
  for (i = 0; i < l; i++) {
    tween = a[i];
    tween && tween._lazy && (tween.render(tween._lazy[0], tween._lazy[1], true)._lazy = 0);
  }
}, _lazySafeRender = function _lazySafeRender2(animation, time, suppressEvents, force) {
  _lazyTweens.length && !_reverting$2 && _lazyRender();
  animation.render(time, suppressEvents, force || _reverting$2 && time < 0 && (animation._initted || animation._startAt));
  _lazyTweens.length && !_reverting$2 && _lazyRender();
}, _numericIfPossible = function _numericIfPossible2(value) {
  var n = parseFloat(value);
  return (n || n === 0) && (value + "").match(_delimitedValueExp).length < 2 ? n : _isString$1(value) ? value.trim() : value;
}, _passThrough = function _passThrough2(p) {
  return p;
}, _setDefaults$1 = function _setDefaults(obj, defaults2) {
  for (var p in defaults2) {
    p in obj || (obj[p] = defaults2[p]);
  }
  return obj;
}, _setKeyframeDefaults = function _setKeyframeDefaults2(excludeDuration) {
  return function(obj, defaults2) {
    for (var p in defaults2) {
      p in obj || p === "duration" && excludeDuration || p === "ease" || (obj[p] = defaults2[p]);
    }
  };
}, _merge = function _merge2(base, toMerge) {
  for (var p in toMerge) {
    base[p] = toMerge[p];
  }
  return base;
}, _mergeDeep = function _mergeDeep2(base, toMerge) {
  for (var p in toMerge) {
    p !== "__proto__" && p !== "constructor" && p !== "prototype" && (base[p] = _isObject$1(toMerge[p]) ? _mergeDeep2(base[p] || (base[p] = {}), toMerge[p]) : toMerge[p]);
  }
  return base;
}, _copyExcluding = function _copyExcluding2(obj, excluding) {
  var copy = {}, p;
  for (p in obj) {
    p in excluding || (copy[p] = obj[p]);
  }
  return copy;
}, _inheritDefaults = function _inheritDefaults2(vars) {
  var parent = vars.parent || _globalTimeline, func = vars.keyframes ? _setKeyframeDefaults(_isArray$1(vars.keyframes)) : _setDefaults$1;
  if (_isNotFalse(vars.inherit)) {
    while (parent) {
      func(vars, parent.vars.defaults);
      parent = parent.parent || parent._dp;
    }
  }
  return vars;
}, _arraysMatch = function _arraysMatch2(a1, a2) {
  var i = a1.length, match = i === a2.length;
  while (match && i-- && a1[i] === a2[i]) {
  }
  return i < 0;
}, _addLinkedListItem = function _addLinkedListItem2(parent, child, firstProp, lastProp, sortBy) {
  if (firstProp === void 0) {
    firstProp = "_first";
  }
  if (lastProp === void 0) {
    lastProp = "_last";
  }
  var prev = parent[lastProp], t;
  if (sortBy) {
    t = child[sortBy];
    while (prev && prev[sortBy] > t) {
      prev = prev._prev;
    }
  }
  if (prev) {
    child._next = prev._next;
    prev._next = child;
  } else {
    child._next = parent[firstProp];
    parent[firstProp] = child;
  }
  if (child._next) {
    child._next._prev = child;
  } else {
    parent[lastProp] = child;
  }
  child._prev = prev;
  child.parent = child._dp = parent;
  return child;
}, _removeLinkedListItem = function _removeLinkedListItem2(parent, child, firstProp, lastProp) {
  if (firstProp === void 0) {
    firstProp = "_first";
  }
  if (lastProp === void 0) {
    lastProp = "_last";
  }
  var prev = child._prev, next = child._next;
  if (prev) {
    prev._next = next;
  } else if (parent[firstProp] === child) {
    parent[firstProp] = next;
  }
  if (next) {
    next._prev = prev;
  } else if (parent[lastProp] === child) {
    parent[lastProp] = prev;
  }
  child._next = child._prev = child.parent = null;
}, _removeFromParent = function _removeFromParent2(child, onlyIfParentHasAutoRemove) {
  child.parent && (!onlyIfParentHasAutoRemove || child.parent.autoRemoveChildren) && child.parent.remove && child.parent.remove(child);
  child._act = 0;
}, _uncache = function _uncache2(animation, child) {
  if (animation && (!child || child._end > animation._dur || child._start < 0)) {
    var a = animation;
    while (a) {
      a._dirty = 1;
      a = a.parent;
    }
  }
  return animation;
}, _recacheAncestors = function _recacheAncestors2(animation) {
  var parent = animation.parent;
  while (parent && parent.parent) {
    parent._dirty = 1;
    parent.totalDuration();
    parent = parent.parent;
  }
  return animation;
}, _rewindStartAt = function _rewindStartAt2(tween, totalTime, suppressEvents, force) {
  return tween._startAt && (_reverting$2 ? tween._startAt.revert(_revertConfigNoKill) : tween.vars.immediateRender && !tween.vars.autoRevert || tween._startAt.render(totalTime, true, force));
}, _hasNoPausedAncestors = function _hasNoPausedAncestors2(animation) {
  return !animation || animation._ts && _hasNoPausedAncestors2(animation.parent);
}, _elapsedCycleDuration = function _elapsedCycleDuration2(animation) {
  return animation._repeat ? _animationCycle(animation._tTime, animation = animation.duration() + animation._rDelay) * animation : 0;
}, _animationCycle = function _animationCycle2(tTime, cycleDuration) {
  var whole = Math.floor(tTime /= cycleDuration);
  return tTime && whole === tTime ? whole - 1 : whole;
}, _parentToChildTotalTime = function _parentToChildTotalTime2(parentTime, child) {
  return (parentTime - child._start) * child._ts + (child._ts >= 0 ? 0 : child._dirty ? child.totalDuration() : child._tDur);
}, _setEnd = function _setEnd2(animation) {
  return animation._end = _roundPrecise$1(animation._start + (animation._tDur / Math.abs(animation._ts || animation._rts || _tinyNum) || 0));
}, _alignPlayhead = function _alignPlayhead2(animation, totalTime) {
  var parent = animation._dp;
  if (parent && parent.smoothChildTiming && animation._ts) {
    animation._start = _roundPrecise$1(parent._time - (animation._ts > 0 ? totalTime / animation._ts : ((animation._dirty ? animation.totalDuration() : animation._tDur) - totalTime) / -animation._ts));
    _setEnd(animation);
    parent._dirty || _uncache(parent, animation);
  }
  return animation;
}, _postAddChecks = function _postAddChecks2(timeline2, child) {
  var t;
  if (child._time || !child._dur && child._initted || child._start < timeline2._time && (child._dur || !child.add)) {
    t = _parentToChildTotalTime(timeline2.rawTime(), child);
    if (!child._dur || _clamp(0, child.totalDuration(), t) - child._tTime > _tinyNum) {
      child.render(t, true);
    }
  }
  if (_uncache(timeline2, child)._dp && timeline2._initted && timeline2._time >= timeline2._dur && timeline2._ts) {
    if (timeline2._dur < timeline2.duration()) {
      t = timeline2;
      while (t._dp) {
        t.rawTime() >= 0 && t.totalTime(t._tTime);
        t = t._dp;
      }
    }
    timeline2._zTime = -_tinyNum;
  }
}, _addToTimeline = function _addToTimeline2(timeline2, child, position, skipChecks) {
  child.parent && _removeFromParent(child);
  child._start = _roundPrecise$1((_isNumber$1(position) ? position : position || timeline2 !== _globalTimeline ? _parsePosition(timeline2, position, child) : timeline2._time) + child._delay);
  child._end = _roundPrecise$1(child._start + (child.totalDuration() / Math.abs(child.timeScale()) || 0));
  _addLinkedListItem(timeline2, child, "_first", "_last", timeline2._sort ? "_start" : 0);
  _isFromOrFromStart(child) || (timeline2._recent = child);
  skipChecks || _postAddChecks(timeline2, child);
  timeline2._ts < 0 && _alignPlayhead(timeline2, timeline2._tTime);
  return timeline2;
}, _scrollTrigger = function _scrollTrigger2(animation, trigger) {
  return (_globals.ScrollTrigger || _missingPlugin("scrollTrigger", trigger)) && _globals.ScrollTrigger.create(trigger, animation);
}, _attemptInitTween = function _attemptInitTween2(tween, time, force, suppressEvents, tTime) {
  _initTween(tween, time, tTime);
  if (!tween._initted) {
    return 1;
  }
  if (!force && tween._pt && !_reverting$2 && (tween._dur && tween.vars.lazy !== false || !tween._dur && tween.vars.lazy) && _lastRenderedFrame !== _ticker.frame) {
    _lazyTweens.push(tween);
    tween._lazy = [tTime, suppressEvents];
    return 1;
  }
}, _parentPlayheadIsBeforeStart = function _parentPlayheadIsBeforeStart2(_ref) {
  var parent = _ref.parent;
  return parent && parent._ts && parent._initted && !parent._lock && (parent.rawTime() < 0 || _parentPlayheadIsBeforeStart2(parent));
}, _isFromOrFromStart = function _isFromOrFromStart2(_ref2) {
  var data = _ref2.data;
  return data === "isFromStart" || data === "isStart";
}, _renderZeroDurationTween = function _renderZeroDurationTween2(tween, totalTime, suppressEvents, force) {
  var prevRatio = tween.ratio, ratio = totalTime < 0 || !totalTime && (!tween._start && _parentPlayheadIsBeforeStart(tween) && !(!tween._initted && _isFromOrFromStart(tween)) || (tween._ts < 0 || tween._dp._ts < 0) && !_isFromOrFromStart(tween)) ? 0 : 1, repeatDelay = tween._rDelay, tTime = 0, pt, iteration, prevIteration;
  if (repeatDelay && tween._repeat) {
    tTime = _clamp(0, tween._tDur, totalTime);
    iteration = _animationCycle(tTime, repeatDelay);
    tween._yoyo && iteration & 1 && (ratio = 1 - ratio);
    if (iteration !== _animationCycle(tween._tTime, repeatDelay)) {
      prevRatio = 1 - ratio;
      tween.vars.repeatRefresh && tween._initted && tween.invalidate();
    }
  }
  if (ratio !== prevRatio || _reverting$2 || force || tween._zTime === _tinyNum || !totalTime && tween._zTime) {
    if (!tween._initted && _attemptInitTween(tween, totalTime, force, suppressEvents, tTime)) {
      return;
    }
    prevIteration = tween._zTime;
    tween._zTime = totalTime || (suppressEvents ? _tinyNum : 0);
    suppressEvents || (suppressEvents = totalTime && !prevIteration);
    tween.ratio = ratio;
    tween._from && (ratio = 1 - ratio);
    tween._time = 0;
    tween._tTime = tTime;
    pt = tween._pt;
    while (pt) {
      pt.r(ratio, pt.d);
      pt = pt._next;
    }
    totalTime < 0 && _rewindStartAt(tween, totalTime, suppressEvents, true);
    tween._onUpdate && !suppressEvents && _callback(tween, "onUpdate");
    tTime && tween._repeat && !suppressEvents && tween.parent && _callback(tween, "onRepeat");
    if ((totalTime >= tween._tDur || totalTime < 0) && tween.ratio === ratio) {
      ratio && _removeFromParent(tween, 1);
      if (!suppressEvents && !_reverting$2) {
        _callback(tween, ratio ? "onComplete" : "onReverseComplete", true);
        tween._prom && tween._prom();
      }
    }
  } else if (!tween._zTime) {
    tween._zTime = totalTime;
  }
}, _findNextPauseTween = function _findNextPauseTween2(animation, prevTime, time) {
  var child;
  if (time > prevTime) {
    child = animation._first;
    while (child && child._start <= time) {
      if (child.data === "isPause" && child._start > prevTime) {
        return child;
      }
      child = child._next;
    }
  } else {
    child = animation._last;
    while (child && child._start >= time) {
      if (child.data === "isPause" && child._start < prevTime) {
        return child;
      }
      child = child._prev;
    }
  }
}, _setDuration = function _setDuration2(animation, duration, skipUncache, leavePlayhead) {
  var repeat = animation._repeat, dur = _roundPrecise$1(duration) || 0, totalProgress = animation._tTime / animation._tDur;
  totalProgress && !leavePlayhead && (animation._time *= dur / animation._dur);
  animation._dur = dur;
  animation._tDur = !repeat ? dur : repeat < 0 ? 1e10 : _roundPrecise$1(dur * (repeat + 1) + animation._rDelay * repeat);
  totalProgress > 0 && !leavePlayhead && _alignPlayhead(animation, animation._tTime = animation._tDur * totalProgress);
  animation.parent && _setEnd(animation);
  skipUncache || _uncache(animation.parent, animation);
  return animation;
}, _onUpdateTotalDuration = function _onUpdateTotalDuration2(animation) {
  return animation instanceof Timeline ? _uncache(animation) : _setDuration(animation, animation._dur);
}, _zeroPosition = {
  _start: 0,
  endTime: _emptyFunc$2,
  totalDuration: _emptyFunc$2
}, _parsePosition = function _parsePosition2(animation, position, percentAnimation) {
  var labels = animation.labels, recent = animation._recent || _zeroPosition, clippedDuration = animation.duration() >= _bigNum$3 ? recent.endTime(false) : animation._dur, i, offset, isPercent;
  if (_isString$1(position) && (isNaN(position) || position in labels)) {
    offset = position.charAt(0);
    isPercent = position.substr(-1) === "%";
    i = position.indexOf("=");
    if (offset === "<" || offset === ">") {
      i >= 0 && (position = position.replace(/=/, ""));
      return (offset === "<" ? recent._start : recent.endTime(recent._repeat >= 0)) + (parseFloat(position.substr(1)) || 0) * (isPercent ? (i < 0 ? recent : percentAnimation).totalDuration() / 100 : 1);
    }
    if (i < 0) {
      position in labels || (labels[position] = clippedDuration);
      return labels[position];
    }
    offset = parseFloat(position.charAt(i - 1) + position.substr(i + 1));
    if (isPercent && percentAnimation) {
      offset = offset / 100 * (_isArray$1(percentAnimation) ? percentAnimation[0] : percentAnimation).totalDuration();
    }
    return i > 1 ? _parsePosition2(animation, position.substr(0, i - 1), percentAnimation) + offset : clippedDuration + offset;
  }
  return position == null ? clippedDuration : +position;
}, _createTweenType = function _createTweenType2(type, params, timeline2) {
  var isLegacy = _isNumber$1(params[1]), varsIndex = (isLegacy ? 2 : 1) + (type < 2 ? 0 : 1), vars = params[varsIndex], irVars, parent;
  isLegacy && (vars.duration = params[1]);
  vars.parent = timeline2;
  if (type) {
    irVars = vars;
    parent = timeline2;
    while (parent && !("immediateRender" in irVars)) {
      irVars = parent.vars.defaults || {};
      parent = _isNotFalse(parent.vars.inherit) && parent.parent;
    }
    vars.immediateRender = _isNotFalse(irVars.immediateRender);
    type < 2 ? vars.runBackwards = 1 : vars.startAt = params[varsIndex - 1];
  }
  return new Tween(params[0], vars, params[varsIndex + 1]);
}, _conditionalReturn = function _conditionalReturn2(value, func) {
  return value || value === 0 ? func(value) : func;
}, _clamp = function _clamp2(min, max, value) {
  return value < min ? min : value > max ? max : value;
}, getUnit = function getUnit2(value, v) {
  return !_isString$1(value) || !(v = _unitExp.exec(value)) ? "" : v[1];
}, clamp = function clamp2(min, max, value) {
  return _conditionalReturn(value, function(v) {
    return _clamp(min, max, v);
  });
}, _slice = [].slice, _isArrayLike = function _isArrayLike2(value, nonEmpty) {
  return value && _isObject$1(value) && "length" in value && (!nonEmpty && !value.length || value.length - 1 in value && _isObject$1(value[0])) && !value.nodeType && value !== _win$4;
}, _flatten = function _flatten2(ar, leaveStrings, accumulator) {
  if (accumulator === void 0) {
    accumulator = [];
  }
  return ar.forEach(function(value) {
    var _accumulator;
    return _isString$1(value) && !leaveStrings || _isArrayLike(value, 1) ? (_accumulator = accumulator).push.apply(_accumulator, toArray$1(value)) : accumulator.push(value);
  }) || accumulator;
}, toArray$1 = function toArray(value, scope, leaveStrings) {
  return _context$2 && !scope && _context$2.selector ? _context$2.selector(value) : _isString$1(value) && !leaveStrings && (_coreInitted$3 || !_wake()) ? _slice.call((scope || _doc$4).querySelectorAll(value), 0) : _isArray$1(value) ? _flatten(value, leaveStrings) : _isArrayLike(value) ? _slice.call(value, 0) : value ? [value] : [];
}, selector = function selector2(value) {
  value = toArray$1(value)[0] || _warn("Invalid scope") || {};
  return function(v) {
    var el = value.current || value.nativeElement || value;
    return toArray$1(v, el.querySelectorAll ? el : el === value ? _warn("Invalid scope") || _doc$4.createElement("div") : value);
  };
}, shuffle$1 = function shuffle(a) {
  return a.sort(function() {
    return 0.5 - Math.random();
  });
}, distribute = function distribute2(v) {
  if (_isFunction$1(v)) {
    return v;
  }
  var vars = _isObject$1(v) ? v : {
    each: v
  }, ease = _parseEase(vars.ease), from = vars.from || 0, base = parseFloat(vars.base) || 0, cache = {}, isDecimal = from > 0 && from < 1, ratios = isNaN(from) || isDecimal, axis = vars.axis, ratioX = from, ratioY = from;
  if (_isString$1(from)) {
    ratioX = ratioY = {
      center: 0.5,
      edges: 0.5,
      end: 1
    }[from] || 0;
  } else if (!isDecimal && ratios) {
    ratioX = from[0];
    ratioY = from[1];
  }
  return function(i, target, a) {
    var l = (a || vars).length, distances = cache[l], originX, originY, x, y, d, j, max, min, wrapAt;
    if (!distances) {
      wrapAt = vars.grid === "auto" ? 0 : (vars.grid || [1, _bigNum$3])[1];
      if (!wrapAt) {
        max = -_bigNum$3;
        while (max < (max = a[wrapAt++].getBoundingClientRect().left) && wrapAt < l) {
        }
        wrapAt < l && wrapAt--;
      }
      distances = cache[l] = [];
      originX = ratios ? Math.min(wrapAt, l) * ratioX - 0.5 : from % wrapAt;
      originY = wrapAt === _bigNum$3 ? 0 : ratios ? l * ratioY / wrapAt - 0.5 : from / wrapAt | 0;
      max = 0;
      min = _bigNum$3;
      for (j = 0; j < l; j++) {
        x = j % wrapAt - originX;
        y = originY - (j / wrapAt | 0);
        distances[j] = d = !axis ? _sqrt$1(x * x + y * y) : Math.abs(axis === "y" ? y : x);
        d > max && (max = d);
        d < min && (min = d);
      }
      from === "random" && shuffle$1(distances);
      distances.max = max - min;
      distances.min = min;
      distances.v = l = (parseFloat(vars.amount) || parseFloat(vars.each) * (wrapAt > l ? l - 1 : !axis ? Math.max(wrapAt, l / wrapAt) : axis === "y" ? l / wrapAt : wrapAt) || 0) * (from === "edges" ? -1 : 1);
      distances.b = l < 0 ? base - l : base;
      distances.u = getUnit(vars.amount || vars.each) || 0;
      ease = ease && l < 0 ? _invertEase(ease) : ease;
    }
    l = (distances[i] - distances.min) / distances.max || 0;
    return _roundPrecise$1(distances.b + (ease ? ease(l) : l) * distances.v) + distances.u;
  };
}, _roundModifier = function _roundModifier2(v) {
  var p = Math.pow(10, ((v + "").split(".")[1] || "").length);
  return function(raw) {
    var n = _roundPrecise$1(Math.round(parseFloat(raw) / v) * v * p);
    return (n - n % 1) / p + (_isNumber$1(raw) ? 0 : getUnit(raw));
  };
}, snap = function snap2(snapTo, value) {
  var isArray2 = _isArray$1(snapTo), radius, is2D;
  if (!isArray2 && _isObject$1(snapTo)) {
    radius = isArray2 = snapTo.radius || _bigNum$3;
    if (snapTo.values) {
      snapTo = toArray$1(snapTo.values);
      if (is2D = !_isNumber$1(snapTo[0])) {
        radius *= radius;
      }
    } else {
      snapTo = _roundModifier(snapTo.increment);
    }
  }
  return _conditionalReturn(value, !isArray2 ? _roundModifier(snapTo) : _isFunction$1(snapTo) ? function(raw) {
    is2D = snapTo(raw);
    return Math.abs(is2D - raw) <= radius ? is2D : raw;
  } : function(raw) {
    var x = parseFloat(is2D ? raw.x : raw), y = parseFloat(is2D ? raw.y : 0), min = _bigNum$3, closest = 0, i = snapTo.length, dx, dy;
    while (i--) {
      if (is2D) {
        dx = snapTo[i].x - x;
        dy = snapTo[i].y - y;
        dx = dx * dx + dy * dy;
      } else {
        dx = Math.abs(snapTo[i] - x);
      }
      if (dx < min) {
        min = dx;
        closest = i;
      }
    }
    closest = !radius || min <= radius ? snapTo[closest] : raw;
    return is2D || closest === raw || _isNumber$1(raw) ? closest : closest + getUnit(raw);
  });
}, random = function random2(min, max, roundingIncrement, returnFunction) {
  return _conditionalReturn(_isArray$1(min) ? !max : roundingIncrement === true ? !!(roundingIncrement = 0) : !returnFunction, function() {
    return _isArray$1(min) ? min[~~(Math.random() * min.length)] : (roundingIncrement = roundingIncrement || 1e-5) && (returnFunction = roundingIncrement < 1 ? Math.pow(10, (roundingIncrement + "").length - 2) : 1) && Math.floor(Math.round((min - roundingIncrement / 2 + Math.random() * (max - min + roundingIncrement * 0.99)) / roundingIncrement) * roundingIncrement * returnFunction) / returnFunction;
  });
}, pipe = function pipe2() {
  for (var _len = arguments.length, functions = new Array(_len), _key = 0; _key < _len; _key++) {
    functions[_key] = arguments[_key];
  }
  return function(value) {
    return functions.reduce(function(v, f) {
      return f(v);
    }, value);
  };
}, unitize = function unitize2(func, unit) {
  return function(value) {
    return func(parseFloat(value)) + (unit || getUnit(value));
  };
}, normalize = function normalize2(min, max, value) {
  return mapRange(min, max, 0, 1, value);
}, _wrapArray = function _wrapArray2(a, wrapper, value) {
  return _conditionalReturn(value, function(index) {
    return a[~~wrapper(index)];
  });
}, wrap = function wrap2(min, max, value) {
  var range = max - min;
  return _isArray$1(min) ? _wrapArray(min, wrap2(0, min.length), max) : _conditionalReturn(value, function(value2) {
    return (range + (value2 - min) % range) % range + min;
  });
}, wrapYoyo = function wrapYoyo2(min, max, value) {
  var range = max - min, total = range * 2;
  return _isArray$1(min) ? _wrapArray(min, wrapYoyo2(0, min.length - 1), max) : _conditionalReturn(value, function(value2) {
    value2 = (total + (value2 - min) % total) % total || 0;
    return min + (value2 > range ? total - value2 : value2);
  });
}, _replaceRandom = function _replaceRandom2(value) {
  var prev = 0, s = "", i, nums, end, isArray2;
  while (~(i = value.indexOf("random(", prev))) {
    end = value.indexOf(")", i);
    isArray2 = value.charAt(i + 7) === "[";
    nums = value.substr(i + 7, end - i - 7).match(isArray2 ? _delimitedValueExp : _strictNumExp);
    s += value.substr(prev, i - prev) + random(isArray2 ? nums : +nums[0], isArray2 ? 0 : +nums[1], +nums[2] || 1e-5);
    prev = end + 1;
  }
  return s + value.substr(prev, value.length - prev);
}, mapRange = function mapRange2(inMin, inMax, outMin, outMax, value) {
  var inRange = inMax - inMin, outRange = outMax - outMin;
  return _conditionalReturn(value, function(value2) {
    return outMin + ((value2 - inMin) / inRange * outRange || 0);
  });
}, interpolate = function interpolate2(start, end, progress, mutate) {
  var func = isNaN(start + end) ? 0 : function(p2) {
    return (1 - p2) * start + p2 * end;
  };
  if (!func) {
    var isString = _isString$1(start), master = {}, p, i, interpolators, l, il;
    progress === true && (mutate = 1) && (progress = null);
    if (isString) {
      start = {
        p: start
      };
      end = {
        p: end
      };
    } else if (_isArray$1(start) && !_isArray$1(end)) {
      interpolators = [];
      l = start.length;
      il = l - 2;
      for (i = 1; i < l; i++) {
        interpolators.push(interpolate2(start[i - 1], start[i]));
      }
      l--;
      func = function func2(p2) {
        p2 *= l;
        var i2 = Math.min(il, ~~p2);
        return interpolators[i2](p2 - i2);
      };
      progress = end;
    } else if (!mutate) {
      start = _merge(_isArray$1(start) ? [] : {}, start);
    }
    if (!interpolators) {
      for (p in end) {
        _addPropTween.call(master, start, p, "get", end[p]);
      }
      func = function func2(p2) {
        return _renderPropTweens(p2, master) || (isString ? start.p : start);
      };
    }
  }
  return _conditionalReturn(progress, func);
}, _getLabelInDirection = function _getLabelInDirection2(timeline2, fromTime, backward) {
  var labels = timeline2.labels, min = _bigNum$3, p, distance, label;
  for (p in labels) {
    distance = labels[p] - fromTime;
    if (distance < 0 === !!backward && distance && min > (distance = Math.abs(distance))) {
      label = p;
      min = distance;
    }
  }
  return label;
}, _callback = function _callback2(animation, type, executeLazyFirst) {
  var v = animation.vars, callback = v[type], prevContext = _context$2, context3 = animation._ctx, params, scope, result;
  if (!callback) {
    return;
  }
  params = v[type + "Params"];
  scope = v.callbackScope || animation;
  executeLazyFirst && _lazyTweens.length && _lazyRender();
  context3 && (_context$2 = context3);
  result = params ? callback.apply(scope, params) : callback.call(scope);
  _context$2 = prevContext;
  return result;
}, _interrupt$1 = function _interrupt(animation) {
  _removeFromParent(animation);
  animation.scrollTrigger && animation.scrollTrigger.kill(!!_reverting$2);
  animation.progress() < 1 && _callback(animation, "onInterrupt");
  return animation;
}, _quickTween, _registerPluginQueue = [], _createPlugin = function _createPlugin2(config3) {
  if (!config3)
    return;
  config3 = !config3.name && config3["default"] || config3;
  if (_windowExists$2() || config3.headless) {
    var name = config3.name, isFunc2 = _isFunction$1(config3), Plugin = name && !isFunc2 && config3.init ? function() {
      this._props = [];
    } : config3, instanceDefaults = {
      init: _emptyFunc$2,
      render: _renderPropTweens,
      add: _addPropTween,
      kill: _killPropTweensOf,
      modifier: _addPluginModifier,
      rawVars: 0
    }, statics = {
      targetTest: 0,
      get: 0,
      getSetter: _getSetter,
      aliases: {},
      register: 0
    };
    _wake();
    if (config3 !== Plugin) {
      if (_plugins[name]) {
        return;
      }
      _setDefaults$1(Plugin, _setDefaults$1(_copyExcluding(config3, instanceDefaults), statics));
      _merge(Plugin.prototype, _merge(instanceDefaults, _copyExcluding(config3, statics)));
      _plugins[Plugin.prop = name] = Plugin;
      if (config3.targetTest) {
        _harnessPlugins.push(Plugin);
        _reservedProps[name] = 1;
      }
      name = (name === "css" ? "CSS" : name.charAt(0).toUpperCase() + name.substr(1)) + "Plugin";
    }
    _addGlobal(name, Plugin);
    config3.register && config3.register(gsap$6, Plugin, PropTween$1);
  } else {
    _registerPluginQueue.push(config3);
  }
}, _255 = 255, _colorLookup = {
  aqua: [0, _255, _255],
  lime: [0, _255, 0],
  silver: [192, 192, 192],
  black: [0, 0, 0],
  maroon: [128, 0, 0],
  teal: [0, 128, 128],
  blue: [0, 0, _255],
  navy: [0, 0, 128],
  white: [_255, _255, _255],
  olive: [128, 128, 0],
  yellow: [_255, _255, 0],
  orange: [_255, 165, 0],
  gray: [128, 128, 128],
  purple: [128, 0, 128],
  green: [0, 128, 0],
  red: [_255, 0, 0],
  pink: [_255, 192, 203],
  cyan: [0, _255, _255],
  transparent: [_255, _255, _255, 0]
}, _hue = function _hue2(h, m1, m2) {
  h += h < 0 ? 1 : h > 1 ? -1 : 0;
  return (h * 6 < 1 ? m1 + (m2 - m1) * h * 6 : h < 0.5 ? m2 : h * 3 < 2 ? m1 + (m2 - m1) * (2 / 3 - h) * 6 : m1) * _255 + 0.5 | 0;
}, splitColor = function splitColor2(v, toHSL, forceAlpha) {
  var a = !v ? _colorLookup.black : _isNumber$1(v) ? [v >> 16, v >> 8 & _255, v & _255] : 0, r, g, b, h, s, l, max, min, d, wasHSL;
  if (!a) {
    if (v.substr(-1) === ",") {
      v = v.substr(0, v.length - 1);
    }
    if (_colorLookup[v]) {
      a = _colorLookup[v];
    } else if (v.charAt(0) === "#") {
      if (v.length < 6) {
        r = v.charAt(1);
        g = v.charAt(2);
        b = v.charAt(3);
        v = "#" + r + r + g + g + b + b + (v.length === 5 ? v.charAt(4) + v.charAt(4) : "");
      }
      if (v.length === 9) {
        a = parseInt(v.substr(1, 6), 16);
        return [a >> 16, a >> 8 & _255, a & _255, parseInt(v.substr(7), 16) / 255];
      }
      v = parseInt(v.substr(1), 16);
      a = [v >> 16, v >> 8 & _255, v & _255];
    } else if (v.substr(0, 3) === "hsl") {
      a = wasHSL = v.match(_strictNumExp);
      if (!toHSL) {
        h = +a[0] % 360 / 360;
        s = +a[1] / 100;
        l = +a[2] / 100;
        g = l <= 0.5 ? l * (s + 1) : l + s - l * s;
        r = l * 2 - g;
        a.length > 3 && (a[3] *= 1);
        a[0] = _hue(h + 1 / 3, r, g);
        a[1] = _hue(h, r, g);
        a[2] = _hue(h - 1 / 3, r, g);
      } else if (~v.indexOf("=")) {
        a = v.match(_numExp$2);
        forceAlpha && a.length < 4 && (a[3] = 1);
        return a;
      }
    } else {
      a = v.match(_strictNumExp) || _colorLookup.transparent;
    }
    a = a.map(Number);
  }
  if (toHSL && !wasHSL) {
    r = a[0] / _255;
    g = a[1] / _255;
    b = a[2] / _255;
    max = Math.max(r, g, b);
    min = Math.min(r, g, b);
    l = (max + min) / 2;
    if (max === min) {
      h = s = 0;
    } else {
      d = max - min;
      s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
      h = max === r ? (g - b) / d + (g < b ? 6 : 0) : max === g ? (b - r) / d + 2 : (r - g) / d + 4;
      h *= 60;
    }
    a[0] = ~~(h + 0.5);
    a[1] = ~~(s * 100 + 0.5);
    a[2] = ~~(l * 100 + 0.5);
  }
  forceAlpha && a.length < 4 && (a[3] = 1);
  return a;
}, _colorOrderData = function _colorOrderData2(v) {
  var values = [], c = [], i = -1;
  v.split(_colorExp).forEach(function(v2) {
    var a = v2.match(_numWithUnitExp) || [];
    values.push.apply(values, a);
    c.push(i += a.length + 1);
  });
  values.c = c;
  return values;
}, _formatColors = function _formatColors2(s, toHSL, orderMatchData) {
  var result = "", colors = (s + result).match(_colorExp), type = toHSL ? "hsla(" : "rgba(", i = 0, c, shell, d, l;
  if (!colors) {
    return s;
  }
  colors = colors.map(function(color) {
    return (color = splitColor(color, toHSL, 1)) && type + (toHSL ? color[0] + "," + color[1] + "%," + color[2] + "%," + color[3] : color.join(",")) + ")";
  });
  if (orderMatchData) {
    d = _colorOrderData(s);
    c = orderMatchData.c;
    if (c.join(result) !== d.c.join(result)) {
      shell = s.replace(_colorExp, "1").split(_numWithUnitExp);
      l = shell.length - 1;
      for (; i < l; i++) {
        result += shell[i] + (~c.indexOf(i) ? colors.shift() || type + "0,0,0,0)" : (d.length ? d : colors.length ? colors : orderMatchData).shift());
      }
    }
  }
  if (!shell) {
    shell = s.split(_colorExp);
    l = shell.length - 1;
    for (; i < l; i++) {
      result += shell[i] + colors[i];
    }
  }
  return result + shell[l];
}, _colorExp = function() {
  var s = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b", p;
  for (p in _colorLookup) {
    s += "|" + p + "\\b";
  }
  return new RegExp(s + ")", "gi");
}(), _hslExp = /hsl[a]?\(/, _colorStringFilter = function _colorStringFilter2(a) {
  var combined = a.join(" "), toHSL;
  _colorExp.lastIndex = 0;
  if (_colorExp.test(combined)) {
    toHSL = _hslExp.test(combined);
    a[1] = _formatColors(a[1], toHSL);
    a[0] = _formatColors(a[0], toHSL, _colorOrderData(a[1]));
    return true;
  }
}, _tickerActive, _ticker = function() {
  var _getTime2 = Date.now, _lagThreshold = 500, _adjustedLag = 33, _startTime = _getTime2(), _lastUpdate = _startTime, _gap = 1e3 / 240, _nextTime = _gap, _listeners2 = [], _id2, _req, _raf, _self, _delta, _i, _tick = function _tick2(v) {
    var elapsed = _getTime2() - _lastUpdate, manual = v === true, overlap, dispatch, time, frame;
    (elapsed > _lagThreshold || elapsed < 0) && (_startTime += elapsed - _adjustedLag);
    _lastUpdate += elapsed;
    time = _lastUpdate - _startTime;
    overlap = time - _nextTime;
    if (overlap > 0 || manual) {
      frame = ++_self.frame;
      _delta = time - _self.time * 1e3;
      _self.time = time = time / 1e3;
      _nextTime += overlap + (overlap >= _gap ? 4 : _gap - overlap);
      dispatch = 1;
    }
    manual || (_id2 = _req(_tick2));
    if (dispatch) {
      for (_i = 0; _i < _listeners2.length; _i++) {
        _listeners2[_i](time, _delta, frame, v);
      }
    }
  };
  _self = {
    time: 0,
    frame: 0,
    tick: function tick() {
      _tick(true);
    },
    deltaRatio: function deltaRatio(fps) {
      return _delta / (1e3 / (fps || 60));
    },
    wake: function wake() {
      if (_coreReady) {
        if (!_coreInitted$3 && _windowExists$2()) {
          _win$4 = _coreInitted$3 = window;
          _doc$4 = _win$4.document || {};
          _globals.gsap = gsap$6;
          (_win$4.gsapVersions || (_win$4.gsapVersions = [])).push(gsap$6.version);
          _install(_installScope || _win$4.GreenSockGlobals || !_win$4.gsap && _win$4 || {});
          _registerPluginQueue.forEach(_createPlugin);
        }
        _raf = typeof requestAnimationFrame !== "undefined" && requestAnimationFrame;
        _id2 && _self.sleep();
        _req = _raf || function(f) {
          return setTimeout(f, _nextTime - _self.time * 1e3 + 1 | 0);
        };
        _tickerActive = 1;
        _tick(2);
      }
    },
    sleep: function sleep2() {
      (_raf ? cancelAnimationFrame : clearTimeout)(_id2);
      _tickerActive = 0;
      _req = _emptyFunc$2;
    },
    lagSmoothing: function lagSmoothing(threshold, adjustedLag) {
      _lagThreshold = threshold || Infinity;
      _adjustedLag = Math.min(adjustedLag || 33, _lagThreshold);
    },
    fps: function fps(_fps) {
      _gap = 1e3 / (_fps || 240);
      _nextTime = _self.time * 1e3 + _gap;
    },
    add: function add(callback, once, prioritize) {
      var func = once ? function(t, d, f, v) {
        callback(t, d, f, v);
        _self.remove(func);
      } : callback;
      _self.remove(callback);
      _listeners2[prioritize ? "unshift" : "push"](func);
      _wake();
      return func;
    },
    remove: function remove2(callback, i) {
      ~(i = _listeners2.indexOf(callback)) && _listeners2.splice(i, 1) && _i >= i && _i--;
    },
    _listeners: _listeners2
  };
  return _self;
}(), _wake = function _wake2() {
  return !_tickerActive && _ticker.wake();
}, _easeMap = {}, _customEaseExp = /^[\d.\-M][\d.\-,\s]/, _quotesExp = /["']/g, _parseObjectInString = function _parseObjectInString2(value) {
  var obj = {}, split = value.substr(1, value.length - 3).split(":"), key = split[0], i = 1, l = split.length, index, val, parsedVal;
  for (; i < l; i++) {
    val = split[i];
    index = i !== l - 1 ? val.lastIndexOf(",") : val.length;
    parsedVal = val.substr(0, index);
    obj[key] = isNaN(parsedVal) ? parsedVal.replace(_quotesExp, "").trim() : +parsedVal;
    key = val.substr(index + 1).trim();
  }
  return obj;
}, _valueInParentheses = function _valueInParentheses2(value) {
  var open = value.indexOf("(") + 1, close = value.indexOf(")"), nested = value.indexOf("(", open);
  return value.substring(open, ~nested && nested < close ? value.indexOf(")", close + 1) : close);
}, _configEaseFromString = function _configEaseFromString2(name) {
  var split = (name + "").split("("), ease = _easeMap[split[0]];
  return ease && split.length > 1 && ease.config ? ease.config.apply(null, ~name.indexOf("{") ? [_parseObjectInString(split[1])] : _valueInParentheses(name).split(",").map(_numericIfPossible)) : _easeMap._CE && _customEaseExp.test(name) ? _easeMap._CE("", name) : ease;
}, _invertEase = function _invertEase2(ease) {
  return function(p) {
    return 1 - ease(1 - p);
  };
}, _propagateYoyoEase = function _propagateYoyoEase2(timeline2, isYoyo) {
  var child = timeline2._first, ease;
  while (child) {
    if (child instanceof Timeline) {
      _propagateYoyoEase2(child, isYoyo);
    } else if (child.vars.yoyoEase && (!child._yoyo || !child._repeat) && child._yoyo !== isYoyo) {
      if (child.timeline) {
        _propagateYoyoEase2(child.timeline, isYoyo);
      } else {
        ease = child._ease;
        child._ease = child._yEase;
        child._yEase = ease;
        child._yoyo = isYoyo;
      }
    }
    child = child._next;
  }
}, _parseEase = function _parseEase2(ease, defaultEase) {
  return !ease ? defaultEase : (_isFunction$1(ease) ? ease : _easeMap[ease] || _configEaseFromString(ease)) || defaultEase;
}, _insertEase = function _insertEase2(names, easeIn, easeOut, easeInOut) {
  if (easeOut === void 0) {
    easeOut = function easeOut2(p) {
      return 1 - easeIn(1 - p);
    };
  }
  if (easeInOut === void 0) {
    easeInOut = function easeInOut2(p) {
      return p < 0.5 ? easeIn(p * 2) / 2 : 1 - easeIn((1 - p) * 2) / 2;
    };
  }
  var ease = {
    easeIn,
    easeOut,
    easeInOut
  }, lowercaseName;
  _forEachName(names, function(name) {
    _easeMap[name] = _globals[name] = ease;
    _easeMap[lowercaseName = name.toLowerCase()] = easeOut;
    for (var p in ease) {
      _easeMap[lowercaseName + (p === "easeIn" ? ".in" : p === "easeOut" ? ".out" : ".inOut")] = _easeMap[name + "." + p] = ease[p];
    }
  });
  return ease;
}, _easeInOutFromOut = function _easeInOutFromOut2(easeOut) {
  return function(p) {
    return p < 0.5 ? (1 - easeOut(1 - p * 2)) / 2 : 0.5 + easeOut((p - 0.5) * 2) / 2;
  };
}, _configElastic = function _configElastic2(type, amplitude, period) {
  var p1 = amplitude >= 1 ? amplitude : 1, p2 = (period || (type ? 0.3 : 0.45)) / (amplitude < 1 ? amplitude : 1), p3 = p2 / _2PI * (Math.asin(1 / p1) || 0), easeOut = function easeOut2(p) {
    return p === 1 ? 1 : p1 * Math.pow(2, -10 * p) * _sin$1((p - p3) * p2) + 1;
  }, ease = type === "out" ? easeOut : type === "in" ? function(p) {
    return 1 - easeOut(1 - p);
  } : _easeInOutFromOut(easeOut);
  p2 = _2PI / p2;
  ease.config = function(amplitude2, period2) {
    return _configElastic2(type, amplitude2, period2);
  };
  return ease;
}, _configBack = function _configBack2(type, overshoot) {
  if (overshoot === void 0) {
    overshoot = 1.70158;
  }
  var easeOut = function easeOut2(p) {
    return p ? --p * p * ((overshoot + 1) * p + overshoot) + 1 : 0;
  }, ease = type === "out" ? easeOut : type === "in" ? function(p) {
    return 1 - easeOut(1 - p);
  } : _easeInOutFromOut(easeOut);
  ease.config = function(overshoot2) {
    return _configBack2(type, overshoot2);
  };
  return ease;
};
_forEachName("Linear,Quad,Cubic,Quart,Quint,Strong", function(name, i) {
  var power = i < 5 ? i + 1 : i;
  _insertEase(name + ",Power" + (power - 1), i ? function(p) {
    return Math.pow(p, power);
  } : function(p) {
    return p;
  }, function(p) {
    return 1 - Math.pow(1 - p, power);
  }, function(p) {
    return p < 0.5 ? Math.pow(p * 2, power) / 2 : 1 - Math.pow((1 - p) * 2, power) / 2;
  });
});
_easeMap.Linear.easeNone = _easeMap.none = _easeMap.Linear.easeIn;
_insertEase("Elastic", _configElastic("in"), _configElastic("out"), _configElastic());
(function(n, c) {
  var n1 = 1 / c, n2 = 2 * n1, n3 = 2.5 * n1, easeOut = function easeOut2(p) {
    return p < n1 ? n * p * p : p < n2 ? n * Math.pow(p - 1.5 / c, 2) + 0.75 : p < n3 ? n * (p -= 2.25 / c) * p + 0.9375 : n * Math.pow(p - 2.625 / c, 2) + 0.984375;
  };
  _insertEase("Bounce", function(p) {
    return 1 - easeOut(1 - p);
  }, easeOut);
})(7.5625, 2.75);
_insertEase("Expo", function(p) {
  return p ? Math.pow(2, 10 * (p - 1)) : 0;
});
_insertEase("Circ", function(p) {
  return -(_sqrt$1(1 - p * p) - 1);
});
_insertEase("Sine", function(p) {
  return p === 1 ? 1 : -_cos$1(p * _HALF_PI) + 1;
});
_insertEase("Back", _configBack("in"), _configBack("out"), _configBack());
_easeMap.SteppedEase = _easeMap.steps = _globals.SteppedEase = {
  config: function config(steps, immediateStart) {
    if (steps === void 0) {
      steps = 1;
    }
    var p1 = 1 / steps, p2 = steps + (immediateStart ? 0 : 1), p3 = immediateStart ? 1 : 0, max = 1 - _tinyNum;
    return function(p) {
      return ((p2 * _clamp(0, max, p) | 0) + p3) * p1;
    };
  }
};
_defaults.ease = _easeMap["quad.out"];
_forEachName("onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt", function(name) {
  return _callbackNames += name + "," + name + "Params,";
});
var GSCache = function GSCache2(target, harness) {
  this.id = _gsID++;
  target._gsap = this;
  this.target = target;
  this.harness = harness;
  this.get = harness ? harness.get : _getProperty;
  this.set = harness ? harness.getSetter : _getSetter;
};
var Animation = /* @__PURE__ */ function() {
  function Animation2(vars) {
    this.vars = vars;
    this._delay = +vars.delay || 0;
    if (this._repeat = vars.repeat === Infinity ? -2 : vars.repeat || 0) {
      this._rDelay = vars.repeatDelay || 0;
      this._yoyo = !!vars.yoyo || !!vars.yoyoEase;
    }
    this._ts = 1;
    _setDuration(this, +vars.duration, 1, 1);
    this.data = vars.data;
    if (_context$2) {
      this._ctx = _context$2;
      _context$2.data.push(this);
    }
    _tickerActive || _ticker.wake();
  }
  var _proto = Animation2.prototype;
  _proto.delay = function delay(value) {
    if (value || value === 0) {
      this.parent && this.parent.smoothChildTiming && this.startTime(this._start + value - this._delay);
      this._delay = value;
      return this;
    }
    return this._delay;
  };
  _proto.duration = function duration(value) {
    return arguments.length ? this.totalDuration(this._repeat > 0 ? value + (value + this._rDelay) * this._repeat : value) : this.totalDuration() && this._dur;
  };
  _proto.totalDuration = function totalDuration(value) {
    if (!arguments.length) {
      return this._tDur;
    }
    this._dirty = 0;
    return _setDuration(this, this._repeat < 0 ? value : (value - this._repeat * this._rDelay) / (this._repeat + 1));
  };
  _proto.totalTime = function totalTime(_totalTime, suppressEvents) {
    _wake();
    if (!arguments.length) {
      return this._tTime;
    }
    var parent = this._dp;
    if (parent && parent.smoothChildTiming && this._ts) {
      _alignPlayhead(this, _totalTime);
      !parent._dp || parent.parent || _postAddChecks(parent, this);
      while (parent && parent.parent) {
        if (parent.parent._time !== parent._start + (parent._ts >= 0 ? parent._tTime / parent._ts : (parent.totalDuration() - parent._tTime) / -parent._ts)) {
          parent.totalTime(parent._tTime, true);
        }
        parent = parent.parent;
      }
      if (!this.parent && this._dp.autoRemoveChildren && (this._ts > 0 && _totalTime < this._tDur || this._ts < 0 && _totalTime > 0 || !this._tDur && !_totalTime)) {
        _addToTimeline(this._dp, this, this._start - this._delay);
      }
    }
    if (this._tTime !== _totalTime || !this._dur && !suppressEvents || this._initted && Math.abs(this._zTime) === _tinyNum || !_totalTime && !this._initted && (this.add || this._ptLookup)) {
      this._ts || (this._pTime = _totalTime);
      _lazySafeRender(this, _totalTime, suppressEvents);
    }
    return this;
  };
  _proto.time = function time(value, suppressEvents) {
    return arguments.length ? this.totalTime(Math.min(this.totalDuration(), value + _elapsedCycleDuration(this)) % (this._dur + this._rDelay) || (value ? this._dur : 0), suppressEvents) : this._time;
  };
  _proto.totalProgress = function totalProgress(value, suppressEvents) {
    return arguments.length ? this.totalTime(this.totalDuration() * value, suppressEvents) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.rawTime() > 0 ? 1 : 0;
  };
  _proto.progress = function progress(value, suppressEvents) {
    return arguments.length ? this.totalTime(this.duration() * (this._yoyo && !(this.iteration() & 1) ? 1 - value : value) + _elapsedCycleDuration(this), suppressEvents) : this.duration() ? Math.min(1, this._time / this._dur) : this.rawTime() > 0 ? 1 : 0;
  };
  _proto.iteration = function iteration(value, suppressEvents) {
    var cycleDuration = this.duration() + this._rDelay;
    return arguments.length ? this.totalTime(this._time + (value - 1) * cycleDuration, suppressEvents) : this._repeat ? _animationCycle(this._tTime, cycleDuration) + 1 : 1;
  };
  _proto.timeScale = function timeScale(value, suppressEvents) {
    if (!arguments.length) {
      return this._rts === -_tinyNum ? 0 : this._rts;
    }
    if (this._rts === value) {
      return this;
    }
    var tTime = this.parent && this._ts ? _parentToChildTotalTime(this.parent._time, this) : this._tTime;
    this._rts = +value || 0;
    this._ts = this._ps || value === -_tinyNum ? 0 : this._rts;
    this.totalTime(_clamp(-Math.abs(this._delay), this._tDur, tTime), suppressEvents !== false);
    _setEnd(this);
    return _recacheAncestors(this);
  };
  _proto.paused = function paused(value) {
    if (!arguments.length) {
      return this._ps;
    }
    if (this._ps !== value) {
      this._ps = value;
      if (value) {
        this._pTime = this._tTime || Math.max(-this._delay, this.rawTime());
        this._ts = this._act = 0;
      } else {
        _wake();
        this._ts = this._rts;
        this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, this.progress() === 1 && Math.abs(this._zTime) !== _tinyNum && (this._tTime -= _tinyNum));
      }
    }
    return this;
  };
  _proto.startTime = function startTime(value) {
    if (arguments.length) {
      this._start = value;
      var parent = this.parent || this._dp;
      parent && (parent._sort || !this.parent) && _addToTimeline(parent, this, value - this._delay);
      return this;
    }
    return this._start;
  };
  _proto.endTime = function endTime(includeRepeats) {
    return this._start + (_isNotFalse(includeRepeats) ? this.totalDuration() : this.duration()) / Math.abs(this._ts || 1);
  };
  _proto.rawTime = function rawTime(wrapRepeats) {
    var parent = this.parent || this._dp;
    return !parent ? this._tTime : wrapRepeats && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : !this._ts ? this._tTime : _parentToChildTotalTime(parent.rawTime(wrapRepeats), this);
  };
  _proto.revert = function revert(config3) {
    if (config3 === void 0) {
      config3 = _revertConfig;
    }
    var prevIsReverting = _reverting$2;
    _reverting$2 = config3;
    if (this._initted || this._startAt) {
      this.timeline && this.timeline.revert(config3);
      this.totalTime(-0.01, config3.suppressEvents);
    }
    this.data !== "nested" && config3.kill !== false && this.kill();
    _reverting$2 = prevIsReverting;
    return this;
  };
  _proto.globalTime = function globalTime(rawTime) {
    var animation = this, time = arguments.length ? rawTime : animation.rawTime();
    while (animation) {
      time = animation._start + time / (Math.abs(animation._ts) || 1);
      animation = animation._dp;
    }
    return !this.parent && this._sat ? this._sat.globalTime(rawTime) : time;
  };
  _proto.repeat = function repeat(value) {
    if (arguments.length) {
      this._repeat = value === Infinity ? -2 : value;
      return _onUpdateTotalDuration(this);
    }
    return this._repeat === -2 ? Infinity : this._repeat;
  };
  _proto.repeatDelay = function repeatDelay(value) {
    if (arguments.length) {
      var time = this._time;
      this._rDelay = value;
      _onUpdateTotalDuration(this);
      return time ? this.time(time) : this;
    }
    return this._rDelay;
  };
  _proto.yoyo = function yoyo(value) {
    if (arguments.length) {
      this._yoyo = value;
      return this;
    }
    return this._yoyo;
  };
  _proto.seek = function seek(position, suppressEvents) {
    return this.totalTime(_parsePosition(this, position), _isNotFalse(suppressEvents));
  };
  _proto.restart = function restart(includeDelay, suppressEvents) {
    return this.play().totalTime(includeDelay ? -this._delay : 0, _isNotFalse(suppressEvents));
  };
  _proto.play = function play(from, suppressEvents) {
    from != null && this.seek(from, suppressEvents);
    return this.reversed(false).paused(false);
  };
  _proto.reverse = function reverse(from, suppressEvents) {
    from != null && this.seek(from || this.totalDuration(), suppressEvents);
    return this.reversed(true).paused(false);
  };
  _proto.pause = function pause(atTime, suppressEvents) {
    atTime != null && this.seek(atTime, suppressEvents);
    return this.paused(true);
  };
  _proto.resume = function resume() {
    return this.paused(false);
  };
  _proto.reversed = function reversed(value) {
    if (arguments.length) {
      !!value !== this.reversed() && this.timeScale(-this._rts || (value ? -_tinyNum : 0));
      return this;
    }
    return this._rts < 0;
  };
  _proto.invalidate = function invalidate() {
    this._initted = this._act = 0;
    this._zTime = -_tinyNum;
    return this;
  };
  _proto.isActive = function isActive() {
    var parent = this.parent || this._dp, start = this._start, rawTime;
    return !!(!parent || this._ts && this._initted && parent.isActive() && (rawTime = parent.rawTime(true)) >= start && rawTime < this.endTime(true) - _tinyNum);
  };
  _proto.eventCallback = function eventCallback(type, callback, params) {
    var vars = this.vars;
    if (arguments.length > 1) {
      if (!callback) {
        delete vars[type];
      } else {
        vars[type] = callback;
        params && (vars[type + "Params"] = params);
        type === "onUpdate" && (this._onUpdate = callback);
      }
      return this;
    }
    return vars[type];
  };
  _proto.then = function then(onFulfilled) {
    var self2 = this;
    return new Promise(function(resolve) {
      var f = _isFunction$1(onFulfilled) ? onFulfilled : _passThrough, _resolve = function _resolve2() {
        var _then = self2.then;
        self2.then = null;
        _isFunction$1(f) && (f = f(self2)) && (f.then || f === self2) && (self2.then = _then);
        resolve(f);
        self2.then = _then;
      };
      if (self2._initted && self2.totalProgress() === 1 && self2._ts >= 0 || !self2._tTime && self2._ts < 0) {
        _resolve();
      } else {
        self2._prom = _resolve;
      }
    });
  };
  _proto.kill = function kill() {
    _interrupt$1(this);
  };
  return Animation2;
}();
_setDefaults$1(Animation.prototype, {
  _time: 0,
  _start: 0,
  _end: 0,
  _tTime: 0,
  _tDur: 0,
  _dirty: 0,
  _repeat: 0,
  _yoyo: false,
  parent: null,
  _initted: false,
  _rDelay: 0,
  _ts: 1,
  _dp: 0,
  ratio: 0,
  _zTime: -_tinyNum,
  _prom: 0,
  _ps: false,
  _rts: 1
});
var Timeline = /* @__PURE__ */ function(_Animation) {
  _inheritsLoose$1(Timeline2, _Animation);
  function Timeline2(vars, position) {
    var _this;
    if (vars === void 0) {
      vars = {};
    }
    _this = _Animation.call(this, vars) || this;
    _this.labels = {};
    _this.smoothChildTiming = !!vars.smoothChildTiming;
    _this.autoRemoveChildren = !!vars.autoRemoveChildren;
    _this._sort = _isNotFalse(vars.sortChildren);
    _globalTimeline && _addToTimeline(vars.parent || _globalTimeline, _assertThisInitialized$1(_this), position);
    vars.reversed && _this.reverse();
    vars.paused && _this.paused(true);
    vars.scrollTrigger && _scrollTrigger(_assertThisInitialized$1(_this), vars.scrollTrigger);
    return _this;
  }
  var _proto2 = Timeline2.prototype;
  _proto2.to = function to(targets, vars, position) {
    _createTweenType(0, arguments, this);
    return this;
  };
  _proto2.from = function from(targets, vars, position) {
    _createTweenType(1, arguments, this);
    return this;
  };
  _proto2.fromTo = function fromTo(targets, fromVars, toVars, position) {
    _createTweenType(2, arguments, this);
    return this;
  };
  _proto2.set = function set2(targets, vars, position) {
    vars.duration = 0;
    vars.parent = this;
    _inheritDefaults(vars).repeatDelay || (vars.repeat = 0);
    vars.immediateRender = !!vars.immediateRender;
    new Tween(targets, vars, _parsePosition(this, position), 1);
    return this;
  };
  _proto2.call = function call(callback, params, position) {
    return _addToTimeline(this, Tween.delayedCall(0, callback, params), position);
  };
  _proto2.staggerTo = function staggerTo(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams) {
    vars.duration = duration;
    vars.stagger = vars.stagger || stagger;
    vars.onComplete = onCompleteAll;
    vars.onCompleteParams = onCompleteAllParams;
    vars.parent = this;
    new Tween(targets, vars, _parsePosition(this, position));
    return this;
  };
  _proto2.staggerFrom = function staggerFrom(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams) {
    vars.runBackwards = 1;
    _inheritDefaults(vars).immediateRender = _isNotFalse(vars.immediateRender);
    return this.staggerTo(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams);
  };
  _proto2.staggerFromTo = function staggerFromTo(targets, duration, fromVars, toVars, stagger, position, onCompleteAll, onCompleteAllParams) {
    toVars.startAt = fromVars;
    _inheritDefaults(toVars).immediateRender = _isNotFalse(toVars.immediateRender);
    return this.staggerTo(targets, duration, toVars, stagger, position, onCompleteAll, onCompleteAllParams);
  };
  _proto2.render = function render5(totalTime, suppressEvents, force) {
    var prevTime = this._time, tDur = this._dirty ? this.totalDuration() : this._tDur, dur = this._dur, tTime = totalTime <= 0 ? 0 : _roundPrecise$1(totalTime), crossingStart = this._zTime < 0 !== totalTime < 0 && (this._initted || !dur), time, child, next, iteration, cycleDuration, prevPaused, pauseTween, timeScale, prevStart, prevIteration, yoyo, isYoyo;
    this !== _globalTimeline && tTime > tDur && totalTime >= 0 && (tTime = tDur);
    if (tTime !== this._tTime || force || crossingStart) {
      if (prevTime !== this._time && dur) {
        tTime += this._time - prevTime;
        totalTime += this._time - prevTime;
      }
      time = tTime;
      prevStart = this._start;
      timeScale = this._ts;
      prevPaused = !timeScale;
      if (crossingStart) {
        dur || (prevTime = this._zTime);
        (totalTime || !suppressEvents) && (this._zTime = totalTime);
      }
      if (this._repeat) {
        yoyo = this._yoyo;
        cycleDuration = dur + this._rDelay;
        if (this._repeat < -1 && totalTime < 0) {
          return this.totalTime(cycleDuration * 100 + totalTime, suppressEvents, force);
        }
        time = _roundPrecise$1(tTime % cycleDuration);
        if (tTime === tDur) {
          iteration = this._repeat;
          time = dur;
        } else {
          iteration = ~~(tTime / cycleDuration);
          if (iteration && iteration === tTime / cycleDuration) {
            time = dur;
            iteration--;
          }
          time > dur && (time = dur);
        }
        prevIteration = _animationCycle(this._tTime, cycleDuration);
        !prevTime && this._tTime && prevIteration !== iteration && this._tTime - prevIteration * cycleDuration - this._dur <= 0 && (prevIteration = iteration);
        if (yoyo && iteration & 1) {
          time = dur - time;
          isYoyo = 1;
        }
        if (iteration !== prevIteration && !this._lock) {
          var rewinding = yoyo && prevIteration & 1, doesWrap = rewinding === (yoyo && iteration & 1);
          iteration < prevIteration && (rewinding = !rewinding);
          prevTime = rewinding ? 0 : tTime % dur ? dur : tTime;
          this._lock = 1;
          this.render(prevTime || (isYoyo ? 0 : _roundPrecise$1(iteration * cycleDuration)), suppressEvents, !dur)._lock = 0;
          this._tTime = tTime;
          !suppressEvents && this.parent && _callback(this, "onRepeat");
          this.vars.repeatRefresh && !isYoyo && (this.invalidate()._lock = 1);
          if (prevTime && prevTime !== this._time || prevPaused !== !this._ts || this.vars.onRepeat && !this.parent && !this._act) {
            return this;
          }
          dur = this._dur;
          tDur = this._tDur;
          if (doesWrap) {
            this._lock = 2;
            prevTime = rewinding ? dur : -1e-4;
            this.render(prevTime, true);
            this.vars.repeatRefresh && !isYoyo && this.invalidate();
          }
          this._lock = 0;
          if (!this._ts && !prevPaused) {
            return this;
          }
          _propagateYoyoEase(this, isYoyo);
        }
      }
      if (this._hasPause && !this._forcing && this._lock < 2) {
        pauseTween = _findNextPauseTween(this, _roundPrecise$1(prevTime), _roundPrecise$1(time));
        if (pauseTween) {
          tTime -= time - (time = pauseTween._start);
        }
      }
      this._tTime = tTime;
      this._time = time;
      this._act = !timeScale;
      if (!this._initted) {
        this._onUpdate = this.vars.onUpdate;
        this._initted = 1;
        this._zTime = totalTime;
        prevTime = 0;
      }
      if (!prevTime && time && !suppressEvents && !iteration) {
        _callback(this, "onStart");
        if (this._tTime !== tTime) {
          return this;
        }
      }
      if (time >= prevTime && totalTime >= 0) {
        child = this._first;
        while (child) {
          next = child._next;
          if ((child._act || time >= child._start) && child._ts && pauseTween !== child) {
            if (child.parent !== this) {
              return this.render(totalTime, suppressEvents, force);
            }
            child.render(child._ts > 0 ? (time - child._start) * child._ts : (child._dirty ? child.totalDuration() : child._tDur) + (time - child._start) * child._ts, suppressEvents, force);
            if (time !== this._time || !this._ts && !prevPaused) {
              pauseTween = 0;
              next && (tTime += this._zTime = -_tinyNum);
              break;
            }
          }
          child = next;
        }
      } else {
        child = this._last;
        var adjustedTime = totalTime < 0 ? totalTime : time;
        while (child) {
          next = child._prev;
          if ((child._act || adjustedTime <= child._end) && child._ts && pauseTween !== child) {
            if (child.parent !== this) {
              return this.render(totalTime, suppressEvents, force);
            }
            child.render(child._ts > 0 ? (adjustedTime - child._start) * child._ts : (child._dirty ? child.totalDuration() : child._tDur) + (adjustedTime - child._start) * child._ts, suppressEvents, force || _reverting$2 && (child._initted || child._startAt));
            if (time !== this._time || !this._ts && !prevPaused) {
              pauseTween = 0;
              next && (tTime += this._zTime = adjustedTime ? -_tinyNum : _tinyNum);
              break;
            }
          }
          child = next;
        }
      }
      if (pauseTween && !suppressEvents) {
        this.pause();
        pauseTween.render(time >= prevTime ? 0 : -_tinyNum)._zTime = time >= prevTime ? 1 : -1;
        if (this._ts) {
          this._start = prevStart;
          _setEnd(this);
          return this.render(totalTime, suppressEvents, force);
        }
      }
      this._onUpdate && !suppressEvents && _callback(this, "onUpdate", true);
      if (tTime === tDur && this._tTime >= this.totalDuration() || !tTime && prevTime) {
        if (prevStart === this._start || Math.abs(timeScale) !== Math.abs(this._ts)) {
          if (!this._lock) {
            (totalTime || !dur) && (tTime === tDur && this._ts > 0 || !tTime && this._ts < 0) && _removeFromParent(this, 1);
            if (!suppressEvents && !(totalTime < 0 && !prevTime) && (tTime || prevTime || !tDur)) {
              _callback(this, tTime === tDur && totalTime >= 0 ? "onComplete" : "onReverseComplete", true);
              this._prom && !(tTime < tDur && this.timeScale() > 0) && this._prom();
            }
          }
        }
      }
    }
    return this;
  };
  _proto2.add = function add(child, position) {
    var _this2 = this;
    _isNumber$1(position) || (position = _parsePosition(this, position, child));
    if (!(child instanceof Animation)) {
      if (_isArray$1(child)) {
        child.forEach(function(obj) {
          return _this2.add(obj, position);
        });
        return this;
      }
      if (_isString$1(child)) {
        return this.addLabel(child, position);
      }
      if (_isFunction$1(child)) {
        child = Tween.delayedCall(0, child);
      } else {
        return this;
      }
    }
    return this !== child ? _addToTimeline(this, child, position) : this;
  };
  _proto2.getChildren = function getChildren(nested, tweens, timelines, ignoreBeforeTime) {
    if (nested === void 0) {
      nested = true;
    }
    if (tweens === void 0) {
      tweens = true;
    }
    if (timelines === void 0) {
      timelines = true;
    }
    if (ignoreBeforeTime === void 0) {
      ignoreBeforeTime = -_bigNum$3;
    }
    var a = [], child = this._first;
    while (child) {
      if (child._start >= ignoreBeforeTime) {
        if (child instanceof Tween) {
          tweens && a.push(child);
        } else {
          timelines && a.push(child);
          nested && a.push.apply(a, child.getChildren(true, tweens, timelines));
        }
      }
      child = child._next;
    }
    return a;
  };
  _proto2.getById = function getById2(id) {
    var animations = this.getChildren(1, 1, 1), i = animations.length;
    while (i--) {
      if (animations[i].vars.id === id) {
        return animations[i];
      }
    }
  };
  _proto2.remove = function remove2(child) {
    if (_isString$1(child)) {
      return this.removeLabel(child);
    }
    if (_isFunction$1(child)) {
      return this.killTweensOf(child);
    }
    _removeLinkedListItem(this, child);
    if (child === this._recent) {
      this._recent = this._last;
    }
    return _uncache(this);
  };
  _proto2.totalTime = function totalTime(_totalTime2, suppressEvents) {
    if (!arguments.length) {
      return this._tTime;
    }
    this._forcing = 1;
    if (!this._dp && this._ts) {
      this._start = _roundPrecise$1(_ticker.time - (this._ts > 0 ? _totalTime2 / this._ts : (this.totalDuration() - _totalTime2) / -this._ts));
    }
    _Animation.prototype.totalTime.call(this, _totalTime2, suppressEvents);
    this._forcing = 0;
    return this;
  };
  _proto2.addLabel = function addLabel(label, position) {
    this.labels[label] = _parsePosition(this, position);
    return this;
  };
  _proto2.removeLabel = function removeLabel(label) {
    delete this.labels[label];
    return this;
  };
  _proto2.addPause = function addPause(position, callback, params) {
    var t = Tween.delayedCall(0, callback || _emptyFunc$2, params);
    t.data = "isPause";
    this._hasPause = 1;
    return _addToTimeline(this, t, _parsePosition(this, position));
  };
  _proto2.removePause = function removePause(position) {
    var child = this._first;
    position = _parsePosition(this, position);
    while (child) {
      if (child._start === position && child.data === "isPause") {
        _removeFromParent(child);
      }
      child = child._next;
    }
  };
  _proto2.killTweensOf = function killTweensOf(targets, props, onlyActive) {
    var tweens = this.getTweensOf(targets, onlyActive), i = tweens.length;
    while (i--) {
      _overwritingTween !== tweens[i] && tweens[i].kill(targets, props);
    }
    return this;
  };
  _proto2.getTweensOf = function getTweensOf2(targets, onlyActive) {
    var a = [], parsedTargets = toArray$1(targets), child = this._first, isGlobalTime = _isNumber$1(onlyActive), children;
    while (child) {
      if (child instanceof Tween) {
        if (_arrayContainsAny(child._targets, parsedTargets) && (isGlobalTime ? (!_overwritingTween || child._initted && child._ts) && child.globalTime(0) <= onlyActive && child.globalTime(child.totalDuration()) > onlyActive : !onlyActive || child.isActive())) {
          a.push(child);
        }
      } else if ((children = child.getTweensOf(parsedTargets, onlyActive)).length) {
        a.push.apply(a, children);
      }
      child = child._next;
    }
    return a;
  };
  _proto2.tweenTo = function tweenTo(position, vars) {
    vars = vars || {};
    var tl = this, endTime = _parsePosition(tl, position), _vars = vars, startAt = _vars.startAt, _onStart = _vars.onStart, onStartParams = _vars.onStartParams, immediateRender = _vars.immediateRender, initted, tween = Tween.to(tl, _setDefaults$1({
      ease: vars.ease || "none",
      lazy: false,
      immediateRender: false,
      time: endTime,
      overwrite: "auto",
      duration: vars.duration || Math.abs((endTime - (startAt && "time" in startAt ? startAt.time : tl._time)) / tl.timeScale()) || _tinyNum,
      onStart: function onStart() {
        tl.pause();
        if (!initted) {
          var duration = vars.duration || Math.abs((endTime - (startAt && "time" in startAt ? startAt.time : tl._time)) / tl.timeScale());
          tween._dur !== duration && _setDuration(tween, duration, 0, 1).render(tween._time, true, true);
          initted = 1;
        }
        _onStart && _onStart.apply(tween, onStartParams || []);
      }
    }, vars));
    return immediateRender ? tween.render(0) : tween;
  };
  _proto2.tweenFromTo = function tweenFromTo(fromPosition, toPosition, vars) {
    return this.tweenTo(toPosition, _setDefaults$1({
      startAt: {
        time: _parsePosition(this, fromPosition)
      }
    }, vars));
  };
  _proto2.recent = function recent() {
    return this._recent;
  };
  _proto2.nextLabel = function nextLabel(afterTime) {
    if (afterTime === void 0) {
      afterTime = this._time;
    }
    return _getLabelInDirection(this, _parsePosition(this, afterTime));
  };
  _proto2.previousLabel = function previousLabel(beforeTime) {
    if (beforeTime === void 0) {
      beforeTime = this._time;
    }
    return _getLabelInDirection(this, _parsePosition(this, beforeTime), 1);
  };
  _proto2.currentLabel = function currentLabel(value) {
    return arguments.length ? this.seek(value, true) : this.previousLabel(this._time + _tinyNum);
  };
  _proto2.shiftChildren = function shiftChildren(amount, adjustLabels, ignoreBeforeTime) {
    if (ignoreBeforeTime === void 0) {
      ignoreBeforeTime = 0;
    }
    var child = this._first, labels = this.labels, p;
    while (child) {
      if (child._start >= ignoreBeforeTime) {
        child._start += amount;
        child._end += amount;
      }
      child = child._next;
    }
    if (adjustLabels) {
      for (p in labels) {
        if (labels[p] >= ignoreBeforeTime) {
          labels[p] += amount;
        }
      }
    }
    return _uncache(this);
  };
  _proto2.invalidate = function invalidate(soft) {
    var child = this._first;
    this._lock = 0;
    while (child) {
      child.invalidate(soft);
      child = child._next;
    }
    return _Animation.prototype.invalidate.call(this, soft);
  };
  _proto2.clear = function clear(includeLabels) {
    if (includeLabels === void 0) {
      includeLabels = true;
    }
    var child = this._first, next;
    while (child) {
      next = child._next;
      this.remove(child);
      child = next;
    }
    this._dp && (this._time = this._tTime = this._pTime = 0);
    includeLabels && (this.labels = {});
    return _uncache(this);
  };
  _proto2.totalDuration = function totalDuration(value) {
    var max = 0, self2 = this, child = self2._last, prevStart = _bigNum$3, prev, start, parent;
    if (arguments.length) {
      return self2.timeScale((self2._repeat < 0 ? self2.duration() : self2.totalDuration()) / (self2.reversed() ? -value : value));
    }
    if (self2._dirty) {
      parent = self2.parent;
      while (child) {
        prev = child._prev;
        child._dirty && child.totalDuration();
        start = child._start;
        if (start > prevStart && self2._sort && child._ts && !self2._lock) {
          self2._lock = 1;
          _addToTimeline(self2, child, start - child._delay, 1)._lock = 0;
        } else {
          prevStart = start;
        }
        if (start < 0 && child._ts) {
          max -= start;
          if (!parent && !self2._dp || parent && parent.smoothChildTiming) {
            self2._start += start / self2._ts;
            self2._time -= start;
            self2._tTime -= start;
          }
          self2.shiftChildren(-start, false, -Infinity);
          prevStart = 0;
        }
        child._end > max && child._ts && (max = child._end);
        child = prev;
      }
      _setDuration(self2, self2 === _globalTimeline && self2._time > max ? self2._time : max, 1, 1);
      self2._dirty = 0;
    }
    return self2._tDur;
  };
  Timeline2.updateRoot = function updateRoot(time) {
    if (_globalTimeline._ts) {
      _lazySafeRender(_globalTimeline, _parentToChildTotalTime(time, _globalTimeline));
      _lastRenderedFrame = _ticker.frame;
    }
    if (_ticker.frame >= _nextGCFrame) {
      _nextGCFrame += _config.autoSleep || 120;
      var child = _globalTimeline._first;
      if (!child || !child._ts) {
        if (_config.autoSleep && _ticker._listeners.length < 2) {
          while (child && !child._ts) {
            child = child._next;
          }
          child || _ticker.sleep();
        }
      }
    }
  };
  return Timeline2;
}(Animation);
_setDefaults$1(Timeline.prototype, {
  _lock: 0,
  _hasPause: 0,
  _forcing: 0
});
var _addComplexStringPropTween = function _addComplexStringPropTween2(target, prop, start, end, setter, stringFilter, funcParam) {
  var pt = new PropTween$1(this._pt, target, prop, 0, 1, _renderComplexString, null, setter), index = 0, matchIndex = 0, result, startNums, color, endNum, chunk, startNum, hasRandom, a;
  pt.b = start;
  pt.e = end;
  start += "";
  end += "";
  if (hasRandom = ~end.indexOf("random(")) {
    end = _replaceRandom(end);
  }
  if (stringFilter) {
    a = [start, end];
    stringFilter(a, target, prop);
    start = a[0];
    end = a[1];
  }
  startNums = start.match(_complexStringNumExp) || [];
  while (result = _complexStringNumExp.exec(end)) {
    endNum = result[0];
    chunk = end.substring(index, result.index);
    if (color) {
      color = (color + 1) % 5;
    } else if (chunk.substr(-5) === "rgba(") {
      color = 1;
    }
    if (endNum !== startNums[matchIndex++]) {
      startNum = parseFloat(startNums[matchIndex - 1]) || 0;
      pt._pt = {
        _next: pt._pt,
        p: chunk || matchIndex === 1 ? chunk : ",",
        //note: SVG spec allows omission of comma/space when a negative sign is wedged between two numbers, like 2.5-5.3 instead of 2.5,-5.3 but when tweening, the negative value may switch to positive, so we insert the comma just in case.
        s: startNum,
        c: endNum.charAt(1) === "=" ? _parseRelative(startNum, endNum) - startNum : parseFloat(endNum) - startNum,
        m: color && color < 4 ? Math.round : 0
      };
      index = _complexStringNumExp.lastIndex;
    }
  }
  pt.c = index < end.length ? end.substring(index, end.length) : "";
  pt.fp = funcParam;
  if (_relExp.test(end) || hasRandom) {
    pt.e = 0;
  }
  this._pt = pt;
  return pt;
}, _addPropTween = function _addPropTween2(target, prop, start, end, index, targets, modifier, stringFilter, funcParam, optional) {
  _isFunction$1(end) && (end = end(index || 0, target, targets));
  var currentValue = target[prop], parsedStart = start !== "get" ? start : !_isFunction$1(currentValue) ? currentValue : funcParam ? target[prop.indexOf("set") || !_isFunction$1(target["get" + prop.substr(3)]) ? prop : "get" + prop.substr(3)](funcParam) : target[prop](), setter = !_isFunction$1(currentValue) ? _setterPlain : funcParam ? _setterFuncWithParam : _setterFunc, pt;
  if (_isString$1(end)) {
    if (~end.indexOf("random(")) {
      end = _replaceRandom(end);
    }
    if (end.charAt(1) === "=") {
      pt = _parseRelative(parsedStart, end) + (getUnit(parsedStart) || 0);
      if (pt || pt === 0) {
        end = pt;
      }
    }
  }
  if (!optional || parsedStart !== end || _forceAllPropTweens) {
    if (!isNaN(parsedStart * end) && end !== "") {
      pt = new PropTween$1(this._pt, target, prop, +parsedStart || 0, end - (parsedStart || 0), typeof currentValue === "boolean" ? _renderBoolean : _renderPlain, 0, setter);
      funcParam && (pt.fp = funcParam);
      modifier && pt.modifier(modifier, this, target);
      return this._pt = pt;
    }
    !currentValue && !(prop in target) && _missingPlugin(prop, end);
    return _addComplexStringPropTween.call(this, target, prop, parsedStart, end, setter, stringFilter || _config.stringFilter, funcParam);
  }
}, _processVars = function _processVars2(vars, index, target, targets, tween) {
  _isFunction$1(vars) && (vars = _parseFuncOrString(vars, tween, index, target, targets));
  if (!_isObject$1(vars) || vars.style && vars.nodeType || _isArray$1(vars) || _isTypedArray(vars)) {
    return _isString$1(vars) ? _parseFuncOrString(vars, tween, index, target, targets) : vars;
  }
  var copy = {}, p;
  for (p in vars) {
    copy[p] = _parseFuncOrString(vars[p], tween, index, target, targets);
  }
  return copy;
}, _checkPlugin = function _checkPlugin2(property, vars, tween, index, target, targets) {
  var plugin, pt, ptLookup, i;
  if (_plugins[property] && (plugin = new _plugins[property]()).init(target, plugin.rawVars ? vars[property] : _processVars(vars[property], index, target, targets, tween), tween, index, targets) !== false) {
    tween._pt = pt = new PropTween$1(tween._pt, target, property, 0, 1, plugin.render, plugin, 0, plugin.priority);
    if (tween !== _quickTween) {
      ptLookup = tween._ptLookup[tween._targets.indexOf(target)];
      i = plugin._props.length;
      while (i--) {
        ptLookup[plugin._props[i]] = pt;
      }
    }
  }
  return plugin;
}, _overwritingTween, _forceAllPropTweens, _initTween = function _initTween2(tween, time, tTime) {
  var vars = tween.vars, ease = vars.ease, startAt = vars.startAt, immediateRender = vars.immediateRender, lazy = vars.lazy, onUpdate = vars.onUpdate, runBackwards = vars.runBackwards, yoyoEase = vars.yoyoEase, keyframes = vars.keyframes, autoRevert = vars.autoRevert, dur = tween._dur, prevStartAt = tween._startAt, targets = tween._targets, parent = tween.parent, fullTargets = parent && parent.data === "nested" ? parent.vars.targets : targets, autoOverwrite = tween._overwrite === "auto" && !_suppressOverwrites, tl = tween.timeline, cleanVars, i, p, pt, target, hasPriority, gsData, harness, plugin, ptLookup, index, harnessVars, overwritten;
  tl && (!keyframes || !ease) && (ease = "none");
  tween._ease = _parseEase(ease, _defaults.ease);
  tween._yEase = yoyoEase ? _invertEase(_parseEase(yoyoEase === true ? ease : yoyoEase, _defaults.ease)) : 0;
  if (yoyoEase && tween._yoyo && !tween._repeat) {
    yoyoEase = tween._yEase;
    tween._yEase = tween._ease;
    tween._ease = yoyoEase;
  }
  tween._from = !tl && !!vars.runBackwards;
  if (!tl || keyframes && !vars.stagger) {
    harness = targets[0] ? _getCache(targets[0]).harness : 0;
    harnessVars = harness && vars[harness.prop];
    cleanVars = _copyExcluding(vars, _reservedProps);
    if (prevStartAt) {
      prevStartAt._zTime < 0 && prevStartAt.progress(1);
      time < 0 && runBackwards && immediateRender && !autoRevert ? prevStartAt.render(-1, true) : prevStartAt.revert(runBackwards && dur ? _revertConfigNoKill : _startAtRevertConfig);
      prevStartAt._lazy = 0;
    }
    if (startAt) {
      _removeFromParent(tween._startAt = Tween.set(targets, _setDefaults$1({
        data: "isStart",
        overwrite: false,
        parent,
        immediateRender: true,
        lazy: !prevStartAt && _isNotFalse(lazy),
        startAt: null,
        delay: 0,
        onUpdate: onUpdate && function() {
          return _callback(tween, "onUpdate");
        },
        stagger: 0
      }, startAt)));
      tween._startAt._dp = 0;
      tween._startAt._sat = tween;
      time < 0 && (_reverting$2 || !immediateRender && !autoRevert) && tween._startAt.revert(_revertConfigNoKill);
      if (immediateRender) {
        if (dur && time <= 0 && tTime <= 0) {
          time && (tween._zTime = time);
          return;
        }
      }
    } else if (runBackwards && dur) {
      if (!prevStartAt) {
        time && (immediateRender = false);
        p = _setDefaults$1({
          overwrite: false,
          data: "isFromStart",
          //we tag the tween with as "isFromStart" so that if [inside a plugin] we need to only do something at the very END of a tween, we have a way of identifying this tween as merely the one that's setting the beginning values for a "from()" tween. For example, clearProps in CSSPlugin should only get applied at the very END of a tween and without this tag, from(...{height:100, clearProps:"height", delay:1}) would wipe the height at the beginning of the tween and after 1 second, it'd kick back in.
          lazy: immediateRender && !prevStartAt && _isNotFalse(lazy),
          immediateRender,
          //zero-duration tweens render immediately by default, but if we're not specifically instructed to render this tween immediately, we should skip this and merely _init() to record the starting values (rendering them immediately would push them to completion which is wasteful in that case - we'd have to render(-1) immediately after)
          stagger: 0,
          parent
          //ensures that nested tweens that had a stagger are handled properly, like gsap.from(".class", {y: gsap.utils.wrap([-100,100]), stagger: 0.5})
        }, cleanVars);
        harnessVars && (p[harness.prop] = harnessVars);
        _removeFromParent(tween._startAt = Tween.set(targets, p));
        tween._startAt._dp = 0;
        tween._startAt._sat = tween;
        time < 0 && (_reverting$2 ? tween._startAt.revert(_revertConfigNoKill) : tween._startAt.render(-1, true));
        tween._zTime = time;
        if (!immediateRender) {
          _initTween2(tween._startAt, _tinyNum, _tinyNum);
        } else if (!time) {
          return;
        }
      }
    }
    tween._pt = tween._ptCache = 0;
    lazy = dur && _isNotFalse(lazy) || lazy && !dur;
    for (i = 0; i < targets.length; i++) {
      target = targets[i];
      gsData = target._gsap || _harness(targets)[i]._gsap;
      tween._ptLookup[i] = ptLookup = {};
      _lazyLookup[gsData.id] && _lazyTweens.length && _lazyRender();
      index = fullTargets === targets ? i : fullTargets.indexOf(target);
      if (harness && (plugin = new harness()).init(target, harnessVars || cleanVars, tween, index, fullTargets) !== false) {
        tween._pt = pt = new PropTween$1(tween._pt, target, plugin.name, 0, 1, plugin.render, plugin, 0, plugin.priority);
        plugin._props.forEach(function(name) {
          ptLookup[name] = pt;
        });
        plugin.priority && (hasPriority = 1);
      }
      if (!harness || harnessVars) {
        for (p in cleanVars) {
          if (_plugins[p] && (plugin = _checkPlugin(p, cleanVars, tween, index, target, fullTargets))) {
            plugin.priority && (hasPriority = 1);
          } else {
            ptLookup[p] = pt = _addPropTween.call(tween, target, p, "get", cleanVars[p], index, fullTargets, 0, vars.stringFilter);
          }
        }
      }
      tween._op && tween._op[i] && tween.kill(target, tween._op[i]);
      if (autoOverwrite && tween._pt) {
        _overwritingTween = tween;
        _globalTimeline.killTweensOf(target, ptLookup, tween.globalTime(time));
        overwritten = !tween.parent;
        _overwritingTween = 0;
      }
      tween._pt && lazy && (_lazyLookup[gsData.id] = 1);
    }
    hasPriority && _sortPropTweensByPriority(tween);
    tween._onInit && tween._onInit(tween);
  }
  tween._onUpdate = onUpdate;
  tween._initted = (!tween._op || tween._pt) && !overwritten;
  keyframes && time <= 0 && tl.render(_bigNum$3, true, true);
}, _updatePropTweens = function _updatePropTweens2(tween, property, value, start, startIsRelative, ratio, time, skipRecursion) {
  var ptCache = (tween._pt && tween._ptCache || (tween._ptCache = {}))[property], pt, rootPT, lookup, i;
  if (!ptCache) {
    ptCache = tween._ptCache[property] = [];
    lookup = tween._ptLookup;
    i = tween._targets.length;
    while (i--) {
      pt = lookup[i][property];
      if (pt && pt.d && pt.d._pt) {
        pt = pt.d._pt;
        while (pt && pt.p !== property && pt.fp !== property) {
          pt = pt._next;
        }
      }
      if (!pt) {
        _forceAllPropTweens = 1;
        tween.vars[property] = "+=0";
        _initTween(tween, time);
        _forceAllPropTweens = 0;
        return skipRecursion ? _warn(property + " not eligible for reset") : 1;
      }
      ptCache.push(pt);
    }
  }
  i = ptCache.length;
  while (i--) {
    rootPT = ptCache[i];
    pt = rootPT._pt || rootPT;
    pt.s = (start || start === 0) && !startIsRelative ? start : pt.s + (start || 0) + ratio * pt.c;
    pt.c = value - pt.s;
    rootPT.e && (rootPT.e = _round$4(value) + getUnit(rootPT.e));
    rootPT.b && (rootPT.b = pt.s + getUnit(rootPT.b));
  }
}, _addAliasesToVars = function _addAliasesToVars2(targets, vars) {
  var harness = targets[0] ? _getCache(targets[0]).harness : 0, propertyAliases = harness && harness.aliases, copy, p, i, aliases;
  if (!propertyAliases) {
    return vars;
  }
  copy = _merge({}, vars);
  for (p in propertyAliases) {
    if (p in copy) {
      aliases = propertyAliases[p].split(",");
      i = aliases.length;
      while (i--) {
        copy[aliases[i]] = copy[p];
      }
    }
  }
  return copy;
}, _parseKeyframe = function _parseKeyframe2(prop, obj, allProps, easeEach) {
  var ease = obj.ease || easeEach || "power1.inOut", p, a;
  if (_isArray$1(obj)) {
    a = allProps[prop] || (allProps[prop] = []);
    obj.forEach(function(value, i) {
      return a.push({
        t: i / (obj.length - 1) * 100,
        v: value,
        e: ease
      });
    });
  } else {
    for (p in obj) {
      a = allProps[p] || (allProps[p] = []);
      p === "ease" || a.push({
        t: parseFloat(prop),
        v: obj[p],
        e: ease
      });
    }
  }
}, _parseFuncOrString = function _parseFuncOrString2(value, tween, i, target, targets) {
  return _isFunction$1(value) ? value.call(tween, i, target, targets) : _isString$1(value) && ~value.indexOf("random(") ? _replaceRandom(value) : value;
}, _staggerTweenProps = _callbackNames + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase,autoRevert", _staggerPropsToSkip = {};
_forEachName(_staggerTweenProps + ",id,stagger,delay,duration,paused,scrollTrigger", function(name) {
  return _staggerPropsToSkip[name] = 1;
});
var Tween = /* @__PURE__ */ function(_Animation2) {
  _inheritsLoose$1(Tween2, _Animation2);
  function Tween2(targets, vars, position, skipInherit) {
    var _this3;
    if (typeof vars === "number") {
      position.duration = vars;
      vars = position;
      position = null;
    }
    _this3 = _Animation2.call(this, skipInherit ? vars : _inheritDefaults(vars)) || this;
    var _this3$vars = _this3.vars, duration = _this3$vars.duration, delay = _this3$vars.delay, immediateRender = _this3$vars.immediateRender, stagger = _this3$vars.stagger, overwrite = _this3$vars.overwrite, keyframes = _this3$vars.keyframes, defaults2 = _this3$vars.defaults, scrollTrigger = _this3$vars.scrollTrigger, yoyoEase = _this3$vars.yoyoEase, parent = vars.parent || _globalTimeline, parsedTargets = (_isArray$1(targets) || _isTypedArray(targets) ? _isNumber$1(targets[0]) : "length" in vars) ? [targets] : toArray$1(targets), tl, i, copy, l, p, curTarget, staggerFunc, staggerVarsToMerge;
    _this3._targets = parsedTargets.length ? _harness(parsedTargets) : _warn("GSAP target " + targets + " not found. https://gsap.com", !_config.nullTargetWarn) || [];
    _this3._ptLookup = [];
    _this3._overwrite = overwrite;
    if (keyframes || stagger || _isFuncOrString(duration) || _isFuncOrString(delay)) {
      vars = _this3.vars;
      tl = _this3.timeline = new Timeline({
        data: "nested",
        defaults: defaults2 || {},
        targets: parent && parent.data === "nested" ? parent.vars.targets : parsedTargets
      });
      tl.kill();
      tl.parent = tl._dp = _assertThisInitialized$1(_this3);
      tl._start = 0;
      if (stagger || _isFuncOrString(duration) || _isFuncOrString(delay)) {
        l = parsedTargets.length;
        staggerFunc = stagger && distribute(stagger);
        if (_isObject$1(stagger)) {
          for (p in stagger) {
            if (~_staggerTweenProps.indexOf(p)) {
              staggerVarsToMerge || (staggerVarsToMerge = {});
              staggerVarsToMerge[p] = stagger[p];
            }
          }
        }
        for (i = 0; i < l; i++) {
          copy = _copyExcluding(vars, _staggerPropsToSkip);
          copy.stagger = 0;
          yoyoEase && (copy.yoyoEase = yoyoEase);
          staggerVarsToMerge && _merge(copy, staggerVarsToMerge);
          curTarget = parsedTargets[i];
          copy.duration = +_parseFuncOrString(duration, _assertThisInitialized$1(_this3), i, curTarget, parsedTargets);
          copy.delay = (+_parseFuncOrString(delay, _assertThisInitialized$1(_this3), i, curTarget, parsedTargets) || 0) - _this3._delay;
          if (!stagger && l === 1 && copy.delay) {
            _this3._delay = delay = copy.delay;
            _this3._start += delay;
            copy.delay = 0;
          }
          tl.to(curTarget, copy, staggerFunc ? staggerFunc(i, curTarget, parsedTargets) : 0);
          tl._ease = _easeMap.none;
        }
        tl.duration() ? duration = delay = 0 : _this3.timeline = 0;
      } else if (keyframes) {
        _inheritDefaults(_setDefaults$1(tl.vars.defaults, {
          ease: "none"
        }));
        tl._ease = _parseEase(keyframes.ease || vars.ease || "none");
        var time = 0, a, kf, v;
        if (_isArray$1(keyframes)) {
          keyframes.forEach(function(frame) {
            return tl.to(parsedTargets, frame, ">");
          });
          tl.duration();
        } else {
          copy = {};
          for (p in keyframes) {
            p === "ease" || p === "easeEach" || _parseKeyframe(p, keyframes[p], copy, keyframes.easeEach);
          }
          for (p in copy) {
            a = copy[p].sort(function(a2, b) {
              return a2.t - b.t;
            });
            time = 0;
            for (i = 0; i < a.length; i++) {
              kf = a[i];
              v = {
                ease: kf.e,
                duration: (kf.t - (i ? a[i - 1].t : 0)) / 100 * duration
              };
              v[p] = kf.v;
              tl.to(parsedTargets, v, time);
              time += v.duration;
            }
          }
          tl.duration() < duration && tl.to({}, {
            duration: duration - tl.duration()
          });
        }
      }
      duration || _this3.duration(duration = tl.duration());
    } else {
      _this3.timeline = 0;
    }
    if (overwrite === true && !_suppressOverwrites) {
      _overwritingTween = _assertThisInitialized$1(_this3);
      _globalTimeline.killTweensOf(parsedTargets);
      _overwritingTween = 0;
    }
    _addToTimeline(parent, _assertThisInitialized$1(_this3), position);
    vars.reversed && _this3.reverse();
    vars.paused && _this3.paused(true);
    if (immediateRender || !duration && !keyframes && _this3._start === _roundPrecise$1(parent._time) && _isNotFalse(immediateRender) && _hasNoPausedAncestors(_assertThisInitialized$1(_this3)) && parent.data !== "nested") {
      _this3._tTime = -_tinyNum;
      _this3.render(Math.max(0, -delay) || 0);
    }
    scrollTrigger && _scrollTrigger(_assertThisInitialized$1(_this3), scrollTrigger);
    return _this3;
  }
  var _proto3 = Tween2.prototype;
  _proto3.render = function render5(totalTime, suppressEvents, force) {
    var prevTime = this._time, tDur = this._tDur, dur = this._dur, isNegative = totalTime < 0, tTime = totalTime > tDur - _tinyNum && !isNegative ? tDur : totalTime < _tinyNum ? 0 : totalTime, time, pt, iteration, cycleDuration, prevIteration, isYoyo, ratio, timeline2, yoyoEase;
    if (!dur) {
      _renderZeroDurationTween(this, totalTime, suppressEvents, force);
    } else if (tTime !== this._tTime || !totalTime || force || !this._initted && this._tTime || this._startAt && this._zTime < 0 !== isNegative) {
      time = tTime;
      timeline2 = this.timeline;
      if (this._repeat) {
        cycleDuration = dur + this._rDelay;
        if (this._repeat < -1 && isNegative) {
          return this.totalTime(cycleDuration * 100 + totalTime, suppressEvents, force);
        }
        time = _roundPrecise$1(tTime % cycleDuration);
        if (tTime === tDur) {
          iteration = this._repeat;
          time = dur;
        } else {
          iteration = ~~(tTime / cycleDuration);
          if (iteration && iteration === _roundPrecise$1(tTime / cycleDuration)) {
            time = dur;
            iteration--;
          }
          time > dur && (time = dur);
        }
        isYoyo = this._yoyo && iteration & 1;
        if (isYoyo) {
          yoyoEase = this._yEase;
          time = dur - time;
        }
        prevIteration = _animationCycle(this._tTime, cycleDuration);
        if (time === prevTime && !force && this._initted && iteration === prevIteration) {
          this._tTime = tTime;
          return this;
        }
        if (iteration !== prevIteration) {
          timeline2 && this._yEase && _propagateYoyoEase(timeline2, isYoyo);
          if (this.vars.repeatRefresh && !isYoyo && !this._lock && this._time !== cycleDuration && this._initted) {
            this._lock = force = 1;
            this.render(_roundPrecise$1(cycleDuration * iteration), true).invalidate()._lock = 0;
          }
        }
      }
      if (!this._initted) {
        if (_attemptInitTween(this, isNegative ? totalTime : time, force, suppressEvents, tTime)) {
          this._tTime = 0;
          return this;
        }
        if (prevTime !== this._time && !(force && this.vars.repeatRefresh && iteration !== prevIteration)) {
          return this;
        }
        if (dur !== this._dur) {
          return this.render(totalTime, suppressEvents, force);
        }
      }
      this._tTime = tTime;
      this._time = time;
      if (!this._act && this._ts) {
        this._act = 1;
        this._lazy = 0;
      }
      this.ratio = ratio = (yoyoEase || this._ease)(time / dur);
      if (this._from) {
        this.ratio = ratio = 1 - ratio;
      }
      if (time && !prevTime && !suppressEvents && !iteration) {
        _callback(this, "onStart");
        if (this._tTime !== tTime) {
          return this;
        }
      }
      pt = this._pt;
      while (pt) {
        pt.r(ratio, pt.d);
        pt = pt._next;
      }
      timeline2 && timeline2.render(totalTime < 0 ? totalTime : timeline2._dur * timeline2._ease(time / this._dur), suppressEvents, force) || this._startAt && (this._zTime = totalTime);
      if (this._onUpdate && !suppressEvents) {
        isNegative && _rewindStartAt(this, totalTime, suppressEvents, force);
        _callback(this, "onUpdate");
      }
      this._repeat && iteration !== prevIteration && this.vars.onRepeat && !suppressEvents && this.parent && _callback(this, "onRepeat");
      if ((tTime === this._tDur || !tTime) && this._tTime === tTime) {
        isNegative && !this._onUpdate && _rewindStartAt(this, totalTime, true, true);
        (totalTime || !dur) && (tTime === this._tDur && this._ts > 0 || !tTime && this._ts < 0) && _removeFromParent(this, 1);
        if (!suppressEvents && !(isNegative && !prevTime) && (tTime || prevTime || isYoyo)) {
          _callback(this, tTime === tDur ? "onComplete" : "onReverseComplete", true);
          this._prom && !(tTime < tDur && this.timeScale() > 0) && this._prom();
        }
      }
    }
    return this;
  };
  _proto3.targets = function targets() {
    return this._targets;
  };
  _proto3.invalidate = function invalidate(soft) {
    (!soft || !this.vars.runBackwards) && (this._startAt = 0);
    this._pt = this._op = this._onUpdate = this._lazy = this.ratio = 0;
    this._ptLookup = [];
    this.timeline && this.timeline.invalidate(soft);
    return _Animation2.prototype.invalidate.call(this, soft);
  };
  _proto3.resetTo = function resetTo(property, value, start, startIsRelative, skipRecursion) {
    _tickerActive || _ticker.wake();
    this._ts || this.play();
    var time = Math.min(this._dur, (this._dp._time - this._start) * this._ts), ratio;
    this._initted || _initTween(this, time);
    ratio = this._ease(time / this._dur);
    if (_updatePropTweens(this, property, value, start, startIsRelative, ratio, time, skipRecursion)) {
      return this.resetTo(property, value, start, startIsRelative, 1);
    }
    _alignPlayhead(this, 0);
    this.parent || _addLinkedListItem(this._dp, this, "_first", "_last", this._dp._sort ? "_start" : 0);
    return this.render(0);
  };
  _proto3.kill = function kill(targets, vars) {
    if (vars === void 0) {
      vars = "all";
    }
    if (!targets && (!vars || vars === "all")) {
      this._lazy = this._pt = 0;
      return this.parent ? _interrupt$1(this) : this;
    }
    if (this.timeline) {
      var tDur = this.timeline.totalDuration();
      this.timeline.killTweensOf(targets, vars, _overwritingTween && _overwritingTween.vars.overwrite !== true)._first || _interrupt$1(this);
      this.parent && tDur !== this.timeline.totalDuration() && _setDuration(this, this._dur * this.timeline._tDur / tDur, 0, 1);
      return this;
    }
    var parsedTargets = this._targets, killingTargets = targets ? toArray$1(targets) : parsedTargets, propTweenLookup = this._ptLookup, firstPT = this._pt, overwrittenProps, curLookup, curOverwriteProps, props, p, pt, i;
    if ((!vars || vars === "all") && _arraysMatch(parsedTargets, killingTargets)) {
      vars === "all" && (this._pt = 0);
      return _interrupt$1(this);
    }
    overwrittenProps = this._op = this._op || [];
    if (vars !== "all") {
      if (_isString$1(vars)) {
        p = {};
        _forEachName(vars, function(name) {
          return p[name] = 1;
        });
        vars = p;
      }
      vars = _addAliasesToVars(parsedTargets, vars);
    }
    i = parsedTargets.length;
    while (i--) {
      if (~killingTargets.indexOf(parsedTargets[i])) {
        curLookup = propTweenLookup[i];
        if (vars === "all") {
          overwrittenProps[i] = vars;
          props = curLookup;
          curOverwriteProps = {};
        } else {
          curOverwriteProps = overwrittenProps[i] = overwrittenProps[i] || {};
          props = vars;
        }
        for (p in props) {
          pt = curLookup && curLookup[p];
          if (pt) {
            if (!("kill" in pt.d) || pt.d.kill(p) === true) {
              _removeLinkedListItem(this, pt, "_pt");
            }
            delete curLookup[p];
          }
          if (curOverwriteProps !== "all") {
            curOverwriteProps[p] = 1;
          }
        }
      }
    }
    this._initted && !this._pt && firstPT && _interrupt$1(this);
    return this;
  };
  Tween2.to = function to(targets, vars) {
    return new Tween2(targets, vars, arguments[2]);
  };
  Tween2.from = function from(targets, vars) {
    return _createTweenType(1, arguments);
  };
  Tween2.delayedCall = function delayedCall(delay, callback, params, scope) {
    return new Tween2(callback, 0, {
      immediateRender: false,
      lazy: false,
      overwrite: false,
      delay,
      onComplete: callback,
      onReverseComplete: callback,
      onCompleteParams: params,
      onReverseCompleteParams: params,
      callbackScope: scope
    });
  };
  Tween2.fromTo = function fromTo(targets, fromVars, toVars) {
    return _createTweenType(2, arguments);
  };
  Tween2.set = function set2(targets, vars) {
    vars.duration = 0;
    vars.repeatDelay || (vars.repeat = 0);
    return new Tween2(targets, vars);
  };
  Tween2.killTweensOf = function killTweensOf(targets, props, onlyActive) {
    return _globalTimeline.killTweensOf(targets, props, onlyActive);
  };
  return Tween2;
}(Animation);
_setDefaults$1(Tween.prototype, {
  _targets: [],
  _lazy: 0,
  _startAt: 0,
  _op: 0,
  _onInit: 0
});
_forEachName("staggerTo,staggerFrom,staggerFromTo", function(name) {
  Tween[name] = function() {
    var tl = new Timeline(), params = _slice.call(arguments, 0);
    params.splice(name === "staggerFromTo" ? 5 : 4, 0, 0);
    return tl[name].apply(tl, params);
  };
});
var _setterPlain = function _setterPlain2(target, property, value) {
  return target[property] = value;
}, _setterFunc = function _setterFunc2(target, property, value) {
  return target[property](value);
}, _setterFuncWithParam = function _setterFuncWithParam2(target, property, value, data) {
  return target[property](data.fp, value);
}, _setterAttribute = function _setterAttribute2(target, property, value) {
  return target.setAttribute(property, value);
}, _getSetter = function _getSetter2(target, property) {
  return _isFunction$1(target[property]) ? _setterFunc : _isUndefined$2(target[property]) && target.setAttribute ? _setterAttribute : _setterPlain;
}, _renderPlain = function _renderPlain2(ratio, data) {
  return data.set(data.t, data.p, Math.round((data.s + data.c * ratio) * 1e6) / 1e6, data);
}, _renderBoolean = function _renderBoolean2(ratio, data) {
  return data.set(data.t, data.p, !!(data.s + data.c * ratio), data);
}, _renderComplexString = function _renderComplexString2(ratio, data) {
  var pt = data._pt, s = "";
  if (!ratio && data.b) {
    s = data.b;
  } else if (ratio === 1 && data.e) {
    s = data.e;
  } else {
    while (pt) {
      s = pt.p + (pt.m ? pt.m(pt.s + pt.c * ratio) : Math.round((pt.s + pt.c * ratio) * 1e4) / 1e4) + s;
      pt = pt._next;
    }
    s += data.c;
  }
  data.set(data.t, data.p, s, data);
}, _renderPropTweens = function _renderPropTweens2(ratio, data) {
  var pt = data._pt;
  while (pt) {
    pt.r(ratio, pt.d);
    pt = pt._next;
  }
}, _addPluginModifier = function _addPluginModifier2(modifier, tween, target, property) {
  var pt = this._pt, next;
  while (pt) {
    next = pt._next;
    pt.p === property && pt.modifier(modifier, tween, target);
    pt = next;
  }
}, _killPropTweensOf = function _killPropTweensOf2(property) {
  var pt = this._pt, hasNonDependentRemaining, next;
  while (pt) {
    next = pt._next;
    if (pt.p === property && !pt.op || pt.op === property) {
      _removeLinkedListItem(this, pt, "_pt");
    } else if (!pt.dep) {
      hasNonDependentRemaining = 1;
    }
    pt = next;
  }
  return !hasNonDependentRemaining;
}, _setterWithModifier = function _setterWithModifier2(target, property, value, data) {
  data.mSet(target, property, data.m.call(data.tween, value, data.mt), data);
}, _sortPropTweensByPriority = function _sortPropTweensByPriority2(parent) {
  var pt = parent._pt, next, pt2, first, last;
  while (pt) {
    next = pt._next;
    pt2 = first;
    while (pt2 && pt2.pr > pt.pr) {
      pt2 = pt2._next;
    }
    if (pt._prev = pt2 ? pt2._prev : last) {
      pt._prev._next = pt;
    } else {
      first = pt;
    }
    if (pt._next = pt2) {
      pt2._prev = pt;
    } else {
      last = pt;
    }
    pt = next;
  }
  parent._pt = first;
};
var PropTween$1 = /* @__PURE__ */ function() {
  function PropTween2(next, target, prop, start, change, renderer, data, setter, priority) {
    this.t = target;
    this.s = start;
    this.c = change;
    this.p = prop;
    this.r = renderer || _renderPlain;
    this.d = data || this;
    this.set = setter || _setterPlain;
    this.pr = priority || 0;
    this._next = next;
    if (next) {
      next._prev = this;
    }
  }
  var _proto4 = PropTween2.prototype;
  _proto4.modifier = function modifier(func, tween, target) {
    this.mSet = this.mSet || this.set;
    this.set = _setterWithModifier;
    this.m = func;
    this.mt = target;
    this.tween = tween;
  };
  return PropTween2;
}();
_forEachName(_callbackNames + "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger", function(name) {
  return _reservedProps[name] = 1;
});
_globals.TweenMax = _globals.TweenLite = Tween;
_globals.TimelineLite = _globals.TimelineMax = Timeline;
_globalTimeline = new Timeline({
  sortChildren: false,
  defaults: _defaults,
  autoRemoveChildren: true,
  id: "root",
  smoothChildTiming: true
});
_config.stringFilter = _colorStringFilter;
var _media = [], _listeners = {}, _emptyArray = [], _lastMediaTime = 0, _contextID = 0, _dispatch = function _dispatch2(type) {
  return (_listeners[type] || _emptyArray).map(function(f) {
    return f();
  });
}, _onMediaChange = function _onMediaChange2() {
  var time = Date.now(), matches = [];
  if (time - _lastMediaTime > 2) {
    _dispatch("matchMediaInit");
    _media.forEach(function(c) {
      var queries = c.queries, conditions = c.conditions, match, p, anyMatch, toggled;
      for (p in queries) {
        match = _win$4.matchMedia(queries[p]).matches;
        match && (anyMatch = 1);
        if (match !== conditions[p]) {
          conditions[p] = match;
          toggled = 1;
        }
      }
      if (toggled) {
        c.revert();
        anyMatch && matches.push(c);
      }
    });
    _dispatch("matchMediaRevert");
    matches.forEach(function(c) {
      return c.onMatch(c, function(func) {
        return c.add(null, func);
      });
    });
    _lastMediaTime = time;
    _dispatch("matchMedia");
  }
};
var Context = /* @__PURE__ */ function() {
  function Context2(func, scope) {
    this.selector = scope && selector(scope);
    this.data = [];
    this._r = [];
    this.isReverted = false;
    this.id = _contextID++;
    func && this.add(func);
  }
  var _proto5 = Context2.prototype;
  _proto5.add = function add(name, func, scope) {
    if (_isFunction$1(name)) {
      scope = func;
      func = name;
      name = _isFunction$1;
    }
    var self2 = this, f = function f2() {
      var prev = _context$2, prevSelector = self2.selector, result;
      prev && prev !== self2 && prev.data.push(self2);
      scope && (self2.selector = selector(scope));
      _context$2 = self2;
      result = func.apply(self2, arguments);
      _isFunction$1(result) && self2._r.push(result);
      _context$2 = prev;
      self2.selector = prevSelector;
      self2.isReverted = false;
      return result;
    };
    self2.last = f;
    return name === _isFunction$1 ? f(self2, function(func2) {
      return self2.add(null, func2);
    }) : name ? self2[name] = f : f;
  };
  _proto5.ignore = function ignore(func) {
    var prev = _context$2;
    _context$2 = null;
    func(this);
    _context$2 = prev;
  };
  _proto5.getTweens = function getTweens() {
    var a = [];
    this.data.forEach(function(e) {
      return e instanceof Context2 ? a.push.apply(a, e.getTweens()) : e instanceof Tween && !(e.parent && e.parent.data === "nested") && a.push(e);
    });
    return a;
  };
  _proto5.clear = function clear() {
    this._r.length = this.data.length = 0;
  };
  _proto5.kill = function kill(revert, matchMedia2) {
    var _this4 = this;
    if (revert) {
      (function() {
        var tweens = _this4.getTweens(), i2 = _this4.data.length, t;
        while (i2--) {
          t = _this4.data[i2];
          if (t.data === "isFlip") {
            t.revert();
            t.getChildren(true, true, false).forEach(function(tween) {
              return tweens.splice(tweens.indexOf(tween), 1);
            });
          }
        }
        tweens.map(function(t2) {
          return {
            g: t2._dur || t2._delay || t2._sat && !t2._sat.vars.immediateRender ? t2.globalTime(0) : -Infinity,
            t: t2
          };
        }).sort(function(a, b) {
          return b.g - a.g || -Infinity;
        }).forEach(function(o) {
          return o.t.revert(revert);
        });
        i2 = _this4.data.length;
        while (i2--) {
          t = _this4.data[i2];
          if (t instanceof Timeline) {
            if (t.data !== "nested") {
              t.scrollTrigger && t.scrollTrigger.revert();
              t.kill();
            }
          } else {
            !(t instanceof Tween) && t.revert && t.revert(revert);
          }
        }
        _this4._r.forEach(function(f) {
          return f(revert, _this4);
        });
        _this4.isReverted = true;
      })();
    } else {
      this.data.forEach(function(e) {
        return e.kill && e.kill();
      });
    }
    this.clear();
    if (matchMedia2) {
      var i = _media.length;
      while (i--) {
        _media[i].id === this.id && _media.splice(i, 1);
      }
    }
  };
  _proto5.revert = function revert(config3) {
    this.kill(config3 || {});
  };
  return Context2;
}();
var MatchMedia = /* @__PURE__ */ function() {
  function MatchMedia2(scope) {
    this.contexts = [];
    this.scope = scope;
    _context$2 && _context$2.data.push(this);
  }
  var _proto6 = MatchMedia2.prototype;
  _proto6.add = function add(conditions, func, scope) {
    _isObject$1(conditions) || (conditions = {
      matches: conditions
    });
    var context3 = new Context(0, scope || this.scope), cond = context3.conditions = {}, mq, p, active;
    _context$2 && !context3.selector && (context3.selector = _context$2.selector);
    this.contexts.push(context3);
    func = context3.add("onMatch", func);
    context3.queries = conditions;
    for (p in conditions) {
      if (p === "all") {
        active = 1;
      } else {
        mq = _win$4.matchMedia(conditions[p]);
        if (mq) {
          _media.indexOf(context3) < 0 && _media.push(context3);
          (cond[p] = mq.matches) && (active = 1);
          mq.addListener ? mq.addListener(_onMediaChange) : mq.addEventListener("change", _onMediaChange);
        }
      }
    }
    active && func(context3, function(f) {
      return context3.add(null, f);
    });
    return this;
  };
  _proto6.revert = function revert(config3) {
    this.kill(config3 || {});
  };
  _proto6.kill = function kill(revert) {
    this.contexts.forEach(function(c) {
      return c.kill(revert, true);
    });
  };
  return MatchMedia2;
}();
var _gsap = {
  registerPlugin: function registerPlugin() {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    args.forEach(function(config3) {
      return _createPlugin(config3);
    });
  },
  timeline: function timeline(vars) {
    return new Timeline(vars);
  },
  getTweensOf: function getTweensOf(targets, onlyActive) {
    return _globalTimeline.getTweensOf(targets, onlyActive);
  },
  getProperty: function getProperty2(target, property, unit, uncache) {
    _isString$1(target) && (target = toArray$1(target)[0]);
    var getter = _getCache(target || {}).get, format = unit ? _passThrough : _numericIfPossible;
    unit === "native" && (unit = "");
    return !target ? target : !property ? function(property2, unit2, uncache2) {
      return format((_plugins[property2] && _plugins[property2].get || getter)(target, property2, unit2, uncache2));
    } : format((_plugins[property] && _plugins[property].get || getter)(target, property, unit, uncache));
  },
  quickSetter: function quickSetter(target, property, unit) {
    target = toArray$1(target);
    if (target.length > 1) {
      var setters = target.map(function(t) {
        return gsap$6.quickSetter(t, property, unit);
      }), l = setters.length;
      return function(value) {
        var i = l;
        while (i--) {
          setters[i](value);
        }
      };
    }
    target = target[0] || {};
    var Plugin = _plugins[property], cache = _getCache(target), p = cache.harness && (cache.harness.aliases || {})[property] || property, setter = Plugin ? function(value) {
      var p2 = new Plugin();
      _quickTween._pt = 0;
      p2.init(target, unit ? value + unit : value, _quickTween, 0, [target]);
      p2.render(1, p2);
      _quickTween._pt && _renderPropTweens(1, _quickTween);
    } : cache.set(target, p);
    return Plugin ? setter : function(value) {
      return setter(target, p, unit ? value + unit : value, cache, 1);
    };
  },
  quickTo: function quickTo(target, property, vars) {
    var _merge22;
    var tween = gsap$6.to(target, _merge((_merge22 = {}, _merge22[property] = "+=0.1", _merge22.paused = true, _merge22), vars || {})), func = function func2(value, start, startIsRelative) {
      return tween.resetTo(property, value, start, startIsRelative);
    };
    func.tween = tween;
    return func;
  },
  isTweening: function isTweening(targets) {
    return _globalTimeline.getTweensOf(targets, true).length > 0;
  },
  defaults: function defaults(value) {
    value && value.ease && (value.ease = _parseEase(value.ease, _defaults.ease));
    return _mergeDeep(_defaults, value || {});
  },
  config: function config2(value) {
    return _mergeDeep(_config, value || {});
  },
  registerEffect: function registerEffect(_ref3) {
    var name = _ref3.name, effect = _ref3.effect, plugins = _ref3.plugins, defaults2 = _ref3.defaults, extendTimeline = _ref3.extendTimeline;
    (plugins || "").split(",").forEach(function(pluginName) {
      return pluginName && !_plugins[pluginName] && !_globals[pluginName] && _warn(name + " effect requires " + pluginName + " plugin.");
    });
    _effects[name] = function(targets, vars, tl) {
      return effect(toArray$1(targets), _setDefaults$1(vars || {}, defaults2), tl);
    };
    if (extendTimeline) {
      Timeline.prototype[name] = function(targets, vars, position) {
        return this.add(_effects[name](targets, _isObject$1(vars) ? vars : (position = vars) && {}, this), position);
      };
    }
  },
  registerEase: function registerEase(name, ease) {
    _easeMap[name] = _parseEase(ease);
  },
  parseEase: function parseEase(ease, defaultEase) {
    return arguments.length ? _parseEase(ease, defaultEase) : _easeMap;
  },
  getById: function getById(id) {
    return _globalTimeline.getById(id);
  },
  exportRoot: function exportRoot(vars, includeDelayedCalls) {
    if (vars === void 0) {
      vars = {};
    }
    var tl = new Timeline(vars), child, next;
    tl.smoothChildTiming = _isNotFalse(vars.smoothChildTiming);
    _globalTimeline.remove(tl);
    tl._dp = 0;
    tl._time = tl._tTime = _globalTimeline._time;
    child = _globalTimeline._first;
    while (child) {
      next = child._next;
      if (includeDelayedCalls || !(!child._dur && child instanceof Tween && child.vars.onComplete === child._targets[0])) {
        _addToTimeline(tl, child, child._start - child._delay);
      }
      child = next;
    }
    _addToTimeline(_globalTimeline, tl, 0);
    return tl;
  },
  context: function context(func, scope) {
    return func ? new Context(func, scope) : _context$2;
  },
  matchMedia: function matchMedia(scope) {
    return new MatchMedia(scope);
  },
  matchMediaRefresh: function matchMediaRefresh() {
    return _media.forEach(function(c) {
      var cond = c.conditions, found, p;
      for (p in cond) {
        if (cond[p]) {
          cond[p] = false;
          found = 1;
        }
      }
      found && c.revert();
    }) || _onMediaChange();
  },
  addEventListener: function addEventListener(type, callback) {
    var a = _listeners[type] || (_listeners[type] = []);
    ~a.indexOf(callback) || a.push(callback);
  },
  removeEventListener: function removeEventListener(type, callback) {
    var a = _listeners[type], i = a && a.indexOf(callback);
    i >= 0 && a.splice(i, 1);
  },
  utils: {
    wrap,
    wrapYoyo,
    distribute,
    random,
    snap,
    normalize,
    getUnit,
    clamp,
    splitColor,
    toArray: toArray$1,
    selector,
    mapRange,
    pipe,
    unitize,
    interpolate,
    shuffle: shuffle$1
  },
  install: _install,
  effects: _effects,
  ticker: _ticker,
  updateRoot: Timeline.updateRoot,
  plugins: _plugins,
  globalTimeline: _globalTimeline,
  core: {
    PropTween: PropTween$1,
    globals: _addGlobal,
    Tween,
    Timeline,
    Animation,
    getCache: _getCache,
    _removeLinkedListItem,
    reverting: function reverting() {
      return _reverting$2;
    },
    context: function context2(toAdd) {
      if (toAdd && _context$2) {
        _context$2.data.push(toAdd);
        toAdd._ctx = _context$2;
      }
      return _context$2;
    },
    suppressOverwrites: function suppressOverwrites(value) {
      return _suppressOverwrites = value;
    }
  }
};
_forEachName("to,from,fromTo,delayedCall,set,killTweensOf", function(name) {
  return _gsap[name] = Tween[name];
});
_ticker.add(Timeline.updateRoot);
_quickTween = _gsap.to({}, {
  duration: 0
});
var _getPluginPropTween = function _getPluginPropTween2(plugin, prop) {
  var pt = plugin._pt;
  while (pt && pt.p !== prop && pt.op !== prop && pt.fp !== prop) {
    pt = pt._next;
  }
  return pt;
}, _addModifiers = function _addModifiers2(tween, modifiers) {
  var targets = tween._targets, p, i, pt;
  for (p in modifiers) {
    i = targets.length;
    while (i--) {
      pt = tween._ptLookup[i][p];
      if (pt && (pt = pt.d)) {
        if (pt._pt) {
          pt = _getPluginPropTween(pt, p);
        }
        pt && pt.modifier && pt.modifier(modifiers[p], tween, targets[i], p);
      }
    }
  }
}, _buildModifierPlugin = function _buildModifierPlugin2(name, modifier) {
  return {
    name,
    rawVars: 1,
    //don't pre-process function-based values or "random()" strings.
    init: function init6(target, vars, tween) {
      tween._onInit = function(tween2) {
        var temp, p;
        if (_isString$1(vars)) {
          temp = {};
          _forEachName(vars, function(name2) {
            return temp[name2] = 1;
          });
          vars = temp;
        }
        if (modifier) {
          temp = {};
          for (p in vars) {
            temp[p] = modifier(vars[p]);
          }
          vars = temp;
        }
        _addModifiers(tween2, vars);
      };
    }
  };
};
var gsap$6 = _gsap.registerPlugin({
  name: "attr",
  init: function init(target, vars, tween, index, targets) {
    var p, pt, v;
    this.tween = tween;
    for (p in vars) {
      v = target.getAttribute(p) || "";
      pt = this.add(target, "setAttribute", (v || 0) + "", vars[p], index, targets, 0, 0, p);
      pt.op = p;
      pt.b = v;
      this._props.push(p);
    }
  },
  render: function render(ratio, data) {
    var pt = data._pt;
    while (pt) {
      _reverting$2 ? pt.set(pt.t, pt.p, pt.b, pt) : pt.r(ratio, pt.d);
      pt = pt._next;
    }
  }
}, {
  name: "endArray",
  init: function init2(target, value) {
    var i = value.length;
    while (i--) {
      this.add(target, i, target[i] || 0, value[i], 0, 0, 0, 0, 0, 1);
    }
  }
}, _buildModifierPlugin("roundProps", _roundModifier), _buildModifierPlugin("modifiers"), _buildModifierPlugin("snap", snap)) || _gsap;
Tween.version = Timeline.version = gsap$6.version = "3.12.5";
_coreReady = 1;
_windowExists$2() && _wake();
_easeMap.Power0;
_easeMap.Power1;
_easeMap.Power2;
_easeMap.Power3;
_easeMap.Power4;
_easeMap.Linear;
_easeMap.Quad;
_easeMap.Cubic;
_easeMap.Quart;
_easeMap.Quint;
_easeMap.Strong;
_easeMap.Elastic;
_easeMap.Back;
_easeMap.SteppedEase;
_easeMap.Bounce;
_easeMap.Sine;
_easeMap.Expo;
_easeMap.Circ;
/*!
 * CSSPlugin 3.12.5
 * https://gsap.com
 *
 * Copyright 2008-2024, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license or for
 * Club GSAP members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/
var _win$3, _doc$3, _docElement$2, _pluginInitted, _tempDiv$2, _recentSetterPlugin, _reverting$1, _windowExists$1 = function _windowExists2() {
  return typeof window !== "undefined";
}, _transformProps = {}, _RAD2DEG$3 = 180 / Math.PI, _DEG2RAD$3 = Math.PI / 180, _atan2$1 = Math.atan2, _bigNum$2 = 1e8, _capsExp = /([A-Z])/g, _horizontalExp = /(left|right|width|margin|padding|x)/i, _complexExp = /[\s,\(]\S/, _propertyAliases = {
  autoAlpha: "opacity,visibility",
  scale: "scaleX,scaleY",
  alpha: "opacity"
}, _renderCSSProp = function _renderCSSProp2(ratio, data) {
  return data.set(data.t, data.p, Math.round((data.s + data.c * ratio) * 1e4) / 1e4 + data.u, data);
}, _renderPropWithEnd = function _renderPropWithEnd2(ratio, data) {
  return data.set(data.t, data.p, ratio === 1 ? data.e : Math.round((data.s + data.c * ratio) * 1e4) / 1e4 + data.u, data);
}, _renderCSSPropWithBeginning = function _renderCSSPropWithBeginning2(ratio, data) {
  return data.set(data.t, data.p, ratio ? Math.round((data.s + data.c * ratio) * 1e4) / 1e4 + data.u : data.b, data);
}, _renderRoundedCSSProp = function _renderRoundedCSSProp2(ratio, data) {
  var value = data.s + data.c * ratio;
  data.set(data.t, data.p, ~~(value + (value < 0 ? -0.5 : 0.5)) + data.u, data);
}, _renderNonTweeningValue = function _renderNonTweeningValue2(ratio, data) {
  return data.set(data.t, data.p, ratio ? data.e : data.b, data);
}, _renderNonTweeningValueOnlyAtEnd = function _renderNonTweeningValueOnlyAtEnd2(ratio, data) {
  return data.set(data.t, data.p, ratio !== 1 ? data.b : data.e, data);
}, _setterCSSStyle = function _setterCSSStyle2(target, property, value) {
  return target.style[property] = value;
}, _setterCSSProp = function _setterCSSProp2(target, property, value) {
  return target.style.setProperty(property, value);
}, _setterTransform = function _setterTransform2(target, property, value) {
  return target._gsap[property] = value;
}, _setterScale = function _setterScale2(target, property, value) {
  return target._gsap.scaleX = target._gsap.scaleY = value;
}, _setterScaleWithRender = function _setterScaleWithRender2(target, property, value, data, ratio) {
  var cache = target._gsap;
  cache.scaleX = cache.scaleY = value;
  cache.renderTransform(ratio, cache);
}, _setterTransformWithRender = function _setterTransformWithRender2(target, property, value, data, ratio) {
  var cache = target._gsap;
  cache[property] = value;
  cache.renderTransform(ratio, cache);
}, _transformProp$2 = "transform", _transformOriginProp$2 = _transformProp$2 + "Origin", _saveStyle = function _saveStyle2(property, isNotCSS) {
  var _this = this;
  var target = this.target, style = target.style, cache = target._gsap;
  if (property in _transformProps && style) {
    this.tfm = this.tfm || {};
    if (property !== "transform") {
      property = _propertyAliases[property] || property;
      ~property.indexOf(",") ? property.split(",").forEach(function(a) {
        return _this.tfm[a] = _get(target, a);
      }) : this.tfm[property] = cache.x ? cache[property] : _get(target, property);
      property === _transformOriginProp$2 && (this.tfm.zOrigin = cache.zOrigin);
    } else {
      return _propertyAliases.transform.split(",").forEach(function(p) {
        return _saveStyle2.call(_this, p, isNotCSS);
      });
    }
    if (this.props.indexOf(_transformProp$2) >= 0) {
      return;
    }
    if (cache.svg) {
      this.svgo = target.getAttribute("data-svg-origin");
      this.props.push(_transformOriginProp$2, isNotCSS, "");
    }
    property = _transformProp$2;
  }
  (style || isNotCSS) && this.props.push(property, isNotCSS, style[property]);
}, _removeIndependentTransforms = function _removeIndependentTransforms2(style) {
  if (style.translate) {
    style.removeProperty("translate");
    style.removeProperty("scale");
    style.removeProperty("rotate");
  }
}, _revertStyle = function _revertStyle2() {
  var props = this.props, target = this.target, style = target.style, cache = target._gsap, i, p;
  for (i = 0; i < props.length; i += 3) {
    props[i + 1] ? target[props[i]] = props[i + 2] : props[i + 2] ? style[props[i]] = props[i + 2] : style.removeProperty(props[i].substr(0, 2) === "--" ? props[i] : props[i].replace(_capsExp, "-$1").toLowerCase());
  }
  if (this.tfm) {
    for (p in this.tfm) {
      cache[p] = this.tfm[p];
    }
    if (cache.svg) {
      cache.renderTransform();
      target.setAttribute("data-svg-origin", this.svgo || "");
    }
    i = _reverting$1();
    if ((!i || !i.isStart) && !style[_transformProp$2]) {
      _removeIndependentTransforms(style);
      if (cache.zOrigin && style[_transformOriginProp$2]) {
        style[_transformOriginProp$2] += " " + cache.zOrigin + "px";
        cache.zOrigin = 0;
        cache.renderTransform();
      }
      cache.uncache = 1;
    }
  }
}, _getStyleSaver$3 = function _getStyleSaver(target, properties) {
  var saver = {
    target,
    props: [],
    revert: _revertStyle,
    save: _saveStyle
  };
  target._gsap || gsap$6.core.getCache(target);
  properties && properties.split(",").forEach(function(p) {
    return saver.save(p);
  });
  return saver;
}, _supports3D$1, _createElement$1 = function _createElement(type, ns) {
  var e = _doc$3.createElementNS ? _doc$3.createElementNS((ns || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), type) : _doc$3.createElement(type);
  return e && e.style ? e : _doc$3.createElement(type);
}, _getComputedProperty = function _getComputedProperty2(target, property, skipPrefixFallback) {
  var cs = getComputedStyle(target);
  return cs[property] || cs.getPropertyValue(property.replace(_capsExp, "-$1").toLowerCase()) || cs.getPropertyValue(property) || !skipPrefixFallback && _getComputedProperty2(target, _checkPropPrefix(property) || property, 1) || "";
}, _prefixes = "O,Moz,ms,Ms,Webkit".split(","), _checkPropPrefix = function _checkPropPrefix2(property, element, preferPrefix) {
  var e = element || _tempDiv$2, s = e.style, i = 5;
  if (property in s && !preferPrefix) {
    return property;
  }
  property = property.charAt(0).toUpperCase() + property.substr(1);
  while (i-- && !(_prefixes[i] + property in s)) {
  }
  return i < 0 ? null : (i === 3 ? "ms" : i >= 0 ? _prefixes[i] : "") + property;
}, _initCore$3 = function _initCore() {
  if (_windowExists$1() && window.document) {
    _win$3 = window;
    _doc$3 = _win$3.document;
    _docElement$2 = _doc$3.documentElement;
    _tempDiv$2 = _createElement$1("div") || {
      style: {}
    };
    _createElement$1("div");
    _transformProp$2 = _checkPropPrefix(_transformProp$2);
    _transformOriginProp$2 = _transformProp$2 + "Origin";
    _tempDiv$2.style.cssText = "border-width:0;line-height:0;position:absolute;padding:0";
    _supports3D$1 = !!_checkPropPrefix("perspective");
    _reverting$1 = gsap$6.core.reverting;
    _pluginInitted = 1;
  }
}, _getBBoxHack = function _getBBoxHack2(swapIfPossible) {
  var svg = _createElement$1("svg", this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns") || "http://www.w3.org/2000/svg"), oldParent = this.parentNode, oldSibling = this.nextSibling, oldCSS = this.style.cssText, bbox;
  _docElement$2.appendChild(svg);
  svg.appendChild(this);
  this.style.display = "block";
  if (swapIfPossible) {
    try {
      bbox = this.getBBox();
      this._gsapBBox = this.getBBox;
      this.getBBox = _getBBoxHack2;
    } catch (e) {
    }
  } else if (this._gsapBBox) {
    bbox = this._gsapBBox();
  }
  if (oldParent) {
    if (oldSibling) {
      oldParent.insertBefore(this, oldSibling);
    } else {
      oldParent.appendChild(this);
    }
  }
  _docElement$2.removeChild(svg);
  this.style.cssText = oldCSS;
  return bbox;
}, _getAttributeFallbacks = function _getAttributeFallbacks2(target, attributesArray) {
  var i = attributesArray.length;
  while (i--) {
    if (target.hasAttribute(attributesArray[i])) {
      return target.getAttribute(attributesArray[i]);
    }
  }
}, _getBBox = function _getBBox2(target) {
  var bounds;
  try {
    bounds = target.getBBox();
  } catch (error) {
    bounds = _getBBoxHack.call(target, true);
  }
  bounds && (bounds.width || bounds.height) || target.getBBox === _getBBoxHack || (bounds = _getBBoxHack.call(target, true));
  return bounds && !bounds.width && !bounds.x && !bounds.y ? {
    x: +_getAttributeFallbacks(target, ["x", "cx", "x1"]) || 0,
    y: +_getAttributeFallbacks(target, ["y", "cy", "y1"]) || 0,
    width: 0,
    height: 0
  } : bounds;
}, _isSVG = function _isSVG2(e) {
  return !!(e.getCTM && (!e.parentNode || e.ownerSVGElement) && _getBBox(e));
}, _removeProperty = function _removeProperty2(target, property) {
  if (property) {
    var style = target.style, first2Chars;
    if (property in _transformProps && property !== _transformOriginProp$2) {
      property = _transformProp$2;
    }
    if (style.removeProperty) {
      first2Chars = property.substr(0, 2);
      if (first2Chars === "ms" || property.substr(0, 6) === "webkit") {
        property = "-" + property;
      }
      style.removeProperty(first2Chars === "--" ? property : property.replace(_capsExp, "-$1").toLowerCase());
    } else {
      style.removeAttribute(property);
    }
  }
}, _addNonTweeningPT = function _addNonTweeningPT2(plugin, target, property, beginning, end, onlySetAtEnd) {
  var pt = new PropTween$1(plugin._pt, target, property, 0, 1, onlySetAtEnd ? _renderNonTweeningValueOnlyAtEnd : _renderNonTweeningValue);
  plugin._pt = pt;
  pt.b = beginning;
  pt.e = end;
  plugin._props.push(property);
  return pt;
}, _nonConvertibleUnits = {
  deg: 1,
  rad: 1,
  turn: 1
}, _nonStandardLayouts = {
  grid: 1,
  flex: 1
}, _convertToUnit = function _convertToUnit2(target, property, value, unit) {
  var curValue = parseFloat(value) || 0, curUnit = (value + "").trim().substr((curValue + "").length) || "px", style = _tempDiv$2.style, horizontal = _horizontalExp.test(property), isRootSVG = target.tagName.toLowerCase() === "svg", measureProperty = (isRootSVG ? "client" : "offset") + (horizontal ? "Width" : "Height"), amount = 100, toPixels = unit === "px", toPercent = unit === "%", px, parent, cache, isSVG;
  if (unit === curUnit || !curValue || _nonConvertibleUnits[unit] || _nonConvertibleUnits[curUnit]) {
    return curValue;
  }
  curUnit !== "px" && !toPixels && (curValue = _convertToUnit2(target, property, value, "px"));
  isSVG = target.getCTM && _isSVG(target);
  if ((toPercent || curUnit === "%") && (_transformProps[property] || ~property.indexOf("adius"))) {
    px = isSVG ? target.getBBox()[horizontal ? "width" : "height"] : target[measureProperty];
    return _round$4(toPercent ? curValue / px * amount : curValue / 100 * px);
  }
  style[horizontal ? "width" : "height"] = amount + (toPixels ? curUnit : unit);
  parent = ~property.indexOf("adius") || unit === "em" && target.appendChild && !isRootSVG ? target : target.parentNode;
  if (isSVG) {
    parent = (target.ownerSVGElement || {}).parentNode;
  }
  if (!parent || parent === _doc$3 || !parent.appendChild) {
    parent = _doc$3.body;
  }
  cache = parent._gsap;
  if (cache && toPercent && cache.width && horizontal && cache.time === _ticker.time && !cache.uncache) {
    return _round$4(curValue / cache.width * amount);
  } else {
    if (toPercent && (property === "height" || property === "width")) {
      var v = target.style[property];
      target.style[property] = amount + unit;
      px = target[measureProperty];
      v ? target.style[property] = v : _removeProperty(target, property);
    } else {
      (toPercent || curUnit === "%") && !_nonStandardLayouts[_getComputedProperty(parent, "display")] && (style.position = _getComputedProperty(target, "position"));
      parent === target && (style.position = "static");
      parent.appendChild(_tempDiv$2);
      px = _tempDiv$2[measureProperty];
      parent.removeChild(_tempDiv$2);
      style.position = "absolute";
    }
    if (horizontal && toPercent) {
      cache = _getCache(parent);
      cache.time = _ticker.time;
      cache.width = parent[measureProperty];
    }
  }
  return _round$4(toPixels ? px * curValue / amount : px && curValue ? amount / px * curValue : 0);
}, _get = function _get2(target, property, unit, uncache) {
  var value;
  _pluginInitted || _initCore$3();
  if (property in _propertyAliases && property !== "transform") {
    property = _propertyAliases[property];
    if (~property.indexOf(",")) {
      property = property.split(",")[0];
    }
  }
  if (_transformProps[property] && property !== "transform") {
    value = _parseTransform(target, uncache);
    value = property !== "transformOrigin" ? value[property] : value.svg ? value.origin : _firstTwoOnly(_getComputedProperty(target, _transformOriginProp$2)) + " " + value.zOrigin + "px";
  } else {
    value = target.style[property];
    if (!value || value === "auto" || uncache || ~(value + "").indexOf("calc(")) {
      value = _specialProps[property] && _specialProps[property](target, property, unit) || _getComputedProperty(target, property) || _getProperty(target, property) || (property === "opacity" ? 1 : 0);
    }
  }
  return unit && !~(value + "").trim().indexOf(" ") ? _convertToUnit(target, property, value, unit) + unit : value;
}, _tweenComplexCSSString = function _tweenComplexCSSString2(target, prop, start, end) {
  if (!start || start === "none") {
    var p = _checkPropPrefix(prop, target, 1), s = p && _getComputedProperty(target, p, 1);
    if (s && s !== start) {
      prop = p;
      start = s;
    } else if (prop === "borderColor") {
      start = _getComputedProperty(target, "borderTopColor");
    }
  }
  var pt = new PropTween$1(this._pt, target.style, prop, 0, 1, _renderComplexString), index = 0, matchIndex = 0, a, result, startValues, startNum, color, startValue, endValue, endNum, chunk, endUnit, startUnit, endValues;
  pt.b = start;
  pt.e = end;
  start += "";
  end += "";
  if (end === "auto") {
    startValue = target.style[prop];
    target.style[prop] = end;
    end = _getComputedProperty(target, prop) || end;
    startValue ? target.style[prop] = startValue : _removeProperty(target, prop);
  }
  a = [start, end];
  _colorStringFilter(a);
  start = a[0];
  end = a[1];
  startValues = start.match(_numWithUnitExp) || [];
  endValues = end.match(_numWithUnitExp) || [];
  if (endValues.length) {
    while (result = _numWithUnitExp.exec(end)) {
      endValue = result[0];
      chunk = end.substring(index, result.index);
      if (color) {
        color = (color + 1) % 5;
      } else if (chunk.substr(-5) === "rgba(" || chunk.substr(-5) === "hsla(") {
        color = 1;
      }
      if (endValue !== (startValue = startValues[matchIndex++] || "")) {
        startNum = parseFloat(startValue) || 0;
        startUnit = startValue.substr((startNum + "").length);
        endValue.charAt(1) === "=" && (endValue = _parseRelative(startNum, endValue) + startUnit);
        endNum = parseFloat(endValue);
        endUnit = endValue.substr((endNum + "").length);
        index = _numWithUnitExp.lastIndex - endUnit.length;
        if (!endUnit) {
          endUnit = endUnit || _config.units[prop] || startUnit;
          if (index === end.length) {
            end += endUnit;
            pt.e += endUnit;
          }
        }
        if (startUnit !== endUnit) {
          startNum = _convertToUnit(target, prop, startValue, endUnit) || 0;
        }
        pt._pt = {
          _next: pt._pt,
          p: chunk || matchIndex === 1 ? chunk : ",",
          //note: SVG spec allows omission of comma/space when a negative sign is wedged between two numbers, like 2.5-5.3 instead of 2.5,-5.3 but when tweening, the negative value may switch to positive, so we insert the comma just in case.
          s: startNum,
          c: endNum - startNum,
          m: color && color < 4 || prop === "zIndex" ? Math.round : 0
        };
      }
    }
    pt.c = index < end.length ? end.substring(index, end.length) : "";
  } else {
    pt.r = prop === "display" && end === "none" ? _renderNonTweeningValueOnlyAtEnd : _renderNonTweeningValue;
  }
  _relExp.test(end) && (pt.e = 0);
  this._pt = pt;
  return pt;
}, _keywordToPercent = {
  top: "0%",
  bottom: "100%",
  left: "0%",
  right: "100%",
  center: "50%"
}, _convertKeywordsToPercentages = function _convertKeywordsToPercentages2(value) {
  var split = value.split(" "), x = split[0], y = split[1] || "50%";
  if (x === "top" || x === "bottom" || y === "left" || y === "right") {
    value = x;
    x = y;
    y = value;
  }
  split[0] = _keywordToPercent[x] || x;
  split[1] = _keywordToPercent[y] || y;
  return split.join(" ");
}, _renderClearProps = function _renderClearProps2(ratio, data) {
  if (data.tween && data.tween._time === data.tween._dur) {
    var target = data.t, style = target.style, props = data.u, cache = target._gsap, prop, clearTransforms, i;
    if (props === "all" || props === true) {
      style.cssText = "";
      clearTransforms = 1;
    } else {
      props = props.split(",");
      i = props.length;
      while (--i > -1) {
        prop = props[i];
        if (_transformProps[prop]) {
          clearTransforms = 1;
          prop = prop === "transformOrigin" ? _transformOriginProp$2 : _transformProp$2;
        }
        _removeProperty(target, prop);
      }
    }
    if (clearTransforms) {
      _removeProperty(target, _transformProp$2);
      if (cache) {
        cache.svg && target.removeAttribute("transform");
        _parseTransform(target, 1);
        cache.uncache = 1;
        _removeIndependentTransforms(style);
      }
    }
  }
}, _specialProps = {
  clearProps: function clearProps(plugin, target, property, endValue, tween) {
    if (tween.data !== "isFromStart") {
      var pt = plugin._pt = new PropTween$1(plugin._pt, target, property, 0, 0, _renderClearProps);
      pt.u = endValue;
      pt.pr = -10;
      pt.tween = tween;
      plugin._props.push(property);
      return 1;
    }
  }
  /* className feature (about 0.4kb gzipped).
  , className(plugin, target, property, endValue, tween) {
  	let _renderClassName = (ratio, data) => {
  			data.css.render(ratio, data.css);
  			if (!ratio || ratio === 1) {
  				let inline = data.rmv,
  					target = data.t,
  					p;
  				target.setAttribute("class", ratio ? data.e : data.b);
  				for (p in inline) {
  					_removeProperty(target, p);
  				}
  			}
  		},
  		_getAllStyles = (target) => {
  			let styles = {},
  				computed = getComputedStyle(target),
  				p;
  			for (p in computed) {
  				if (isNaN(p) && p !== "cssText" && p !== "length") {
  					styles[p] = computed[p];
  				}
  			}
  			_setDefaults(styles, _parseTransform(target, 1));
  			return styles;
  		},
  		startClassList = target.getAttribute("class"),
  		style = target.style,
  		cssText = style.cssText,
  		cache = target._gsap,
  		classPT = cache.classPT,
  		inlineToRemoveAtEnd = {},
  		data = {t:target, plugin:plugin, rmv:inlineToRemoveAtEnd, b:startClassList, e:(endValue.charAt(1) !== "=") ? endValue : startClassList.replace(new RegExp("(?:\\s|^)" + endValue.substr(2) + "(?![\\w-])"), "") + ((endValue.charAt(0) === "+") ? " " + endValue.substr(2) : "")},
  		changingVars = {},
  		startVars = _getAllStyles(target),
  		transformRelated = /(transform|perspective)/i,
  		endVars, p;
  	if (classPT) {
  		classPT.r(1, classPT.d);
  		_removeLinkedListItem(classPT.d.plugin, classPT, "_pt");
  	}
  	target.setAttribute("class", data.e);
  	endVars = _getAllStyles(target, true);
  	target.setAttribute("class", startClassList);
  	for (p in endVars) {
  		if (endVars[p] !== startVars[p] && !transformRelated.test(p)) {
  			changingVars[p] = endVars[p];
  			if (!style[p] && style[p] !== "0") {
  				inlineToRemoveAtEnd[p] = 1;
  			}
  		}
  	}
  	cache.classPT = plugin._pt = new PropTween(plugin._pt, target, "className", 0, 0, _renderClassName, data, 0, -11);
  	if (style.cssText !== cssText) { //only apply if things change. Otherwise, in cases like a background-image that's pulled dynamically, it could cause a refresh. See https://gsap.com/forums/topic/20368-possible-gsap-bug-switching-classnames-in-chrome/.
  		style.cssText = cssText; //we recorded cssText before we swapped classes and ran _getAllStyles() because in cases when a className tween is overwritten, we remove all the related tweening properties from that class change (otherwise class-specific stuff can't override properties we've directly set on the target's style object due to specificity).
  	}
  	_parseTransform(target, true); //to clear the caching of transforms
  	data.css = new gsap.plugins.css();
  	data.css.init(target, changingVars, tween);
  	plugin._props.push(...data.css._props);
  	return 1;
  }
  */
}, _identity2DMatrix = [1, 0, 0, 1, 0, 0], _rotationalProperties = {}, _isNullTransform = function _isNullTransform2(value) {
  return value === "matrix(1, 0, 0, 1, 0, 0)" || value === "none" || !value;
}, _getComputedTransformMatrixAsArray = function _getComputedTransformMatrixAsArray2(target) {
  var matrixString = _getComputedProperty(target, _transformProp$2);
  return _isNullTransform(matrixString) ? _identity2DMatrix : matrixString.substr(7).match(_numExp$2).map(_round$4);
}, _getMatrix = function _getMatrix2(target, force2D) {
  var cache = target._gsap || _getCache(target), style = target.style, matrix = _getComputedTransformMatrixAsArray(target), parent, nextSibling, temp, addedToDOM;
  if (cache.svg && target.getAttribute("transform")) {
    temp = target.transform.baseVal.consolidate().matrix;
    matrix = [temp.a, temp.b, temp.c, temp.d, temp.e, temp.f];
    return matrix.join(",") === "1,0,0,1,0,0" ? _identity2DMatrix : matrix;
  } else if (matrix === _identity2DMatrix && !target.offsetParent && target !== _docElement$2 && !cache.svg) {
    temp = style.display;
    style.display = "block";
    parent = target.parentNode;
    if (!parent || !target.offsetParent) {
      addedToDOM = 1;
      nextSibling = target.nextElementSibling;
      _docElement$2.appendChild(target);
    }
    matrix = _getComputedTransformMatrixAsArray(target);
    temp ? style.display = temp : _removeProperty(target, "display");
    if (addedToDOM) {
      nextSibling ? parent.insertBefore(target, nextSibling) : parent ? parent.appendChild(target) : _docElement$2.removeChild(target);
    }
  }
  return force2D && matrix.length > 6 ? [matrix[0], matrix[1], matrix[4], matrix[5], matrix[12], matrix[13]] : matrix;
}, _applySVGOrigin = function _applySVGOrigin2(target, origin, originIsAbsolute, smooth, matrixArray, pluginToAddPropTweensTo) {
  var cache = target._gsap, matrix = matrixArray || _getMatrix(target, true), xOriginOld = cache.xOrigin || 0, yOriginOld = cache.yOrigin || 0, xOffsetOld = cache.xOffset || 0, yOffsetOld = cache.yOffset || 0, a = matrix[0], b = matrix[1], c = matrix[2], d = matrix[3], tx = matrix[4], ty = matrix[5], originSplit = origin.split(" "), xOrigin = parseFloat(originSplit[0]) || 0, yOrigin = parseFloat(originSplit[1]) || 0, bounds, determinant, x, y;
  if (!originIsAbsolute) {
    bounds = _getBBox(target);
    xOrigin = bounds.x + (~originSplit[0].indexOf("%") ? xOrigin / 100 * bounds.width : xOrigin);
    yOrigin = bounds.y + (~(originSplit[1] || originSplit[0]).indexOf("%") ? yOrigin / 100 * bounds.height : yOrigin);
  } else if (matrix !== _identity2DMatrix && (determinant = a * d - b * c)) {
    x = xOrigin * (d / determinant) + yOrigin * (-c / determinant) + (c * ty - d * tx) / determinant;
    y = xOrigin * (-b / determinant) + yOrigin * (a / determinant) - (a * ty - b * tx) / determinant;
    xOrigin = x;
    yOrigin = y;
  }
  if (smooth || smooth !== false && cache.smooth) {
    tx = xOrigin - xOriginOld;
    ty = yOrigin - yOriginOld;
    cache.xOffset = xOffsetOld + (tx * a + ty * c) - tx;
    cache.yOffset = yOffsetOld + (tx * b + ty * d) - ty;
  } else {
    cache.xOffset = cache.yOffset = 0;
  }
  cache.xOrigin = xOrigin;
  cache.yOrigin = yOrigin;
  cache.smooth = !!smooth;
  cache.origin = origin;
  cache.originIsAbsolute = !!originIsAbsolute;
  target.style[_transformOriginProp$2] = "0px 0px";
  if (pluginToAddPropTweensTo) {
    _addNonTweeningPT(pluginToAddPropTweensTo, cache, "xOrigin", xOriginOld, xOrigin);
    _addNonTweeningPT(pluginToAddPropTweensTo, cache, "yOrigin", yOriginOld, yOrigin);
    _addNonTweeningPT(pluginToAddPropTweensTo, cache, "xOffset", xOffsetOld, cache.xOffset);
    _addNonTweeningPT(pluginToAddPropTweensTo, cache, "yOffset", yOffsetOld, cache.yOffset);
  }
  target.setAttribute("data-svg-origin", xOrigin + " " + yOrigin);
}, _parseTransform = function _parseTransform2(target, uncache) {
  var cache = target._gsap || new GSCache(target);
  if ("x" in cache && !uncache && !cache.uncache) {
    return cache;
  }
  var style = target.style, invertedScaleX = cache.scaleX < 0, px = "px", deg = "deg", cs = getComputedStyle(target), origin = _getComputedProperty(target, _transformOriginProp$2) || "0", x, y, z, scaleX, scaleY, rotation, rotationX, rotationY, skewX, skewY, perspective, xOrigin, yOrigin, matrix, angle, cos, sin, a, b, c, d, a12, a22, t1, t2, t3, a13, a23, a33, a42, a43, a32;
  x = y = z = rotation = rotationX = rotationY = skewX = skewY = perspective = 0;
  scaleX = scaleY = 1;
  cache.svg = !!(target.getCTM && _isSVG(target));
  if (cs.translate) {
    if (cs.translate !== "none" || cs.scale !== "none" || cs.rotate !== "none") {
      style[_transformProp$2] = (cs.translate !== "none" ? "translate3d(" + (cs.translate + " 0 0").split(" ").slice(0, 3).join(", ") + ") " : "") + (cs.rotate !== "none" ? "rotate(" + cs.rotate + ") " : "") + (cs.scale !== "none" ? "scale(" + cs.scale.split(" ").join(",") + ") " : "") + (cs[_transformProp$2] !== "none" ? cs[_transformProp$2] : "");
    }
    style.scale = style.rotate = style.translate = "none";
  }
  matrix = _getMatrix(target, cache.svg);
  if (cache.svg) {
    if (cache.uncache) {
      t2 = target.getBBox();
      origin = cache.xOrigin - t2.x + "px " + (cache.yOrigin - t2.y) + "px";
      t1 = "";
    } else {
      t1 = !uncache && target.getAttribute("data-svg-origin");
    }
    _applySVGOrigin(target, t1 || origin, !!t1 || cache.originIsAbsolute, cache.smooth !== false, matrix);
  }
  xOrigin = cache.xOrigin || 0;
  yOrigin = cache.yOrigin || 0;
  if (matrix !== _identity2DMatrix) {
    a = matrix[0];
    b = matrix[1];
    c = matrix[2];
    d = matrix[3];
    x = a12 = matrix[4];
    y = a22 = matrix[5];
    if (matrix.length === 6) {
      scaleX = Math.sqrt(a * a + b * b);
      scaleY = Math.sqrt(d * d + c * c);
      rotation = a || b ? _atan2$1(b, a) * _RAD2DEG$3 : 0;
      skewX = c || d ? _atan2$1(c, d) * _RAD2DEG$3 + rotation : 0;
      skewX && (scaleY *= Math.abs(Math.cos(skewX * _DEG2RAD$3)));
      if (cache.svg) {
        x -= xOrigin - (xOrigin * a + yOrigin * c);
        y -= yOrigin - (xOrigin * b + yOrigin * d);
      }
    } else {
      a32 = matrix[6];
      a42 = matrix[7];
      a13 = matrix[8];
      a23 = matrix[9];
      a33 = matrix[10];
      a43 = matrix[11];
      x = matrix[12];
      y = matrix[13];
      z = matrix[14];
      angle = _atan2$1(a32, a33);
      rotationX = angle * _RAD2DEG$3;
      if (angle) {
        cos = Math.cos(-angle);
        sin = Math.sin(-angle);
        t1 = a12 * cos + a13 * sin;
        t2 = a22 * cos + a23 * sin;
        t3 = a32 * cos + a33 * sin;
        a13 = a12 * -sin + a13 * cos;
        a23 = a22 * -sin + a23 * cos;
        a33 = a32 * -sin + a33 * cos;
        a43 = a42 * -sin + a43 * cos;
        a12 = t1;
        a22 = t2;
        a32 = t3;
      }
      angle = _atan2$1(-c, a33);
      rotationY = angle * _RAD2DEG$3;
      if (angle) {
        cos = Math.cos(-angle);
        sin = Math.sin(-angle);
        t1 = a * cos - a13 * sin;
        t2 = b * cos - a23 * sin;
        t3 = c * cos - a33 * sin;
        a43 = d * sin + a43 * cos;
        a = t1;
        b = t2;
        c = t3;
      }
      angle = _atan2$1(b, a);
      rotation = angle * _RAD2DEG$3;
      if (angle) {
        cos = Math.cos(angle);
        sin = Math.sin(angle);
        t1 = a * cos + b * sin;
        t2 = a12 * cos + a22 * sin;
        b = b * cos - a * sin;
        a22 = a22 * cos - a12 * sin;
        a = t1;
        a12 = t2;
      }
      if (rotationX && Math.abs(rotationX) + Math.abs(rotation) > 359.9) {
        rotationX = rotation = 0;
        rotationY = 180 - rotationY;
      }
      scaleX = _round$4(Math.sqrt(a * a + b * b + c * c));
      scaleY = _round$4(Math.sqrt(a22 * a22 + a32 * a32));
      angle = _atan2$1(a12, a22);
      skewX = Math.abs(angle) > 2e-4 ? angle * _RAD2DEG$3 : 0;
      perspective = a43 ? 1 / (a43 < 0 ? -a43 : a43) : 0;
    }
    if (cache.svg) {
      t1 = target.getAttribute("transform");
      cache.forceCSS = target.setAttribute("transform", "") || !_isNullTransform(_getComputedProperty(target, _transformProp$2));
      t1 && target.setAttribute("transform", t1);
    }
  }
  if (Math.abs(skewX) > 90 && Math.abs(skewX) < 270) {
    if (invertedScaleX) {
      scaleX *= -1;
      skewX += rotation <= 0 ? 180 : -180;
      rotation += rotation <= 0 ? 180 : -180;
    } else {
      scaleY *= -1;
      skewX += skewX <= 0 ? 180 : -180;
    }
  }
  uncache = uncache || cache.uncache;
  cache.x = x - ((cache.xPercent = x && (!uncache && cache.xPercent || (Math.round(target.offsetWidth / 2) === Math.round(-x) ? -50 : 0))) ? target.offsetWidth * cache.xPercent / 100 : 0) + px;
  cache.y = y - ((cache.yPercent = y && (!uncache && cache.yPercent || (Math.round(target.offsetHeight / 2) === Math.round(-y) ? -50 : 0))) ? target.offsetHeight * cache.yPercent / 100 : 0) + px;
  cache.z = z + px;
  cache.scaleX = _round$4(scaleX);
  cache.scaleY = _round$4(scaleY);
  cache.rotation = _round$4(rotation) + deg;
  cache.rotationX = _round$4(rotationX) + deg;
  cache.rotationY = _round$4(rotationY) + deg;
  cache.skewX = skewX + deg;
  cache.skewY = skewY + deg;
  cache.transformPerspective = perspective + px;
  if (cache.zOrigin = parseFloat(origin.split(" ")[2]) || !uncache && cache.zOrigin || 0) {
    style[_transformOriginProp$2] = _firstTwoOnly(origin);
  }
  cache.xOffset = cache.yOffset = 0;
  cache.force3D = _config.force3D;
  cache.renderTransform = cache.svg ? _renderSVGTransforms : _supports3D$1 ? _renderCSSTransforms : _renderNon3DTransforms;
  cache.uncache = 0;
  return cache;
}, _firstTwoOnly = function _firstTwoOnly2(value) {
  return (value = value.split(" "))[0] + " " + value[1];
}, _addPxTranslate = function _addPxTranslate2(target, start, value) {
  var unit = getUnit(start);
  return _round$4(parseFloat(start) + parseFloat(_convertToUnit(target, "x", value + "px", unit))) + unit;
}, _renderNon3DTransforms = function _renderNon3DTransforms2(ratio, cache) {
  cache.z = "0px";
  cache.rotationY = cache.rotationX = "0deg";
  cache.force3D = 0;
  _renderCSSTransforms(ratio, cache);
}, _zeroDeg = "0deg", _zeroPx = "0px", _endParenthesis = ") ", _renderCSSTransforms = function _renderCSSTransforms2(ratio, cache) {
  var _ref = cache || this, xPercent = _ref.xPercent, yPercent = _ref.yPercent, x = _ref.x, y = _ref.y, z = _ref.z, rotation = _ref.rotation, rotationY = _ref.rotationY, rotationX = _ref.rotationX, skewX = _ref.skewX, skewY = _ref.skewY, scaleX = _ref.scaleX, scaleY = _ref.scaleY, transformPerspective = _ref.transformPerspective, force3D = _ref.force3D, target = _ref.target, zOrigin = _ref.zOrigin, transforms = "", use3D = force3D === "auto" && ratio && ratio !== 1 || force3D === true;
  if (zOrigin && (rotationX !== _zeroDeg || rotationY !== _zeroDeg)) {
    var angle = parseFloat(rotationY) * _DEG2RAD$3, a13 = Math.sin(angle), a33 = Math.cos(angle), cos;
    angle = parseFloat(rotationX) * _DEG2RAD$3;
    cos = Math.cos(angle);
    x = _addPxTranslate(target, x, a13 * cos * -zOrigin);
    y = _addPxTranslate(target, y, -Math.sin(angle) * -zOrigin);
    z = _addPxTranslate(target, z, a33 * cos * -zOrigin + zOrigin);
  }
  if (transformPerspective !== _zeroPx) {
    transforms += "perspective(" + transformPerspective + _endParenthesis;
  }
  if (xPercent || yPercent) {
    transforms += "translate(" + xPercent + "%, " + yPercent + "%) ";
  }
  if (use3D || x !== _zeroPx || y !== _zeroPx || z !== _zeroPx) {
    transforms += z !== _zeroPx || use3D ? "translate3d(" + x + ", " + y + ", " + z + ") " : "translate(" + x + ", " + y + _endParenthesis;
  }
  if (rotation !== _zeroDeg) {
    transforms += "rotate(" + rotation + _endParenthesis;
  }
  if (rotationY !== _zeroDeg) {
    transforms += "rotateY(" + rotationY + _endParenthesis;
  }
  if (rotationX !== _zeroDeg) {
    transforms += "rotateX(" + rotationX + _endParenthesis;
  }
  if (skewX !== _zeroDeg || skewY !== _zeroDeg) {
    transforms += "skew(" + skewX + ", " + skewY + _endParenthesis;
  }
  if (scaleX !== 1 || scaleY !== 1) {
    transforms += "scale(" + scaleX + ", " + scaleY + _endParenthesis;
  }
  target.style[_transformProp$2] = transforms || "translate(0, 0)";
}, _renderSVGTransforms = function _renderSVGTransforms2(ratio, cache) {
  var _ref2 = cache || this, xPercent = _ref2.xPercent, yPercent = _ref2.yPercent, x = _ref2.x, y = _ref2.y, rotation = _ref2.rotation, skewX = _ref2.skewX, skewY = _ref2.skewY, scaleX = _ref2.scaleX, scaleY = _ref2.scaleY, target = _ref2.target, xOrigin = _ref2.xOrigin, yOrigin = _ref2.yOrigin, xOffset = _ref2.xOffset, yOffset = _ref2.yOffset, forceCSS = _ref2.forceCSS, tx = parseFloat(x), ty = parseFloat(y), a11, a21, a12, a22, temp;
  rotation = parseFloat(rotation);
  skewX = parseFloat(skewX);
  skewY = parseFloat(skewY);
  if (skewY) {
    skewY = parseFloat(skewY);
    skewX += skewY;
    rotation += skewY;
  }
  if (rotation || skewX) {
    rotation *= _DEG2RAD$3;
    skewX *= _DEG2RAD$3;
    a11 = Math.cos(rotation) * scaleX;
    a21 = Math.sin(rotation) * scaleX;
    a12 = Math.sin(rotation - skewX) * -scaleY;
    a22 = Math.cos(rotation - skewX) * scaleY;
    if (skewX) {
      skewY *= _DEG2RAD$3;
      temp = Math.tan(skewX - skewY);
      temp = Math.sqrt(1 + temp * temp);
      a12 *= temp;
      a22 *= temp;
      if (skewY) {
        temp = Math.tan(skewY);
        temp = Math.sqrt(1 + temp * temp);
        a11 *= temp;
        a21 *= temp;
      }
    }
    a11 = _round$4(a11);
    a21 = _round$4(a21);
    a12 = _round$4(a12);
    a22 = _round$4(a22);
  } else {
    a11 = scaleX;
    a22 = scaleY;
    a21 = a12 = 0;
  }
  if (tx && !~(x + "").indexOf("px") || ty && !~(y + "").indexOf("px")) {
    tx = _convertToUnit(target, "x", x, "px");
    ty = _convertToUnit(target, "y", y, "px");
  }
  if (xOrigin || yOrigin || xOffset || yOffset) {
    tx = _round$4(tx + xOrigin - (xOrigin * a11 + yOrigin * a12) + xOffset);
    ty = _round$4(ty + yOrigin - (xOrigin * a21 + yOrigin * a22) + yOffset);
  }
  if (xPercent || yPercent) {
    temp = target.getBBox();
    tx = _round$4(tx + xPercent / 100 * temp.width);
    ty = _round$4(ty + yPercent / 100 * temp.height);
  }
  temp = "matrix(" + a11 + "," + a21 + "," + a12 + "," + a22 + "," + tx + "," + ty + ")";
  target.setAttribute("transform", temp);
  forceCSS && (target.style[_transformProp$2] = temp);
}, _addRotationalPropTween = function _addRotationalPropTween2(plugin, target, property, startNum, endValue) {
  var cap = 360, isString = _isString$1(endValue), endNum = parseFloat(endValue) * (isString && ~endValue.indexOf("rad") ? _RAD2DEG$3 : 1), change = endNum - startNum, finalValue = startNum + change + "deg", direction, pt;
  if (isString) {
    direction = endValue.split("_")[1];
    if (direction === "short") {
      change %= cap;
      if (change !== change % (cap / 2)) {
        change += change < 0 ? cap : -cap;
      }
    }
    if (direction === "cw" && change < 0) {
      change = (change + cap * _bigNum$2) % cap - ~~(change / cap) * cap;
    } else if (direction === "ccw" && change > 0) {
      change = (change - cap * _bigNum$2) % cap - ~~(change / cap) * cap;
    }
  }
  plugin._pt = pt = new PropTween$1(plugin._pt, target, property, startNum, change, _renderPropWithEnd);
  pt.e = finalValue;
  pt.u = "deg";
  plugin._props.push(property);
  return pt;
}, _assign = function _assign2(target, source) {
  for (var p in source) {
    target[p] = source[p];
  }
  return target;
}, _addRawTransformPTs = function _addRawTransformPTs2(plugin, transforms, target) {
  var startCache = _assign({}, target._gsap), exclude = "perspective,force3D,transformOrigin,svgOrigin", style = target.style, endCache, p, startValue, endValue, startNum, endNum, startUnit, endUnit;
  if (startCache.svg) {
    startValue = target.getAttribute("transform");
    target.setAttribute("transform", "");
    style[_transformProp$2] = transforms;
    endCache = _parseTransform(target, 1);
    _removeProperty(target, _transformProp$2);
    target.setAttribute("transform", startValue);
  } else {
    startValue = getComputedStyle(target)[_transformProp$2];
    style[_transformProp$2] = transforms;
    endCache = _parseTransform(target, 1);
    style[_transformProp$2] = startValue;
  }
  for (p in _transformProps) {
    startValue = startCache[p];
    endValue = endCache[p];
    if (startValue !== endValue && exclude.indexOf(p) < 0) {
      startUnit = getUnit(startValue);
      endUnit = getUnit(endValue);
      startNum = startUnit !== endUnit ? _convertToUnit(target, p, startValue, endUnit) : parseFloat(startValue);
      endNum = parseFloat(endValue);
      plugin._pt = new PropTween$1(plugin._pt, endCache, p, startNum, endNum - startNum, _renderCSSProp);
      plugin._pt.u = endUnit || 0;
      plugin._props.push(p);
    }
  }
  _assign(endCache, startCache);
};
_forEachName("padding,margin,Width,Radius", function(name, index) {
  var t = "Top", r = "Right", b = "Bottom", l = "Left", props = (index < 3 ? [t, r, b, l] : [t + l, t + r, b + r, b + l]).map(function(side) {
    return index < 2 ? name + side : "border" + side + name;
  });
  _specialProps[index > 1 ? "border" + name : name] = function(plugin, target, property, endValue, tween) {
    var a, vars;
    if (arguments.length < 4) {
      a = props.map(function(prop) {
        return _get(plugin, prop, property);
      });
      vars = a.join(" ");
      return vars.split(a[0]).length === 5 ? a[0] : vars;
    }
    a = (endValue + "").split(" ");
    vars = {};
    props.forEach(function(prop, i) {
      return vars[prop] = a[i] = a[i] || a[(i - 1) / 2 | 0];
    });
    plugin.init(target, vars, tween);
  };
});
var CSSPlugin = {
  name: "css",
  register: _initCore$3,
  targetTest: function targetTest(target) {
    return target.style && target.nodeType;
  },
  init: function init3(target, vars, tween, index, targets) {
    var props = this._props, style = target.style, startAt = tween.vars.startAt, startValue, endValue, endNum, startNum, type, specialProp, p, startUnit, endUnit, relative, isTransformRelated, transformPropTween, cache, smooth, hasPriority, inlineProps;
    _pluginInitted || _initCore$3();
    this.styles = this.styles || _getStyleSaver$3(target);
    inlineProps = this.styles.props;
    this.tween = tween;
    for (p in vars) {
      if (p === "autoRound") {
        continue;
      }
      endValue = vars[p];
      if (_plugins[p] && _checkPlugin(p, vars, tween, index, target, targets)) {
        continue;
      }
      type = typeof endValue;
      specialProp = _specialProps[p];
      if (type === "function") {
        endValue = endValue.call(tween, index, target, targets);
        type = typeof endValue;
      }
      if (type === "string" && ~endValue.indexOf("random(")) {
        endValue = _replaceRandom(endValue);
      }
      if (specialProp) {
        specialProp(this, target, p, endValue, tween) && (hasPriority = 1);
      } else if (p.substr(0, 2) === "--") {
        startValue = (getComputedStyle(target).getPropertyValue(p) + "").trim();
        endValue += "";
        _colorExp.lastIndex = 0;
        if (!_colorExp.test(startValue)) {
          startUnit = getUnit(startValue);
          endUnit = getUnit(endValue);
        }
        endUnit ? startUnit !== endUnit && (startValue = _convertToUnit(target, p, startValue, endUnit) + endUnit) : startUnit && (endValue += startUnit);
        this.add(style, "setProperty", startValue, endValue, index, targets, 0, 0, p);
        props.push(p);
        inlineProps.push(p, 0, style[p]);
      } else if (type !== "undefined") {
        if (startAt && p in startAt) {
          startValue = typeof startAt[p] === "function" ? startAt[p].call(tween, index, target, targets) : startAt[p];
          _isString$1(startValue) && ~startValue.indexOf("random(") && (startValue = _replaceRandom(startValue));
          getUnit(startValue + "") || startValue === "auto" || (startValue += _config.units[p] || getUnit(_get(target, p)) || "");
          (startValue + "").charAt(1) === "=" && (startValue = _get(target, p));
        } else {
          startValue = _get(target, p);
        }
        startNum = parseFloat(startValue);
        relative = type === "string" && endValue.charAt(1) === "=" && endValue.substr(0, 2);
        relative && (endValue = endValue.substr(2));
        endNum = parseFloat(endValue);
        if (p in _propertyAliases) {
          if (p === "autoAlpha") {
            if (startNum === 1 && _get(target, "visibility") === "hidden" && endNum) {
              startNum = 0;
            }
            inlineProps.push("visibility", 0, style.visibility);
            _addNonTweeningPT(this, style, "visibility", startNum ? "inherit" : "hidden", endNum ? "inherit" : "hidden", !endNum);
          }
          if (p !== "scale" && p !== "transform") {
            p = _propertyAliases[p];
            ~p.indexOf(",") && (p = p.split(",")[0]);
          }
        }
        isTransformRelated = p in _transformProps;
        if (isTransformRelated) {
          this.styles.save(p);
          if (!transformPropTween) {
            cache = target._gsap;
            cache.renderTransform && !vars.parseTransform || _parseTransform(target, vars.parseTransform);
            smooth = vars.smoothOrigin !== false && cache.smooth;
            transformPropTween = this._pt = new PropTween$1(this._pt, style, _transformProp$2, 0, 1, cache.renderTransform, cache, 0, -1);
            transformPropTween.dep = 1;
          }
          if (p === "scale") {
            this._pt = new PropTween$1(this._pt, cache, "scaleY", cache.scaleY, (relative ? _parseRelative(cache.scaleY, relative + endNum) : endNum) - cache.scaleY || 0, _renderCSSProp);
            this._pt.u = 0;
            props.push("scaleY", p);
            p += "X";
          } else if (p === "transformOrigin") {
            inlineProps.push(_transformOriginProp$2, 0, style[_transformOriginProp$2]);
            endValue = _convertKeywordsToPercentages(endValue);
            if (cache.svg) {
              _applySVGOrigin(target, endValue, 0, smooth, 0, this);
            } else {
              endUnit = parseFloat(endValue.split(" ")[2]) || 0;
              endUnit !== cache.zOrigin && _addNonTweeningPT(this, cache, "zOrigin", cache.zOrigin, endUnit);
              _addNonTweeningPT(this, style, p, _firstTwoOnly(startValue), _firstTwoOnly(endValue));
            }
            continue;
          } else if (p === "svgOrigin") {
            _applySVGOrigin(target, endValue, 1, smooth, 0, this);
            continue;
          } else if (p in _rotationalProperties) {
            _addRotationalPropTween(this, cache, p, startNum, relative ? _parseRelative(startNum, relative + endValue) : endValue);
            continue;
          } else if (p === "smoothOrigin") {
            _addNonTweeningPT(this, cache, "smooth", cache.smooth, endValue);
            continue;
          } else if (p === "force3D") {
            cache[p] = endValue;
            continue;
          } else if (p === "transform") {
            _addRawTransformPTs(this, endValue, target);
            continue;
          }
        } else if (!(p in style)) {
          p = _checkPropPrefix(p) || p;
        }
        if (isTransformRelated || (endNum || endNum === 0) && (startNum || startNum === 0) && !_complexExp.test(endValue) && p in style) {
          startUnit = (startValue + "").substr((startNum + "").length);
          endNum || (endNum = 0);
          endUnit = getUnit(endValue) || (p in _config.units ? _config.units[p] : startUnit);
          startUnit !== endUnit && (startNum = _convertToUnit(target, p, startValue, endUnit));
          this._pt = new PropTween$1(this._pt, isTransformRelated ? cache : style, p, startNum, (relative ? _parseRelative(startNum, relative + endNum) : endNum) - startNum, !isTransformRelated && (endUnit === "px" || p === "zIndex") && vars.autoRound !== false ? _renderRoundedCSSProp : _renderCSSProp);
          this._pt.u = endUnit || 0;
          if (startUnit !== endUnit && endUnit !== "%") {
            this._pt.b = startValue;
            this._pt.r = _renderCSSPropWithBeginning;
          }
        } else if (!(p in style)) {
          if (p in target) {
            this.add(target, p, startValue || target[p], relative ? relative + endValue : endValue, index, targets);
          } else if (p !== "parseTransform") {
            _missingPlugin(p, endValue);
            continue;
          }
        } else {
          _tweenComplexCSSString.call(this, target, p, startValue, relative ? relative + endValue : endValue);
        }
        isTransformRelated || (p in style ? inlineProps.push(p, 0, style[p]) : inlineProps.push(p, 1, startValue || target[p]));
        props.push(p);
      }
    }
    hasPriority && _sortPropTweensByPriority(this);
  },
  render: function render2(ratio, data) {
    if (data.tween._time || !_reverting$1()) {
      var pt = data._pt;
      while (pt) {
        pt.r(ratio, pt.d);
        pt = pt._next;
      }
    } else {
      data.styles.revert();
    }
  },
  get: _get,
  aliases: _propertyAliases,
  getSetter: function getSetter(target, property, plugin) {
    var p = _propertyAliases[property];
    p && p.indexOf(",") < 0 && (property = p);
    return property in _transformProps && property !== _transformOriginProp$2 && (target._gsap.x || _get(target, "x")) ? plugin && _recentSetterPlugin === plugin ? property === "scale" ? _setterScale : _setterTransform : (_recentSetterPlugin = plugin || {}) && (property === "scale" ? _setterScaleWithRender : _setterTransformWithRender) : target.style && !_isUndefined$2(target.style[property]) ? _setterCSSStyle : ~property.indexOf("-") ? _setterCSSProp : _getSetter(target, property);
  },
  core: {
    _removeProperty,
    _getMatrix
  }
};
gsap$6.utils.checkPrefix = _checkPropPrefix;
gsap$6.core.getStyleSaver = _getStyleSaver$3;
(function(positionAndScale, rotation, others, aliases) {
  var all = _forEachName(positionAndScale + "," + rotation + "," + others, function(name) {
    _transformProps[name] = 1;
  });
  _forEachName(rotation, function(name) {
    _config.units[name] = "deg";
    _rotationalProperties[name] = 1;
  });
  _propertyAliases[all[13]] = positionAndScale + "," + rotation;
  _forEachName(aliases, function(name) {
    var split = name.split(":");
    _propertyAliases[split[1]] = all[split[0]];
  });
})("x,y,z,scale,scaleX,scaleY,xPercent,yPercent", "rotation,rotationX,rotationY,skewX,skewY", "transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective", "0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY");
_forEachName("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective", function(name) {
  _config.units[name] = "px";
});
gsap$6.registerPlugin(CSSPlugin);
var gsapWithCSS = gsap$6.registerPlugin(CSSPlugin) || gsap$6;
gsapWithCSS.core.Tween;
/*!
 * paths 3.12.5
 * https://gsap.com
 *
 * Copyright 2008-2024, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license or for
 * Club GSAP members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/
var _svgPathExp = /[achlmqstvz]|(-?\d*\.?\d*(?:e[\-+]?\d+)?)[0-9]/ig, _numbersExp = /(?:(-)?\d*\.?\d*(?:e[\-+]?\d+)?)[0-9]/ig, _scientific = /[\+\-]?\d*\.?\d+e[\+\-]?\d+/ig, _selectorExp = /(^[#\.][a-z]|[a-y][a-z])/i, _DEG2RAD$2 = Math.PI / 180, _RAD2DEG$2 = 180 / Math.PI, _sin = Math.sin, _cos = Math.cos, _abs = Math.abs, _sqrt = Math.sqrt, _atan2 = Math.atan2, _largeNum = 1e8, _isString2 = function _isString3(value) {
  return typeof value === "string";
}, _isNumber2 = function _isNumber3(value) {
  return typeof value === "number";
}, _isUndefined$1 = function _isUndefined2(value) {
  return typeof value === "undefined";
}, _temp = {}, _temp2 = {}, _roundingNum = 1e5, _wrapProgress = function _wrapProgress2(progress) {
  return Math.round((progress + _largeNum) % 1 * _roundingNum) / _roundingNum || (progress < 0 ? 0 : 1);
}, _round$3 = function _round2(value) {
  return Math.round(value * _roundingNum) / _roundingNum || 0;
}, _roundPrecise2 = function _roundPrecise3(value) {
  return Math.round(value * 1e10) / 1e10 || 0;
}, _splitSegment = function _splitSegment2(rawPath, segIndex, i, t) {
  var segment = rawPath[segIndex], shift = t === 1 ? 6 : subdivideSegment(segment, i, t);
  if ((shift || !t) && shift + i + 2 < segment.length) {
    rawPath.splice(segIndex, 0, segment.slice(0, i + shift + 2));
    segment.splice(0, i + shift);
    return 1;
  }
}, _getSampleIndex = function _getSampleIndex2(samples, length, progress) {
  var l = samples.length, i = ~~(progress * l);
  if (samples[i] > length) {
    while (--i && samples[i] > length) {
    }
    i < 0 && (i = 0);
  } else {
    while (samples[++i] < length && i < l) {
    }
  }
  return i < l ? i : l - 1;
}, _reverseRawPath = function _reverseRawPath2(rawPath, skipOuter) {
  var i = rawPath.length;
  skipOuter || rawPath.reverse();
  while (i--) {
    rawPath[i].reversed || reverseSegment(rawPath[i]);
  }
}, _copyMetaData = function _copyMetaData2(source, copy) {
  copy.totalLength = source.totalLength;
  if (source.samples) {
    copy.samples = source.samples.slice(0);
    copy.lookup = source.lookup.slice(0);
    copy.minLength = source.minLength;
    copy.resolution = source.resolution;
  } else if (source.totalPoints) {
    copy.totalPoints = source.totalPoints;
  }
  return copy;
}, _appendOrMerge = function _appendOrMerge2(rawPath, segment) {
  var index = rawPath.length, prevSeg = rawPath[index - 1] || [], l = prevSeg.length;
  if (index && segment[0] === prevSeg[l - 2] && segment[1] === prevSeg[l - 1]) {
    segment = prevSeg.concat(segment.slice(2));
    index--;
  }
  rawPath[index] = segment;
};
function getRawPath(value) {
  value = _isString2(value) && _selectorExp.test(value) ? document.querySelector(value) || value : value;
  var e = value.getAttribute ? value : 0, rawPath;
  if (e && (value = value.getAttribute("d"))) {
    if (!e._gsPath) {
      e._gsPath = {};
    }
    rawPath = e._gsPath[value];
    return rawPath && !rawPath._dirty ? rawPath : e._gsPath[value] = stringToRawPath(value);
  }
  return !value ? console.warn("Expecting a <path> element or an SVG path data string") : _isString2(value) ? stringToRawPath(value) : _isNumber2(value[0]) ? [value] : value;
}
function copyRawPath(rawPath) {
  var a = [], i = 0;
  for (; i < rawPath.length; i++) {
    a[i] = _copyMetaData(rawPath[i], rawPath[i].slice(0));
  }
  return _copyMetaData(rawPath, a);
}
function reverseSegment(segment) {
  var i = 0, y;
  segment.reverse();
  for (; i < segment.length; i += 2) {
    y = segment[i];
    segment[i] = segment[i + 1];
    segment[i + 1] = y;
  }
  segment.reversed = !segment.reversed;
}
var _createPath = function _createPath2(e, ignore) {
  var path = document.createElementNS("http://www.w3.org/2000/svg", "path"), attr = [].slice.call(e.attributes), i = attr.length, name;
  ignore = "," + ignore + ",";
  while (--i > -1) {
    name = attr[i].nodeName.toLowerCase();
    if (ignore.indexOf("," + name + ",") < 0) {
      path.setAttributeNS(null, name, attr[i].nodeValue);
    }
  }
  return path;
}, _typeAttrs = {
  rect: "rx,ry,x,y,width,height",
  circle: "r,cx,cy",
  ellipse: "rx,ry,cx,cy",
  line: "x1,x2,y1,y2"
}, _attrToObj = function _attrToObj2(e, attrs) {
  var props = attrs ? attrs.split(",") : [], obj = {}, i = props.length;
  while (--i > -1) {
    obj[props[i]] = +e.getAttribute(props[i]) || 0;
  }
  return obj;
};
function convertToPath(element, swap) {
  var type = element.tagName.toLowerCase(), circ = 0.552284749831, data, x, y, r, ry, path, rcirc, rycirc, points, w, h, x2, x3, x4, x5, x6, y2, y3, y4, y5, y6, attr;
  if (type === "path" || !element.getBBox) {
    return element;
  }
  path = _createPath(element, "x,y,width,height,cx,cy,rx,ry,r,x1,x2,y1,y2,points");
  attr = _attrToObj(element, _typeAttrs[type]);
  if (type === "rect") {
    r = attr.rx;
    ry = attr.ry || r;
    x = attr.x;
    y = attr.y;
    w = attr.width - r * 2;
    h = attr.height - ry * 2;
    if (r || ry) {
      x2 = x + r * (1 - circ);
      x3 = x + r;
      x4 = x3 + w;
      x5 = x4 + r * circ;
      x6 = x4 + r;
      y2 = y + ry * (1 - circ);
      y3 = y + ry;
      y4 = y3 + h;
      y5 = y4 + ry * circ;
      y6 = y4 + ry;
      data = "M" + x6 + "," + y3 + " V" + y4 + " C" + [x6, y5, x5, y6, x4, y6, x4 - (x4 - x3) / 3, y6, x3 + (x4 - x3) / 3, y6, x3, y6, x2, y6, x, y5, x, y4, x, y4 - (y4 - y3) / 3, x, y3 + (y4 - y3) / 3, x, y3, x, y2, x2, y, x3, y, x3 + (x4 - x3) / 3, y, x4 - (x4 - x3) / 3, y, x4, y, x5, y, x6, y2, x6, y3].join(",") + "z";
    } else {
      data = "M" + (x + w) + "," + y + " v" + h + " h" + -w + " v" + -h + " h" + w + "z";
    }
  } else if (type === "circle" || type === "ellipse") {
    if (type === "circle") {
      r = ry = attr.r;
      rycirc = r * circ;
    } else {
      r = attr.rx;
      ry = attr.ry;
      rycirc = ry * circ;
    }
    x = attr.cx;
    y = attr.cy;
    rcirc = r * circ;
    data = "M" + (x + r) + "," + y + " C" + [x + r, y + rycirc, x + rcirc, y + ry, x, y + ry, x - rcirc, y + ry, x - r, y + rycirc, x - r, y, x - r, y - rycirc, x - rcirc, y - ry, x, y - ry, x + rcirc, y - ry, x + r, y - rycirc, x + r, y].join(",") + "z";
  } else if (type === "line") {
    data = "M" + attr.x1 + "," + attr.y1 + " L" + attr.x2 + "," + attr.y2;
  } else if (type === "polyline" || type === "polygon") {
    points = (element.getAttribute("points") + "").match(_numbersExp) || [];
    x = points.shift();
    y = points.shift();
    data = "M" + x + "," + y + " L" + points.join(",");
    if (type === "polygon") {
      data += "," + x + "," + y + "z";
    }
  }
  path.setAttribute("d", rawPathToString(path._gsRawPath = stringToRawPath(data)));
  if (swap && element.parentNode) {
    element.parentNode.insertBefore(path, element);
    element.parentNode.removeChild(element);
  }
  return path;
}
function getRotationAtBezierT(segment, i, t) {
  var a = segment[i], b = segment[i + 2], c = segment[i + 4], x;
  a += (b - a) * t;
  b += (c - b) * t;
  a += (b - a) * t;
  x = b + (c + (segment[i + 6] - c) * t - b) * t - a;
  a = segment[i + 1];
  b = segment[i + 3];
  c = segment[i + 5];
  a += (b - a) * t;
  b += (c - b) * t;
  a += (b - a) * t;
  return _round$3(_atan2(b + (c + (segment[i + 7] - c) * t - b) * t - a, x) * _RAD2DEG$2);
}
function sliceRawPath(rawPath, start, end) {
  end = _isUndefined$1(end) ? 1 : _roundPrecise2(end) || 0;
  start = _roundPrecise2(start) || 0;
  var loops = Math.max(0, ~~(_abs(end - start) - 1e-8)), path = copyRawPath(rawPath);
  if (start > end) {
    start = 1 - start;
    end = 1 - end;
    _reverseRawPath(path);
    path.totalLength = 0;
  }
  if (start < 0 || end < 0) {
    var offset = Math.abs(~~Math.min(start, end)) + 1;
    start += offset;
    end += offset;
  }
  path.totalLength || cacheRawPathMeasurements(path);
  var wrap3 = end > 1, s = getProgressData(path, start, _temp, true), e = getProgressData(path, end, _temp2), eSeg = e.segment, sSeg = s.segment, eSegIndex = e.segIndex, sSegIndex = s.segIndex, ei = e.i, si = s.i, sameSegment = sSegIndex === eSegIndex, sameBezier = ei === si && sameSegment, wrapsBehind, sShift, eShift, i, copy, totalSegments, l, j;
  if (wrap3 || loops) {
    wrapsBehind = eSegIndex < sSegIndex || sameSegment && ei < si || sameBezier && e.t < s.t;
    if (_splitSegment(path, sSegIndex, si, s.t)) {
      sSegIndex++;
      if (!wrapsBehind) {
        eSegIndex++;
        if (sameBezier) {
          e.t = (e.t - s.t) / (1 - s.t);
          ei = 0;
        } else if (sameSegment) {
          ei -= si;
        }
      }
    }
    if (Math.abs(1 - (end - start)) < 1e-5) {
      eSegIndex = sSegIndex - 1;
    } else if (!e.t && eSegIndex) {
      eSegIndex--;
    } else if (_splitSegment(path, eSegIndex, ei, e.t) && wrapsBehind) {
      sSegIndex++;
    }
    if (s.t === 1) {
      sSegIndex = (sSegIndex + 1) % path.length;
    }
    copy = [];
    totalSegments = path.length;
    l = 1 + totalSegments * loops;
    j = sSegIndex;
    l += (totalSegments - sSegIndex + eSegIndex) % totalSegments;
    for (i = 0; i < l; i++) {
      _appendOrMerge(copy, path[j++ % totalSegments]);
    }
    path = copy;
  } else {
    eShift = e.t === 1 ? 6 : subdivideSegment(eSeg, ei, e.t);
    if (start !== end) {
      sShift = subdivideSegment(sSeg, si, sameBezier ? s.t / e.t : s.t);
      sameSegment && (eShift += sShift);
      eSeg.splice(ei + eShift + 2);
      (sShift || si) && sSeg.splice(0, si + sShift);
      i = path.length;
      while (i--) {
        (i < sSegIndex || i > eSegIndex) && path.splice(i, 1);
      }
    } else {
      eSeg.angle = getRotationAtBezierT(eSeg, ei + eShift, 0);
      ei += eShift;
      s = eSeg[ei];
      e = eSeg[ei + 1];
      eSeg.length = eSeg.totalLength = 0;
      eSeg.totalPoints = path.totalPoints = 8;
      eSeg.push(s, e, s, e, s, e, s, e);
    }
  }
  path.totalLength = 0;
  return path;
}
function measureSegment(segment, startIndex, bezierQty) {
  startIndex = startIndex || 0;
  if (!segment.samples) {
    segment.samples = [];
    segment.lookup = [];
  }
  var resolution = ~~segment.resolution || 12, inc = 1 / resolution, endIndex = bezierQty ? startIndex + bezierQty * 6 + 1 : segment.length, x1 = segment[startIndex], y1 = segment[startIndex + 1], samplesIndex = startIndex ? startIndex / 6 * resolution : 0, samples = segment.samples, lookup = segment.lookup, min = (startIndex ? segment.minLength : _largeNum) || _largeNum, prevLength = samples[samplesIndex + bezierQty * resolution - 1], length = startIndex ? samples[samplesIndex - 1] : 0, i, j, x4, x3, x2, xd, xd1, y4, y3, y2, yd, yd1, inv, t, lengthIndex, l, segLength;
  samples.length = lookup.length = 0;
  for (j = startIndex + 2; j < endIndex; j += 6) {
    x4 = segment[j + 4] - x1;
    x3 = segment[j + 2] - x1;
    x2 = segment[j] - x1;
    y4 = segment[j + 5] - y1;
    y3 = segment[j + 3] - y1;
    y2 = segment[j + 1] - y1;
    xd = xd1 = yd = yd1 = 0;
    if (_abs(x4) < 0.01 && _abs(y4) < 0.01 && _abs(x2) + _abs(y2) < 0.01) {
      if (segment.length > 8) {
        segment.splice(j, 6);
        j -= 6;
        endIndex -= 6;
      }
    } else {
      for (i = 1; i <= resolution; i++) {
        t = inc * i;
        inv = 1 - t;
        xd = xd1 - (xd1 = (t * t * x4 + 3 * inv * (t * x3 + inv * x2)) * t);
        yd = yd1 - (yd1 = (t * t * y4 + 3 * inv * (t * y3 + inv * y2)) * t);
        l = _sqrt(yd * yd + xd * xd);
        if (l < min) {
          min = l;
        }
        length += l;
        samples[samplesIndex++] = length;
      }
    }
    x1 += x4;
    y1 += y4;
  }
  if (prevLength) {
    prevLength -= length;
    for (; samplesIndex < samples.length; samplesIndex++) {
      samples[samplesIndex] += prevLength;
    }
  }
  if (samples.length && min) {
    segment.totalLength = segLength = samples[samples.length - 1] || 0;
    segment.minLength = min;
    if (segLength / min < 9999) {
      l = lengthIndex = 0;
      for (i = 0; i < segLength; i += min) {
        lookup[l++] = samples[lengthIndex] < i ? ++lengthIndex : lengthIndex;
      }
    }
  } else {
    segment.totalLength = samples[0] = 0;
  }
  return startIndex ? length - samples[startIndex / 2 - 1] : length;
}
function cacheRawPathMeasurements(rawPath, resolution) {
  var pathLength, points, i;
  for (i = pathLength = points = 0; i < rawPath.length; i++) {
    rawPath[i].resolution = ~~resolution || 12;
    points += rawPath[i].length;
    pathLength += measureSegment(rawPath[i]);
  }
  rawPath.totalPoints = points;
  rawPath.totalLength = pathLength;
  return rawPath;
}
function subdivideSegment(segment, i, t) {
  if (t <= 0 || t >= 1) {
    return 0;
  }
  var ax = segment[i], ay = segment[i + 1], cp1x = segment[i + 2], cp1y = segment[i + 3], cp2x = segment[i + 4], cp2y = segment[i + 5], bx = segment[i + 6], by = segment[i + 7], x1a = ax + (cp1x - ax) * t, x2 = cp1x + (cp2x - cp1x) * t, y1a = ay + (cp1y - ay) * t, y2 = cp1y + (cp2y - cp1y) * t, x1 = x1a + (x2 - x1a) * t, y1 = y1a + (y2 - y1a) * t, x2a = cp2x + (bx - cp2x) * t, y2a = cp2y + (by - cp2y) * t;
  x2 += (x2a - x2) * t;
  y2 += (y2a - y2) * t;
  segment.splice(
    i + 2,
    4,
    _round$3(x1a),
    //first control point
    _round$3(y1a),
    _round$3(x1),
    //second control point
    _round$3(y1),
    _round$3(x1 + (x2 - x1) * t),
    //new fabricated anchor on line
    _round$3(y1 + (y2 - y1) * t),
    _round$3(x2),
    //third control point
    _round$3(y2),
    _round$3(x2a),
    //fourth control point
    _round$3(y2a)
  );
  segment.samples && segment.samples.splice(i / 6 * segment.resolution | 0, 0, 0, 0, 0, 0, 0, 0);
  return 6;
}
function getProgressData(rawPath, progress, decoratee, pushToNextIfAtEnd) {
  decoratee = decoratee || {};
  rawPath.totalLength || cacheRawPathMeasurements(rawPath);
  if (progress < 0 || progress > 1) {
    progress = _wrapProgress(progress);
  }
  var segIndex = 0, segment = rawPath[0], samples, resolution, length, min, max, i, t;
  if (!progress) {
    t = i = segIndex = 0;
    segment = rawPath[0];
  } else if (progress === 1) {
    t = 1;
    segIndex = rawPath.length - 1;
    segment = rawPath[segIndex];
    i = segment.length - 8;
  } else {
    if (rawPath.length > 1) {
      length = rawPath.totalLength * progress;
      max = i = 0;
      while ((max += rawPath[i++].totalLength) < length) {
        segIndex = i;
      }
      segment = rawPath[segIndex];
      min = max - segment.totalLength;
      progress = (length - min) / (max - min) || 0;
    }
    samples = segment.samples;
    resolution = segment.resolution;
    length = segment.totalLength * progress;
    i = segment.lookup.length ? segment.lookup[~~(length / segment.minLength)] || 0 : _getSampleIndex(samples, length, progress);
    min = i ? samples[i - 1] : 0;
    max = samples[i];
    if (max < length) {
      min = max;
      max = samples[++i];
    }
    t = 1 / resolution * ((length - min) / (max - min) + i % resolution);
    i = ~~(i / resolution) * 6;
    if (pushToNextIfAtEnd && t === 1) {
      if (i + 6 < segment.length) {
        i += 6;
        t = 0;
      } else if (segIndex + 1 < rawPath.length) {
        i = t = 0;
        segment = rawPath[++segIndex];
      }
    }
  }
  decoratee.t = t;
  decoratee.i = i;
  decoratee.path = rawPath;
  decoratee.segment = segment;
  decoratee.segIndex = segIndex;
  return decoratee;
}
function getPositionOnPath(rawPath, progress, includeAngle, point) {
  var segment = rawPath[0], result = point || {}, samples, resolution, length, min, max, i, t, a, inv;
  if (progress < 0 || progress > 1) {
    progress = _wrapProgress(progress);
  }
  segment.lookup || cacheRawPathMeasurements(rawPath);
  if (rawPath.length > 1) {
    length = rawPath.totalLength * progress;
    max = i = 0;
    while ((max += rawPath[i++].totalLength) < length) {
      segment = rawPath[i];
    }
    min = max - segment.totalLength;
    progress = (length - min) / (max - min) || 0;
  }
  samples = segment.samples;
  resolution = segment.resolution;
  length = segment.totalLength * progress;
  i = segment.lookup.length ? segment.lookup[progress < 1 ? ~~(length / segment.minLength) : segment.lookup.length - 1] || 0 : _getSampleIndex(samples, length, progress);
  min = i ? samples[i - 1] : 0;
  max = samples[i];
  if (max < length) {
    min = max;
    max = samples[++i];
  }
  t = 1 / resolution * ((length - min) / (max - min) + i % resolution) || 0;
  inv = 1 - t;
  i = ~~(i / resolution) * 6;
  a = segment[i];
  result.x = _round$3((t * t * (segment[i + 6] - a) + 3 * inv * (t * (segment[i + 4] - a) + inv * (segment[i + 2] - a))) * t + a);
  result.y = _round$3((t * t * (segment[i + 7] - (a = segment[i + 1])) + 3 * inv * (t * (segment[i + 5] - a) + inv * (segment[i + 3] - a))) * t + a);
  if (includeAngle) {
    result.angle = segment.totalLength ? getRotationAtBezierT(segment, i, t >= 1 ? 1 - 1e-9 : t ? t : 1e-9) : segment.angle || 0;
  }
  return result;
}
function transformRawPath(rawPath, a, b, c, d, tx, ty) {
  var j = rawPath.length, segment, l, i, x, y;
  while (--j > -1) {
    segment = rawPath[j];
    l = segment.length;
    for (i = 0; i < l; i += 2) {
      x = segment[i];
      y = segment[i + 1];
      segment[i] = x * a + y * c + tx;
      segment[i + 1] = x * b + y * d + ty;
    }
  }
  rawPath._dirty = 1;
  return rawPath;
}
function arcToSegment(lastX, lastY, rx, ry, angle, largeArcFlag, sweepFlag, x, y) {
  if (lastX === x && lastY === y) {
    return;
  }
  rx = _abs(rx);
  ry = _abs(ry);
  var angleRad = angle % 360 * _DEG2RAD$2, cosAngle = _cos(angleRad), sinAngle = _sin(angleRad), PI = Math.PI, TWOPI = PI * 2, dx2 = (lastX - x) / 2, dy2 = (lastY - y) / 2, x1 = cosAngle * dx2 + sinAngle * dy2, y1 = -sinAngle * dx2 + cosAngle * dy2, x1_sq = x1 * x1, y1_sq = y1 * y1, radiiCheck = x1_sq / (rx * rx) + y1_sq / (ry * ry);
  if (radiiCheck > 1) {
    rx = _sqrt(radiiCheck) * rx;
    ry = _sqrt(radiiCheck) * ry;
  }
  var rx_sq = rx * rx, ry_sq = ry * ry, sq = (rx_sq * ry_sq - rx_sq * y1_sq - ry_sq * x1_sq) / (rx_sq * y1_sq + ry_sq * x1_sq);
  if (sq < 0) {
    sq = 0;
  }
  var coef = (largeArcFlag === sweepFlag ? -1 : 1) * _sqrt(sq), cx1 = coef * (rx * y1 / ry), cy1 = coef * -(ry * x1 / rx), sx2 = (lastX + x) / 2, sy2 = (lastY + y) / 2, cx = sx2 + (cosAngle * cx1 - sinAngle * cy1), cy = sy2 + (sinAngle * cx1 + cosAngle * cy1), ux = (x1 - cx1) / rx, uy = (y1 - cy1) / ry, vx = (-x1 - cx1) / rx, vy = (-y1 - cy1) / ry, temp = ux * ux + uy * uy, angleStart = (uy < 0 ? -1 : 1) * Math.acos(ux / _sqrt(temp)), angleExtent = (ux * vy - uy * vx < 0 ? -1 : 1) * Math.acos((ux * vx + uy * vy) / _sqrt(temp * (vx * vx + vy * vy)));
  isNaN(angleExtent) && (angleExtent = PI);
  if (!sweepFlag && angleExtent > 0) {
    angleExtent -= TWOPI;
  } else if (sweepFlag && angleExtent < 0) {
    angleExtent += TWOPI;
  }
  angleStart %= TWOPI;
  angleExtent %= TWOPI;
  var segments = Math.ceil(_abs(angleExtent) / (TWOPI / 4)), rawPath = [], angleIncrement = angleExtent / segments, controlLength = 4 / 3 * _sin(angleIncrement / 2) / (1 + _cos(angleIncrement / 2)), ma = cosAngle * rx, mb = sinAngle * rx, mc = sinAngle * -ry, md = cosAngle * ry, i;
  for (i = 0; i < segments; i++) {
    angle = angleStart + i * angleIncrement;
    x1 = _cos(angle);
    y1 = _sin(angle);
    ux = _cos(angle += angleIncrement);
    uy = _sin(angle);
    rawPath.push(x1 - controlLength * y1, y1 + controlLength * x1, ux + controlLength * uy, uy - controlLength * ux, ux, uy);
  }
  for (i = 0; i < rawPath.length; i += 2) {
    x1 = rawPath[i];
    y1 = rawPath[i + 1];
    rawPath[i] = x1 * ma + y1 * mc + cx;
    rawPath[i + 1] = x1 * mb + y1 * md + cy;
  }
  rawPath[i - 2] = x;
  rawPath[i - 1] = y;
  return rawPath;
}
function stringToRawPath(d) {
  var a = (d + "").replace(_scientific, function(m) {
    var n = +m;
    return n < 1e-4 && n > -1e-4 ? 0 : n;
  }).match(_svgPathExp) || [], path = [], relativeX = 0, relativeY = 0, twoThirds = 2 / 3, elements = a.length, points = 0, errorMessage = "ERROR: malformed path: " + d, i, j, x, y, command, isRelative, segment, startX, startY, difX, difY, beziers, prevCommand, flag1, flag2, line = function line2(sx, sy, ex, ey) {
    difX = (ex - sx) / 3;
    difY = (ey - sy) / 3;
    segment.push(sx + difX, sy + difY, ex - difX, ey - difY, ex, ey);
  };
  if (!d || !isNaN(a[0]) || isNaN(a[1])) {
    console.log(errorMessage);
    return path;
  }
  for (i = 0; i < elements; i++) {
    prevCommand = command;
    if (isNaN(a[i])) {
      command = a[i].toUpperCase();
      isRelative = command !== a[i];
    } else {
      i--;
    }
    x = +a[i + 1];
    y = +a[i + 2];
    if (isRelative) {
      x += relativeX;
      y += relativeY;
    }
    if (!i) {
      startX = x;
      startY = y;
    }
    if (command === "M") {
      if (segment) {
        if (segment.length < 8) {
          path.length -= 1;
        } else {
          points += segment.length;
        }
      }
      relativeX = startX = x;
      relativeY = startY = y;
      segment = [x, y];
      path.push(segment);
      i += 2;
      command = "L";
    } else if (command === "C") {
      if (!segment) {
        segment = [0, 0];
      }
      if (!isRelative) {
        relativeX = relativeY = 0;
      }
      segment.push(x, y, relativeX + a[i + 3] * 1, relativeY + a[i + 4] * 1, relativeX += a[i + 5] * 1, relativeY += a[i + 6] * 1);
      i += 6;
    } else if (command === "S") {
      difX = relativeX;
      difY = relativeY;
      if (prevCommand === "C" || prevCommand === "S") {
        difX += relativeX - segment[segment.length - 4];
        difY += relativeY - segment[segment.length - 3];
      }
      if (!isRelative) {
        relativeX = relativeY = 0;
      }
      segment.push(difX, difY, x, y, relativeX += a[i + 3] * 1, relativeY += a[i + 4] * 1);
      i += 4;
    } else if (command === "Q") {
      difX = relativeX + (x - relativeX) * twoThirds;
      difY = relativeY + (y - relativeY) * twoThirds;
      if (!isRelative) {
        relativeX = relativeY = 0;
      }
      relativeX += a[i + 3] * 1;
      relativeY += a[i + 4] * 1;
      segment.push(difX, difY, relativeX + (x - relativeX) * twoThirds, relativeY + (y - relativeY) * twoThirds, relativeX, relativeY);
      i += 4;
    } else if (command === "T") {
      difX = relativeX - segment[segment.length - 4];
      difY = relativeY - segment[segment.length - 3];
      segment.push(relativeX + difX, relativeY + difY, x + (relativeX + difX * 1.5 - x) * twoThirds, y + (relativeY + difY * 1.5 - y) * twoThirds, relativeX = x, relativeY = y);
      i += 2;
    } else if (command === "H") {
      line(relativeX, relativeY, relativeX = x, relativeY);
      i += 1;
    } else if (command === "V") {
      line(relativeX, relativeY, relativeX, relativeY = x + (isRelative ? relativeY - relativeX : 0));
      i += 1;
    } else if (command === "L" || command === "Z") {
      if (command === "Z") {
        x = startX;
        y = startY;
        segment.closed = true;
      }
      if (command === "L" || _abs(relativeX - x) > 0.5 || _abs(relativeY - y) > 0.5) {
        line(relativeX, relativeY, x, y);
        if (command === "L") {
          i += 2;
        }
      }
      relativeX = x;
      relativeY = y;
    } else if (command === "A") {
      flag1 = a[i + 4];
      flag2 = a[i + 5];
      difX = a[i + 6];
      difY = a[i + 7];
      j = 7;
      if (flag1.length > 1) {
        if (flag1.length < 3) {
          difY = difX;
          difX = flag2;
          j--;
        } else {
          difY = flag2;
          difX = flag1.substr(2);
          j -= 2;
        }
        flag2 = flag1.charAt(1);
        flag1 = flag1.charAt(0);
      }
      beziers = arcToSegment(relativeX, relativeY, +a[i + 1], +a[i + 2], +a[i + 3], +flag1, +flag2, (isRelative ? relativeX : 0) + difX * 1, (isRelative ? relativeY : 0) + difY * 1);
      i += j;
      if (beziers) {
        for (j = 0; j < beziers.length; j++) {
          segment.push(beziers[j]);
        }
      }
      relativeX = segment[segment.length - 2];
      relativeY = segment[segment.length - 1];
    } else {
      console.log(errorMessage);
    }
  }
  i = segment.length;
  if (i < 6) {
    path.pop();
    i = 0;
  } else if (segment[0] === segment[i - 2] && segment[1] === segment[i - 1]) {
    segment.closed = true;
  }
  path.totalPoints = points + i;
  return path;
}
function flatPointsToSegment(points, curviness) {
  if (curviness === void 0) {
    curviness = 1;
  }
  var x = points[0], y = 0, segment = [x, y], i = 2;
  for (; i < points.length; i += 2) {
    segment.push(x, y, points[i], y = (points[i] - x) * curviness / 2, x = points[i], -y);
  }
  return segment;
}
function pointsToSegment(points, curviness) {
  _abs(points[0] - points[2]) < 1e-4 && _abs(points[1] - points[3]) < 1e-4 && (points = points.slice(2));
  var l = points.length - 2, x = +points[0], y = +points[1], nextX = +points[2], nextY = +points[3], segment = [x, y, x, y], dx2 = nextX - x, dy2 = nextY - y, closed = Math.abs(points[l] - x) < 1e-3 && Math.abs(points[l + 1] - y) < 1e-3, prevX, prevY, i, dx1, dy1, r1, r2, r3, tl, mx1, mx2, mxm, my1, my2, mym;
  if (closed) {
    points.push(nextX, nextY);
    nextX = x;
    nextY = y;
    x = points[l - 2];
    y = points[l - 1];
    points.unshift(x, y);
    l += 4;
  }
  curviness = curviness || curviness === 0 ? +curviness : 1;
  for (i = 2; i < l; i += 2) {
    prevX = x;
    prevY = y;
    x = nextX;
    y = nextY;
    nextX = +points[i + 2];
    nextY = +points[i + 3];
    if (x === nextX && y === nextY) {
      continue;
    }
    dx1 = dx2;
    dy1 = dy2;
    dx2 = nextX - x;
    dy2 = nextY - y;
    r1 = _sqrt(dx1 * dx1 + dy1 * dy1);
    r2 = _sqrt(dx2 * dx2 + dy2 * dy2);
    r3 = _sqrt(Math.pow(dx2 / r2 + dx1 / r1, 2) + Math.pow(dy2 / r2 + dy1 / r1, 2));
    tl = (r1 + r2) * curviness * 0.25 / r3;
    mx1 = x - (x - prevX) * (r1 ? tl / r1 : 0);
    mx2 = x + (nextX - x) * (r2 ? tl / r2 : 0);
    mxm = x - (mx1 + ((mx2 - mx1) * (r1 * 3 / (r1 + r2) + 0.5) / 4 || 0));
    my1 = y - (y - prevY) * (r1 ? tl / r1 : 0);
    my2 = y + (nextY - y) * (r2 ? tl / r2 : 0);
    mym = y - (my1 + ((my2 - my1) * (r1 * 3 / (r1 + r2) + 0.5) / 4 || 0));
    if (x !== prevX || y !== prevY) {
      segment.push(
        _round$3(mx1 + mxm),
        // first control point
        _round$3(my1 + mym),
        _round$3(x),
        // anchor
        _round$3(y),
        _round$3(mx2 + mxm),
        // second control point
        _round$3(my2 + mym)
      );
    }
  }
  x !== nextX || y !== nextY || segment.length < 4 ? segment.push(_round$3(nextX), _round$3(nextY), _round$3(nextX), _round$3(nextY)) : segment.length -= 2;
  if (segment.length === 2) {
    segment.push(x, y, x, y, x, y);
  } else if (closed) {
    segment.splice(0, 6);
    segment.length = segment.length - 6;
  }
  return segment;
}
function rawPathToString(rawPath) {
  if (_isNumber2(rawPath[0])) {
    rawPath = [rawPath];
  }
  var result = "", l = rawPath.length, sl, s, i, segment;
  for (s = 0; s < l; s++) {
    segment = rawPath[s];
    result += "M" + _round$3(segment[0]) + "," + _round$3(segment[1]) + " C";
    sl = segment.length;
    for (i = 2; i < sl; i++) {
      result += _round$3(segment[i++]) + "," + _round$3(segment[i++]) + " " + _round$3(segment[i++]) + "," + _round$3(segment[i++]) + " " + _round$3(segment[i++]) + "," + _round$3(segment[i]) + " ";
    }
    if (segment.closed) {
      result += "z";
    }
  }
  return result;
}
/*!
 * CustomEase 3.12.5
 * https://gsap.com
 *
 * @license Copyright 2008-2024, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license or for
 * Club GSAP members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/
var gsap$5, _coreInitted$2, _getGSAP$4 = function _getGSAP() {
  return gsap$5 || typeof window !== "undefined" && (gsap$5 = window.gsap) && gsap$5.registerPlugin && gsap$5;
}, _initCore$2 = function _initCore2() {
  gsap$5 = _getGSAP$4();
  if (gsap$5) {
    gsap$5.registerEase("_CE", CustomEase.create);
    _coreInitted$2 = 1;
  } else {
    console.warn("Please gsap.registerPlugin(CustomEase)");
  }
}, _bigNum$1 = 1e20, _round$2 = function _round3(value) {
  return ~~(value * 1e3 + (value < 0 ? -0.5 : 0.5)) / 1e3;
}, _numExp$1 = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/gi, _needsParsingExp = /[cLlsSaAhHvVtTqQ]/g, _findMinimum = function _findMinimum2(values) {
  var l = values.length, min = _bigNum$1, i;
  for (i = 1; i < l; i += 6) {
    +values[i] < min && (min = +values[i]);
  }
  return min;
}, _normalize = function _normalize2(values, height, originY) {
  if (!originY && originY !== 0) {
    originY = Math.max(+values[values.length - 1], +values[1]);
  }
  var tx = +values[0] * -1, ty = -originY, l = values.length, sx = 1 / (+values[l - 2] + tx), sy = -height || (Math.abs(+values[l - 1] - +values[1]) < 0.01 * (+values[l - 2] - +values[0]) ? _findMinimum(values) + ty : +values[l - 1] + ty), i;
  if (sy) {
    sy = 1 / sy;
  } else {
    sy = -sx;
  }
  for (i = 0; i < l; i += 2) {
    values[i] = (+values[i] + tx) * sx;
    values[i + 1] = (+values[i + 1] + ty) * sy;
  }
}, _bezierToPoints = function _bezierToPoints2(x1, y1, x2, y2, x3, y3, x4, y4, threshold, points, index) {
  var x12 = (x1 + x2) / 2, y12 = (y1 + y2) / 2, x23 = (x2 + x3) / 2, y23 = (y2 + y3) / 2, x34 = (x3 + x4) / 2, y34 = (y3 + y4) / 2, x123 = (x12 + x23) / 2, y123 = (y12 + y23) / 2, x234 = (x23 + x34) / 2, y234 = (y23 + y34) / 2, x1234 = (x123 + x234) / 2, y1234 = (y123 + y234) / 2, dx = x4 - x1, dy = y4 - y1, d2 = Math.abs((x2 - x4) * dy - (y2 - y4) * dx), d3 = Math.abs((x3 - x4) * dy - (y3 - y4) * dx), length;
  if (!points) {
    points = [{
      x: x1,
      y: y1
    }, {
      x: x4,
      y: y4
    }];
    index = 1;
  }
  points.splice(index || points.length - 1, 0, {
    x: x1234,
    y: y1234
  });
  if ((d2 + d3) * (d2 + d3) > threshold * (dx * dx + dy * dy)) {
    length = points.length;
    _bezierToPoints2(x1, y1, x12, y12, x123, y123, x1234, y1234, threshold, points, index);
    _bezierToPoints2(x1234, y1234, x234, y234, x34, y34, x4, y4, threshold, points, index + 1 + (points.length - length));
  }
  return points;
};
var CustomEase = /* @__PURE__ */ function() {
  function CustomEase2(id, data, config3) {
    _coreInitted$2 || _initCore$2();
    this.id = id;
    this.setData(data, config3);
  }
  var _proto = CustomEase2.prototype;
  _proto.setData = function setData(data, config3) {
    config3 = config3 || {};
    data = data || "0,0,1,1";
    var values = data.match(_numExp$1), closest = 1, points = [], lookup = [], precision = config3.precision || 1, fast = precision <= 1, l, a1, a2, i, inc, j, point, prevPoint, p;
    this.data = data;
    if (_needsParsingExp.test(data) || ~data.indexOf("M") && data.indexOf("C") < 0) {
      values = stringToRawPath(data)[0];
    }
    l = values.length;
    if (l === 4) {
      values.unshift(0, 0);
      values.push(1, 1);
      l = 8;
    } else if ((l - 2) % 6) {
      throw "Invalid CustomEase";
    }
    if (+values[0] !== 0 || +values[l - 2] !== 1) {
      _normalize(values, config3.height, config3.originY);
    }
    this.segment = values;
    for (i = 2; i < l; i += 6) {
      a1 = {
        x: +values[i - 2],
        y: +values[i - 1]
      };
      a2 = {
        x: +values[i + 4],
        y: +values[i + 5]
      };
      points.push(a1, a2);
      _bezierToPoints(a1.x, a1.y, +values[i], +values[i + 1], +values[i + 2], +values[i + 3], a2.x, a2.y, 1 / (precision * 2e5), points, points.length - 1);
    }
    l = points.length;
    for (i = 0; i < l; i++) {
      point = points[i];
      prevPoint = points[i - 1] || point;
      if ((point.x > prevPoint.x || prevPoint.y !== point.y && prevPoint.x === point.x || point === prevPoint) && point.x <= 1) {
        prevPoint.cx = point.x - prevPoint.x;
        prevPoint.cy = point.y - prevPoint.y;
        prevPoint.n = point;
        prevPoint.nx = point.x;
        if (fast && i > 1 && Math.abs(prevPoint.cy / prevPoint.cx - points[i - 2].cy / points[i - 2].cx) > 2) {
          fast = 0;
        }
        if (prevPoint.cx < closest) {
          if (!prevPoint.cx) {
            prevPoint.cx = 1e-3;
            if (i === l - 1) {
              prevPoint.x -= 1e-3;
              closest = Math.min(closest, 1e-3);
              fast = 0;
            }
          } else {
            closest = prevPoint.cx;
          }
        }
      } else {
        points.splice(i--, 1);
        l--;
      }
    }
    l = 1 / closest + 1 | 0;
    inc = 1 / l;
    j = 0;
    point = points[0];
    if (fast) {
      for (i = 0; i < l; i++) {
        p = i * inc;
        if (point.nx < p) {
          point = points[++j];
        }
        a1 = point.y + (p - point.x) / point.cx * point.cy;
        lookup[i] = {
          x: p,
          cx: inc,
          y: a1,
          cy: 0,
          nx: 9
        };
        if (i) {
          lookup[i - 1].cy = a1 - lookup[i - 1].y;
        }
      }
      lookup[l - 1].cy = points[points.length - 1].y - a1;
    } else {
      for (i = 0; i < l; i++) {
        if (point.nx < i * inc) {
          point = points[++j];
        }
        lookup[i] = point;
      }
      if (j < points.length - 1) {
        lookup[i - 1] = points[points.length - 2];
      }
    }
    this.ease = function(p2) {
      var point2 = lookup[p2 * l | 0] || lookup[l - 1];
      if (point2.nx < p2) {
        point2 = point2.n;
      }
      return point2.y + (p2 - point2.x) / point2.cx * point2.cy;
    };
    this.ease.custom = this;
    this.id && gsap$5 && gsap$5.registerEase(this.id, this.ease);
    return this;
  };
  _proto.getSVGData = function getSVGData(config3) {
    return CustomEase2.getSVGData(this, config3);
  };
  CustomEase2.create = function create(id, data, config3) {
    return new CustomEase2(id, data, config3).ease;
  };
  CustomEase2.register = function register2(core) {
    gsap$5 = core;
    _initCore$2();
  };
  CustomEase2.get = function get2(id) {
    return gsap$5.parseEase(id);
  };
  CustomEase2.getSVGData = function getSVGData(ease, config3) {
    config3 = config3 || {};
    var width = config3.width || 100, height = config3.height || 100, x = config3.x || 0, y = (config3.y || 0) + height, e = gsap$5.utils.toArray(config3.path)[0], a, slope, i, inc, tx, ty, precision, threshold, prevX, prevY;
    if (config3.invert) {
      height = -height;
      y = 0;
    }
    if (typeof ease === "string") {
      ease = gsap$5.parseEase(ease);
    }
    if (ease.custom) {
      ease = ease.custom;
    }
    if (ease instanceof CustomEase2) {
      a = rawPathToString(transformRawPath([ease.segment], width, 0, 0, -height, x, y));
    } else {
      a = [x, y];
      precision = Math.max(5, (config3.precision || 1) * 200);
      inc = 1 / precision;
      precision += 2;
      threshold = 5 / precision;
      prevX = _round$2(x + inc * width);
      prevY = _round$2(y + ease(inc) * -height);
      slope = (prevY - y) / (prevX - x);
      for (i = 2; i < precision; i++) {
        tx = _round$2(x + i * inc * width);
        ty = _round$2(y + ease(i * inc) * -height);
        if (Math.abs((ty - prevY) / (tx - prevX) - slope) > threshold || i === precision - 1) {
          a.push(prevX, prevY);
          slope = (ty - prevY) / (tx - prevX);
        }
        prevX = tx;
        prevY = ty;
      }
      a = "M" + a.join(",");
    }
    e && e.setAttribute("d", a);
    return a;
  };
  return CustomEase2;
}();
_getGSAP$4() && gsap$5.registerPlugin(CustomEase);
CustomEase.version = "3.12.5";
/*!
 * matrix 3.12.5
 * https://gsap.com
 *
 * Copyright 2008-2024, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license or for
 * Club GSAP members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/
var _doc$2, _win$2, _docElement$1, _body$3, _divContainer, _svgContainer, _identityMatrix$1, _gEl, _transformProp$1 = "transform", _transformOriginProp$1 = _transformProp$1 + "Origin", _hasOffsetBug, _setDoc = function _setDoc2(element) {
  var doc = element.ownerDocument || element;
  if (!(_transformProp$1 in element.style) && "msTransform" in element.style) {
    _transformProp$1 = "msTransform";
    _transformOriginProp$1 = _transformProp$1 + "Origin";
  }
  while (doc.parentNode && (doc = doc.parentNode)) {
  }
  _win$2 = window;
  _identityMatrix$1 = new Matrix2D();
  if (doc) {
    _doc$2 = doc;
    _docElement$1 = doc.documentElement;
    _body$3 = doc.body;
    _gEl = _doc$2.createElementNS("http://www.w3.org/2000/svg", "g");
    _gEl.style.transform = "none";
    var d1 = doc.createElement("div"), d2 = doc.createElement("div"), root = doc && (doc.body || doc.firstElementChild);
    if (root && root.appendChild) {
      root.appendChild(d1);
      d1.appendChild(d2);
      d1.setAttribute("style", "position:static;transform:translate3d(0,0,1px)");
      _hasOffsetBug = d2.offsetParent !== d1;
      root.removeChild(d1);
    }
  }
  return doc;
}, _forceNonZeroScale = function _forceNonZeroScale2(e) {
  var a, cache;
  while (e && e !== _body$3) {
    cache = e._gsap;
    cache && cache.uncache && cache.get(e, "x");
    if (cache && !cache.scaleX && !cache.scaleY && cache.renderTransform) {
      cache.scaleX = cache.scaleY = 1e-4;
      cache.renderTransform(1, cache);
      a ? a.push(cache) : a = [cache];
    }
    e = e.parentNode;
  }
  return a;
}, _svgTemps = [], _divTemps = [], _getDocScrollTop$1 = function _getDocScrollTop() {
  return _win$2.pageYOffset || _doc$2.scrollTop || _docElement$1.scrollTop || _body$3.scrollTop || 0;
}, _getDocScrollLeft$1 = function _getDocScrollLeft() {
  return _win$2.pageXOffset || _doc$2.scrollLeft || _docElement$1.scrollLeft || _body$3.scrollLeft || 0;
}, _svgOwner = function _svgOwner2(element) {
  return element.ownerSVGElement || ((element.tagName + "").toLowerCase() === "svg" ? element : null);
}, _isFixed$1 = function _isFixed(element) {
  if (_win$2.getComputedStyle(element).position === "fixed") {
    return true;
  }
  element = element.parentNode;
  if (element && element.nodeType === 1) {
    return _isFixed(element);
  }
}, _createSibling = function _createSibling2(element, i) {
  if (element.parentNode && (_doc$2 || _setDoc(element))) {
    var svg = _svgOwner(element), ns = svg ? svg.getAttribute("xmlns") || "http://www.w3.org/2000/svg" : "http://www.w3.org/1999/xhtml", type = svg ? i ? "rect" : "g" : "div", x = i !== 2 ? 0 : 100, y = i === 3 ? 100 : 0, css = "position:absolute;display:block;pointer-events:none;margin:0;padding:0;", e = _doc$2.createElementNS ? _doc$2.createElementNS(ns.replace(/^https/, "http"), type) : _doc$2.createElement(type);
    if (i) {
      if (!svg) {
        if (!_divContainer) {
          _divContainer = _createSibling2(element);
          _divContainer.style.cssText = css;
        }
        e.style.cssText = css + "width:0.1px;height:0.1px;top:" + y + "px;left:" + x + "px";
        _divContainer.appendChild(e);
      } else {
        _svgContainer || (_svgContainer = _createSibling2(element));
        e.setAttribute("width", 0.01);
        e.setAttribute("height", 0.01);
        e.setAttribute("transform", "translate(" + x + "," + y + ")");
        _svgContainer.appendChild(e);
      }
    }
    return e;
  }
  throw "Need document and parent.";
}, _consolidate = function _consolidate2(m) {
  var c = new Matrix2D(), i = 0;
  for (; i < m.numberOfItems; i++) {
    c.multiply(m.getItem(i).matrix);
  }
  return c;
}, _getCTM = function _getCTM2(svg) {
  var m = svg.getCTM(), transform;
  if (!m) {
    transform = svg.style[_transformProp$1];
    svg.style[_transformProp$1] = "none";
    svg.appendChild(_gEl);
    m = _gEl.getCTM();
    svg.removeChild(_gEl);
    transform ? svg.style[_transformProp$1] = transform : svg.style.removeProperty(_transformProp$1.replace(/([A-Z])/g, "-$1").toLowerCase());
  }
  return m || _identityMatrix$1.clone();
}, _placeSiblings = function _placeSiblings2(element, adjustGOffset) {
  var svg = _svgOwner(element), isRootSVG = element === svg, siblings = svg ? _svgTemps : _divTemps, parent = element.parentNode, container, m, b, x, y, cs;
  if (element === _win$2) {
    return element;
  }
  siblings.length || siblings.push(_createSibling(element, 1), _createSibling(element, 2), _createSibling(element, 3));
  container = svg ? _svgContainer : _divContainer;
  if (svg) {
    if (isRootSVG) {
      b = _getCTM(element);
      x = -b.e / b.a;
      y = -b.f / b.d;
      m = _identityMatrix$1;
    } else if (element.getBBox) {
      b = element.getBBox();
      m = element.transform ? element.transform.baseVal : {};
      m = !m.numberOfItems ? _identityMatrix$1 : m.numberOfItems > 1 ? _consolidate(m) : m.getItem(0).matrix;
      x = m.a * b.x + m.c * b.y;
      y = m.b * b.x + m.d * b.y;
    } else {
      m = new Matrix2D();
      x = y = 0;
    }
    if (adjustGOffset && element.tagName.toLowerCase() === "g") {
      x = y = 0;
    }
    (isRootSVG ? svg : parent).appendChild(container);
    container.setAttribute("transform", "matrix(" + m.a + "," + m.b + "," + m.c + "," + m.d + "," + (m.e + x) + "," + (m.f + y) + ")");
  } else {
    x = y = 0;
    if (_hasOffsetBug) {
      m = element.offsetParent;
      b = element;
      while (b && (b = b.parentNode) && b !== m && b.parentNode) {
        if ((_win$2.getComputedStyle(b)[_transformProp$1] + "").length > 4) {
          x = b.offsetLeft;
          y = b.offsetTop;
          b = 0;
        }
      }
    }
    cs = _win$2.getComputedStyle(element);
    if (cs.position !== "absolute" && cs.position !== "fixed") {
      m = element.offsetParent;
      while (parent && parent !== m) {
        x += parent.scrollLeft || 0;
        y += parent.scrollTop || 0;
        parent = parent.parentNode;
      }
    }
    b = container.style;
    b.top = element.offsetTop - y + "px";
    b.left = element.offsetLeft - x + "px";
    b[_transformProp$1] = cs[_transformProp$1];
    b[_transformOriginProp$1] = cs[_transformOriginProp$1];
    b.position = cs.position === "fixed" ? "fixed" : "absolute";
    element.parentNode.appendChild(container);
  }
  return container;
}, _setMatrix = function _setMatrix2(m, a, b, c, d, e, f) {
  m.a = a;
  m.b = b;
  m.c = c;
  m.d = d;
  m.e = e;
  m.f = f;
  return m;
};
var Matrix2D = /* @__PURE__ */ function() {
  function Matrix2D2(a, b, c, d, e, f) {
    if (a === void 0) {
      a = 1;
    }
    if (b === void 0) {
      b = 0;
    }
    if (c === void 0) {
      c = 0;
    }
    if (d === void 0) {
      d = 1;
    }
    if (e === void 0) {
      e = 0;
    }
    if (f === void 0) {
      f = 0;
    }
    _setMatrix(this, a, b, c, d, e, f);
  }
  var _proto = Matrix2D2.prototype;
  _proto.inverse = function inverse() {
    var a = this.a, b = this.b, c = this.c, d = this.d, e = this.e, f = this.f, determinant = a * d - b * c || 1e-10;
    return _setMatrix(this, d / determinant, -b / determinant, -c / determinant, a / determinant, (c * f - d * e) / determinant, -(a * f - b * e) / determinant);
  };
  _proto.multiply = function multiply(matrix) {
    var a = this.a, b = this.b, c = this.c, d = this.d, e = this.e, f = this.f, a2 = matrix.a, b2 = matrix.c, c2 = matrix.b, d2 = matrix.d, e2 = matrix.e, f2 = matrix.f;
    return _setMatrix(this, a2 * a + c2 * c, a2 * b + c2 * d, b2 * a + d2 * c, b2 * b + d2 * d, e + e2 * a + f2 * c, f + e2 * b + f2 * d);
  };
  _proto.clone = function clone() {
    return new Matrix2D2(this.a, this.b, this.c, this.d, this.e, this.f);
  };
  _proto.equals = function equals(matrix) {
    var a = this.a, b = this.b, c = this.c, d = this.d, e = this.e, f = this.f;
    return a === matrix.a && b === matrix.b && c === matrix.c && d === matrix.d && e === matrix.e && f === matrix.f;
  };
  _proto.apply = function apply(point, decoratee) {
    if (decoratee === void 0) {
      decoratee = {};
    }
    var x = point.x, y = point.y, a = this.a, b = this.b, c = this.c, d = this.d, e = this.e, f = this.f;
    decoratee.x = x * a + y * c + e || 0;
    decoratee.y = x * b + y * d + f || 0;
    return decoratee;
  };
  return Matrix2D2;
}();
function getGlobalMatrix(element, inverse, adjustGOffset, includeScrollInFixed) {
  if (!element || !element.parentNode || (_doc$2 || _setDoc(element)).documentElement === element) {
    return new Matrix2D();
  }
  var zeroScales = _forceNonZeroScale(element), svg = _svgOwner(element), temps = svg ? _svgTemps : _divTemps, container = _placeSiblings(element, adjustGOffset), b1 = temps[0].getBoundingClientRect(), b2 = temps[1].getBoundingClientRect(), b3 = temps[2].getBoundingClientRect(), parent = container.parentNode, isFixed = !includeScrollInFixed && _isFixed$1(element), m = new Matrix2D((b2.left - b1.left) / 100, (b2.top - b1.top) / 100, (b3.left - b1.left) / 100, (b3.top - b1.top) / 100, b1.left + (isFixed ? 0 : _getDocScrollLeft$1()), b1.top + (isFixed ? 0 : _getDocScrollTop$1()));
  parent.removeChild(container);
  if (zeroScales) {
    b1 = zeroScales.length;
    while (b1--) {
      b2 = zeroScales[b1];
      b2.scaleX = b2.scaleY = 0;
      b2.renderTransform(1, b2);
    }
  }
  return inverse ? m.inverse() : m;
}
/*!
 * Flip 3.12.5
 * https://gsap.com
 *
 * @license Copyright 2008-2024, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license or for
 * Club GSAP members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/
var _id = 1, _toArray$2, gsap$4, _batch, _batchAction, _body$2, _closestTenth, _getStyleSaver$2, _forEachBatch = function _forEachBatch2(batch, name) {
  return batch.actions.forEach(function(a) {
    return a.vars[name] && a.vars[name](a);
  });
}, _batchLookup = {}, _RAD2DEG$1 = 180 / Math.PI, _DEG2RAD$1 = Math.PI / 180, _emptyObj = {}, _dashedNameLookup = {}, _memoizedRemoveProps = {}, _listToArray = function _listToArray2(list) {
  return typeof list === "string" ? list.split(" ").join("").split(",") : list;
}, _callbacks = _listToArray("onStart,onUpdate,onComplete,onReverseComplete,onInterrupt"), _removeProps = _listToArray("transform,transformOrigin,width,height,position,top,left,opacity,zIndex,maxWidth,maxHeight,minWidth,minHeight"), _getEl = function _getEl2(target) {
  return _toArray$2(target)[0] || console.warn("Element not found:", target);
}, _round$1 = function _round4(value) {
  return Math.round(value * 1e4) / 1e4 || 0;
}, _toggleClass = function _toggleClass2(targets, className, action) {
  return targets.forEach(function(el) {
    return el.classList[action](className);
  });
}, _reserved = {
  zIndex: 1,
  kill: 1,
  simple: 1,
  spin: 1,
  clearProps: 1,
  targets: 1,
  toggleClass: 1,
  onComplete: 1,
  onUpdate: 1,
  onInterrupt: 1,
  onStart: 1,
  delay: 1,
  repeat: 1,
  repeatDelay: 1,
  yoyo: 1,
  scale: 1,
  fade: 1,
  absolute: 1,
  props: 1,
  onEnter: 1,
  onLeave: 1,
  custom: 1,
  paused: 1,
  nested: 1,
  prune: 1,
  absoluteOnLeave: 1
}, _fitReserved = {
  zIndex: 1,
  simple: 1,
  clearProps: 1,
  scale: 1,
  absolute: 1,
  fitChild: 1,
  getVars: 1,
  props: 1
}, _camelToDashed = function _camelToDashed2(p) {
  return p.replace(/([A-Z])/g, "-$1").toLowerCase();
}, _copy$1 = function _copy(obj, exclude) {
  var result = {}, p;
  for (p in obj) {
    exclude[p] || (result[p] = obj[p]);
  }
  return result;
}, _memoizedProps = {}, _memoizeProps = function _memoizeProps2(props) {
  var p = _memoizedProps[props] = _listToArray(props);
  _memoizedRemoveProps[props] = p.concat(_removeProps);
  return p;
}, _getInverseGlobalMatrix = function _getInverseGlobalMatrix2(el) {
  var cache = el._gsap || gsap$4.core.getCache(el);
  if (cache.gmCache === gsap$4.ticker.frame) {
    return cache.gMatrix;
  }
  cache.gmCache = gsap$4.ticker.frame;
  return cache.gMatrix = getGlobalMatrix(el, true, false, true);
}, _getDOMDepth = function _getDOMDepth2(el, invert, level) {
  if (level === void 0) {
    level = 0;
  }
  var parent = el.parentNode, inc = 1e3 * Math.pow(10, level) * (invert ? -1 : 1), l = invert ? -inc * 900 : 0;
  while (el) {
    l += inc;
    el = el.previousSibling;
  }
  return parent ? l + _getDOMDepth2(parent, invert, level + 1) : l;
}, _orderByDOMDepth = function _orderByDOMDepth2(comps, invert, isElStates) {
  comps.forEach(function(comp) {
    return comp.d = _getDOMDepth(isElStates ? comp.element : comp.t, invert);
  });
  comps.sort(function(c1, c2) {
    return c1.d - c2.d;
  });
  return comps;
}, _recordInlineStyles = function _recordInlineStyles2(elState, props) {
  var style = elState.element.style, a = elState.css = elState.css || [], i = props.length, p, v;
  while (i--) {
    p = props[i];
    v = style[p] || style.getPropertyValue(p);
    a.push(v ? p : _dashedNameLookup[p] || (_dashedNameLookup[p] = _camelToDashed(p)), v);
  }
  return style;
}, _applyInlineStyles = function _applyInlineStyles2(state) {
  var css = state.css, style = state.element.style, i = 0;
  state.cache.uncache = 1;
  for (; i < css.length; i += 2) {
    css[i + 1] ? style[css[i]] = css[i + 1] : style.removeProperty(css[i]);
  }
  if (!css[css.indexOf("transform") + 1] && style.translate) {
    style.removeProperty("translate");
    style.removeProperty("scale");
    style.removeProperty("rotate");
  }
}, _setFinalStates = function _setFinalStates2(comps, onlyTransforms) {
  comps.forEach(function(c) {
    return c.a.cache.uncache = 1;
  });
  onlyTransforms || comps.finalStates.forEach(_applyInlineStyles);
}, _absoluteProps = "paddingTop,paddingRight,paddingBottom,paddingLeft,gridArea,transition".split(","), _makeAbsolute = function _makeAbsolute2(elState, fallbackNode, ignoreBatch) {
  var element = elState.element, width = elState.width, height = elState.height, uncache = elState.uncache, getProp = elState.getProp, style = element.style, i = 4, result, displayIsNone, cs;
  typeof fallbackNode !== "object" && (fallbackNode = elState);
  if (_batch && ignoreBatch !== 1) {
    _batch._abs.push({
      t: element,
      b: elState,
      a: elState,
      sd: 0
    });
    _batch._final.push(function() {
      return (elState.cache.uncache = 1) && _applyInlineStyles(elState);
    });
    return element;
  }
  displayIsNone = getProp("display") === "none";
  if (!elState.isVisible || displayIsNone) {
    displayIsNone && (_recordInlineStyles(elState, ["display"]).display = fallbackNode.display);
    elState.matrix = fallbackNode.matrix;
    elState.width = width = elState.width || fallbackNode.width;
    elState.height = height = elState.height || fallbackNode.height;
  }
  _recordInlineStyles(elState, _absoluteProps);
  cs = window.getComputedStyle(element);
  while (i--) {
    style[_absoluteProps[i]] = cs[_absoluteProps[i]];
  }
  style.gridArea = "1 / 1 / 1 / 1";
  style.transition = "none";
  style.position = "absolute";
  style.width = width + "px";
  style.height = height + "px";
  style.top || (style.top = "0px");
  style.left || (style.left = "0px");
  if (uncache) {
    result = new ElementState(element);
  } else {
    result = _copy$1(elState, _emptyObj);
    result.position = "absolute";
    if (elState.simple) {
      var bounds = element.getBoundingClientRect();
      result.matrix = new Matrix2D(1, 0, 0, 1, bounds.left + _getDocScrollLeft$1(), bounds.top + _getDocScrollTop$1());
    } else {
      result.matrix = getGlobalMatrix(element, false, false, true);
    }
  }
  result = _fit(result, elState, true);
  elState.x = _closestTenth(result.x, 0.01);
  elState.y = _closestTenth(result.y, 0.01);
  return element;
}, _filterComps = function _filterComps2(comps, targets) {
  if (targets !== true) {
    targets = _toArray$2(targets);
    comps = comps.filter(function(c) {
      if (targets.indexOf((c.sd < 0 ? c.b : c.a).element) !== -1) {
        return true;
      } else {
        c.t._gsap.renderTransform(1);
        if (c.b.isVisible) {
          c.t.style.width = c.b.width + "px";
          c.t.style.height = c.b.height + "px";
        }
      }
    });
  }
  return comps;
}, _makeCompsAbsolute = function _makeCompsAbsolute2(comps) {
  return _orderByDOMDepth(comps, true).forEach(function(c) {
    return (c.a.isVisible || c.b.isVisible) && _makeAbsolute(c.sd < 0 ? c.b : c.a, c.b, 1);
  });
}, _findElStateInState = function _findElStateInState2(state, other) {
  return other && state.idLookup[_parseElementState(other).id] || state.elementStates[0];
}, _parseElementState = function _parseElementState2(elOrNode, props, simple, other) {
  return elOrNode instanceof ElementState ? elOrNode : elOrNode instanceof FlipState ? _findElStateInState(elOrNode, other) : new ElementState(typeof elOrNode === "string" ? _getEl(elOrNode) || console.warn(elOrNode + " not found") : elOrNode, props, simple);
}, _recordProps = function _recordProps2(elState, props) {
  var getProp = gsap$4.getProperty(elState.element, null, "native"), obj = elState.props = {}, i = props.length;
  while (i--) {
    obj[props[i]] = (getProp(props[i]) + "").trim();
  }
  obj.zIndex && (obj.zIndex = parseFloat(obj.zIndex) || 0);
  return elState;
}, _applyProps = function _applyProps2(element, props) {
  var style = element.style || element, p;
  for (p in props) {
    style[p] = props[p];
  }
}, _getID = function _getID2(el) {
  var id = el.getAttribute("data-flip-id");
  id || el.setAttribute("data-flip-id", id = "auto-" + _id++);
  return id;
}, _elementsFromElementStates = function _elementsFromElementStates2(elStates) {
  return elStates.map(function(elState) {
    return elState.element;
  });
}, _handleCallback = function _handleCallback2(callback, elStates, tl) {
  return callback && elStates.length && tl.add(callback(_elementsFromElementStates(elStates), tl, new FlipState(elStates, 0, true)), 0);
}, _fit = function _fit2(fromState, toState, scale, applyProps, fitChild, vars) {
  var element = fromState.element, cache = fromState.cache, parent = fromState.parent, x = fromState.x, y = fromState.y, width = toState.width, height = toState.height, scaleX = toState.scaleX, scaleY = toState.scaleY, rotation = toState.rotation, bounds = toState.bounds, styles = vars && _getStyleSaver$2 && _getStyleSaver$2(element, "transform"), dimensionState = fromState, _toState$matrix = toState.matrix, e = _toState$matrix.e, f = _toState$matrix.f, deep = fromState.bounds.width !== bounds.width || fromState.bounds.height !== bounds.height || fromState.scaleX !== scaleX || fromState.scaleY !== scaleY || fromState.rotation !== rotation, simple = !deep && fromState.simple && toState.simple && !fitChild, skewX, fromPoint, toPoint, getProp, parentMatrix, matrix, bbox;
  if (simple || !parent) {
    scaleX = scaleY = 1;
    rotation = skewX = 0;
  } else {
    parentMatrix = _getInverseGlobalMatrix(parent);
    matrix = parentMatrix.clone().multiply(toState.ctm ? toState.matrix.clone().multiply(toState.ctm) : toState.matrix);
    rotation = _round$1(Math.atan2(matrix.b, matrix.a) * _RAD2DEG$1);
    skewX = _round$1(Math.atan2(matrix.c, matrix.d) * _RAD2DEG$1 + rotation) % 360;
    scaleX = Math.sqrt(Math.pow(matrix.a, 2) + Math.pow(matrix.b, 2));
    scaleY = Math.sqrt(Math.pow(matrix.c, 2) + Math.pow(matrix.d, 2)) * Math.cos(skewX * _DEG2RAD$1);
    if (fitChild) {
      fitChild = _toArray$2(fitChild)[0];
      getProp = gsap$4.getProperty(fitChild);
      bbox = fitChild.getBBox && typeof fitChild.getBBox === "function" && fitChild.getBBox();
      dimensionState = {
        scaleX: getProp("scaleX"),
        scaleY: getProp("scaleY"),
        width: bbox ? bbox.width : Math.ceil(parseFloat(getProp("width", "px"))),
        height: bbox ? bbox.height : parseFloat(getProp("height", "px"))
      };
    }
    cache.rotation = rotation + "deg";
    cache.skewX = skewX + "deg";
  }
  if (scale) {
    scaleX *= width === dimensionState.width || !dimensionState.width ? 1 : width / dimensionState.width;
    scaleY *= height === dimensionState.height || !dimensionState.height ? 1 : height / dimensionState.height;
    cache.scaleX = scaleX;
    cache.scaleY = scaleY;
  } else {
    width = _closestTenth(width * scaleX / dimensionState.scaleX, 0);
    height = _closestTenth(height * scaleY / dimensionState.scaleY, 0);
    element.style.width = width + "px";
    element.style.height = height + "px";
  }
  applyProps && _applyProps(element, toState.props);
  if (simple || !parent) {
    x += e - fromState.matrix.e;
    y += f - fromState.matrix.f;
  } else if (deep || parent !== toState.parent) {
    cache.renderTransform(1, cache);
    matrix = getGlobalMatrix(fitChild || element, false, false, true);
    fromPoint = parentMatrix.apply({
      x: matrix.e,
      y: matrix.f
    });
    toPoint = parentMatrix.apply({
      x: e,
      y: f
    });
    x += toPoint.x - fromPoint.x;
    y += toPoint.y - fromPoint.y;
  } else {
    parentMatrix.e = parentMatrix.f = 0;
    toPoint = parentMatrix.apply({
      x: e - fromState.matrix.e,
      y: f - fromState.matrix.f
    });
    x += toPoint.x;
    y += toPoint.y;
  }
  x = _closestTenth(x, 0.02);
  y = _closestTenth(y, 0.02);
  if (vars && !(vars instanceof ElementState)) {
    styles && styles.revert();
  } else {
    cache.x = x + "px";
    cache.y = y + "px";
    cache.renderTransform(1, cache);
  }
  if (vars) {
    vars.x = x;
    vars.y = y;
    vars.rotation = rotation;
    vars.skewX = skewX;
    if (scale) {
      vars.scaleX = scaleX;
      vars.scaleY = scaleY;
    } else {
      vars.width = width;
      vars.height = height;
    }
  }
  return vars || cache;
}, _parseState = function _parseState2(targetsOrState, vars) {
  return targetsOrState instanceof FlipState ? targetsOrState : new FlipState(targetsOrState, vars);
}, _getChangingElState = function _getChangingElState2(toState, fromState, id) {
  var to1 = toState.idLookup[id], to2 = toState.alt[id];
  return to2.isVisible && (!(fromState.getElementState(to2.element) || to2).isVisible || !to1.isVisible) ? to2 : to1;
}, _bodyMetrics = [], _bodyProps = "width,height,overflowX,overflowY".split(","), _bodyLocked, _lockBodyScroll = function _lockBodyScroll2(lock) {
  if (lock !== _bodyLocked) {
    var s = _body$2.style, w = _body$2.clientWidth === window.outerWidth, h = _body$2.clientHeight === window.outerHeight, i = 4;
    if (lock && (w || h)) {
      while (i--) {
        _bodyMetrics[i] = s[_bodyProps[i]];
      }
      if (w) {
        s.width = _body$2.clientWidth + "px";
        s.overflowY = "hidden";
      }
      if (h) {
        s.height = _body$2.clientHeight + "px";
        s.overflowX = "hidden";
      }
      _bodyLocked = lock;
    } else if (_bodyLocked) {
      while (i--) {
        _bodyMetrics[i] ? s[_bodyProps[i]] = _bodyMetrics[i] : s.removeProperty(_camelToDashed(_bodyProps[i]));
      }
      _bodyLocked = lock;
    }
  }
}, _fromTo = function _fromTo2(fromState, toState, vars, relative) {
  fromState instanceof FlipState && toState instanceof FlipState || console.warn("Not a valid state object.");
  vars = vars || {};
  var _vars = vars, clearProps2 = _vars.clearProps, onEnter = _vars.onEnter, onLeave = _vars.onLeave, absolute = _vars.absolute, absoluteOnLeave = _vars.absoluteOnLeave, custom = _vars.custom, delay = _vars.delay, paused = _vars.paused, repeat = _vars.repeat, repeatDelay = _vars.repeatDelay, yoyo = _vars.yoyo, toggleClass = _vars.toggleClass, nested = _vars.nested, _zIndex = _vars.zIndex, scale = _vars.scale, fade = _vars.fade, stagger = _vars.stagger, spin = _vars.spin, prune = _vars.prune, props = ("props" in vars ? vars : fromState).props, tweenVars = _copy$1(vars, _reserved), animation = gsap$4.timeline({
    delay,
    paused,
    repeat,
    repeatDelay,
    yoyo,
    data: "isFlip"
  }), remainingProps = tweenVars, entering = [], leaving = [], comps = [], swapOutTargets = [], spinNum = spin === true ? 1 : spin || 0, spinFunc = typeof spin === "function" ? spin : function() {
    return spinNum;
  }, interrupted = fromState.interrupted || toState.interrupted, addFunc = animation[relative !== 1 ? "to" : "from"], v, p, endTime, i, el, comp, state, targets, finalStates, fromNode, toNode, run, a, b;
  for (p in toState.idLookup) {
    toNode = !toState.alt[p] ? toState.idLookup[p] : _getChangingElState(toState, fromState, p);
    el = toNode.element;
    fromNode = fromState.idLookup[p];
    fromState.alt[p] && el === fromNode.element && (fromState.alt[p].isVisible || !toNode.isVisible) && (fromNode = fromState.alt[p]);
    if (fromNode) {
      comp = {
        t: el,
        b: fromNode,
        a: toNode,
        sd: fromNode.element === el ? 0 : toNode.isVisible ? 1 : -1
      };
      comps.push(comp);
      if (comp.sd) {
        if (comp.sd < 0) {
          comp.b = toNode;
          comp.a = fromNode;
        }
        interrupted && _recordInlineStyles(comp.b, props ? _memoizedRemoveProps[props] : _removeProps);
        fade && comps.push(comp.swap = {
          t: fromNode.element,
          b: comp.b,
          a: comp.a,
          sd: -comp.sd,
          swap: comp
        });
      }
      el._flip = fromNode.element._flip = _batch ? _batch.timeline : animation;
    } else if (toNode.isVisible) {
      comps.push({
        t: el,
        b: _copy$1(toNode, {
          isVisible: 1
        }),
        a: toNode,
        sd: 0,
        entering: 1
      });
      el._flip = _batch ? _batch.timeline : animation;
    }
  }
  props && (_memoizedProps[props] || _memoizeProps(props)).forEach(function(p2) {
    return tweenVars[p2] = function(i2) {
      return comps[i2].a.props[p2];
    };
  });
  comps.finalStates = finalStates = [];
  run = function run2() {
    _orderByDOMDepth(comps);
    _lockBodyScroll(true);
    for (i = 0; i < comps.length; i++) {
      comp = comps[i];
      a = comp.a;
      b = comp.b;
      if (prune && !a.isDifferent(b) && !comp.entering) {
        comps.splice(i--, 1);
      } else {
        el = comp.t;
        nested && !(comp.sd < 0) && i && (a.matrix = getGlobalMatrix(el, false, false, true));
        if (b.isVisible && a.isVisible) {
          if (comp.sd < 0) {
            state = new ElementState(el, props, fromState.simple);
            _fit(state, a, scale, 0, 0, state);
            state.matrix = getGlobalMatrix(el, false, false, true);
            state.css = comp.b.css;
            comp.a = a = state;
            fade && (el.style.opacity = interrupted ? b.opacity : a.opacity);
            stagger && swapOutTargets.push(el);
          } else if (comp.sd > 0 && fade) {
            el.style.opacity = interrupted ? a.opacity - b.opacity : "0";
          }
          _fit(a, b, scale, props);
        } else if (b.isVisible !== a.isVisible) {
          if (!b.isVisible) {
            a.isVisible && entering.push(a);
            comps.splice(i--, 1);
          } else if (!a.isVisible) {
            b.css = a.css;
            leaving.push(b);
            comps.splice(i--, 1);
            absolute && nested && _fit(a, b, scale, props);
          }
        }
        if (!scale) {
          el.style.maxWidth = Math.max(a.width, b.width) + "px";
          el.style.maxHeight = Math.max(a.height, b.height) + "px";
          el.style.minWidth = Math.min(a.width, b.width) + "px";
          el.style.minHeight = Math.min(a.height, b.height) + "px";
        }
        nested && toggleClass && el.classList.add(toggleClass);
      }
      finalStates.push(a);
    }
    var classTargets;
    if (toggleClass) {
      classTargets = finalStates.map(function(s) {
        return s.element;
      });
      nested && classTargets.forEach(function(e) {
        return e.classList.remove(toggleClass);
      });
    }
    _lockBodyScroll(false);
    if (scale) {
      tweenVars.scaleX = function(i2) {
        return comps[i2].a.scaleX;
      };
      tweenVars.scaleY = function(i2) {
        return comps[i2].a.scaleY;
      };
    } else {
      tweenVars.width = function(i2) {
        return comps[i2].a.width + "px";
      };
      tweenVars.height = function(i2) {
        return comps[i2].a.height + "px";
      };
      tweenVars.autoRound = vars.autoRound || false;
    }
    tweenVars.x = function(i2) {
      return comps[i2].a.x + "px";
    };
    tweenVars.y = function(i2) {
      return comps[i2].a.y + "px";
    };
    tweenVars.rotation = function(i2) {
      return comps[i2].a.rotation + (spin ? spinFunc(i2, targets[i2], targets) * 360 : 0);
    };
    tweenVars.skewX = function(i2) {
      return comps[i2].a.skewX;
    };
    targets = comps.map(function(c) {
      return c.t;
    });
    if (_zIndex || _zIndex === 0) {
      tweenVars.modifiers = {
        zIndex: function zIndex() {
          return _zIndex;
        }
      };
      tweenVars.zIndex = _zIndex;
      tweenVars.immediateRender = vars.immediateRender !== false;
    }
    fade && (tweenVars.opacity = function(i2) {
      return comps[i2].sd < 0 ? 0 : comps[i2].sd > 0 ? comps[i2].a.opacity : "+=0";
    });
    if (swapOutTargets.length) {
      stagger = gsap$4.utils.distribute(stagger);
      var dummyArray = targets.slice(swapOutTargets.length);
      tweenVars.stagger = function(i2, el2) {
        return stagger(~swapOutTargets.indexOf(el2) ? targets.indexOf(comps[i2].swap.t) : i2, el2, dummyArray);
      };
    }
    _callbacks.forEach(function(name) {
      return vars[name] && animation.eventCallback(name, vars[name], vars[name + "Params"]);
    });
    if (custom && targets.length) {
      remainingProps = _copy$1(tweenVars, _reserved);
      if ("scale" in custom) {
        custom.scaleX = custom.scaleY = custom.scale;
        delete custom.scale;
      }
      for (p in custom) {
        v = _copy$1(custom[p], _fitReserved);
        v[p] = tweenVars[p];
        !("duration" in v) && "duration" in tweenVars && (v.duration = tweenVars.duration);
        v.stagger = tweenVars.stagger;
        addFunc.call(animation, targets, v, 0);
        delete remainingProps[p];
      }
    }
    if (targets.length || leaving.length || entering.length) {
      toggleClass && animation.add(function() {
        return _toggleClass(classTargets, toggleClass, animation._zTime < 0 ? "remove" : "add");
      }, 0) && !paused && _toggleClass(classTargets, toggleClass, "add");
      targets.length && addFunc.call(animation, targets, remainingProps, 0);
    }
    _handleCallback(onEnter, entering, animation);
    _handleCallback(onLeave, leaving, animation);
    var batchTl = _batch && _batch.timeline;
    if (batchTl) {
      batchTl.add(animation, 0);
      _batch._final.push(function() {
        return _setFinalStates(comps, !clearProps2);
      });
    }
    endTime = animation.duration();
    animation.call(function() {
      var forward = animation.time() >= endTime;
      forward && !batchTl && _setFinalStates(comps, !clearProps2);
      toggleClass && _toggleClass(classTargets, toggleClass, forward ? "remove" : "add");
    });
  };
  absoluteOnLeave && (absolute = comps.filter(function(comp2) {
    return !comp2.sd && !comp2.a.isVisible && comp2.b.isVisible;
  }).map(function(comp2) {
    return comp2.a.element;
  }));
  if (_batch) {
    var _batch$_abs;
    absolute && (_batch$_abs = _batch._abs).push.apply(_batch$_abs, _filterComps(comps, absolute));
    _batch._run.push(run);
  } else {
    absolute && _makeCompsAbsolute(_filterComps(comps, absolute));
    run();
  }
  var anim = _batch ? _batch.timeline : animation;
  anim.revert = function() {
    return _killFlip(anim, 1, 1);
  };
  return anim;
}, _interrupt2 = function _interrupt3(tl) {
  tl.vars.onInterrupt && tl.vars.onInterrupt.apply(tl, tl.vars.onInterruptParams || []);
  tl.getChildren(true, false, true).forEach(_interrupt3);
}, _killFlip = function _killFlip2(tl, action, force) {
  if (tl && tl.progress() < 1 && (!tl.paused() || force)) {
    if (action) {
      _interrupt2(tl);
      action < 2 && tl.progress(1);
      tl.kill();
    }
    return true;
  }
}, _createLookup = function _createLookup2(state) {
  var lookup = state.idLookup = {}, alt = state.alt = {}, elStates = state.elementStates, i = elStates.length, elState;
  while (i--) {
    elState = elStates[i];
    lookup[elState.id] ? alt[elState.id] = elState : lookup[elState.id] = elState;
  }
};
var FlipState = /* @__PURE__ */ function() {
  function FlipState2(targets, vars, targetsAreElementStates) {
    this.props = vars && vars.props;
    this.simple = !!(vars && vars.simple);
    if (targetsAreElementStates) {
      this.targets = _elementsFromElementStates(targets);
      this.elementStates = targets;
      _createLookup(this);
    } else {
      this.targets = _toArray$2(targets);
      var soft = vars && (vars.kill === false || vars.batch && !vars.kill);
      _batch && !soft && _batch._kill.push(this);
      this.update(soft || !!_batch);
    }
  }
  var _proto = FlipState2.prototype;
  _proto.update = function update(soft) {
    var _this = this;
    this.elementStates = this.targets.map(function(el) {
      return new ElementState(el, _this.props, _this.simple);
    });
    _createLookup(this);
    this.interrupt(soft);
    this.recordInlineStyles();
    return this;
  };
  _proto.clear = function clear() {
    this.targets.length = this.elementStates.length = 0;
    _createLookup(this);
    return this;
  };
  _proto.fit = function fit(state, scale, nested) {
    var elStatesInOrder = _orderByDOMDepth(this.elementStates.slice(0), false, true), toElStates = (state || this).idLookup, i = 0, fromNode, toNode;
    for (; i < elStatesInOrder.length; i++) {
      fromNode = elStatesInOrder[i];
      nested && (fromNode.matrix = getGlobalMatrix(fromNode.element, false, false, true));
      toNode = toElStates[fromNode.id];
      toNode && _fit(fromNode, toNode, scale, true, 0, fromNode);
      fromNode.matrix = getGlobalMatrix(fromNode.element, false, false, true);
    }
    return this;
  };
  _proto.getProperty = function getProperty3(element, property) {
    var es = this.getElementState(element) || _emptyObj;
    return (property in es ? es : es.props || _emptyObj)[property];
  };
  _proto.add = function add(state) {
    var i = state.targets.length, lookup = this.idLookup, alt = this.alt, index, es, es2;
    while (i--) {
      es = state.elementStates[i];
      es2 = lookup[es.id];
      if (es2 && (es.element === es2.element || alt[es.id] && alt[es.id].element === es.element)) {
        index = this.elementStates.indexOf(es.element === es2.element ? es2 : alt[es.id]);
        this.targets.splice(index, 1, state.targets[i]);
        this.elementStates.splice(index, 1, es);
      } else {
        this.targets.push(state.targets[i]);
        this.elementStates.push(es);
      }
    }
    state.interrupted && (this.interrupted = true);
    state.simple || (this.simple = false);
    _createLookup(this);
    return this;
  };
  _proto.compare = function compare(state) {
    var l1 = state.idLookup, l2 = this.idLookup, unchanged = [], changed = [], enter = [], leave = [], targets = [], a1 = state.alt, a2 = this.alt, place = function place2(s12, s22, el2) {
      return (s12.isVisible !== s22.isVisible ? s12.isVisible ? enter : leave : s12.isVisible ? changed : unchanged).push(el2) && targets.push(el2);
    }, placeIfDoesNotExist = function placeIfDoesNotExist2(s12, s22, el2) {
      return targets.indexOf(el2) < 0 && place(s12, s22, el2);
    }, s1, s2, p, el, s1Alt, s2Alt, c1, c2;
    for (p in l1) {
      s1Alt = a1[p];
      s2Alt = a2[p];
      s1 = !s1Alt ? l1[p] : _getChangingElState(state, this, p);
      el = s1.element;
      s2 = l2[p];
      if (s2Alt) {
        c2 = s2.isVisible || !s2Alt.isVisible && el === s2.element ? s2 : s2Alt;
        c1 = s1Alt && !s1.isVisible && !s1Alt.isVisible && c2.element === s1Alt.element ? s1Alt : s1;
        if (c1.isVisible && c2.isVisible && c1.element !== c2.element) {
          (c1.isDifferent(c2) ? changed : unchanged).push(c1.element, c2.element);
          targets.push(c1.element, c2.element);
        } else {
          place(c1, c2, c1.element);
        }
        s1Alt && c1.element === s1Alt.element && (s1Alt = l1[p]);
        placeIfDoesNotExist(c1.element !== s2.element && s1Alt ? s1Alt : c1, s2, s2.element);
        placeIfDoesNotExist(s1Alt && s1Alt.element === s2Alt.element ? s1Alt : c1, s2Alt, s2Alt.element);
        s1Alt && placeIfDoesNotExist(s1Alt, s2Alt.element === s1Alt.element ? s2Alt : s2, s1Alt.element);
      } else {
        !s2 ? enter.push(el) : !s2.isDifferent(s1) ? unchanged.push(el) : place(s1, s2, el);
        s1Alt && placeIfDoesNotExist(s1Alt, s2, s1Alt.element);
      }
    }
    for (p in l2) {
      if (!l1[p]) {
        leave.push(l2[p].element);
        a2[p] && leave.push(a2[p].element);
      }
    }
    return {
      changed,
      unchanged,
      enter,
      leave
    };
  };
  _proto.recordInlineStyles = function recordInlineStyles() {
    var props = _memoizedRemoveProps[this.props] || _removeProps, i = this.elementStates.length;
    while (i--) {
      _recordInlineStyles(this.elementStates[i], props);
    }
  };
  _proto.interrupt = function interrupt(soft) {
    var _this2 = this;
    var timelines = [];
    this.targets.forEach(function(t) {
      var tl = t._flip, foundInProgress = _killFlip(tl, soft ? 0 : 1);
      soft && foundInProgress && timelines.indexOf(tl) < 0 && tl.add(function() {
        return _this2.updateVisibility();
      });
      foundInProgress && timelines.push(tl);
    });
    !soft && timelines.length && this.updateVisibility();
    this.interrupted || (this.interrupted = !!timelines.length);
  };
  _proto.updateVisibility = function updateVisibility() {
    this.elementStates.forEach(function(es) {
      var b = es.element.getBoundingClientRect();
      es.isVisible = !!(b.width || b.height || b.top || b.left);
      es.uncache = 1;
    });
  };
  _proto.getElementState = function getElementState(element) {
    return this.elementStates[this.targets.indexOf(_getEl(element))];
  };
  _proto.makeAbsolute = function makeAbsolute() {
    return _orderByDOMDepth(this.elementStates.slice(0), true, true).map(_makeAbsolute);
  };
  return FlipState2;
}();
var ElementState = /* @__PURE__ */ function() {
  function ElementState2(element, props, simple) {
    this.element = element;
    this.update(props, simple);
  }
  var _proto2 = ElementState2.prototype;
  _proto2.isDifferent = function isDifferent(state) {
    var b1 = this.bounds, b2 = state.bounds;
    return b1.top !== b2.top || b1.left !== b2.left || b1.width !== b2.width || b1.height !== b2.height || !this.matrix.equals(state.matrix) || this.opacity !== state.opacity || this.props && state.props && JSON.stringify(this.props) !== JSON.stringify(state.props);
  };
  _proto2.update = function update(props, simple) {
    var self2 = this, element = self2.element, getProp = gsap$4.getProperty(element), cache = gsap$4.core.getCache(element), bounds = element.getBoundingClientRect(), bbox = element.getBBox && typeof element.getBBox === "function" && element.nodeName.toLowerCase() !== "svg" && element.getBBox(), m = simple ? new Matrix2D(1, 0, 0, 1, bounds.left + _getDocScrollLeft$1(), bounds.top + _getDocScrollTop$1()) : getGlobalMatrix(element, false, false, true);
    self2.getProp = getProp;
    self2.element = element;
    self2.id = _getID(element);
    self2.matrix = m;
    self2.cache = cache;
    self2.bounds = bounds;
    self2.isVisible = !!(bounds.width || bounds.height || bounds.left || bounds.top);
    self2.display = getProp("display");
    self2.position = getProp("position");
    self2.parent = element.parentNode;
    self2.x = getProp("x");
    self2.y = getProp("y");
    self2.scaleX = cache.scaleX;
    self2.scaleY = cache.scaleY;
    self2.rotation = getProp("rotation");
    self2.skewX = getProp("skewX");
    self2.opacity = getProp("opacity");
    self2.width = bbox ? bbox.width : _closestTenth(getProp("width", "px"), 0.04);
    self2.height = bbox ? bbox.height : _closestTenth(getProp("height", "px"), 0.04);
    props && _recordProps(self2, _memoizedProps[props] || _memoizeProps(props));
    self2.ctm = element.getCTM && element.nodeName.toLowerCase() === "svg" && _getCTM(element).inverse();
    self2.simple = simple || _round$1(m.a) === 1 && !_round$1(m.b) && !_round$1(m.c) && _round$1(m.d) === 1;
    self2.uncache = 0;
  };
  return ElementState2;
}();
var FlipAction = /* @__PURE__ */ function() {
  function FlipAction2(vars, batch) {
    this.vars = vars;
    this.batch = batch;
    this.states = [];
    this.timeline = batch.timeline;
  }
  var _proto3 = FlipAction2.prototype;
  _proto3.getStateById = function getStateById(id) {
    var i = this.states.length;
    while (i--) {
      if (this.states[i].idLookup[id]) {
        return this.states[i];
      }
    }
  };
  _proto3.kill = function kill() {
    this.batch.remove(this);
  };
  return FlipAction2;
}();
var FlipBatch = /* @__PURE__ */ function() {
  function FlipBatch2(id) {
    this.id = id;
    this.actions = [];
    this._kill = [];
    this._final = [];
    this._abs = [];
    this._run = [];
    this.data = {};
    this.state = new FlipState();
    this.timeline = gsap$4.timeline();
  }
  var _proto4 = FlipBatch2.prototype;
  _proto4.add = function add(config3) {
    var result = this.actions.filter(function(action) {
      return action.vars === config3;
    });
    if (result.length) {
      return result[0];
    }
    result = new FlipAction(typeof config3 === "function" ? {
      animate: config3
    } : config3, this);
    this.actions.push(result);
    return result;
  };
  _proto4.remove = function remove2(action) {
    var i = this.actions.indexOf(action);
    i >= 0 && this.actions.splice(i, 1);
    return this;
  };
  _proto4.getState = function getState(merge) {
    var _this3 = this;
    var prevBatch = _batch, prevAction = _batchAction;
    _batch = this;
    this.state.clear();
    this._kill.length = 0;
    this.actions.forEach(function(action) {
      if (action.vars.getState) {
        action.states.length = 0;
        _batchAction = action;
        action.state = action.vars.getState(action);
      }
      merge && action.states.forEach(function(s) {
        return _this3.state.add(s);
      });
    });
    _batchAction = prevAction;
    _batch = prevBatch;
    this.killConflicts();
    return this;
  };
  _proto4.animate = function animate() {
    var _this4 = this;
    var prevBatch = _batch, tl = this.timeline, i = this.actions.length, finalStates, endTime;
    _batch = this;
    tl.clear();
    this._abs.length = this._final.length = this._run.length = 0;
    this.actions.forEach(function(a) {
      a.vars.animate && a.vars.animate(a);
      var onEnter = a.vars.onEnter, onLeave = a.vars.onLeave, targets = a.targets, s, result;
      if (targets && targets.length && (onEnter || onLeave)) {
        s = new FlipState();
        a.states.forEach(function(state) {
          return s.add(state);
        });
        result = s.compare(Flip.getState(targets));
        result.enter.length && onEnter && onEnter(result.enter);
        result.leave.length && onLeave && onLeave(result.leave);
      }
    });
    _makeCompsAbsolute(this._abs);
    this._run.forEach(function(f) {
      return f();
    });
    endTime = tl.duration();
    finalStates = this._final.slice(0);
    tl.add(function() {
      if (endTime <= tl.time()) {
        finalStates.forEach(function(f) {
          return f();
        });
        _forEachBatch(_this4, "onComplete");
      }
    });
    _batch = prevBatch;
    while (i--) {
      this.actions[i].vars.once && this.actions[i].kill();
    }
    _forEachBatch(this, "onStart");
    tl.restart();
    return this;
  };
  _proto4.loadState = function loadState(done) {
    done || (done = function done2() {
      return 0;
    });
    var queue = [];
    this.actions.forEach(function(c) {
      if (c.vars.loadState) {
        var i, f = function f2(targets) {
          targets && (c.targets = targets);
          i = queue.indexOf(f2);
          if (~i) {
            queue.splice(i, 1);
            queue.length || done();
          }
        };
        queue.push(f);
        c.vars.loadState(f);
      }
    });
    queue.length || done();
    return this;
  };
  _proto4.setState = function setState() {
    this.actions.forEach(function(c) {
      return c.targets = c.vars.setState && c.vars.setState(c);
    });
    return this;
  };
  _proto4.killConflicts = function killConflicts(soft) {
    this.state.interrupt(soft);
    this._kill.forEach(function(state) {
      return state.interrupt(soft);
    });
    return this;
  };
  _proto4.run = function run(skipGetState, merge) {
    var _this5 = this;
    if (this !== _batch) {
      skipGetState || this.getState(merge);
      this.loadState(function() {
        if (!_this5._killed) {
          _this5.setState();
          _this5.animate();
        }
      });
    }
    return this;
  };
  _proto4.clear = function clear(stateOnly) {
    this.state.clear();
    stateOnly || (this.actions.length = 0);
  };
  _proto4.getStateById = function getStateById(id) {
    var i = this.actions.length, s;
    while (i--) {
      s = this.actions[i].getStateById(id);
      if (s) {
        return s;
      }
    }
    return this.state.idLookup[id] && this.state;
  };
  _proto4.kill = function kill() {
    this._killed = 1;
    this.clear();
    delete _batchLookup[this.id];
  };
  return FlipBatch2;
}();
var Flip = /* @__PURE__ */ function() {
  function Flip2() {
  }
  Flip2.getState = function getState(targets, vars) {
    var state = _parseState(targets, vars);
    _batchAction && _batchAction.states.push(state);
    vars && vars.batch && Flip2.batch(vars.batch).state.add(state);
    return state;
  };
  Flip2.from = function from(state, vars) {
    vars = vars || {};
    "clearProps" in vars || (vars.clearProps = true);
    return _fromTo(state, _parseState(vars.targets || state.targets, {
      props: vars.props || state.props,
      simple: vars.simple,
      kill: !!vars.kill
    }), vars, -1);
  };
  Flip2.to = function to(state, vars) {
    return _fromTo(state, _parseState(vars.targets || state.targets, {
      props: vars.props || state.props,
      simple: vars.simple,
      kill: !!vars.kill
    }), vars, 1);
  };
  Flip2.fromTo = function fromTo(fromState, toState, vars) {
    return _fromTo(fromState, toState, vars);
  };
  Flip2.fit = function fit(fromEl, toEl, vars) {
    var v = vars ? _copy$1(vars, _fitReserved) : {}, _ref = vars || v, absolute = _ref.absolute, scale = _ref.scale, getVars = _ref.getVars, props = _ref.props, runBackwards = _ref.runBackwards, onComplete = _ref.onComplete, simple = _ref.simple, fitChild = vars && vars.fitChild && _getEl(vars.fitChild), before = _parseElementState(toEl, props, simple, fromEl), after = _parseElementState(fromEl, 0, simple, before), inlineProps = props ? _memoizedRemoveProps[props] : _removeProps, ctx = gsap$4.context();
    props && _applyProps(v, before.props);
    _recordInlineStyles(after, inlineProps);
    if (runBackwards) {
      "immediateRender" in v || (v.immediateRender = true);
      v.onComplete = function() {
        _applyInlineStyles(after);
        onComplete && onComplete.apply(this, arguments);
      };
    }
    absolute && _makeAbsolute(after, before);
    v = _fit(after, before, scale || fitChild, props, fitChild, v.duration || getVars ? v : 0);
    ctx && !getVars && ctx.add(function() {
      return function() {
        return _applyInlineStyles(after);
      };
    });
    return getVars ? v : v.duration ? gsap$4.to(after.element, v) : null;
  };
  Flip2.makeAbsolute = function makeAbsolute(targetsOrStates, vars) {
    return (targetsOrStates instanceof FlipState ? targetsOrStates : new FlipState(targetsOrStates, vars)).makeAbsolute();
  };
  Flip2.batch = function batch(id) {
    id || (id = "default");
    return _batchLookup[id] || (_batchLookup[id] = new FlipBatch(id));
  };
  Flip2.killFlipsOf = function killFlipsOf(targets, complete) {
    (targets instanceof FlipState ? targets.targets : _toArray$2(targets)).forEach(function(t) {
      return t && _killFlip(t._flip, complete !== false ? 1 : 2);
    });
  };
  Flip2.isFlipping = function isFlipping(target) {
    var f = Flip2.getByTarget(target);
    return !!f && f.isActive();
  };
  Flip2.getByTarget = function getByTarget(target) {
    return (_getEl(target) || _emptyObj)._flip;
  };
  Flip2.getElementState = function getElementState(target, props) {
    return new ElementState(_getEl(target), props);
  };
  Flip2.convertCoordinates = function convertCoordinates2(fromElement, toElement, point) {
    var m = getGlobalMatrix(toElement, true, true).multiply(getGlobalMatrix(fromElement));
    return point ? m.apply(point) : m;
  };
  Flip2.register = function register2(core) {
    _body$2 = typeof document !== "undefined" && document.body;
    if (_body$2) {
      gsap$4 = core;
      _setDoc(_body$2);
      _toArray$2 = gsap$4.utils.toArray;
      _getStyleSaver$2 = gsap$4.core.getStyleSaver;
      var snap3 = gsap$4.utils.snap(0.1);
      _closestTenth = function _closestTenth2(value, add) {
        return snap3(parseFloat(value) + add);
      };
    }
  };
  return Flip2;
}();
Flip.version = "3.12.5";
typeof window !== "undefined" && window.gsap && window.gsap.registerPlugin(Flip);
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties(Constructor, staticProps);
  return Constructor;
}
/*!
 * Observer 3.12.5
 * https://gsap.com
 *
 * @license Copyright 2008-2024, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license or for
 * Club GSAP members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/
var gsap$3, _coreInitted$1, _win$1, _doc$1, _docEl, _body$1, _isTouch, _pointerType, ScrollTrigger, _root, _normalizer, _eventTypes, _context$1, _getGSAP$3 = function _getGSAP2() {
  return gsap$3 || typeof window !== "undefined" && (gsap$3 = window.gsap) && gsap$3.registerPlugin && gsap$3;
}, _startup = 1, _observers = [], _scrollers = [], _proxies = [], _getTime$1 = Date.now, _bridge = function _bridge2(name, value) {
  return value;
}, _integrate = function _integrate2() {
  var core = ScrollTrigger.core, data = core.bridge || {}, scrollers = core._scrollers, proxies = core._proxies;
  scrollers.push.apply(scrollers, _scrollers);
  proxies.push.apply(proxies, _proxies);
  _scrollers = scrollers;
  _proxies = proxies;
  _bridge = function _bridge3(name, value) {
    return data[name](value);
  };
}, _getProxyProp = function _getProxyProp2(element, property) {
  return ~_proxies.indexOf(element) && _proxies[_proxies.indexOf(element) + 1][property];
}, _isViewport = function _isViewport2(el) {
  return !!~_root.indexOf(el);
}, _addListener$1 = function _addListener(element, type, func, passive, capture) {
  return element.addEventListener(type, func, {
    passive: passive !== false,
    capture: !!capture
  });
}, _removeListener$1 = function _removeListener(element, type, func, capture) {
  return element.removeEventListener(type, func, !!capture);
}, _scrollLeft = "scrollLeft", _scrollTop = "scrollTop", _onScroll = function _onScroll2() {
  return _normalizer && _normalizer.isPressed || _scrollers.cache++;
}, _scrollCacheFunc = function _scrollCacheFunc2(f, doNotCache) {
  var cachingFunc = function cachingFunc2(value) {
    if (value || value === 0) {
      _startup && (_win$1.history.scrollRestoration = "manual");
      var isNormalizing = _normalizer && _normalizer.isPressed;
      value = cachingFunc2.v = Math.round(value) || (_normalizer && _normalizer.iOS ? 1 : 0);
      f(value);
      cachingFunc2.cacheID = _scrollers.cache;
      isNormalizing && _bridge("ss", value);
    } else if (doNotCache || _scrollers.cache !== cachingFunc2.cacheID || _bridge("ref")) {
      cachingFunc2.cacheID = _scrollers.cache;
      cachingFunc2.v = f();
    }
    return cachingFunc2.v + cachingFunc2.offset;
  };
  cachingFunc.offset = 0;
  return f && cachingFunc;
}, _horizontal = {
  s: _scrollLeft,
  p: "left",
  p2: "Left",
  os: "right",
  os2: "Right",
  d: "width",
  d2: "Width",
  a: "x",
  sc: _scrollCacheFunc(function(value) {
    return arguments.length ? _win$1.scrollTo(value, _vertical.sc()) : _win$1.pageXOffset || _doc$1[_scrollLeft] || _docEl[_scrollLeft] || _body$1[_scrollLeft] || 0;
  })
}, _vertical = {
  s: _scrollTop,
  p: "top",
  p2: "Top",
  os: "bottom",
  os2: "Bottom",
  d: "height",
  d2: "Height",
  a: "y",
  op: _horizontal,
  sc: _scrollCacheFunc(function(value) {
    return arguments.length ? _win$1.scrollTo(_horizontal.sc(), value) : _win$1.pageYOffset || _doc$1[_scrollTop] || _docEl[_scrollTop] || _body$1[_scrollTop] || 0;
  })
}, _getTarget = function _getTarget2(t, self2) {
  return (self2 && self2._ctx && self2._ctx.selector || gsap$3.utils.toArray)(t)[0] || (typeof t === "string" && gsap$3.config().nullTargetWarn !== false ? console.warn("Element not found:", t) : null);
}, _getScrollFunc = function _getScrollFunc2(element, _ref) {
  var s = _ref.s, sc = _ref.sc;
  _isViewport(element) && (element = _doc$1.scrollingElement || _docEl);
  var i = _scrollers.indexOf(element), offset = sc === _vertical.sc ? 1 : 2;
  !~i && (i = _scrollers.push(element) - 1);
  _scrollers[i + offset] || _addListener$1(element, "scroll", _onScroll);
  var prev = _scrollers[i + offset], func = prev || (_scrollers[i + offset] = _scrollCacheFunc(_getProxyProp(element, s), true) || (_isViewport(element) ? sc : _scrollCacheFunc(function(value) {
    return arguments.length ? element[s] = value : element[s];
  })));
  func.target = element;
  prev || (func.smooth = gsap$3.getProperty(element, "scrollBehavior") === "smooth");
  return func;
}, _getVelocityProp = function _getVelocityProp2(value, minTimeRefresh, useDelta) {
  var v1 = value, v2 = value, t1 = _getTime$1(), t2 = t1, min = minTimeRefresh || 50, dropToZeroTime = Math.max(500, min * 3), update = function update2(value2, force) {
    var t = _getTime$1();
    if (force || t - t1 > min) {
      v2 = v1;
      v1 = value2;
      t2 = t1;
      t1 = t;
    } else if (useDelta) {
      v1 += value2;
    } else {
      v1 = v2 + (value2 - v2) / (t - t2) * (t1 - t2);
    }
  }, reset = function reset2() {
    v2 = v1 = useDelta ? 0 : v1;
    t2 = t1 = 0;
  }, getVelocity = function getVelocity2(latestValue) {
    var tOld = t2, vOld = v2, t = _getTime$1();
    (latestValue || latestValue === 0) && latestValue !== v1 && update(latestValue);
    return t1 === t2 || t - t2 > dropToZeroTime ? 0 : (v1 + (useDelta ? vOld : -vOld)) / ((useDelta ? t : t1) - tOld) * 1e3;
  };
  return {
    update,
    reset,
    getVelocity
  };
}, _getEvent = function _getEvent2(e, preventDefault) {
  preventDefault && !e._gsapAllow && e.preventDefault();
  return e.changedTouches ? e.changedTouches[0] : e;
}, _getAbsoluteMax = function _getAbsoluteMax2(a) {
  var max = Math.max.apply(Math, a), min = Math.min.apply(Math, a);
  return Math.abs(max) >= Math.abs(min) ? max : min;
}, _setScrollTrigger = function _setScrollTrigger2() {
  ScrollTrigger = gsap$3.core.globals().ScrollTrigger;
  ScrollTrigger && ScrollTrigger.core && _integrate();
}, _initCore$1 = function _initCore3(core) {
  gsap$3 = core || _getGSAP$3();
  if (!_coreInitted$1 && gsap$3 && typeof document !== "undefined" && document.body) {
    _win$1 = window;
    _doc$1 = document;
    _docEl = _doc$1.documentElement;
    _body$1 = _doc$1.body;
    _root = [_win$1, _doc$1, _docEl, _body$1];
    gsap$3.utils.clamp;
    _context$1 = gsap$3.core.context || function() {
    };
    _pointerType = "onpointerenter" in _body$1 ? "pointer" : "mouse";
    _isTouch = Observer$1.isTouch = _win$1.matchMedia && _win$1.matchMedia("(hover: none), (pointer: coarse)").matches ? 1 : "ontouchstart" in _win$1 || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0 ? 2 : 0;
    _eventTypes = Observer$1.eventTypes = ("ontouchstart" in _docEl ? "touchstart,touchmove,touchcancel,touchend" : !("onpointerdown" in _docEl) ? "mousedown,mousemove,mouseup,mouseup" : "pointerdown,pointermove,pointercancel,pointerup").split(",");
    setTimeout(function() {
      return _startup = 0;
    }, 500);
    _setScrollTrigger();
    _coreInitted$1 = 1;
  }
  return _coreInitted$1;
};
_horizontal.op = _vertical;
_scrollers.cache = 0;
var Observer$1 = /* @__PURE__ */ function() {
  function Observer2(vars) {
    this.init(vars);
  }
  var _proto = Observer2.prototype;
  _proto.init = function init6(vars) {
    _coreInitted$1 || _initCore$1(gsap$3) || console.warn("Please gsap.registerPlugin(Observer)");
    ScrollTrigger || _setScrollTrigger();
    var tolerance = vars.tolerance, dragMinimum = vars.dragMinimum, type = vars.type, target = vars.target, lineHeight = vars.lineHeight, debounce = vars.debounce, preventDefault = vars.preventDefault, onStop = vars.onStop, onStopDelay = vars.onStopDelay, ignore = vars.ignore, wheelSpeed = vars.wheelSpeed, event = vars.event, onDragStart = vars.onDragStart, onDragEnd = vars.onDragEnd, onDrag = vars.onDrag, onPress = vars.onPress, onRelease = vars.onRelease, onRight = vars.onRight, onLeft = vars.onLeft, onUp = vars.onUp, onDown = vars.onDown, onChangeX = vars.onChangeX, onChangeY = vars.onChangeY, onChange = vars.onChange, onToggleX = vars.onToggleX, onToggleY = vars.onToggleY, onHover = vars.onHover, onHoverEnd = vars.onHoverEnd, onMove = vars.onMove, ignoreCheck = vars.ignoreCheck, isNormalizer = vars.isNormalizer, onGestureStart = vars.onGestureStart, onGestureEnd = vars.onGestureEnd, onWheel = vars.onWheel, onEnable = vars.onEnable, onDisable = vars.onDisable, onClick = vars.onClick, scrollSpeed = vars.scrollSpeed, capture = vars.capture, allowClicks = vars.allowClicks, lockAxis = vars.lockAxis, onLockAxis = vars.onLockAxis;
    this.target = target = _getTarget(target) || _docEl;
    this.vars = vars;
    ignore && (ignore = gsap$3.utils.toArray(ignore));
    tolerance = tolerance || 1e-9;
    dragMinimum = dragMinimum || 0;
    wheelSpeed = wheelSpeed || 1;
    scrollSpeed = scrollSpeed || 1;
    type = type || "wheel,touch,pointer";
    debounce = debounce !== false;
    lineHeight || (lineHeight = parseFloat(_win$1.getComputedStyle(_body$1).lineHeight) || 22);
    var id, onStopDelayedCall, dragged, moved, wheeled, locked, axis, self2 = this, prevDeltaX = 0, prevDeltaY = 0, passive = vars.passive || !preventDefault, scrollFuncX = _getScrollFunc(target, _horizontal), scrollFuncY = _getScrollFunc(target, _vertical), scrollX = scrollFuncX(), scrollY = scrollFuncY(), limitToTouch = ~type.indexOf("touch") && !~type.indexOf("pointer") && _eventTypes[0] === "pointerdown", isViewport = _isViewport(target), ownerDoc = target.ownerDocument || _doc$1, deltaX = [0, 0, 0], deltaY = [0, 0, 0], onClickTime = 0, clickCapture = function clickCapture2() {
      return onClickTime = _getTime$1();
    }, _ignoreCheck = function _ignoreCheck2(e, isPointerOrTouch) {
      return (self2.event = e) && ignore && ~ignore.indexOf(e.target) || isPointerOrTouch && limitToTouch && e.pointerType !== "touch" || ignoreCheck && ignoreCheck(e, isPointerOrTouch);
    }, onStopFunc = function onStopFunc2() {
      self2._vx.reset();
      self2._vy.reset();
      onStopDelayedCall.pause();
      onStop && onStop(self2);
    }, update = function update2() {
      var dx = self2.deltaX = _getAbsoluteMax(deltaX), dy = self2.deltaY = _getAbsoluteMax(deltaY), changedX = Math.abs(dx) >= tolerance, changedY = Math.abs(dy) >= tolerance;
      onChange && (changedX || changedY) && onChange(self2, dx, dy, deltaX, deltaY);
      if (changedX) {
        onRight && self2.deltaX > 0 && onRight(self2);
        onLeft && self2.deltaX < 0 && onLeft(self2);
        onChangeX && onChangeX(self2);
        onToggleX && self2.deltaX < 0 !== prevDeltaX < 0 && onToggleX(self2);
        prevDeltaX = self2.deltaX;
        deltaX[0] = deltaX[1] = deltaX[2] = 0;
      }
      if (changedY) {
        onDown && self2.deltaY > 0 && onDown(self2);
        onUp && self2.deltaY < 0 && onUp(self2);
        onChangeY && onChangeY(self2);
        onToggleY && self2.deltaY < 0 !== prevDeltaY < 0 && onToggleY(self2);
        prevDeltaY = self2.deltaY;
        deltaY[0] = deltaY[1] = deltaY[2] = 0;
      }
      if (moved || dragged) {
        onMove && onMove(self2);
        if (dragged) {
          onDrag(self2);
          dragged = false;
        }
        moved = false;
      }
      locked && !(locked = false) && onLockAxis && onLockAxis(self2);
      if (wheeled) {
        onWheel(self2);
        wheeled = false;
      }
      id = 0;
    }, onDelta = function onDelta2(x, y, index) {
      deltaX[index] += x;
      deltaY[index] += y;
      self2._vx.update(x);
      self2._vy.update(y);
      debounce ? id || (id = requestAnimationFrame(update)) : update();
    }, onTouchOrPointerDelta = function onTouchOrPointerDelta2(x, y) {
      if (lockAxis && !axis) {
        self2.axis = axis = Math.abs(x) > Math.abs(y) ? "x" : "y";
        locked = true;
      }
      if (axis !== "y") {
        deltaX[2] += x;
        self2._vx.update(x, true);
      }
      if (axis !== "x") {
        deltaY[2] += y;
        self2._vy.update(y, true);
      }
      debounce ? id || (id = requestAnimationFrame(update)) : update();
    }, _onDrag = function _onDrag2(e) {
      if (_ignoreCheck(e, 1)) {
        return;
      }
      e = _getEvent(e, preventDefault);
      var x = e.clientX, y = e.clientY, dx = x - self2.x, dy = y - self2.y, isDragging = self2.isDragging;
      self2.x = x;
      self2.y = y;
      if (isDragging || Math.abs(self2.startX - x) >= dragMinimum || Math.abs(self2.startY - y) >= dragMinimum) {
        onDrag && (dragged = true);
        isDragging || (self2.isDragging = true);
        onTouchOrPointerDelta(dx, dy);
        isDragging || onDragStart && onDragStart(self2);
      }
    }, _onPress = self2.onPress = function(e) {
      if (_ignoreCheck(e, 1) || e && e.button) {
        return;
      }
      self2.axis = axis = null;
      onStopDelayedCall.pause();
      self2.isPressed = true;
      e = _getEvent(e);
      prevDeltaX = prevDeltaY = 0;
      self2.startX = self2.x = e.clientX;
      self2.startY = self2.y = e.clientY;
      self2._vx.reset();
      self2._vy.reset();
      _addListener$1(isNormalizer ? target : ownerDoc, _eventTypes[1], _onDrag, passive, true);
      self2.deltaX = self2.deltaY = 0;
      onPress && onPress(self2);
    }, _onRelease = self2.onRelease = function(e) {
      if (_ignoreCheck(e, 1)) {
        return;
      }
      _removeListener$1(isNormalizer ? target : ownerDoc, _eventTypes[1], _onDrag, true);
      var isTrackingDrag = !isNaN(self2.y - self2.startY), wasDragging = self2.isDragging, isDragNotClick = wasDragging && (Math.abs(self2.x - self2.startX) > 3 || Math.abs(self2.y - self2.startY) > 3), eventData = _getEvent(e);
      if (!isDragNotClick && isTrackingDrag) {
        self2._vx.reset();
        self2._vy.reset();
        if (preventDefault && allowClicks) {
          gsap$3.delayedCall(0.08, function() {
            if (_getTime$1() - onClickTime > 300 && !e.defaultPrevented) {
              if (e.target.click) {
                e.target.click();
              } else if (ownerDoc.createEvent) {
                var syntheticEvent = ownerDoc.createEvent("MouseEvents");
                syntheticEvent.initMouseEvent("click", true, true, _win$1, 1, eventData.screenX, eventData.screenY, eventData.clientX, eventData.clientY, false, false, false, false, 0, null);
                e.target.dispatchEvent(syntheticEvent);
              }
            }
          });
        }
      }
      self2.isDragging = self2.isGesturing = self2.isPressed = false;
      onStop && wasDragging && !isNormalizer && onStopDelayedCall.restart(true);
      onDragEnd && wasDragging && onDragEnd(self2);
      onRelease && onRelease(self2, isDragNotClick);
    }, _onGestureStart = function _onGestureStart2(e) {
      return e.touches && e.touches.length > 1 && (self2.isGesturing = true) && onGestureStart(e, self2.isDragging);
    }, _onGestureEnd = function _onGestureEnd2() {
      return (self2.isGesturing = false) || onGestureEnd(self2);
    }, onScroll = function onScroll2(e) {
      if (_ignoreCheck(e)) {
        return;
      }
      var x = scrollFuncX(), y = scrollFuncY();
      onDelta((x - scrollX) * scrollSpeed, (y - scrollY) * scrollSpeed, 1);
      scrollX = x;
      scrollY = y;
      onStop && onStopDelayedCall.restart(true);
    }, _onWheel = function _onWheel2(e) {
      if (_ignoreCheck(e)) {
        return;
      }
      e = _getEvent(e, preventDefault);
      onWheel && (wheeled = true);
      var multiplier = (e.deltaMode === 1 ? lineHeight : e.deltaMode === 2 ? _win$1.innerHeight : 1) * wheelSpeed;
      onDelta(e.deltaX * multiplier, e.deltaY * multiplier, 0);
      onStop && !isNormalizer && onStopDelayedCall.restart(true);
    }, _onMove = function _onMove2(e) {
      if (_ignoreCheck(e)) {
        return;
      }
      var x = e.clientX, y = e.clientY, dx = x - self2.x, dy = y - self2.y;
      self2.x = x;
      self2.y = y;
      moved = true;
      onStop && onStopDelayedCall.restart(true);
      (dx || dy) && onTouchOrPointerDelta(dx, dy);
    }, _onHover = function _onHover2(e) {
      self2.event = e;
      onHover(self2);
    }, _onHoverEnd = function _onHoverEnd2(e) {
      self2.event = e;
      onHoverEnd(self2);
    }, _onClick = function _onClick2(e) {
      return _ignoreCheck(e) || _getEvent(e, preventDefault) && onClick(self2);
    };
    onStopDelayedCall = self2._dc = gsap$3.delayedCall(onStopDelay || 0.25, onStopFunc).pause();
    self2.deltaX = self2.deltaY = 0;
    self2._vx = _getVelocityProp(0, 50, true);
    self2._vy = _getVelocityProp(0, 50, true);
    self2.scrollX = scrollFuncX;
    self2.scrollY = scrollFuncY;
    self2.isDragging = self2.isGesturing = self2.isPressed = false;
    _context$1(this);
    self2.enable = function(e) {
      if (!self2.isEnabled) {
        _addListener$1(isViewport ? ownerDoc : target, "scroll", _onScroll);
        type.indexOf("scroll") >= 0 && _addListener$1(isViewport ? ownerDoc : target, "scroll", onScroll, passive, capture);
        type.indexOf("wheel") >= 0 && _addListener$1(target, "wheel", _onWheel, passive, capture);
        if (type.indexOf("touch") >= 0 && _isTouch || type.indexOf("pointer") >= 0) {
          _addListener$1(target, _eventTypes[0], _onPress, passive, capture);
          _addListener$1(ownerDoc, _eventTypes[2], _onRelease);
          _addListener$1(ownerDoc, _eventTypes[3], _onRelease);
          allowClicks && _addListener$1(target, "click", clickCapture, true, true);
          onClick && _addListener$1(target, "click", _onClick);
          onGestureStart && _addListener$1(ownerDoc, "gesturestart", _onGestureStart);
          onGestureEnd && _addListener$1(ownerDoc, "gestureend", _onGestureEnd);
          onHover && _addListener$1(target, _pointerType + "enter", _onHover);
          onHoverEnd && _addListener$1(target, _pointerType + "leave", _onHoverEnd);
          onMove && _addListener$1(target, _pointerType + "move", _onMove);
        }
        self2.isEnabled = true;
        e && e.type && _onPress(e);
        onEnable && onEnable(self2);
      }
      return self2;
    };
    self2.disable = function() {
      if (self2.isEnabled) {
        _observers.filter(function(o) {
          return o !== self2 && _isViewport(o.target);
        }).length || _removeListener$1(isViewport ? ownerDoc : target, "scroll", _onScroll);
        if (self2.isPressed) {
          self2._vx.reset();
          self2._vy.reset();
          _removeListener$1(isNormalizer ? target : ownerDoc, _eventTypes[1], _onDrag, true);
        }
        _removeListener$1(isViewport ? ownerDoc : target, "scroll", onScroll, capture);
        _removeListener$1(target, "wheel", _onWheel, capture);
        _removeListener$1(target, _eventTypes[0], _onPress, capture);
        _removeListener$1(ownerDoc, _eventTypes[2], _onRelease);
        _removeListener$1(ownerDoc, _eventTypes[3], _onRelease);
        _removeListener$1(target, "click", clickCapture, true);
        _removeListener$1(target, "click", _onClick);
        _removeListener$1(ownerDoc, "gesturestart", _onGestureStart);
        _removeListener$1(ownerDoc, "gestureend", _onGestureEnd);
        _removeListener$1(target, _pointerType + "enter", _onHover);
        _removeListener$1(target, _pointerType + "leave", _onHoverEnd);
        _removeListener$1(target, _pointerType + "move", _onMove);
        self2.isEnabled = self2.isPressed = self2.isDragging = false;
        onDisable && onDisable(self2);
      }
    };
    self2.kill = self2.revert = function() {
      self2.disable();
      var i = _observers.indexOf(self2);
      i >= 0 && _observers.splice(i, 1);
      _normalizer === self2 && (_normalizer = 0);
    };
    _observers.push(self2);
    isNormalizer && _isViewport(target) && (_normalizer = self2);
    self2.enable(event);
  };
  _createClass(Observer2, [{
    key: "velocityX",
    get: function get2() {
      return this._vx.getVelocity();
    }
  }, {
    key: "velocityY",
    get: function get2() {
      return this._vy.getVelocity();
    }
  }]);
  return Observer2;
}();
Observer$1.version = "3.12.5";
Observer$1.create = function(vars) {
  return new Observer$1(vars);
};
Observer$1.register = _initCore$1;
Observer$1.getAll = function() {
  return _observers.slice();
};
Observer$1.getById = function(id) {
  return _observers.filter(function(o) {
    return o.vars.id === id;
  })[0];
};
_getGSAP$3() && gsap$3.registerPlugin(Observer$1);
function _assertThisInitialized(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}
var gsap$2, _win, _doc, _docElement, _body, _tempDiv$1, _placeholderDiv, _coreInitted, _checkPrefix, _toArray$1, _supportsPassive, _isTouchDevice, _touchEventLookup, _isMultiTouching, _isAndroid, InertiaPlugin, _defaultCursor, _supportsPointer, _context, _getStyleSaver$1, _dragCount = 0, _windowExists3 = function _windowExists4() {
  return typeof window !== "undefined";
}, _getGSAP$2 = function _getGSAP3() {
  return gsap$2 || _windowExists3() && (gsap$2 = window.gsap) && gsap$2.registerPlugin && gsap$2;
}, _isFunction2 = function _isFunction3(value) {
  return typeof value === "function";
}, _isObject2 = function _isObject3(value) {
  return typeof value === "object";
}, _isUndefined3 = function _isUndefined4(value) {
  return typeof value === "undefined";
}, _emptyFunc$1 = function _emptyFunc2() {
  return false;
}, _transformProp = "transform", _transformOriginProp = "transformOrigin", _round5 = function _round6(value) {
  return Math.round(value * 1e4) / 1e4;
}, _isArray = Array.isArray, _createElement2 = function _createElement3(type, ns) {
  var e = _doc.createElementNS ? _doc.createElementNS((ns || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), type) : _doc.createElement(type);
  return e.style ? e : _doc.createElement(type);
}, _RAD2DEG = 180 / Math.PI, _bigNum = 1e20, _identityMatrix = new Matrix2D(), _getTime = Date.now || function() {
  return (/* @__PURE__ */ new Date()).getTime();
}, _renderQueue = [], _lookup = {}, _lookupCount = 0, _clickableTagExp = /^(?:a|input|textarea|button|select)$/i, _lastDragTime = 0, _temp1 = {}, _windowProxy = {}, _copy2 = function _copy3(obj, factor) {
  var copy = {}, p;
  for (p in obj) {
    copy[p] = factor ? obj[p] * factor : obj[p];
  }
  return copy;
}, _extend = function _extend2(obj, defaults2) {
  for (var p in defaults2) {
    if (!(p in obj)) {
      obj[p] = defaults2[p];
    }
  }
  return obj;
}, _setTouchActionForAllDescendants = function _setTouchActionForAllDescendants2(elements, value) {
  var i = elements.length, children;
  while (i--) {
    value ? elements[i].style.touchAction = value : elements[i].style.removeProperty("touch-action");
    children = elements[i].children;
    children && children.length && _setTouchActionForAllDescendants2(children, value);
  }
}, _renderQueueTick = function _renderQueueTick2() {
  return _renderQueue.forEach(function(func) {
    return func();
  });
}, _addToRenderQueue = function _addToRenderQueue2(func) {
  _renderQueue.push(func);
  if (_renderQueue.length === 1) {
    gsap$2.ticker.add(_renderQueueTick);
  }
}, _renderQueueTimeout = function _renderQueueTimeout2() {
  return !_renderQueue.length && gsap$2.ticker.remove(_renderQueueTick);
}, _removeFromRenderQueue = function _removeFromRenderQueue2(func) {
  var i = _renderQueue.length;
  while (i--) {
    if (_renderQueue[i] === func) {
      _renderQueue.splice(i, 1);
    }
  }
  gsap$2.to(_renderQueueTimeout, {
    overwrite: true,
    delay: 15,
    duration: 0,
    onComplete: _renderQueueTimeout,
    data: "_draggable"
  });
}, _setDefaults2 = function _setDefaults3(obj, defaults2) {
  for (var p in defaults2) {
    if (!(p in obj)) {
      obj[p] = defaults2[p];
    }
  }
  return obj;
}, _addListener2 = function _addListener3(element, type, func, capture) {
  if (element.addEventListener) {
    var touchType = _touchEventLookup[type];
    capture = capture || (_supportsPassive ? {
      passive: false
    } : null);
    element.addEventListener(touchType || type, func, capture);
    touchType && type !== touchType && element.addEventListener(type, func, capture);
  }
}, _removeListener2 = function _removeListener3(element, type, func, capture) {
  if (element.removeEventListener) {
    var touchType = _touchEventLookup[type];
    element.removeEventListener(touchType || type, func, capture);
    touchType && type !== touchType && element.removeEventListener(type, func, capture);
  }
}, _preventDefault = function _preventDefault2(event) {
  event.preventDefault && event.preventDefault();
  event.preventManipulation && event.preventManipulation();
}, _hasTouchID = function _hasTouchID2(list, ID) {
  var i = list.length;
  while (i--) {
    if (list[i].identifier === ID) {
      return true;
    }
  }
}, _onMultiTouchDocumentEnd = function _onMultiTouchDocumentEnd2(event) {
  _isMultiTouching = event.touches && _dragCount < event.touches.length;
  _removeListener2(event.target, "touchend", _onMultiTouchDocumentEnd2);
}, _onMultiTouchDocument = function _onMultiTouchDocument2(event) {
  _isMultiTouching = event.touches && _dragCount < event.touches.length;
  _addListener2(event.target, "touchend", _onMultiTouchDocumentEnd);
}, _getDocScrollTop2 = function _getDocScrollTop3(doc) {
  return _win.pageYOffset || doc.scrollTop || doc.documentElement.scrollTop || doc.body.scrollTop || 0;
}, _getDocScrollLeft2 = function _getDocScrollLeft3(doc) {
  return _win.pageXOffset || doc.scrollLeft || doc.documentElement.scrollLeft || doc.body.scrollLeft || 0;
}, _addScrollListener = function _addScrollListener2(e, callback) {
  _addListener2(e, "scroll", callback);
  if (!_isRoot(e.parentNode)) {
    _addScrollListener2(e.parentNode, callback);
  }
}, _removeScrollListener = function _removeScrollListener2(e, callback) {
  _removeListener2(e, "scroll", callback);
  if (!_isRoot(e.parentNode)) {
    _removeScrollListener2(e.parentNode, callback);
  }
}, _isRoot = function _isRoot2(e) {
  return !!(!e || e === _docElement || e.nodeType === 9 || e === _doc.body || e === _win || !e.nodeType || !e.parentNode);
}, _getMaxScroll = function _getMaxScroll2(element, axis) {
  var dim = axis === "x" ? "Width" : "Height", scroll = "scroll" + dim, client = "client" + dim;
  return Math.max(0, _isRoot(element) ? Math.max(_docElement[scroll], _body[scroll]) - (_win["inner" + dim] || _docElement[client] || _body[client]) : element[scroll] - element[client]);
}, _recordMaxScrolls = function _recordMaxScrolls2(e, skipCurrent) {
  var x = _getMaxScroll(e, "x"), y = _getMaxScroll(e, "y");
  if (_isRoot(e)) {
    e = _windowProxy;
  } else {
    _recordMaxScrolls2(e.parentNode, skipCurrent);
  }
  e._gsMaxScrollX = x;
  e._gsMaxScrollY = y;
  if (!skipCurrent) {
    e._gsScrollX = e.scrollLeft || 0;
    e._gsScrollY = e.scrollTop || 0;
  }
}, _setStyle = function _setStyle2(element, property, value) {
  var style = element.style;
  if (!style) {
    return;
  }
  if (_isUndefined3(style[property])) {
    property = _checkPrefix(property, element) || property;
  }
  if (value == null) {
    style.removeProperty && style.removeProperty(property.replace(/([A-Z])/g, "-$1").toLowerCase());
  } else {
    style[property] = value;
  }
}, _getComputedStyle = function _getComputedStyle2(element) {
  return _win.getComputedStyle(element instanceof Element ? element : element.host || (element.parentNode || {}).host || element);
}, _tempRect = {}, _parseRect = function _parseRect2(e) {
  if (e === _win) {
    _tempRect.left = _tempRect.top = 0;
    _tempRect.width = _tempRect.right = _docElement.clientWidth || e.innerWidth || _body.clientWidth || 0;
    _tempRect.height = _tempRect.bottom = (e.innerHeight || 0) - 20 < _docElement.clientHeight ? _docElement.clientHeight : e.innerHeight || _body.clientHeight || 0;
    return _tempRect;
  }
  var doc = e.ownerDocument || _doc, r = !_isUndefined3(e.pageX) ? {
    left: e.pageX - _getDocScrollLeft2(doc),
    top: e.pageY - _getDocScrollTop2(doc),
    right: e.pageX - _getDocScrollLeft2(doc) + 1,
    bottom: e.pageY - _getDocScrollTop2(doc) + 1
  } : !e.nodeType && !_isUndefined3(e.left) && !_isUndefined3(e.top) ? e : _toArray$1(e)[0].getBoundingClientRect();
  if (_isUndefined3(r.right) && !_isUndefined3(r.width)) {
    r.right = r.left + r.width;
    r.bottom = r.top + r.height;
  } else if (_isUndefined3(r.width)) {
    r = {
      width: r.right - r.left,
      height: r.bottom - r.top,
      right: r.right,
      left: r.left,
      bottom: r.bottom,
      top: r.top
    };
  }
  return r;
}, _dispatchEvent = function _dispatchEvent2(target, type, callbackName) {
  var vars = target.vars, callback = vars[callbackName], listeners = target._listeners[type], result;
  if (_isFunction2(callback)) {
    result = callback.apply(vars.callbackScope || target, vars[callbackName + "Params"] || [target.pointerEvent]);
  }
  if (listeners && target.dispatchEvent(type) === false) {
    result = false;
  }
  return result;
}, _getBounds = function _getBounds2(target, context3) {
  var e = _toArray$1(target)[0], top, left, offset;
  if (!e.nodeType && e !== _win) {
    if (!_isUndefined3(target.left)) {
      offset = {
        x: 0,
        y: 0
      };
      return {
        left: target.left - offset.x,
        top: target.top - offset.y,
        width: target.width,
        height: target.height
      };
    }
    left = target.min || target.minX || target.minRotation || 0;
    top = target.min || target.minY || 0;
    return {
      left,
      top,
      width: (target.max || target.maxX || target.maxRotation || 0) - left,
      height: (target.max || target.maxY || 0) - top
    };
  }
  return _getElementBounds(e, context3);
}, _point1 = {}, _getElementBounds = function _getElementBounds2(element, context3) {
  context3 = _toArray$1(context3)[0];
  var isSVG = element.getBBox && element.ownerSVGElement, doc = element.ownerDocument || _doc, left, right, top, bottom, matrix, p1, p2, p3, p4, bbox, width, height, cs;
  if (element === _win) {
    top = _getDocScrollTop2(doc);
    left = _getDocScrollLeft2(doc);
    right = left + (doc.documentElement.clientWidth || element.innerWidth || doc.body.clientWidth || 0);
    bottom = top + ((element.innerHeight || 0) - 20 < doc.documentElement.clientHeight ? doc.documentElement.clientHeight : element.innerHeight || doc.body.clientHeight || 0);
  } else if (context3 === _win || _isUndefined3(context3)) {
    return element.getBoundingClientRect();
  } else {
    left = top = 0;
    if (isSVG) {
      bbox = element.getBBox();
      width = bbox.width;
      height = bbox.height;
    } else {
      if (element.viewBox && (bbox = element.viewBox.baseVal)) {
        left = bbox.x || 0;
        top = bbox.y || 0;
        width = bbox.width;
        height = bbox.height;
      }
      if (!width) {
        cs = _getComputedStyle(element);
        bbox = cs.boxSizing === "border-box";
        width = (parseFloat(cs.width) || element.clientWidth || 0) + (bbox ? 0 : parseFloat(cs.borderLeftWidth) + parseFloat(cs.borderRightWidth));
        height = (parseFloat(cs.height) || element.clientHeight || 0) + (bbox ? 0 : parseFloat(cs.borderTopWidth) + parseFloat(cs.borderBottomWidth));
      }
    }
    right = width;
    bottom = height;
  }
  if (element === context3) {
    return {
      left,
      top,
      width: right - left,
      height: bottom - top
    };
  }
  matrix = getGlobalMatrix(context3, true).multiply(getGlobalMatrix(element));
  p1 = matrix.apply({
    x: left,
    y: top
  });
  p2 = matrix.apply({
    x: right,
    y: top
  });
  p3 = matrix.apply({
    x: right,
    y: bottom
  });
  p4 = matrix.apply({
    x: left,
    y: bottom
  });
  left = Math.min(p1.x, p2.x, p3.x, p4.x);
  top = Math.min(p1.y, p2.y, p3.y, p4.y);
  return {
    left,
    top,
    width: Math.max(p1.x, p2.x, p3.x, p4.x) - left,
    height: Math.max(p1.y, p2.y, p3.y, p4.y) - top
  };
}, _parseInertia = function _parseInertia2(draggable, snap3, max, min, factor, forceZeroVelocity) {
  var vars = {}, a, i, l;
  if (snap3) {
    if (factor !== 1 && snap3 instanceof Array) {
      vars.end = a = [];
      l = snap3.length;
      if (_isObject2(snap3[0])) {
        for (i = 0; i < l; i++) {
          a[i] = _copy2(snap3[i], factor);
        }
      } else {
        for (i = 0; i < l; i++) {
          a[i] = snap3[i] * factor;
        }
      }
      max += 1.1;
      min -= 1.1;
    } else if (_isFunction2(snap3)) {
      vars.end = function(value) {
        var result = snap3.call(draggable, value), copy, p;
        if (factor !== 1) {
          if (_isObject2(result)) {
            copy = {};
            for (p in result) {
              copy[p] = result[p] * factor;
            }
            result = copy;
          } else {
            result *= factor;
          }
        }
        return result;
      };
    } else {
      vars.end = snap3;
    }
  }
  if (max || max === 0) {
    vars.max = max;
  }
  if (min || min === 0) {
    vars.min = min;
  }
  if (forceZeroVelocity) {
    vars.velocity = 0;
  }
  return vars;
}, _isClickable = function _isClickable2(element) {
  var data;
  return !element || !element.getAttribute || element === _body ? false : (data = element.getAttribute("data-clickable")) === "true" || data !== "false" && (_clickableTagExp.test(element.nodeName + "") || element.getAttribute("contentEditable") === "true") ? true : _isClickable2(element.parentNode);
}, _setSelectable = function _setSelectable2(elements, selectable) {
  var i = elements.length, e;
  while (i--) {
    e = elements[i];
    e.ondragstart = e.onselectstart = selectable ? null : _emptyFunc$1;
    gsap$2.set(e, {
      lazy: true,
      userSelect: selectable ? "text" : "none"
    });
  }
}, _isFixed2 = function _isFixed3(element) {
  if (_getComputedStyle(element).position === "fixed") {
    return true;
  }
  element = element.parentNode;
  if (element && element.nodeType === 1) {
    return _isFixed3(element);
  }
}, _supports3D, _addPaddingBR, ScrollProxy = function ScrollProxy2(element, vars) {
  element = gsap$2.utils.toArray(element)[0];
  vars = vars || {};
  var content = document.createElement("div"), style = content.style, node = element.firstChild, offsetTop = 0, offsetLeft = 0, prevTop = element.scrollTop, prevLeft = element.scrollLeft, scrollWidth = element.scrollWidth, scrollHeight = element.scrollHeight, extraPadRight = 0, maxLeft = 0, maxTop = 0, elementWidth, elementHeight, contentHeight, nextNode, transformStart, transformEnd;
  if (_supports3D && vars.force3D !== false) {
    transformStart = "translate3d(";
    transformEnd = "px,0px)";
  } else if (_transformProp) {
    transformStart = "translate(";
    transformEnd = "px)";
  }
  this.scrollTop = function(value, force) {
    if (!arguments.length) {
      return -this.top();
    }
    this.top(-value, force);
  };
  this.scrollLeft = function(value, force) {
    if (!arguments.length) {
      return -this.left();
    }
    this.left(-value, force);
  };
  this.left = function(value, force) {
    if (!arguments.length) {
      return -(element.scrollLeft + offsetLeft);
    }
    var dif = element.scrollLeft - prevLeft, oldOffset = offsetLeft;
    if ((dif > 2 || dif < -2) && !force) {
      prevLeft = element.scrollLeft;
      gsap$2.killTweensOf(this, {
        left: 1,
        scrollLeft: 1
      });
      this.left(-prevLeft);
      if (vars.onKill) {
        vars.onKill();
      }
      return;
    }
    value = -value;
    if (value < 0) {
      offsetLeft = value - 0.5 | 0;
      value = 0;
    } else if (value > maxLeft) {
      offsetLeft = value - maxLeft | 0;
      value = maxLeft;
    } else {
      offsetLeft = 0;
    }
    if (offsetLeft || oldOffset) {
      if (!this._skip) {
        style[_transformProp] = transformStart + -offsetLeft + "px," + -offsetTop + transformEnd;
      }
      if (offsetLeft + extraPadRight >= 0) {
        style.paddingRight = offsetLeft + extraPadRight + "px";
      }
    }
    element.scrollLeft = value | 0;
    prevLeft = element.scrollLeft;
  };
  this.top = function(value, force) {
    if (!arguments.length) {
      return -(element.scrollTop + offsetTop);
    }
    var dif = element.scrollTop - prevTop, oldOffset = offsetTop;
    if ((dif > 2 || dif < -2) && !force) {
      prevTop = element.scrollTop;
      gsap$2.killTweensOf(this, {
        top: 1,
        scrollTop: 1
      });
      this.top(-prevTop);
      if (vars.onKill) {
        vars.onKill();
      }
      return;
    }
    value = -value;
    if (value < 0) {
      offsetTop = value - 0.5 | 0;
      value = 0;
    } else if (value > maxTop) {
      offsetTop = value - maxTop | 0;
      value = maxTop;
    } else {
      offsetTop = 0;
    }
    if (offsetTop || oldOffset) {
      if (!this._skip) {
        style[_transformProp] = transformStart + -offsetLeft + "px," + -offsetTop + transformEnd;
      }
    }
    element.scrollTop = value | 0;
    prevTop = element.scrollTop;
  };
  this.maxScrollTop = function() {
    return maxTop;
  };
  this.maxScrollLeft = function() {
    return maxLeft;
  };
  this.disable = function() {
    node = content.firstChild;
    while (node) {
      nextNode = node.nextSibling;
      element.appendChild(node);
      node = nextNode;
    }
    if (element === content.parentNode) {
      element.removeChild(content);
    }
  };
  this.enable = function() {
    node = element.firstChild;
    if (node === content) {
      return;
    }
    while (node) {
      nextNode = node.nextSibling;
      content.appendChild(node);
      node = nextNode;
    }
    element.appendChild(content);
    this.calibrate();
  };
  this.calibrate = function(force) {
    var widthMatches = element.clientWidth === elementWidth, cs, x, y;
    prevTop = element.scrollTop;
    prevLeft = element.scrollLeft;
    if (widthMatches && element.clientHeight === elementHeight && content.offsetHeight === contentHeight && scrollWidth === element.scrollWidth && scrollHeight === element.scrollHeight && !force) {
      return;
    }
    if (offsetTop || offsetLeft) {
      x = this.left();
      y = this.top();
      this.left(-element.scrollLeft);
      this.top(-element.scrollTop);
    }
    cs = _getComputedStyle(element);
    if (!widthMatches || force) {
      style.display = "block";
      style.width = "auto";
      style.paddingRight = "0px";
      extraPadRight = Math.max(0, element.scrollWidth - element.clientWidth);
      if (extraPadRight) {
        extraPadRight += parseFloat(cs.paddingLeft) + (_addPaddingBR ? parseFloat(cs.paddingRight) : 0);
      }
    }
    style.display = "inline-block";
    style.position = "relative";
    style.overflow = "visible";
    style.verticalAlign = "top";
    style.boxSizing = "content-box";
    style.width = "100%";
    style.paddingRight = extraPadRight + "px";
    if (_addPaddingBR) {
      style.paddingBottom = cs.paddingBottom;
    }
    elementWidth = element.clientWidth;
    elementHeight = element.clientHeight;
    scrollWidth = element.scrollWidth;
    scrollHeight = element.scrollHeight;
    maxLeft = element.scrollWidth - elementWidth;
    maxTop = element.scrollHeight - elementHeight;
    contentHeight = content.offsetHeight;
    style.display = "block";
    if (x || y) {
      this.left(x);
      this.top(y);
    }
  };
  this.content = content;
  this.element = element;
  this._skip = false;
  this.enable();
}, _initCore4 = function _initCore5(required) {
  if (_windowExists3() && document.body) {
    var nav = window && window.navigator;
    _win = window;
    _doc = document;
    _docElement = _doc.documentElement;
    _body = _doc.body;
    _tempDiv$1 = _createElement2("div");
    _supportsPointer = !!window.PointerEvent;
    _placeholderDiv = _createElement2("div");
    _placeholderDiv.style.cssText = "visibility:hidden;height:1px;top:-1px;pointer-events:none;position:relative;clear:both;cursor:grab";
    _defaultCursor = _placeholderDiv.style.cursor === "grab" ? "grab" : "move";
    _isAndroid = nav && nav.userAgent.toLowerCase().indexOf("android") !== -1;
    _isTouchDevice = "ontouchstart" in _docElement && "orientation" in _win || nav && (nav.MaxTouchPoints > 0 || nav.msMaxTouchPoints > 0);
    _addPaddingBR = function() {
      var div = _createElement2("div"), child = _createElement2("div"), childStyle = child.style, parent = _body, val;
      childStyle.display = "inline-block";
      childStyle.position = "relative";
      div.style.cssText = "width:90px;height:40px;padding:10px;overflow:auto;visibility:hidden";
      div.appendChild(child);
      parent.appendChild(div);
      val = child.offsetHeight + 18 > div.scrollHeight;
      parent.removeChild(div);
      return val;
    }();
    _touchEventLookup = function(types) {
      var standard = types.split(","), converted = ("onpointerdown" in _tempDiv$1 ? "pointerdown,pointermove,pointerup,pointercancel" : "onmspointerdown" in _tempDiv$1 ? "MSPointerDown,MSPointerMove,MSPointerUp,MSPointerCancel" : types).split(","), obj = {}, i = 4;
      while (--i > -1) {
        obj[standard[i]] = converted[i];
        obj[converted[i]] = standard[i];
      }
      try {
        _docElement.addEventListener("test", null, Object.defineProperty({}, "passive", {
          get: function get2() {
            _supportsPassive = 1;
          }
        }));
      } catch (e) {
      }
      return obj;
    }("touchstart,touchmove,touchend,touchcancel");
    _addListener2(_doc, "touchcancel", _emptyFunc$1);
    _addListener2(_win, "touchmove", _emptyFunc$1);
    _body && _body.addEventListener("touchstart", _emptyFunc$1);
    _addListener2(_doc, "contextmenu", function() {
      for (var p in _lookup) {
        if (_lookup[p].isPressed) {
          _lookup[p].endDrag();
        }
      }
    });
    gsap$2 = _coreInitted = _getGSAP$2();
  }
  if (gsap$2) {
    InertiaPlugin = gsap$2.plugins.inertia;
    _context = gsap$2.core.context || function() {
    };
    _checkPrefix = gsap$2.utils.checkPrefix;
    _transformProp = _checkPrefix(_transformProp);
    _transformOriginProp = _checkPrefix(_transformOriginProp);
    _toArray$1 = gsap$2.utils.toArray;
    _getStyleSaver$1 = gsap$2.core.getStyleSaver;
    _supports3D = !!_checkPrefix("perspective");
  } else if (required) {
    console.warn("Please gsap.registerPlugin(Draggable)");
  }
};
var EventDispatcher = /* @__PURE__ */ function() {
  function EventDispatcher2(target) {
    this._listeners = {};
    this.target = target || this;
  }
  var _proto = EventDispatcher2.prototype;
  _proto.addEventListener = function addEventListener2(type, callback) {
    var list = this._listeners[type] || (this._listeners[type] = []);
    if (!~list.indexOf(callback)) {
      list.push(callback);
    }
  };
  _proto.removeEventListener = function removeEventListener2(type, callback) {
    var list = this._listeners[type], i = list && list.indexOf(callback);
    i >= 0 && list.splice(i, 1);
  };
  _proto.dispatchEvent = function dispatchEvent2(type) {
    var _this = this;
    var result;
    (this._listeners[type] || []).forEach(function(callback) {
      return callback.call(_this, {
        type,
        target: _this.target
      }) === false && (result = false);
    });
    return result;
  };
  return EventDispatcher2;
}();
var Draggable = /* @__PURE__ */ function(_EventDispatcher) {
  _inheritsLoose(Draggable2, _EventDispatcher);
  function Draggable2(target, vars) {
    var _this2;
    _this2 = _EventDispatcher.call(this) || this;
    _coreInitted || _initCore4(1);
    target = _toArray$1(target)[0];
    _this2.styles = _getStyleSaver$1 && _getStyleSaver$1(target, "transform,left,top");
    if (!InertiaPlugin) {
      InertiaPlugin = gsap$2.plugins.inertia;
    }
    _this2.vars = vars = _copy2(vars || {});
    _this2.target = target;
    _this2.x = _this2.y = _this2.rotation = 0;
    _this2.dragResistance = parseFloat(vars.dragResistance) || 0;
    _this2.edgeResistance = isNaN(vars.edgeResistance) ? 1 : parseFloat(vars.edgeResistance) || 0;
    _this2.lockAxis = vars.lockAxis;
    _this2.autoScroll = vars.autoScroll || 0;
    _this2.lockedAxis = null;
    _this2.allowEventDefault = !!vars.allowEventDefault;
    gsap$2.getProperty(target, "x");
    var type = (vars.type || "x,y").toLowerCase(), xyMode = ~type.indexOf("x") || ~type.indexOf("y"), rotationMode = type.indexOf("rotation") !== -1, xProp = rotationMode ? "rotation" : xyMode ? "x" : "left", yProp = xyMode ? "y" : "top", allowX = !!(~type.indexOf("x") || ~type.indexOf("left") || type === "scroll"), allowY = !!(~type.indexOf("y") || ~type.indexOf("top") || type === "scroll"), minimumMovement = vars.minimumMovement || 2, self2 = _assertThisInitialized(_this2), triggers = _toArray$1(vars.trigger || vars.handle || target), killProps = {}, dragEndTime = 0, checkAutoScrollBounds = false, autoScrollMarginTop = vars.autoScrollMarginTop || 40, autoScrollMarginRight = vars.autoScrollMarginRight || 40, autoScrollMarginBottom = vars.autoScrollMarginBottom || 40, autoScrollMarginLeft = vars.autoScrollMarginLeft || 40, isClickable = vars.clickableTest || _isClickable, clickTime = 0, gsCache = target._gsap || gsap$2.core.getCache(target), isFixed = _isFixed2(target), getPropAsNum = function getPropAsNum2(property, unit) {
      return parseFloat(gsCache.get(target, property, unit));
    }, ownerDoc = target.ownerDocument || _doc, enabled, scrollProxy, startPointerX, startPointerY, startElementX, startElementY, hasBounds, hasDragCallback, hasMoveCallback, maxX, minX, maxY, minY, touch, touchID, rotationOrigin, dirty, old, snapX, snapY, snapXY, isClicking, touchEventTarget, matrix, interrupted, allowNativeTouchScrolling, touchDragAxis, isDispatching, clickDispatch, trustedClickDispatch, isPreventingDefault, innerMatrix, dragged, onContextMenu = function onContextMenu2(e) {
      _preventDefault(e);
      e.stopImmediatePropagation && e.stopImmediatePropagation();
      return false;
    }, render5 = function render6(suppressEvents) {
      if (self2.autoScroll && self2.isDragging && (checkAutoScrollBounds || dirty)) {
        var e = target, autoScrollFactor = self2.autoScroll * 15, parent, isRoot, rect, pointerX, pointerY, changeX, changeY, gap;
        checkAutoScrollBounds = false;
        _windowProxy.scrollTop = _win.pageYOffset != null ? _win.pageYOffset : ownerDoc.documentElement.scrollTop != null ? ownerDoc.documentElement.scrollTop : ownerDoc.body.scrollTop;
        _windowProxy.scrollLeft = _win.pageXOffset != null ? _win.pageXOffset : ownerDoc.documentElement.scrollLeft != null ? ownerDoc.documentElement.scrollLeft : ownerDoc.body.scrollLeft;
        pointerX = self2.pointerX - _windowProxy.scrollLeft;
        pointerY = self2.pointerY - _windowProxy.scrollTop;
        while (e && !isRoot) {
          isRoot = _isRoot(e.parentNode);
          parent = isRoot ? _windowProxy : e.parentNode;
          rect = isRoot ? {
            bottom: Math.max(_docElement.clientHeight, _win.innerHeight || 0),
            right: Math.max(_docElement.clientWidth, _win.innerWidth || 0),
            left: 0,
            top: 0
          } : parent.getBoundingClientRect();
          changeX = changeY = 0;
          if (allowY) {
            gap = parent._gsMaxScrollY - parent.scrollTop;
            if (gap < 0) {
              changeY = gap;
            } else if (pointerY > rect.bottom - autoScrollMarginBottom && gap) {
              checkAutoScrollBounds = true;
              changeY = Math.min(gap, autoScrollFactor * (1 - Math.max(0, rect.bottom - pointerY) / autoScrollMarginBottom) | 0);
            } else if (pointerY < rect.top + autoScrollMarginTop && parent.scrollTop) {
              checkAutoScrollBounds = true;
              changeY = -Math.min(parent.scrollTop, autoScrollFactor * (1 - Math.max(0, pointerY - rect.top) / autoScrollMarginTop) | 0);
            }
            if (changeY) {
              parent.scrollTop += changeY;
            }
          }
          if (allowX) {
            gap = parent._gsMaxScrollX - parent.scrollLeft;
            if (gap < 0) {
              changeX = gap;
            } else if (pointerX > rect.right - autoScrollMarginRight && gap) {
              checkAutoScrollBounds = true;
              changeX = Math.min(gap, autoScrollFactor * (1 - Math.max(0, rect.right - pointerX) / autoScrollMarginRight) | 0);
            } else if (pointerX < rect.left + autoScrollMarginLeft && parent.scrollLeft) {
              checkAutoScrollBounds = true;
              changeX = -Math.min(parent.scrollLeft, autoScrollFactor * (1 - Math.max(0, pointerX - rect.left) / autoScrollMarginLeft) | 0);
            }
            if (changeX) {
              parent.scrollLeft += changeX;
            }
          }
          if (isRoot && (changeX || changeY)) {
            _win.scrollTo(parent.scrollLeft, parent.scrollTop);
            setPointerPosition(self2.pointerX + changeX, self2.pointerY + changeY);
          }
          e = parent;
        }
      }
      if (dirty) {
        var x = self2.x, y = self2.y;
        if (rotationMode) {
          self2.deltaX = x - parseFloat(gsCache.rotation);
          self2.rotation = x;
          gsCache.rotation = x + "deg";
          gsCache.renderTransform(1, gsCache);
        } else {
          if (scrollProxy) {
            if (allowY) {
              self2.deltaY = y - scrollProxy.top();
              scrollProxy.top(y);
            }
            if (allowX) {
              self2.deltaX = x - scrollProxy.left();
              scrollProxy.left(x);
            }
          } else if (xyMode) {
            if (allowY) {
              self2.deltaY = y - parseFloat(gsCache.y);
              gsCache.y = y + "px";
            }
            if (allowX) {
              self2.deltaX = x - parseFloat(gsCache.x);
              gsCache.x = x + "px";
            }
            gsCache.renderTransform(1, gsCache);
          } else {
            if (allowY) {
              self2.deltaY = y - parseFloat(target.style.top || 0);
              target.style.top = y + "px";
            }
            if (allowX) {
              self2.deltaX = x - parseFloat(target.style.left || 0);
              target.style.left = x + "px";
            }
          }
        }
        if (hasDragCallback && !suppressEvents && !isDispatching) {
          isDispatching = true;
          if (_dispatchEvent(self2, "drag", "onDrag") === false) {
            if (allowX) {
              self2.x -= self2.deltaX;
            }
            if (allowY) {
              self2.y -= self2.deltaY;
            }
            render6(true);
          }
          isDispatching = false;
        }
      }
      dirty = false;
    }, syncXY = function syncXY2(skipOnUpdate, skipSnap) {
      var x = self2.x, y = self2.y, snappedValue, cs;
      if (!target._gsap) {
        gsCache = gsap$2.core.getCache(target);
      }
      gsCache.uncache && gsap$2.getProperty(target, "x");
      if (xyMode) {
        self2.x = parseFloat(gsCache.x);
        self2.y = parseFloat(gsCache.y);
      } else if (rotationMode) {
        self2.x = self2.rotation = parseFloat(gsCache.rotation);
      } else if (scrollProxy) {
        self2.y = scrollProxy.top();
        self2.x = scrollProxy.left();
      } else {
        self2.y = parseFloat(target.style.top || (cs = _getComputedStyle(target)) && cs.top) || 0;
        self2.x = parseFloat(target.style.left || (cs || {}).left) || 0;
      }
      if ((snapX || snapY || snapXY) && !skipSnap && (self2.isDragging || self2.isThrowing)) {
        if (snapXY) {
          _temp1.x = self2.x;
          _temp1.y = self2.y;
          snappedValue = snapXY(_temp1);
          if (snappedValue.x !== self2.x) {
            self2.x = snappedValue.x;
            dirty = true;
          }
          if (snappedValue.y !== self2.y) {
            self2.y = snappedValue.y;
            dirty = true;
          }
        }
        if (snapX) {
          snappedValue = snapX(self2.x);
          if (snappedValue !== self2.x) {
            self2.x = snappedValue;
            if (rotationMode) {
              self2.rotation = snappedValue;
            }
            dirty = true;
          }
        }
        if (snapY) {
          snappedValue = snapY(self2.y);
          if (snappedValue !== self2.y) {
            self2.y = snappedValue;
          }
          dirty = true;
        }
      }
      dirty && render5(true);
      if (!skipOnUpdate) {
        self2.deltaX = self2.x - x;
        self2.deltaY = self2.y - y;
        _dispatchEvent(self2, "throwupdate", "onThrowUpdate");
      }
    }, buildSnapFunc = function buildSnapFunc2(snap3, min, max, factor) {
      if (min == null) {
        min = -_bigNum;
      }
      if (max == null) {
        max = _bigNum;
      }
      if (_isFunction2(snap3)) {
        return function(n) {
          var edgeTolerance = !self2.isPressed ? 1 : 1 - self2.edgeResistance;
          return snap3.call(self2, (n > max ? max + (n - max) * edgeTolerance : n < min ? min + (n - min) * edgeTolerance : n) * factor) * factor;
        };
      }
      if (_isArray(snap3)) {
        return function(n) {
          var i = snap3.length, closest = 0, absDif = _bigNum, val, dif;
          while (--i > -1) {
            val = snap3[i];
            dif = val - n;
            if (dif < 0) {
              dif = -dif;
            }
            if (dif < absDif && val >= min && val <= max) {
              closest = i;
              absDif = dif;
            }
          }
          return snap3[closest];
        };
      }
      return isNaN(snap3) ? function(n) {
        return n;
      } : function() {
        return snap3 * factor;
      };
    }, buildPointSnapFunc = function buildPointSnapFunc2(snap3, minX2, maxX2, minY2, maxY2, radius, factor) {
      radius = radius && radius < _bigNum ? radius * radius : _bigNum;
      if (_isFunction2(snap3)) {
        return function(point) {
          var edgeTolerance = !self2.isPressed ? 1 : 1 - self2.edgeResistance, x = point.x, y = point.y, result, dx, dy;
          point.x = x = x > maxX2 ? maxX2 + (x - maxX2) * edgeTolerance : x < minX2 ? minX2 + (x - minX2) * edgeTolerance : x;
          point.y = y = y > maxY2 ? maxY2 + (y - maxY2) * edgeTolerance : y < minY2 ? minY2 + (y - minY2) * edgeTolerance : y;
          result = snap3.call(self2, point);
          if (result !== point) {
            point.x = result.x;
            point.y = result.y;
          }
          if (factor !== 1) {
            point.x *= factor;
            point.y *= factor;
          }
          if (radius < _bigNum) {
            dx = point.x - x;
            dy = point.y - y;
            if (dx * dx + dy * dy > radius) {
              point.x = x;
              point.y = y;
            }
          }
          return point;
        };
      }
      if (_isArray(snap3)) {
        return function(p) {
          var i = snap3.length, closest = 0, minDist = _bigNum, x, y, point, dist;
          while (--i > -1) {
            point = snap3[i];
            x = point.x - p.x;
            y = point.y - p.y;
            dist = x * x + y * y;
            if (dist < minDist) {
              closest = i;
              minDist = dist;
            }
          }
          return minDist <= radius ? snap3[closest] : p;
        };
      }
      return function(n) {
        return n;
      };
    }, calculateBounds = function calculateBounds2() {
      var bounds, targetBounds, snap3, snapIsRaw;
      hasBounds = false;
      if (scrollProxy) {
        scrollProxy.calibrate();
        self2.minX = minX = -scrollProxy.maxScrollLeft();
        self2.minY = minY = -scrollProxy.maxScrollTop();
        self2.maxX = maxX = self2.maxY = maxY = 0;
        hasBounds = true;
      } else if (!!vars.bounds) {
        bounds = _getBounds(vars.bounds, target.parentNode);
        if (rotationMode) {
          self2.minX = minX = bounds.left;
          self2.maxX = maxX = bounds.left + bounds.width;
          self2.minY = minY = self2.maxY = maxY = 0;
        } else if (!_isUndefined3(vars.bounds.maxX) || !_isUndefined3(vars.bounds.maxY)) {
          bounds = vars.bounds;
          self2.minX = minX = bounds.minX;
          self2.minY = minY = bounds.minY;
          self2.maxX = maxX = bounds.maxX;
          self2.maxY = maxY = bounds.maxY;
        } else {
          targetBounds = _getBounds(target, target.parentNode);
          self2.minX = minX = Math.round(getPropAsNum(xProp, "px") + bounds.left - targetBounds.left);
          self2.minY = minY = Math.round(getPropAsNum(yProp, "px") + bounds.top - targetBounds.top);
          self2.maxX = maxX = Math.round(minX + (bounds.width - targetBounds.width));
          self2.maxY = maxY = Math.round(minY + (bounds.height - targetBounds.height));
        }
        if (minX > maxX) {
          self2.minX = maxX;
          self2.maxX = maxX = minX;
          minX = self2.minX;
        }
        if (minY > maxY) {
          self2.minY = maxY;
          self2.maxY = maxY = minY;
          minY = self2.minY;
        }
        if (rotationMode) {
          self2.minRotation = minX;
          self2.maxRotation = maxX;
        }
        hasBounds = true;
      }
      if (vars.liveSnap) {
        snap3 = vars.liveSnap === true ? vars.snap || {} : vars.liveSnap;
        snapIsRaw = _isArray(snap3) || _isFunction2(snap3);
        if (rotationMode) {
          snapX = buildSnapFunc(snapIsRaw ? snap3 : snap3.rotation, minX, maxX, 1);
          snapY = null;
        } else {
          if (snap3.points) {
            snapXY = buildPointSnapFunc(snapIsRaw ? snap3 : snap3.points, minX, maxX, minY, maxY, snap3.radius, scrollProxy ? -1 : 1);
          } else {
            if (allowX) {
              snapX = buildSnapFunc(snapIsRaw ? snap3 : snap3.x || snap3.left || snap3.scrollLeft, minX, maxX, scrollProxy ? -1 : 1);
            }
            if (allowY) {
              snapY = buildSnapFunc(snapIsRaw ? snap3 : snap3.y || snap3.top || snap3.scrollTop, minY, maxY, scrollProxy ? -1 : 1);
            }
          }
        }
      }
    }, onThrowComplete = function onThrowComplete2() {
      self2.isThrowing = false;
      _dispatchEvent(self2, "throwcomplete", "onThrowComplete");
    }, onThrowInterrupt = function onThrowInterrupt2() {
      self2.isThrowing = false;
    }, animate = function animate2(inertia, forceZeroVelocity) {
      var snap3, snapIsRaw, tween, overshootTolerance;
      if (inertia && InertiaPlugin) {
        if (inertia === true) {
          snap3 = vars.snap || vars.liveSnap || {};
          snapIsRaw = _isArray(snap3) || _isFunction2(snap3);
          inertia = {
            resistance: (vars.throwResistance || vars.resistance || 1e3) / (rotationMode ? 10 : 1)
          };
          if (rotationMode) {
            inertia.rotation = _parseInertia(self2, snapIsRaw ? snap3 : snap3.rotation, maxX, minX, 1, forceZeroVelocity);
          } else {
            if (allowX) {
              inertia[xProp] = _parseInertia(self2, snapIsRaw ? snap3 : snap3.points || snap3.x || snap3.left, maxX, minX, scrollProxy ? -1 : 1, forceZeroVelocity || self2.lockedAxis === "x");
            }
            if (allowY) {
              inertia[yProp] = _parseInertia(self2, snapIsRaw ? snap3 : snap3.points || snap3.y || snap3.top, maxY, minY, scrollProxy ? -1 : 1, forceZeroVelocity || self2.lockedAxis === "y");
            }
            if (snap3.points || _isArray(snap3) && _isObject2(snap3[0])) {
              inertia.linkedProps = xProp + "," + yProp;
              inertia.radius = snap3.radius;
            }
          }
        }
        self2.isThrowing = true;
        overshootTolerance = !isNaN(vars.overshootTolerance) ? vars.overshootTolerance : vars.edgeResistance === 1 ? 0 : 1 - self2.edgeResistance + 0.2;
        if (!inertia.duration) {
          inertia.duration = {
            max: Math.max(vars.minDuration || 0, "maxDuration" in vars ? vars.maxDuration : 2),
            min: !isNaN(vars.minDuration) ? vars.minDuration : overshootTolerance === 0 || _isObject2(inertia) && inertia.resistance > 1e3 ? 0 : 0.5,
            overshoot: overshootTolerance
          };
        }
        self2.tween = tween = gsap$2.to(scrollProxy || target, {
          inertia,
          data: "_draggable",
          inherit: false,
          onComplete: onThrowComplete,
          onInterrupt: onThrowInterrupt,
          onUpdate: vars.fastMode ? _dispatchEvent : syncXY,
          onUpdateParams: vars.fastMode ? [self2, "onthrowupdate", "onThrowUpdate"] : snap3 && snap3.radius ? [false, true] : []
        });
        if (!vars.fastMode) {
          if (scrollProxy) {
            scrollProxy._skip = true;
          }
          tween.render(1e9, true, true);
          syncXY(true, true);
          self2.endX = self2.x;
          self2.endY = self2.y;
          if (rotationMode) {
            self2.endRotation = self2.x;
          }
          tween.play(0);
          syncXY(true, true);
          if (scrollProxy) {
            scrollProxy._skip = false;
          }
        }
      } else if (hasBounds) {
        self2.applyBounds();
      }
    }, updateMatrix = function updateMatrix2(shiftStart) {
      var start = matrix, p;
      matrix = getGlobalMatrix(target.parentNode, true);
      if (shiftStart && self2.isPressed && !matrix.equals(start || new Matrix2D())) {
        p = start.inverse().apply({
          x: startPointerX,
          y: startPointerY
        });
        matrix.apply(p, p);
        startPointerX = p.x;
        startPointerY = p.y;
      }
      if (matrix.equals(_identityMatrix)) {
        matrix = null;
      }
    }, recordStartPositions = function recordStartPositions2() {
      var edgeTolerance = 1 - self2.edgeResistance, offsetX = isFixed ? _getDocScrollLeft2(ownerDoc) : 0, offsetY = isFixed ? _getDocScrollTop2(ownerDoc) : 0, parsedOrigin, x, y;
      if (xyMode) {
        gsCache.x = getPropAsNum(xProp, "px") + "px";
        gsCache.y = getPropAsNum(yProp, "px") + "px";
        gsCache.renderTransform();
      }
      updateMatrix(false);
      _point1.x = self2.pointerX - offsetX;
      _point1.y = self2.pointerY - offsetY;
      matrix && matrix.apply(_point1, _point1);
      startPointerX = _point1.x;
      startPointerY = _point1.y;
      if (dirty) {
        setPointerPosition(self2.pointerX, self2.pointerY);
        render5(true);
      }
      innerMatrix = getGlobalMatrix(target);
      if (scrollProxy) {
        calculateBounds();
        startElementY = scrollProxy.top();
        startElementX = scrollProxy.left();
      } else {
        if (isTweening2()) {
          syncXY(true, true);
          calculateBounds();
        } else {
          self2.applyBounds();
        }
        if (rotationMode) {
          parsedOrigin = target.ownerSVGElement ? [gsCache.xOrigin - target.getBBox().x, gsCache.yOrigin - target.getBBox().y] : (_getComputedStyle(target)[_transformOriginProp] || "0 0").split(" ");
          rotationOrigin = self2.rotationOrigin = getGlobalMatrix(target).apply({
            x: parseFloat(parsedOrigin[0]) || 0,
            y: parseFloat(parsedOrigin[1]) || 0
          });
          syncXY(true, true);
          x = self2.pointerX - rotationOrigin.x - offsetX;
          y = rotationOrigin.y - self2.pointerY + offsetY;
          startElementX = self2.x;
          startElementY = self2.y = Math.atan2(y, x) * _RAD2DEG;
        } else {
          startElementY = getPropAsNum(yProp, "px");
          startElementX = getPropAsNum(xProp, "px");
        }
      }
      if (hasBounds && edgeTolerance) {
        if (startElementX > maxX) {
          startElementX = maxX + (startElementX - maxX) / edgeTolerance;
        } else if (startElementX < minX) {
          startElementX = minX - (minX - startElementX) / edgeTolerance;
        }
        if (!rotationMode) {
          if (startElementY > maxY) {
            startElementY = maxY + (startElementY - maxY) / edgeTolerance;
          } else if (startElementY < minY) {
            startElementY = minY - (minY - startElementY) / edgeTolerance;
          }
        }
      }
      self2.startX = startElementX = _round5(startElementX);
      self2.startY = startElementY = _round5(startElementY);
    }, isTweening2 = function isTweening3() {
      return self2.tween && self2.tween.isActive();
    }, removePlaceholder = function removePlaceholder2() {
      if (_placeholderDiv.parentNode && !isTweening2() && !self2.isDragging) {
        _placeholderDiv.parentNode.removeChild(_placeholderDiv);
      }
    }, onPress = function onPress2(e, force) {
      var i;
      if (!enabled || self2.isPressed || !e || (e.type === "mousedown" || e.type === "pointerdown") && !force && _getTime() - clickTime < 30 && _touchEventLookup[self2.pointerEvent.type]) {
        isPreventingDefault && e && enabled && _preventDefault(e);
        return;
      }
      interrupted = isTweening2();
      dragged = false;
      self2.pointerEvent = e;
      if (_touchEventLookup[e.type]) {
        touchEventTarget = ~e.type.indexOf("touch") ? e.currentTarget || e.target : ownerDoc;
        _addListener2(touchEventTarget, "touchend", onRelease);
        _addListener2(touchEventTarget, "touchmove", onMove);
        _addListener2(touchEventTarget, "touchcancel", onRelease);
        _addListener2(ownerDoc, "touchstart", _onMultiTouchDocument);
      } else {
        touchEventTarget = null;
        _addListener2(ownerDoc, "mousemove", onMove);
      }
      touchDragAxis = null;
      if (!_supportsPointer || !touchEventTarget) {
        _addListener2(ownerDoc, "mouseup", onRelease);
        e && e.target && _addListener2(e.target, "mouseup", onRelease);
      }
      isClicking = isClickable.call(self2, e.target) && vars.dragClickables === false && !force;
      if (isClicking) {
        _addListener2(e.target, "change", onRelease);
        _dispatchEvent(self2, "pressInit", "onPressInit");
        _dispatchEvent(self2, "press", "onPress");
        _setSelectable(triggers, true);
        isPreventingDefault = false;
        return;
      }
      allowNativeTouchScrolling = !touchEventTarget || allowX === allowY || self2.vars.allowNativeTouchScrolling === false || self2.vars.allowContextMenu && e && (e.ctrlKey || e.which > 2) ? false : allowX ? "y" : "x";
      isPreventingDefault = !allowNativeTouchScrolling && !self2.allowEventDefault;
      if (isPreventingDefault) {
        _preventDefault(e);
        _addListener2(_win, "touchforcechange", _preventDefault);
      }
      if (e.changedTouches) {
        e = touch = e.changedTouches[0];
        touchID = e.identifier;
      } else if (e.pointerId) {
        touchID = e.pointerId;
      } else {
        touch = touchID = null;
      }
      _dragCount++;
      _addToRenderQueue(render5);
      startPointerY = self2.pointerY = e.pageY;
      startPointerX = self2.pointerX = e.pageX;
      _dispatchEvent(self2, "pressInit", "onPressInit");
      if (allowNativeTouchScrolling || self2.autoScroll) {
        _recordMaxScrolls(target.parentNode);
      }
      if (target.parentNode && self2.autoScroll && !scrollProxy && !rotationMode && target.parentNode._gsMaxScrollX && !_placeholderDiv.parentNode && !target.getBBox) {
        _placeholderDiv.style.width = target.parentNode.scrollWidth + "px";
        target.parentNode.appendChild(_placeholderDiv);
      }
      recordStartPositions();
      self2.tween && self2.tween.kill();
      self2.isThrowing = false;
      gsap$2.killTweensOf(scrollProxy || target, killProps, true);
      scrollProxy && gsap$2.killTweensOf(target, {
        scrollTo: 1
      }, true);
      self2.tween = self2.lockedAxis = null;
      if (vars.zIndexBoost || !rotationMode && !scrollProxy && vars.zIndexBoost !== false) {
        target.style.zIndex = Draggable2.zIndex++;
      }
      self2.isPressed = true;
      hasDragCallback = !!(vars.onDrag || self2._listeners.drag);
      hasMoveCallback = !!(vars.onMove || self2._listeners.move);
      if (vars.cursor !== false || vars.activeCursor) {
        i = triggers.length;
        while (--i > -1) {
          gsap$2.set(triggers[i], {
            cursor: vars.activeCursor || vars.cursor || (_defaultCursor === "grab" ? "grabbing" : _defaultCursor)
          });
        }
      }
      _dispatchEvent(self2, "press", "onPress");
    }, onMove = function onMove2(e) {
      var originalEvent = e, touches, pointerX, pointerY, i, dx, dy;
      if (!enabled || _isMultiTouching || !self2.isPressed || !e) {
        isPreventingDefault && e && enabled && _preventDefault(e);
        return;
      }
      self2.pointerEvent = e;
      touches = e.changedTouches;
      if (touches) {
        e = touches[0];
        if (e !== touch && e.identifier !== touchID) {
          i = touches.length;
          while (--i > -1 && (e = touches[i]).identifier !== touchID && e.target !== target) {
          }
          if (i < 0) {
            return;
          }
        }
      } else if (e.pointerId && touchID && e.pointerId !== touchID) {
        return;
      }
      if (touchEventTarget && allowNativeTouchScrolling && !touchDragAxis) {
        _point1.x = e.pageX - (isFixed ? _getDocScrollLeft2(ownerDoc) : 0);
        _point1.y = e.pageY - (isFixed ? _getDocScrollTop2(ownerDoc) : 0);
        matrix && matrix.apply(_point1, _point1);
        pointerX = _point1.x;
        pointerY = _point1.y;
        dx = Math.abs(pointerX - startPointerX);
        dy = Math.abs(pointerY - startPointerY);
        if (dx !== dy && (dx > minimumMovement || dy > minimumMovement) || _isAndroid && allowNativeTouchScrolling === touchDragAxis) {
          touchDragAxis = dx > dy && allowX ? "x" : "y";
          if (allowNativeTouchScrolling && touchDragAxis !== allowNativeTouchScrolling) {
            _addListener2(_win, "touchforcechange", _preventDefault);
          }
          if (self2.vars.lockAxisOnTouchScroll !== false && allowX && allowY) {
            self2.lockedAxis = touchDragAxis === "x" ? "y" : "x";
            _isFunction2(self2.vars.onLockAxis) && self2.vars.onLockAxis.call(self2, originalEvent);
          }
          if (_isAndroid && allowNativeTouchScrolling === touchDragAxis) {
            onRelease(originalEvent);
            return;
          }
        }
      }
      if (!self2.allowEventDefault && (!allowNativeTouchScrolling || touchDragAxis && allowNativeTouchScrolling !== touchDragAxis) && originalEvent.cancelable !== false) {
        _preventDefault(originalEvent);
        isPreventingDefault = true;
      } else if (isPreventingDefault) {
        isPreventingDefault = false;
      }
      if (self2.autoScroll) {
        checkAutoScrollBounds = true;
      }
      setPointerPosition(e.pageX, e.pageY, hasMoveCallback);
    }, setPointerPosition = function setPointerPosition2(pointerX, pointerY, invokeOnMove) {
      var dragTolerance = 1 - self2.dragResistance, edgeTolerance = 1 - self2.edgeResistance, prevPointerX = self2.pointerX, prevPointerY = self2.pointerY, prevStartElementY = startElementY, prevX = self2.x, prevY = self2.y, prevEndX = self2.endX, prevEndY = self2.endY, prevEndRotation = self2.endRotation, prevDirty = dirty, xChange, yChange, x, y, dif, temp;
      self2.pointerX = pointerX;
      self2.pointerY = pointerY;
      if (isFixed) {
        pointerX -= _getDocScrollLeft2(ownerDoc);
        pointerY -= _getDocScrollTop2(ownerDoc);
      }
      if (rotationMode) {
        y = Math.atan2(rotationOrigin.y - pointerY, pointerX - rotationOrigin.x) * _RAD2DEG;
        dif = self2.y - y;
        if (dif > 180) {
          startElementY -= 360;
          self2.y = y;
        } else if (dif < -180) {
          startElementY += 360;
          self2.y = y;
        }
        if (self2.x !== startElementX || Math.abs(startElementY - y) > minimumMovement) {
          self2.y = y;
          x = startElementX + (startElementY - y) * dragTolerance;
        } else {
          x = startElementX;
        }
      } else {
        if (matrix) {
          temp = pointerX * matrix.a + pointerY * matrix.c + matrix.e;
          pointerY = pointerX * matrix.b + pointerY * matrix.d + matrix.f;
          pointerX = temp;
        }
        yChange = pointerY - startPointerY;
        xChange = pointerX - startPointerX;
        if (yChange < minimumMovement && yChange > -minimumMovement) {
          yChange = 0;
        }
        if (xChange < minimumMovement && xChange > -minimumMovement) {
          xChange = 0;
        }
        if ((self2.lockAxis || self2.lockedAxis) && (xChange || yChange)) {
          temp = self2.lockedAxis;
          if (!temp) {
            self2.lockedAxis = temp = allowX && Math.abs(xChange) > Math.abs(yChange) ? "y" : allowY ? "x" : null;
            if (temp && _isFunction2(self2.vars.onLockAxis)) {
              self2.vars.onLockAxis.call(self2, self2.pointerEvent);
            }
          }
          if (temp === "y") {
            yChange = 0;
          } else if (temp === "x") {
            xChange = 0;
          }
        }
        x = _round5(startElementX + xChange * dragTolerance);
        y = _round5(startElementY + yChange * dragTolerance);
      }
      if ((snapX || snapY || snapXY) && (self2.x !== x || self2.y !== y && !rotationMode)) {
        if (snapXY) {
          _temp1.x = x;
          _temp1.y = y;
          temp = snapXY(_temp1);
          x = _round5(temp.x);
          y = _round5(temp.y);
        }
        if (snapX) {
          x = _round5(snapX(x));
        }
        if (snapY) {
          y = _round5(snapY(y));
        }
      }
      if (hasBounds) {
        if (x > maxX) {
          x = maxX + Math.round((x - maxX) * edgeTolerance);
        } else if (x < minX) {
          x = minX + Math.round((x - minX) * edgeTolerance);
        }
        if (!rotationMode) {
          if (y > maxY) {
            y = Math.round(maxY + (y - maxY) * edgeTolerance);
          } else if (y < minY) {
            y = Math.round(minY + (y - minY) * edgeTolerance);
          }
        }
      }
      if (self2.x !== x || self2.y !== y && !rotationMode) {
        if (rotationMode) {
          self2.endRotation = self2.x = self2.endX = x;
          dirty = true;
        } else {
          if (allowY) {
            self2.y = self2.endY = y;
            dirty = true;
          }
          if (allowX) {
            self2.x = self2.endX = x;
            dirty = true;
          }
        }
        if (!invokeOnMove || _dispatchEvent(self2, "move", "onMove") !== false) {
          if (!self2.isDragging && self2.isPressed) {
            self2.isDragging = dragged = true;
            _dispatchEvent(self2, "dragstart", "onDragStart");
          }
        } else {
          self2.pointerX = prevPointerX;
          self2.pointerY = prevPointerY;
          startElementY = prevStartElementY;
          self2.x = prevX;
          self2.y = prevY;
          self2.endX = prevEndX;
          self2.endY = prevEndY;
          self2.endRotation = prevEndRotation;
          dirty = prevDirty;
        }
      }
    }, onRelease = function onRelease2(e, force) {
      if (!enabled || !self2.isPressed || e && touchID != null && !force && (e.pointerId && e.pointerId !== touchID && e.target !== target || e.changedTouches && !_hasTouchID(e.changedTouches, touchID))) {
        isPreventingDefault && e && enabled && _preventDefault(e);
        return;
      }
      self2.isPressed = false;
      var originalEvent = e, wasDragging = self2.isDragging, isContextMenuRelease = self2.vars.allowContextMenu && e && (e.ctrlKey || e.which > 2), placeholderDelayedCall = gsap$2.delayedCall(1e-3, removePlaceholder), touches, i, syntheticEvent, eventTarget, syntheticClick;
      if (touchEventTarget) {
        _removeListener2(touchEventTarget, "touchend", onRelease2);
        _removeListener2(touchEventTarget, "touchmove", onMove);
        _removeListener2(touchEventTarget, "touchcancel", onRelease2);
        _removeListener2(ownerDoc, "touchstart", _onMultiTouchDocument);
      } else {
        _removeListener2(ownerDoc, "mousemove", onMove);
      }
      _removeListener2(_win, "touchforcechange", _preventDefault);
      if (!_supportsPointer || !touchEventTarget) {
        _removeListener2(ownerDoc, "mouseup", onRelease2);
        e && e.target && _removeListener2(e.target, "mouseup", onRelease2);
      }
      dirty = false;
      if (wasDragging) {
        dragEndTime = _lastDragTime = _getTime();
        self2.isDragging = false;
      }
      _removeFromRenderQueue(render5);
      if (isClicking && !isContextMenuRelease) {
        if (e) {
          _removeListener2(e.target, "change", onRelease2);
          self2.pointerEvent = originalEvent;
        }
        _setSelectable(triggers, false);
        _dispatchEvent(self2, "release", "onRelease");
        _dispatchEvent(self2, "click", "onClick");
        isClicking = false;
        return;
      }
      i = triggers.length;
      while (--i > -1) {
        _setStyle(triggers[i], "cursor", vars.cursor || (vars.cursor !== false ? _defaultCursor : null));
      }
      _dragCount--;
      if (e) {
        touches = e.changedTouches;
        if (touches) {
          e = touches[0];
          if (e !== touch && e.identifier !== touchID) {
            i = touches.length;
            while (--i > -1 && (e = touches[i]).identifier !== touchID && e.target !== target) {
            }
            if (i < 0 && !force) {
              return;
            }
          }
        }
        self2.pointerEvent = originalEvent;
        self2.pointerX = e.pageX;
        self2.pointerY = e.pageY;
      }
      if (isContextMenuRelease && originalEvent) {
        _preventDefault(originalEvent);
        isPreventingDefault = true;
        _dispatchEvent(self2, "release", "onRelease");
      } else if (originalEvent && !wasDragging) {
        isPreventingDefault = false;
        if (interrupted && (vars.snap || vars.bounds)) {
          animate(vars.inertia || vars.throwProps);
        }
        _dispatchEvent(self2, "release", "onRelease");
        if ((!_isAndroid || originalEvent.type !== "touchmove") && originalEvent.type.indexOf("cancel") === -1) {
          _dispatchEvent(self2, "click", "onClick");
          if (_getTime() - clickTime < 300) {
            _dispatchEvent(self2, "doubleclick", "onDoubleClick");
          }
          eventTarget = originalEvent.target || target;
          clickTime = _getTime();
          syntheticClick = function syntheticClick2() {
            if (clickTime !== clickDispatch && self2.enabled() && !self2.isPressed && !originalEvent.defaultPrevented) {
              if (eventTarget.click) {
                eventTarget.click();
              } else if (ownerDoc.createEvent) {
                syntheticEvent = ownerDoc.createEvent("MouseEvents");
                syntheticEvent.initMouseEvent("click", true, true, _win, 1, self2.pointerEvent.screenX, self2.pointerEvent.screenY, self2.pointerX, self2.pointerY, false, false, false, false, 0, null);
                eventTarget.dispatchEvent(syntheticEvent);
              }
            }
          };
          if (!_isAndroid && !originalEvent.defaultPrevented) {
            gsap$2.delayedCall(0.05, syntheticClick);
          }
        }
      } else {
        animate(vars.inertia || vars.throwProps);
        if (!self2.allowEventDefault && originalEvent && (vars.dragClickables !== false || !isClickable.call(self2, originalEvent.target)) && wasDragging && (!allowNativeTouchScrolling || touchDragAxis && allowNativeTouchScrolling === touchDragAxis) && originalEvent.cancelable !== false) {
          isPreventingDefault = true;
          _preventDefault(originalEvent);
        } else {
          isPreventingDefault = false;
        }
        _dispatchEvent(self2, "release", "onRelease");
      }
      isTweening2() && placeholderDelayedCall.duration(self2.tween.duration());
      wasDragging && _dispatchEvent(self2, "dragend", "onDragEnd");
      return true;
    }, updateScroll = function updateScroll2(e) {
      if (e && self2.isDragging && !scrollProxy) {
        var parent = e.target || target.parentNode, deltaX = parent.scrollLeft - parent._gsScrollX, deltaY = parent.scrollTop - parent._gsScrollY;
        if (deltaX || deltaY) {
          if (matrix) {
            startPointerX -= deltaX * matrix.a + deltaY * matrix.c;
            startPointerY -= deltaY * matrix.d + deltaX * matrix.b;
          } else {
            startPointerX -= deltaX;
            startPointerY -= deltaY;
          }
          parent._gsScrollX += deltaX;
          parent._gsScrollY += deltaY;
          setPointerPosition(self2.pointerX, self2.pointerY);
        }
      }
    }, onClick = function onClick2(e) {
      var time = _getTime(), recentlyClicked = time - clickTime < 100, recentlyDragged = time - dragEndTime < 50, alreadyDispatched = recentlyClicked && clickDispatch === clickTime, defaultPrevented = self2.pointerEvent && self2.pointerEvent.defaultPrevented, alreadyDispatchedTrusted = recentlyClicked && trustedClickDispatch === clickTime, trusted = e.isTrusted || e.isTrusted == null && recentlyClicked && alreadyDispatched;
      if ((alreadyDispatched || recentlyDragged && self2.vars.suppressClickOnDrag !== false) && e.stopImmediatePropagation) {
        e.stopImmediatePropagation();
      }
      if (recentlyClicked && !(self2.pointerEvent && self2.pointerEvent.defaultPrevented) && (!alreadyDispatched || trusted && !alreadyDispatchedTrusted)) {
        if (trusted && alreadyDispatched) {
          trustedClickDispatch = clickTime;
        }
        clickDispatch = clickTime;
        return;
      }
      if (self2.isPressed || recentlyDragged || recentlyClicked) {
        if (!trusted || !e.detail || !recentlyClicked || defaultPrevented) {
          _preventDefault(e);
        }
      }
      if (!recentlyClicked && !recentlyDragged && !dragged) {
        e && e.target && (self2.pointerEvent = e);
        _dispatchEvent(self2, "click", "onClick");
      }
    }, localizePoint = function localizePoint2(p) {
      return matrix ? {
        x: p.x * matrix.a + p.y * matrix.c + matrix.e,
        y: p.x * matrix.b + p.y * matrix.d + matrix.f
      } : {
        x: p.x,
        y: p.y
      };
    };
    old = Draggable2.get(target);
    old && old.kill();
    _this2.startDrag = function(event, align) {
      var r1, r2, p1, p2;
      onPress(event || self2.pointerEvent, true);
      if (align && !self2.hitTest(event || self2.pointerEvent)) {
        r1 = _parseRect(event || self2.pointerEvent);
        r2 = _parseRect(target);
        p1 = localizePoint({
          x: r1.left + r1.width / 2,
          y: r1.top + r1.height / 2
        });
        p2 = localizePoint({
          x: r2.left + r2.width / 2,
          y: r2.top + r2.height / 2
        });
        startPointerX -= p1.x - p2.x;
        startPointerY -= p1.y - p2.y;
      }
      if (!self2.isDragging) {
        self2.isDragging = dragged = true;
        _dispatchEvent(self2, "dragstart", "onDragStart");
      }
    };
    _this2.drag = onMove;
    _this2.endDrag = function(e) {
      return onRelease(e || self2.pointerEvent, true);
    };
    _this2.timeSinceDrag = function() {
      return self2.isDragging ? 0 : (_getTime() - dragEndTime) / 1e3;
    };
    _this2.timeSinceClick = function() {
      return (_getTime() - clickTime) / 1e3;
    };
    _this2.hitTest = function(target2, threshold) {
      return Draggable2.hitTest(self2.target, target2, threshold);
    };
    _this2.getDirection = function(from, diagonalThreshold) {
      var mode = from === "velocity" && InertiaPlugin ? from : _isObject2(from) && !rotationMode ? "element" : "start", xChange, yChange, ratio, direction, r1, r2;
      if (mode === "element") {
        r1 = _parseRect(self2.target);
        r2 = _parseRect(from);
      }
      xChange = mode === "start" ? self2.x - startElementX : mode === "velocity" ? InertiaPlugin.getVelocity(target, xProp) : r1.left + r1.width / 2 - (r2.left + r2.width / 2);
      if (rotationMode) {
        return xChange < 0 ? "counter-clockwise" : "clockwise";
      } else {
        diagonalThreshold = diagonalThreshold || 2;
        yChange = mode === "start" ? self2.y - startElementY : mode === "velocity" ? InertiaPlugin.getVelocity(target, yProp) : r1.top + r1.height / 2 - (r2.top + r2.height / 2);
        ratio = Math.abs(xChange / yChange);
        direction = ratio < 1 / diagonalThreshold ? "" : xChange < 0 ? "left" : "right";
        if (ratio < diagonalThreshold) {
          if (direction !== "") {
            direction += "-";
          }
          direction += yChange < 0 ? "up" : "down";
        }
      }
      return direction;
    };
    _this2.applyBounds = function(newBounds, sticky) {
      var x, y, forceZeroVelocity, e, parent, isRoot;
      if (newBounds && vars.bounds !== newBounds) {
        vars.bounds = newBounds;
        return self2.update(true, sticky);
      }
      syncXY(true);
      calculateBounds();
      if (hasBounds && !isTweening2()) {
        x = self2.x;
        y = self2.y;
        if (x > maxX) {
          x = maxX;
        } else if (x < minX) {
          x = minX;
        }
        if (y > maxY) {
          y = maxY;
        } else if (y < minY) {
          y = minY;
        }
        if (self2.x !== x || self2.y !== y) {
          forceZeroVelocity = true;
          self2.x = self2.endX = x;
          if (rotationMode) {
            self2.endRotation = x;
          } else {
            self2.y = self2.endY = y;
          }
          dirty = true;
          render5(true);
          if (self2.autoScroll && !self2.isDragging) {
            _recordMaxScrolls(target.parentNode);
            e = target;
            _windowProxy.scrollTop = _win.pageYOffset != null ? _win.pageYOffset : ownerDoc.documentElement.scrollTop != null ? ownerDoc.documentElement.scrollTop : ownerDoc.body.scrollTop;
            _windowProxy.scrollLeft = _win.pageXOffset != null ? _win.pageXOffset : ownerDoc.documentElement.scrollLeft != null ? ownerDoc.documentElement.scrollLeft : ownerDoc.body.scrollLeft;
            while (e && !isRoot) {
              isRoot = _isRoot(e.parentNode);
              parent = isRoot ? _windowProxy : e.parentNode;
              if (allowY && parent.scrollTop > parent._gsMaxScrollY) {
                parent.scrollTop = parent._gsMaxScrollY;
              }
              if (allowX && parent.scrollLeft > parent._gsMaxScrollX) {
                parent.scrollLeft = parent._gsMaxScrollX;
              }
              e = parent;
            }
          }
        }
        if (self2.isThrowing && (forceZeroVelocity || self2.endX > maxX || self2.endX < minX || self2.endY > maxY || self2.endY < minY)) {
          animate(vars.inertia || vars.throwProps, forceZeroVelocity);
        }
      }
      return self2;
    };
    _this2.update = function(applyBounds, sticky, ignoreExternalChanges) {
      if (sticky && self2.isPressed) {
        var m = getGlobalMatrix(target), p = innerMatrix.apply({
          x: self2.x - startElementX,
          y: self2.y - startElementY
        }), m2 = getGlobalMatrix(target.parentNode, true);
        m2.apply({
          x: m.e - p.x,
          y: m.f - p.y
        }, p);
        self2.x -= p.x - m2.e;
        self2.y -= p.y - m2.f;
        render5(true);
        recordStartPositions();
      }
      var x = self2.x, y = self2.y;
      updateMatrix(!sticky);
      if (applyBounds) {
        self2.applyBounds();
      } else {
        dirty && ignoreExternalChanges && render5(true);
        syncXY(true);
      }
      if (sticky) {
        setPointerPosition(self2.pointerX, self2.pointerY);
        dirty && render5(true);
      }
      if (self2.isPressed && !sticky && (allowX && Math.abs(x - self2.x) > 0.01 || allowY && Math.abs(y - self2.y) > 0.01 && !rotationMode)) {
        recordStartPositions();
      }
      if (self2.autoScroll) {
        _recordMaxScrolls(target.parentNode, self2.isDragging);
        checkAutoScrollBounds = self2.isDragging;
        render5(true);
        _removeScrollListener(target, updateScroll);
        _addScrollListener(target, updateScroll);
      }
      return self2;
    };
    _this2.enable = function(type2) {
      var setVars = {
        lazy: true
      }, id, i, trigger;
      if (vars.cursor !== false) {
        setVars.cursor = vars.cursor || _defaultCursor;
      }
      if (gsap$2.utils.checkPrefix("touchCallout")) {
        setVars.touchCallout = "none";
      }
      if (type2 !== "soft") {
        _setTouchActionForAllDescendants(triggers, allowX === allowY ? "none" : vars.allowNativeTouchScrolling && target.scrollHeight === target.clientHeight === (target.scrollWidth === target.clientHeight) || vars.allowEventDefault ? "manipulation" : allowX ? "pan-y" : "pan-x");
        i = triggers.length;
        while (--i > -1) {
          trigger = triggers[i];
          _supportsPointer || _addListener2(trigger, "mousedown", onPress);
          _addListener2(trigger, "touchstart", onPress);
          _addListener2(trigger, "click", onClick, true);
          gsap$2.set(trigger, setVars);
          if (trigger.getBBox && trigger.ownerSVGElement && allowX !== allowY) {
            gsap$2.set(trigger.ownerSVGElement, {
              touchAction: vars.allowNativeTouchScrolling || vars.allowEventDefault ? "manipulation" : allowX ? "pan-y" : "pan-x"
            });
          }
          vars.allowContextMenu || _addListener2(trigger, "contextmenu", onContextMenu);
        }
        _setSelectable(triggers, false);
      }
      _addScrollListener(target, updateScroll);
      enabled = true;
      if (InertiaPlugin && type2 !== "soft") {
        InertiaPlugin.track(scrollProxy || target, xyMode ? "x,y" : rotationMode ? "rotation" : "top,left");
      }
      target._gsDragID = id = "d" + _lookupCount++;
      _lookup[id] = self2;
      if (scrollProxy) {
        scrollProxy.enable();
        scrollProxy.element._gsDragID = id;
      }
      (vars.bounds || rotationMode) && recordStartPositions();
      vars.bounds && self2.applyBounds();
      return self2;
    };
    _this2.disable = function(type2) {
      var dragging = self2.isDragging, i = triggers.length, trigger;
      while (--i > -1) {
        _setStyle(triggers[i], "cursor", null);
      }
      if (type2 !== "soft") {
        _setTouchActionForAllDescendants(triggers, null);
        i = triggers.length;
        while (--i > -1) {
          trigger = triggers[i];
          _setStyle(trigger, "touchCallout", null);
          _removeListener2(trigger, "mousedown", onPress);
          _removeListener2(trigger, "touchstart", onPress);
          _removeListener2(trigger, "click", onClick, true);
          _removeListener2(trigger, "contextmenu", onContextMenu);
        }
        _setSelectable(triggers, true);
        if (touchEventTarget) {
          _removeListener2(touchEventTarget, "touchcancel", onRelease);
          _removeListener2(touchEventTarget, "touchend", onRelease);
          _removeListener2(touchEventTarget, "touchmove", onMove);
        }
        _removeListener2(ownerDoc, "mouseup", onRelease);
        _removeListener2(ownerDoc, "mousemove", onMove);
      }
      _removeScrollListener(target, updateScroll);
      enabled = false;
      if (InertiaPlugin && type2 !== "soft") {
        InertiaPlugin.untrack(scrollProxy || target, xyMode ? "x,y" : rotationMode ? "rotation" : "top,left");
        self2.tween && self2.tween.kill();
      }
      scrollProxy && scrollProxy.disable();
      _removeFromRenderQueue(render5);
      self2.isDragging = self2.isPressed = isClicking = false;
      dragging && _dispatchEvent(self2, "dragend", "onDragEnd");
      return self2;
    };
    _this2.enabled = function(value, type2) {
      return arguments.length ? value ? self2.enable(type2) : self2.disable(type2) : enabled;
    };
    _this2.kill = function() {
      self2.isThrowing = false;
      self2.tween && self2.tween.kill();
      self2.disable();
      gsap$2.set(triggers, {
        clearProps: "userSelect"
      });
      delete _lookup[target._gsDragID];
      return self2;
    };
    _this2.revert = function() {
      this.kill();
      this.styles && this.styles.revert();
    };
    if (~type.indexOf("scroll")) {
      scrollProxy = _this2.scrollProxy = new ScrollProxy(target, _extend({
        onKill: function onKill() {
          self2.isPressed && onRelease(null);
        }
      }, vars));
      target.style.overflowY = allowY && !_isTouchDevice ? "auto" : "hidden";
      target.style.overflowX = allowX && !_isTouchDevice ? "auto" : "hidden";
      target = scrollProxy.content;
    }
    if (rotationMode) {
      killProps.rotation = 1;
    } else {
      if (allowX) {
        killProps[xProp] = 1;
      }
      if (allowY) {
        killProps[yProp] = 1;
      }
    }
    gsCache.force3D = "force3D" in vars ? vars.force3D : true;
    _context(_assertThisInitialized(_this2));
    _this2.enable();
    return _this2;
  }
  Draggable2.register = function register2(core) {
    gsap$2 = core;
    _initCore4();
  };
  Draggable2.create = function create(targets, vars) {
    _coreInitted || _initCore4(true);
    return _toArray$1(targets).map(function(target) {
      return new Draggable2(target, vars);
    });
  };
  Draggable2.get = function get2(target) {
    return _lookup[(_toArray$1(target)[0] || {})._gsDragID];
  };
  Draggable2.timeSinceDrag = function timeSinceDrag() {
    return (_getTime() - _lastDragTime) / 1e3;
  };
  Draggable2.hitTest = function hitTest(obj1, obj2, threshold) {
    if (obj1 === obj2) {
      return false;
    }
    var r1 = _parseRect(obj1), r2 = _parseRect(obj2), top = r1.top, left = r1.left, right = r1.right, bottom = r1.bottom, width = r1.width, height = r1.height, isOutside = r2.left > right || r2.right < left || r2.top > bottom || r2.bottom < top, overlap, area, isRatio;
    if (isOutside || !threshold) {
      return !isOutside;
    }
    isRatio = (threshold + "").indexOf("%") !== -1;
    threshold = parseFloat(threshold) || 0;
    overlap = {
      left: Math.max(left, r2.left),
      top: Math.max(top, r2.top)
    };
    overlap.width = Math.min(right, r2.right) - overlap.left;
    overlap.height = Math.min(bottom, r2.bottom) - overlap.top;
    if (overlap.width < 0 || overlap.height < 0) {
      return false;
    }
    if (isRatio) {
      threshold *= 0.01;
      area = overlap.width * overlap.height;
      return area >= width * height * threshold || area >= r2.width * r2.height * threshold;
    }
    return overlap.width > threshold && overlap.height > threshold;
  };
  return Draggable2;
}(EventDispatcher);
_setDefaults2(Draggable.prototype, {
  pointerX: 0,
  pointerY: 0,
  startX: 0,
  startY: 0,
  deltaX: 0,
  deltaY: 0,
  isDragging: false,
  isPressed: false
});
Draggable.zIndex = 1e3;
Draggable.version = "3.12.5";
_getGSAP$2() && gsap$2.registerPlugin(Draggable);
/*!
 * MotionPathPlugin 3.12.5
 * https://gsap.com
 *
 * @license Copyright 2008-2024, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license or for
 * Club GSAP members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/
var _xProps = "x,translateX,left,marginLeft,xPercent".split(","), _yProps = "y,translateY,top,marginTop,yPercent".split(","), _DEG2RAD = Math.PI / 180, gsap$1, PropTween, _getUnit, _toArray, _getStyleSaver2, _reverting, _getGSAP$1 = function _getGSAP4() {
  return gsap$1 || typeof window !== "undefined" && (gsap$1 = window.gsap) && gsap$1.registerPlugin && gsap$1;
}, _populateSegmentFromArray = function _populateSegmentFromArray2(segment, values, property, mode) {
  var l = values.length, si = mode === 2 ? 0 : mode, i = 0;
  for (; i < l; i++) {
    segment[si] = parseFloat(values[i][property]);
    mode === 2 && (segment[si + 1] = 0);
    si += 2;
  }
  return segment;
}, _getPropNum = function _getPropNum2(target, prop, unit) {
  return parseFloat(target._gsap.get(target, prop, unit || "px")) || 0;
}, _relativize = function _relativize2(segment) {
  var x = segment[0], y = segment[1], i;
  for (i = 2; i < segment.length; i += 2) {
    x = segment[i] += x;
    y = segment[i + 1] += y;
  }
}, _segmentToRawPath = function _segmentToRawPath2(plugin, segment, target, x, y, slicer, vars, unitX, unitY) {
  if (vars.type === "cubic") {
    segment = [segment];
  } else {
    vars.fromCurrent !== false && segment.unshift(_getPropNum(target, x, unitX), y ? _getPropNum(target, y, unitY) : 0);
    vars.relative && _relativize(segment);
    var pointFunc = y ? pointsToSegment : flatPointsToSegment;
    segment = [pointFunc(segment, vars.curviness)];
  }
  segment = slicer(_align(segment, target, vars));
  _addDimensionalPropTween(plugin, target, x, segment, "x", unitX);
  y && _addDimensionalPropTween(plugin, target, y, segment, "y", unitY);
  return cacheRawPathMeasurements(segment, vars.resolution || (vars.curviness === 0 ? 20 : 12));
}, _emptyFunc3 = function _emptyFunc4(v) {
  return v;
}, _numExp = /[-+\.]*\d+\.?(?:e-|e\+)?\d*/g, _originToPoint = function _originToPoint2(element, origin, parentMatrix) {
  var m = getGlobalMatrix(element), x = 0, y = 0, svg;
  if ((element.tagName + "").toLowerCase() === "svg") {
    svg = element.viewBox.baseVal;
    svg.width || (svg = {
      width: +element.getAttribute("width"),
      height: +element.getAttribute("height")
    });
  } else {
    svg = origin && element.getBBox && element.getBBox();
  }
  if (origin && origin !== "auto") {
    x = origin.push ? origin[0] * (svg ? svg.width : element.offsetWidth || 0) : origin.x;
    y = origin.push ? origin[1] * (svg ? svg.height : element.offsetHeight || 0) : origin.y;
  }
  return parentMatrix.apply(x || y ? m.apply({
    x,
    y
  }) : {
    x: m.e,
    y: m.f
  });
}, _getAlignMatrix = function _getAlignMatrix2(fromElement, toElement, fromOrigin, toOrigin) {
  var parentMatrix = getGlobalMatrix(fromElement.parentNode, true, true), m = parentMatrix.clone().multiply(getGlobalMatrix(toElement)), fromPoint = _originToPoint(fromElement, fromOrigin, parentMatrix), _originToPoint22 = _originToPoint(toElement, toOrigin, parentMatrix), x = _originToPoint22.x, y = _originToPoint22.y, p;
  m.e = m.f = 0;
  if (toOrigin === "auto" && toElement.getTotalLength && toElement.tagName.toLowerCase() === "path") {
    p = toElement.getAttribute("d").match(_numExp) || [];
    p = m.apply({
      x: +p[0],
      y: +p[1]
    });
    x += p.x;
    y += p.y;
  }
  if (p) {
    p = m.apply(toElement.getBBox());
    x -= p.x;
    y -= p.y;
  }
  m.e = x - fromPoint.x;
  m.f = y - fromPoint.y;
  return m;
}, _align = function _align2(rawPath, target, _ref) {
  var align = _ref.align, matrix = _ref.matrix, offsetX = _ref.offsetX, offsetY = _ref.offsetY, alignOrigin = _ref.alignOrigin;
  var x = rawPath[0][0], y = rawPath[0][1], curX = _getPropNum(target, "x"), curY = _getPropNum(target, "y"), alignTarget, m, p;
  if (!rawPath || !rawPath.length) {
    return getRawPath("M0,0L0,0");
  }
  if (align) {
    if (align === "self" || (alignTarget = _toArray(align)[0] || target) === target) {
      transformRawPath(rawPath, 1, 0, 0, 1, curX - x, curY - y);
    } else {
      if (alignOrigin && alignOrigin[2] !== false) {
        gsap$1.set(target, {
          transformOrigin: alignOrigin[0] * 100 + "% " + alignOrigin[1] * 100 + "%"
        });
      } else {
        alignOrigin = [_getPropNum(target, "xPercent") / -100, _getPropNum(target, "yPercent") / -100];
      }
      m = _getAlignMatrix(target, alignTarget, alignOrigin, "auto");
      p = m.apply({
        x,
        y
      });
      transformRawPath(rawPath, m.a, m.b, m.c, m.d, curX + m.e - (p.x - m.e), curY + m.f - (p.y - m.f));
    }
  }
  if (matrix) {
    transformRawPath(rawPath, matrix.a, matrix.b, matrix.c, matrix.d, matrix.e, matrix.f);
  } else if (offsetX || offsetY) {
    transformRawPath(rawPath, 1, 0, 0, 1, offsetX || 0, offsetY || 0);
  }
  return rawPath;
}, _addDimensionalPropTween = function _addDimensionalPropTween2(plugin, target, property, rawPath, pathProperty, forceUnit) {
  var cache = target._gsap, harness = cache.harness, alias = harness && harness.aliases && harness.aliases[property], prop = alias && alias.indexOf(",") < 0 ? alias : property, pt = plugin._pt = new PropTween(plugin._pt, target, prop, 0, 0, _emptyFunc3, 0, cache.set(target, prop, plugin));
  pt.u = _getUnit(cache.get(target, prop, forceUnit)) || 0;
  pt.path = rawPath;
  pt.pp = pathProperty;
  plugin._props.push(prop);
}, _sliceModifier = function _sliceModifier2(start, end) {
  return function(rawPath) {
    return start || end !== 1 ? sliceRawPath(rawPath, start, end) : rawPath;
  };
};
var MotionPathPlugin = {
  version: "3.12.5",
  name: "motionPath",
  register: function register(core, Plugin, propTween) {
    gsap$1 = core;
    _getUnit = gsap$1.utils.getUnit;
    _toArray = gsap$1.utils.toArray;
    _getStyleSaver2 = gsap$1.core.getStyleSaver;
    _reverting = gsap$1.core.reverting || function() {
    };
    PropTween = propTween;
  },
  init: function init4(target, vars, tween) {
    if (!gsap$1) {
      console.warn("Please gsap.registerPlugin(MotionPathPlugin)");
      return false;
    }
    if (!(typeof vars === "object" && !vars.style) || !vars.path) {
      vars = {
        path: vars
      };
    }
    var rawPaths = [], _vars = vars, path = _vars.path, autoRotate = _vars.autoRotate, unitX = _vars.unitX, unitY = _vars.unitY, x = _vars.x, y = _vars.y, firstObj = path[0], slicer = _sliceModifier(vars.start, "end" in vars ? vars.end : 1), rawPath, p;
    this.rawPaths = rawPaths;
    this.target = target;
    this.tween = tween;
    this.styles = _getStyleSaver2 && _getStyleSaver2(target, "transform");
    if (this.rotate = autoRotate || autoRotate === 0) {
      this.rOffset = parseFloat(autoRotate) || 0;
      this.radians = !!vars.useRadians;
      this.rProp = vars.rotation || "rotation";
      this.rSet = target._gsap.set(target, this.rProp, this);
      this.ru = _getUnit(target._gsap.get(target, this.rProp)) || 0;
    }
    if (Array.isArray(path) && !("closed" in path) && typeof firstObj !== "number") {
      for (p in firstObj) {
        if (!x && ~_xProps.indexOf(p)) {
          x = p;
        } else if (!y && ~_yProps.indexOf(p)) {
          y = p;
        }
      }
      if (x && y) {
        rawPaths.push(_segmentToRawPath(this, _populateSegmentFromArray(_populateSegmentFromArray([], path, x, 0), path, y, 1), target, x, y, slicer, vars, unitX || _getUnit(path[0][x]), unitY || _getUnit(path[0][y])));
      } else {
        x = y = 0;
      }
      for (p in firstObj) {
        p !== x && p !== y && rawPaths.push(_segmentToRawPath(this, _populateSegmentFromArray([], path, p, 2), target, p, 0, slicer, vars, _getUnit(path[0][p])));
      }
    } else {
      rawPath = slicer(_align(getRawPath(vars.path), target, vars));
      cacheRawPathMeasurements(rawPath, vars.resolution);
      rawPaths.push(rawPath);
      _addDimensionalPropTween(this, target, vars.x || "x", rawPath, "x", vars.unitX || "px");
      _addDimensionalPropTween(this, target, vars.y || "y", rawPath, "y", vars.unitY || "px");
    }
  },
  render: function render3(ratio, data) {
    var rawPaths = data.rawPaths, i = rawPaths.length, pt = data._pt;
    if (data.tween._time || !_reverting()) {
      if (ratio > 1) {
        ratio = 1;
      } else if (ratio < 0) {
        ratio = 0;
      }
      while (i--) {
        getPositionOnPath(rawPaths[i], ratio, !i && data.rotate, rawPaths[i]);
      }
      while (pt) {
        pt.set(pt.t, pt.p, pt.path[pt.pp] + pt.u, pt.d, ratio);
        pt = pt._next;
      }
      data.rotate && data.rSet(data.target, data.rProp, rawPaths[0].angle * (data.radians ? _DEG2RAD : 1) + data.rOffset + data.ru, data, ratio);
    } else {
      data.styles.revert();
    }
  },
  getLength: function getLength(path) {
    return cacheRawPathMeasurements(getRawPath(path)).totalLength;
  },
  sliceRawPath,
  getRawPath,
  pointsToSegment,
  stringToRawPath,
  rawPathToString,
  transformRawPath,
  getGlobalMatrix,
  getPositionOnPath,
  cacheRawPathMeasurements,
  convertToPath: function convertToPath$1(targets, swap) {
    return _toArray(targets).map(function(target) {
      return convertToPath(target, swap !== false);
    });
  },
  convertCoordinates: function convertCoordinates(fromElement, toElement, point) {
    var m = getGlobalMatrix(toElement, true, true).multiply(getGlobalMatrix(fromElement));
    return point ? m.apply(point) : m;
  },
  getAlignMatrix: _getAlignMatrix,
  getRelativePosition: function getRelativePosition(fromElement, toElement, fromOrigin, toOrigin) {
    var m = _getAlignMatrix(fromElement, toElement, fromOrigin, toOrigin);
    return {
      x: m.e,
      y: m.f
    };
  },
  arrayToRawPath: function arrayToRawPath(value, vars) {
    vars = vars || {};
    var segment = _populateSegmentFromArray(_populateSegmentFromArray([], value, vars.x || "x", 0), value, vars.y || "y", 1);
    vars.relative && _relativize(segment);
    return [vars.type === "cubic" ? segment : pointsToSegment(segment, vars.curviness)];
  }
};
_getGSAP$1() && gsap$1.registerPlugin(MotionPathPlugin);
/*!
 * strings: 3.12.5
 * https://gsap.com
 *
 * Copyright 2008-2024, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license or for
 * Club GSAP members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/
var _trimExp = /(?:^\s+|\s+$)/g;
var emojiExp = /([\uD800-\uDBFF][\uDC00-\uDFFF](?:[\u200D\uFE0F][\uD800-\uDBFF][\uDC00-\uDFFF]){2,}|\uD83D\uDC69(?:\u200D(?:(?:\uD83D\uDC69\u200D)?\uD83D\uDC67|(?:\uD83D\uDC69\u200D)?\uD83D\uDC66)|\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC69\u200D(?:\uD83D\uDC69\u200D)?\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D(?:\uD83D\uDC69\u200D)?\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]\uFE0F|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC6F\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3C-\uDD3E\uDDD6-\uDDDF])\u200D[\u2640\u2642]\uFE0F|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF6\uD83C\uDDE6|\uD83C\uDDF4\uD83C\uDDF2|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F\u200D[\u2640\u2642]|(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642])\uFE0F|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2695\u2696\u2708]|\uD83D\uDC69\u200D[\u2695\u2696\u2708]|\uD83D\uDC68(?:(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708]))\uFE0F|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83D\uDC69\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69]))|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|[#\*0-9]\uFE0F\u20E3|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67)\uDB40\uDC7F|\uD83D\uDC68(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC66\u200D\uD83D\uDC66|(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92])|(?:\uD83C[\uDFFB-\uDFFF])\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]))|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270A-\u270D]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC70\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDCAA\uDD74\uDD7A\uDD90\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD36\uDDD1-\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\u200D(?:(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC67|(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC66)|\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC69\uDC6E\uDC70-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD18-\uDD1C\uDD1E\uDD1F\uDD26\uDD30-\uDD39\uDD3D\uDD3E\uDDD1-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])?|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDEEB\uDEEC\uDEF4-\uDEF8]|\uD83E[\uDD10-\uDD3A\uDD3C-\uDD3E\uDD40-\uDD45\uDD47-\uDD4C\uDD50-\uDD6B\uDD80-\uDD97\uDDC0\uDDD0-\uDDE6])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u2660\u2663\u2665\u2666\u2668\u267B\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEF8]|\uD83E[\uDD10-\uDD3A\uDD3C-\uDD3E\uDD40-\uDD45\uDD47-\uDD4C\uDD50-\uDD6B\uDD80-\uDD97\uDDC0\uDDD0-\uDDE6])\uFE0F)/;
function getText(e) {
  var type = e.nodeType, result = "";
  if (type === 1 || type === 9 || type === 11) {
    if (typeof e.textContent === "string") {
      return e.textContent;
    } else {
      for (e = e.firstChild; e; e = e.nextSibling) {
        result += getText(e);
      }
    }
  } else if (type === 3 || type === 4) {
    return e.nodeValue;
  }
  return result;
}
function splitInnerHTML(element, delimiter, trim, preserveSpaces) {
  var node = element.firstChild, result = [], s;
  while (node) {
    if (node.nodeType === 3) {
      s = (node.nodeValue + "").replace(/^\n+/g, "");
      if (!preserveSpaces) {
        s = s.replace(/\s+/g, " ");
      }
      result.push.apply(result, emojiSafeSplit(s, delimiter, trim, preserveSpaces));
    } else if ((node.nodeName + "").toLowerCase() === "br") {
      result[result.length - 1] += "<br>";
    } else {
      result.push(node.outerHTML);
    }
    node = node.nextSibling;
  }
  s = result.length;
  while (s--) {
    result[s] === "&" && result.splice(s, 1, "&amp;");
  }
  return result;
}
function emojiSafeSplit(text, delimiter, trim, preserveSpaces) {
  text += "";
  trim && (text = text.trim ? text.trim() : text.replace(_trimExp, ""));
  if (delimiter && delimiter !== "") {
    return text.replace(/>/g, "&gt;").replace(/</g, "&lt;").split(delimiter);
  }
  var result = [], l = text.length, i = 0, j, character;
  for (; i < l; i++) {
    character = text.charAt(i);
    if (character.charCodeAt(0) >= 55296 && character.charCodeAt(0) <= 56319 || text.charCodeAt(i + 1) >= 65024 && text.charCodeAt(i + 1) <= 65039) {
      j = ((text.substr(i, 12).split(emojiExp) || [])[1] || "").length || 2;
      character = text.substr(i, j);
      result.emoji = 1;
      i += j - 1;
    }
    result.push(character === ">" ? "&gt;" : character === "<" ? "&lt;" : preserveSpaces && character === " " && (text.charAt(i - 1) === " " || text.charAt(i + 1) === " ") ? "&nbsp;" : character);
  }
  return result;
}
/*!
 * TextPlugin 3.12.5
 * https://gsap.com
 *
 * @license Copyright 2008-2024, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license or for
 * Club GSAP members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/
var gsap, _tempDiv, _getGSAP5 = function _getGSAP6() {
  return gsap || typeof window !== "undefined" && (gsap = window.gsap) && gsap.registerPlugin && gsap;
};
var TextPlugin = {
  version: "3.12.5",
  name: "text",
  init: function init5(target, value, tween) {
    typeof value !== "object" && (value = {
      value
    });
    var i = target.nodeName.toUpperCase(), data = this, _value = value, newClass = _value.newClass, oldClass = _value.oldClass, preserveSpaces = _value.preserveSpaces, rtl = _value.rtl, delimiter = data.delimiter = value.delimiter || "", fillChar = data.fillChar = value.fillChar || (value.padSpace ? "&nbsp;" : ""), _short, text, original, j, condensedText, condensedOriginal, aggregate, s;
    data.svg = target.getBBox && (i === "TEXT" || i === "TSPAN");
    if (!("innerHTML" in target) && !data.svg) {
      return false;
    }
    data.target = target;
    if (!("value" in value)) {
      data.text = data.original = [""];
      return;
    }
    original = splitInnerHTML(target, delimiter, false, preserveSpaces);
    _tempDiv || (_tempDiv = document.createElement("div"));
    _tempDiv.innerHTML = value.value;
    text = splitInnerHTML(_tempDiv, delimiter, false, preserveSpaces);
    data.from = tween._from;
    if ((data.from || rtl) && !(rtl && data.from)) {
      i = original;
      original = text;
      text = i;
    }
    data.hasClass = !!(newClass || oldClass);
    data.newClass = rtl ? oldClass : newClass;
    data.oldClass = rtl ? newClass : oldClass;
    i = original.length - text.length;
    _short = i < 0 ? original : text;
    if (i < 0) {
      i = -i;
    }
    while (--i > -1) {
      _short.push(fillChar);
    }
    if (value.type === "diff") {
      j = 0;
      condensedText = [];
      condensedOriginal = [];
      aggregate = "";
      for (i = 0; i < text.length; i++) {
        s = text[i];
        if (s === original[i]) {
          aggregate += s;
        } else {
          condensedText[j] = aggregate + s;
          condensedOriginal[j++] = aggregate + original[i];
          aggregate = "";
        }
      }
      text = condensedText;
      original = condensedOriginal;
      if (aggregate) {
        text.push(aggregate);
        original.push(aggregate);
      }
    }
    value.speed && tween.duration(Math.min(0.05 / value.speed * _short.length, value.maxDuration || 9999));
    data.rtl = rtl;
    data.original = original;
    data.text = text;
    data._props.push("text");
  },
  render: function render4(ratio, data) {
    if (ratio > 1) {
      ratio = 1;
    } else if (ratio < 0) {
      ratio = 0;
    }
    if (data.from) {
      ratio = 1 - ratio;
    }
    var text = data.text, hasClass = data.hasClass, newClass = data.newClass, oldClass = data.oldClass, delimiter = data.delimiter, target = data.target, fillChar = data.fillChar, original = data.original, rtl = data.rtl, l = text.length, i = (rtl ? 1 - ratio : ratio) * l + 0.5 | 0, applyNew, applyOld, str2;
    if (hasClass && ratio) {
      applyNew = newClass && i;
      applyOld = oldClass && i !== l;
      str2 = (applyNew ? "<span class='" + newClass + "'>" : "") + text.slice(0, i).join(delimiter) + (applyNew ? "</span>" : "") + (applyOld ? "<span class='" + oldClass + "'>" : "") + delimiter + original.slice(i).join(delimiter) + (applyOld ? "</span>" : "");
    } else {
      str2 = text.slice(0, i).join(delimiter) + delimiter + original.slice(i).join(delimiter);
    }
    if (data.svg) {
      target.textContent = str2;
    } else {
      target.innerHTML = fillChar === "&nbsp;" && ~str2.indexOf("  ") ? str2.split("  ").join("&nbsp;&nbsp;") : str2;
    }
  }
};
TextPlugin.splitInnerHTML = splitInnerHTML;
TextPlugin.emojiSafeSplit = emojiSafeSplit;
TextPlugin.getText = getText;
_getGSAP5() && gsap.registerPlugin(TextPlugin);
gsapWithCSS.registerPlugin(MotionPathPlugin);
const _noCapWords = "a|above|after|an|and|at|below|but|by|down|for|for|from|in|nor|of|off|on|onto|or|out|so|the|to|under|up|with|yet".split("|").map((word) => new RegExp(`\\b${word}\\b`, "gui"));
const _capWords = [
  "I",
  /[^a-z]{3,}|[.0-9]/gu
].map((word) => /RegExp/.test(Object.prototype.toString.call(word)) ? word : new RegExp(`\\b${word}\\b`, "gui"));
const _loremIpsumText = `Lorem ipsum dolor sit amet, consectetur adipiscing elit. Suspendisse ultricies
nibh sed massa euismod lacinia. Aliquam nec est ac nunc ultricies scelerisque porta vulputate odio.
Integer gravida mattis odio, semper volutpat tellus. Ut elit leo, auctor eget fermentum hendrerit,
aliquet ac nunc. Suspendisse porta turpis vitae mi posuere molestie. Cras lectus lacus, vulputate a
vestibulum in, mattis vel mi. Mauris quis semper mauris. Praesent blandit nec diam eget tincidunt. Nunc
aliquet consequat massa ac lacinia. Ut posuere velit sagittis, vehicula nisl eget, fringilla nibh. Duis
volutpat mattis libero, a porttitor sapien viverra ut. Phasellus vulputate imperdiet ligula, eget
eleifend metus tempor nec. Nam eget sapien risus. Praesent id suscipit elit. Sed pellentesque ligula
diam, non aliquet magna feugiat vitae. Pellentesque ut tortor id erat placerat dignissim. Pellentesque
ut dui vel leo laoreet sodales nec ac tellus. In hac habitasse platea dictumst. Proin sed ex sed augue
sollicitudin interdum. Sed id lacus porttitor nisi vestibulum tincidunt. Nulla facilisi. Vestibulum
feugiat finibus magna in pretium. Proin consectetur lectus nisi, non commodo lectus tempor et. Cras
viverra, mi in consequat aliquet, justo mauris fringilla tellus, at accumsan magna metus in eros. Sed
vehicula, diam ut sagittis semper, purus massa mattis dolor, in posuere.`;
const _randomWords = `
aboveboard|account|achiever|acoustics|act|action|activity|actor|addition|adjustment|advertisement|advice|afterglow|afterimage|afterlife|aftermath|afternoon|afterthought|agreement
air|aircraft|airfield|airlift|airline|airmen|airplane|airport|airtime|alarm|allover|allspice|alongside|also|amount|amusement|anger|angle|animal|another|ants|anyhow|anymore
anyone|anyplace|anytime|anywhere|apparatus|apparel|appliance|approval|arch|argument|arithmetic|arm|army|around|art|ashtray|attack|attraction|aunt|authority|babies|baby|babysitter
back|backache|backbone|backbreaker|backdrop|backfire|background|backhand|backlash|backlog|backpack|backside|backslap|backslide|backspace|backspin|backstroke|backtrack|backward
badge|bag|bait|balance|ball|ballroom|bankbook|bankroll|base|baseball|basin|basket|basketball|bat|bath|battle|beachcomb|bead|bear|because|become|bed|bedrock|bedroll|bedroom
beds|bee|beef|beginner|behavior|belief|believe|bell|bellboy|bellhop|bells|below|berry|bike|bikes|bird|birds|birth|birthday|bit|bite|blackball|blackberries|blackbird|blackboard
blackjack|blacklist|blackmail|blackout|blacksmith|blacktop|blade|blood|blow|blowgun|bluebell|blueberry|bluebird|bluefish|bluegrass|blueprint|board|boardwalk|boat|bodyguard
bomb|bone|book|bookcase|bookend|bookkeeper|bookmark|bookmobile|books|bookseller|bookshelf|bookworm|boot|border|bottle|boundary|bowlegs|bowtie|box|boy|brainchild|brake|branch
brass|breath|brick|bridge|brother|bubble|bucket|bugspray|building|bulb|burst|bushes|business|butter|butterball|buttercup|butterfingers|buttermilk|butternut|butterscotch|button
bypass|cabbage|cabdriver|cable|cactus|cake|cakes|calculator|calendar|camera|camp|can|cancan|candlelight|candlestick|cannon|cannot|canvas|cap|caption|car|card|cardsharp|care
carefree|careworn|carfare|carload|carpenter|carpool|carport|carriage|cars|carsick|cart|cartwheel|cast|cat|cats|cattle|catwalk|cause|cave|caveman|celery|cellar|cemetery|cent
centercut|chalk|chance|change|channel|cheese|cheeseburger|cherries|cherry|chess|chicken|chickens|children|chin|church|circle|clam|class|clockwise|cloth|clover|club|coach|coal
coast|coat|cobweb|coffeemaker|coil|collar|color|comeback|committee|commonplace|commonwealth|company|comparison|competition|condition|connection|control|cook|copper|corn|cornmeal
cough|country|courthouse|cover|cow|cows|crack|cracker|crate|crayon|cream|creator|creature|credit|crewcut|crib|crime|crook|crossbow|crossbreed|crosscut|crossover|crosswalk
crow|crowd|crown|cub|cup|current|curtain|curve|cushion|dad|dairymaid|daisywheel|daughter|day|daybed|daybook|daybreak|daydream|daylight|daytime|deadend|deadline|death|debt
decision|deer|degree|design|desire|desk|destruction|detail|development|digestion|dime|dinner|dinosaurs|direction|dirt|discovery|discussion|dishcloth|dishpan|dishwasher|dishwater
diskdrive|distance|distribution|division|dock|doctor|dog|dogs|doll|dolls|donkey|door|doorstop|downtown|downunder|drain|drawbridge|drawer|dress|drink|driveway|driving|drop
duck|duckbill|duckpin|ducks|dust|ear|earache|earring|earth|earthquake|earthward|earthworm|edge|education|effect|egg|egghead|eggnog|eggs|eggshell|elbow|end|engine|error|event
everything|example|exchange|existence|expansion|experience|expert|eye|eyeballs|eyecatching|eyeglasses|eyelash|eyelid|eyes|eyesight|eyewitness|face|fact|fairies|fall|fang|farm
fatherland|fear|feeling|field|finger|fire|fireball|fireboat|firebomb|firebreak|firecracker|firefighter|firehouse|fireman|fireproof|fireworks|fish|fishbowl|fisherman|fisheye
fishhook|fishmonger|fishnet|fishpond|fishtail|flag|flame|flavor|flesh|flight|flock|floor|flower|flowers|fly|fog|fold|food|foot|football|foothill|footlights|footlocker|footprints
forbearer|force|forearm|forebear|forebrain|forecast|foreclose|foreclosure|foredoom|forefather|forefeet|forefinger|forefoot|forego|foregone|forehand|forehead|foreknowledge
foreleg|foreman|forepaws|foresee|foreshadow|forestall|forethought|foretold|forever|forewarn|foreword|forget|fork|forklift|form|fowl|frame|friction|friend|friends|frog|frogs
front|fruit|fruitcup|fuel|furniture|gate|gearshift|geese|ghost|giants|giraffe|girl|girls|glass|glassmaking|glove|gold|goodbye|goodnight|government|governor|grade|grain|grandaunt
granddaughter|grandfather|grandmaster|grandmother|grandnephew|grandparent|grandson|grandstand|granduncle|grape|grass|grassland|graveyard|grip|ground|group|growth|guide|guitar
gumball|gun|hair|haircut|hall|hamburger|hammer|hand|handbook|handgun|handmade|handout|hands|harbor|harmony|hat|hate|head|headache|headlight|headline|headquarters|health|heat
hereafter|hereby|herein|hereupon|highchair|highland|highway|hill|himself|history|hobbies|hole|holiday|home|homemade|hometown|honey|honeybee|honeydew|honeysuckle|hook|hookup
hope|horn|horse|horseback|horsefly|horsehair|horseman|horseplay|horsepower|horseradish|horses|hose|hospital|hot|hour|house|houseboat|household|housekeeper|houses|housetop
however|humor|hydrant|ice|icicle|idea|impulse|income|increase|industry|ink|insect|inside|instrument|insurance|intake|interest|invention|iron|island|itself|jail|jailbait|jam
jar|jeans|jelly|jellybean|jellyfish|jetliner|jetport|jewel|join|judge|juice|jump|jumpshot|kettle|key|keyboard|keyhole|keynote|keypad|keypunch|keystone|keystroke|keyword|kick
kiss|kittens|kitty|knee|knife|knot|knowledge|laborer|lace|ladybug|lake|lamp|land|language|laugh|leather|leg|legs|letter|letters|lettuce|level|library|lifeblood|lifeguard|lifelike
lifeline|lifelong|lifetime|lifework|limelight|limestone|limit|line|linen|lip|liquid|loaf|lock|locket|longhand|look|loss|love|low|lukewarm|lumber|lunch|lunchroom|machine|magic
maid|mailbox|mainline|man|marble|mark|market|mask|mass|match|matchbox|meal|meantime|meanwhile|measure|meat|meeting|memory|men|metal|mice|middle|milk|mind|mine|minister|mint
minute|mist|mitten|mom|money|monkey|month|moon|moonbeam|moonlight|moonlit|moonscape|moonshine|moonstruck|moonwalk|moreover|morning|mother|motion|motorcycle|mountain|mouth
move|muscle|name|nation|nearby|neck|need|needle|nerve|nest|nevermore|newsboy|newsbreak|newscaster|newsdealer|newsletter|newsman|newspaper|newsprint|newsreel|newsroom|night
nightfall|nobody|noise|noisemaker|north|northeast|nose|note|notebook|nowhere|number|nursemaid|nut|nutcracker|oatmeal|observation|ocean|offer|office|oil|oneself|onetime|orange
oranges|order|oven|overboard|overcoat|overflow|overland|pacemaker|page|pail|pan|pancake|paper|parcel|part|partner|party|passbook|passenger|passkey|Passover|passport|payment
peace|pear|pen|pencil|peppermint|person|pest|pet|pets|pickle|pickup|picture|pie|pies|pig|pigs|pin|pinhole|pinstripe|pinup|pinwheel|pipe|pizzas|place|plane|planes|plant|plantation
plants|plastic|plate|play|playback|playground|playhouse|playthings|pleasure|plot|plough|pocket|point|poison|pollution|ponytail|popcorn|porter|position|postcard|pot|potato
powder|power|price|produce|profit|property|prose|protest|pull|pump|punishment|purpose|push|quarter|quartz|queen|question|quicksand|quiet|quill|quilt|quince|quiver|rabbit|rabbits
racquetball|rail|railroad|railway|rain|raincheck|raincoat|rainstorm|rainwater|rake|range|rat|rate|rattlesnake|rattletrap|ray|reaction|reading|reason|receipt|recess|record
regret|relation|religion|repairman|representative|request|respect|rest|reward|rhythm|rice|riddle|rifle|ring|rings|river|riverbanks|road|robin|rock|rod|roll|roof|room|root
rose|route|rub|rubberband|rule|run|sack|sail|sailboat|salesclerk|salt|sand|sandlot|sandstone|saucepan|scale|scapegoat|scarecrow|scarf|scene|scent|school|schoolbook|schoolboy
schoolbus|schoolhouse|science|scissors|screw|sea|seashore|seat|secretary|seed|selection|self|sense|servant|shade|shadyside|shake|shame|shape|sharecropper|sharpshooter|sheep
sheepskin|sheet|shelf|ship|shirt|shock|shoe|shoelace|shoemaker|shoes|shop|shortbread|show|showoff|showplace|side|sidekick|sidewalk|sign|silk|silver|silversmith|sink|sister
sisterhood|sisters|sixfold|size|skate|skateboard|skin|skintight|skirt|sky|skylark|skylight|slave|sleep|sleet|slip|slope|slowdown|slumlord|smash|smell|smile|smoke|snail|snails
snake|snakes|snakeskin|sneeze|snow|snowball|snowbank|snowbird|snowdrift|snowshovel|soap|society|sock|soda|sofa|softball|somebody|someday|somehow|someone|someplace|something
sometimes|somewhat|somewhere|son|song|songs|sort|sound|soundproof|soup|southeast|southwest|soybean|space|spacewalk|spade|spark|spearmint|spiders|spillway|spokesperson|sponge
spoon|spot|spring|spy|square|squirrel|stage|stagehand|stamp|standby|standoff|standout|standpoint|star|starfish|start|statement|station|steam|steamship|steel|stem|step|stepson
stew|stick|sticks|stitch|stocking|stockroom|stomach|stone|stop|stoplight|stopwatch|store|story|stove|stranger|straw|stream|street|stretch|string|stronghold|structure|substance
subway|sugar|suggestion|suit|summer|sun|sunbaked|sunbathe|sundial|sundown|sunfish|sunflower|sunglasses|sunlit|sunray|sunroof|sunup|supercargo|supercharge|supercool|superego
superfine|supergiant|superhero|superhighways|superhuman|superimpose|supermarket|supermen|supernatural|superpower|superscript|supersensitive|supersonic|superstar|superstrong
superstructure|supertanker|superweapon|superwoman|support|surprise|sweater|sweetheart|sweetmeat|swim|swing|system|table|tablecloth|tablespoon|tabletop|tableware|tail|tailcoat
tailgate|taillight|taillike|tailpiece|tailspin|takeoff|takeout|takeover|talebearer|taleteller|talk|tank|tapeworm|taproom|taproot|target|taskmaster|taste|tax|taxicab|taxpayer
teaching|teacup|team|teammate|teamwork|teapot|teaspoon|teenager|teeth|telltale|temper|tendency|tenderfoot|tenfold|tent|territory|test|textbook|texture|theory|therefore|thing
things|thought|thread|thrill|throat|throne|throwaway|throwback|thumb|thunder|thunderbird|thunderstorm|ticket|tiger|time|timekeeper|timesaving|timeshare|timetable|tin|title
toad|toe|toes|together|tomatoes|tongue|toolbox|tooth|toothbrush|toothpaste|toothpick|top|touch|touchdown|town|township|toy|toys|trade|trail|train|trains|tramp|transport|tray
treatment|tree|trees|trick|trip|trouble|trousers|truck|trucks|tub|turkey|turn|turnabout|turnaround|turnbuckle|turndown|turnkey|turnoff|turntable|twig|twist|typewriter|umbrella
uncle|underachieve|underage|underarm|underbelly|underbid|undercharge|underclothes|undercover|undercut|underdevelop|underestimate|underexpose|underfoot|underground|underwear
unit|upbeat|upbringing|upcoming|update|upend|upgrade|upheaval|uphill|uphold|upkeep|upland|uplift|upload|upmarket|upon|uppercase|upperclassman|uppercut|uproar|uproot|upset
upshot|upside|upstage|upstairs|upstanding|upstart|upstate|upstream|uptake|upthrust|uptight|uptime|uptown|upward|upwind|use|vacation|value|van|vase|vegetable|veil|vein|verse
vessel|vest|view|visitor|voice|volcano|volleyball|voyage|waistline|walk|walkways|wall|walleyed|wallpaper|war|wardroom|warfare|warmblooded|warpath|wash|washbowl|washcloth|washhouse
washout|washrag|washroom|washstand|washtub|waste|wastebasket|wasteland|wastepaper|wastewater|watch|watchband|watchdog|watchmaker|watchman|watchtower|watchword|water|watercolor
watercooler|watercraft|waterfall|waterfront|waterline|waterlog|watermelon|waterpower|waterproof|waterscape|watershed|waterside|waterspout|watertight|wave|wavelike|waves|wax
waxwork|way|waybill|wayfarer|waylaid|wayside|wayward|wealth|weather|weathercock|weatherman|weatherproof|week|weekday|weekend|weeknight|weight|whatever|whatsoever|wheel|wheelchair
wheelhouse|whip|whistle|whitecap|whitefish|whitewall|whitewash|widespread|wilderness|wind|window|wine|wing|winter|wipeout|wire|wish|without|woman|women|wood|woodshop|wool
word|work|worm|wound|wren|wrench|wrist|writer|writing|yak|yam|yard|yarn|year|yoke|zebra|zephyr|zinc|zipper|zoo
`.split("|");
const _numberWords = {
  ones: [
    "zero",
    "one",
    "two",
    "three",
    "four",
    "five",
    "six",
    "seven",
    "eight",
    "nine",
    "ten",
    "eleven",
    "twelve",
    "thirteen",
    "fourteen",
    "fifteen",
    "sixteen",
    "seventeen",
    "eighteen",
    "nineteen",
    "twenty"
  ],
  tens: ["", "", "twenty", "thirty", "forty", "fifty", "sixty", "seventy", "eighty", "ninety"],
  tiers: ["", "thousand", "million", "billion", "trillion", "quadrillion", "quintillion", "sextillion", "septillion", "octillion", "nonillion"],
  bigPrefixes: ["", "un", "duo", "tre", "quattuor", "quin", "sex", "octo", "novem"],
  bigSuffixes: ["", "decillion", "vigintillion", "trigintillion", "quadragintillion", "quinquagintillion", "sexagintillion", "septuagintillion", "octogintillion", "nonagintillion", "centillion"]
};
const _ordinals = {
  zero: "zeroeth",
  one: "first",
  two: "second",
  three: "third",
  four: "fourth",
  five: "fifth",
  eight: "eighth",
  nine: "ninth",
  twelve: "twelfth",
  twenty: "twentieth",
  thirty: "thirtieth",
  forty: "fortieth",
  fifty: "fiftieth",
  sixty: "sixtieth",
  seventy: "seventieth",
  eighty: "eightieth",
  ninety: "ninetieth"
};
const _romanNumerals = {
  grouped: [
    ["", "Ⅰ", "Ⅱ", "Ⅲ", "Ⅳ", "Ⅴ", "Ⅵ", "Ⅶ", "Ⅷ", "Ⅸ"],
    ["", "Ⅹ", "ⅩⅩ", "ⅩⅩⅩ", "ⅩⅬ", "Ⅼ", "ⅬⅩ", "ⅬⅩⅩ", "ⅬⅩⅩⅩ", "ⅩⅭ"],
    ["", "Ⅽ", "ⅭⅭ", "ⅭⅭⅭ", "ⅭⅮ", "Ⅾ", "ⅮⅭ", "ⅮⅭⅭ", "ⅮⅭⅭⅭ", "ⅭⅯ"],
    ["", "Ⅿ", "ⅯⅯ", "ⅯⅯⅯ", "Ⅿↁ", "ↁ", "ↁⅯ", "ↁⅯⅯ", "ↁⅯⅯⅯ", "ↁↂ"],
    ["", "ↂ", "ↂↂ", "ↂↂↂ", "ↂↇ", "ↇ", "ↇↂ", "ↇↂↂ", "ↇↂↂↂ", "ↇↈ"],
    ["", "ↈ", "ↈↈ", "ↈↈↈ"]
  ],
  ungrouped: [
    ["", "Ⅰ", "ⅠⅠ", "ⅠⅠⅠ", "ⅠⅤ", "Ⅴ", "ⅤⅠ", "ⅤⅠⅠ", "ⅤⅠⅠⅠ", "ⅠⅩ"],
    ["", "Ⅹ", "ⅩⅩ", "ⅩⅩⅩ", "ⅩⅬ", "Ⅼ", "ⅬⅩ", "ⅬⅩⅩ", "ⅬⅩⅩⅩ", "ⅩⅭ"],
    ["", "Ⅽ", "ⅭⅭ", "ⅭⅭⅭ", "ⅭⅮ", "Ⅾ", "ⅮⅭ", "ⅮⅭⅭ", "ⅮⅭⅭⅭ", "ⅭⅯ"],
    ["", "Ⅿ", "ⅯⅯ", "ⅯⅯⅯ", "Ⅿↁ", "ↁ", "ↁⅯ", "ↁⅯⅯ", "ↁⅯⅯⅯ", "ↁↂ"],
    ["", "ↂ", "ↂↂ", "ↂↂↂ", "ↂↇ", "ↇ", "ↇↂ", "ↇↂↂ", "ↇↂↂↂ", "ↇↈ"],
    ["", "ↈ", "ↈↈ", "ↈↈↈ"]
  ]
};
const UUIDLOG = [];
const GMID = () => {
  var _a2, _b;
  return ((_b = (_a2 = game == null ? void 0 : game.user) == null ? void 0 : _a2.find((user) => user.isGM)) == null ? void 0 : _b.id) ?? false;
};
const isNumber = (ref) => typeof ref === "number" && !isNaN(ref);
const isNumString = (ref) => typeof ref === "string" && !isNaN(parseFloat(ref)) && isFinite(parseFloat(ref));
const isBooleanString = (ref) => typeof ref === "string" && (ref === "true" || ref === "false");
const isArray = (ref) => Array.isArray(ref);
const isSimpleObj = (ref) => ref === Object(ref) && !isArray(ref);
const isList = (ref) => ref === Object(ref) && !isArray(ref);
const isFunc = (ref) => typeof ref === "function";
const isInt = (ref) => isNumber(ref) && Math.round(ref) === ref;
const isFloat = (ref) => isNumber(ref) && /\./.test(`${ref}`);
const isPosInt = (ref) => isInt(ref) && ref >= 0;
const isIndex = (ref) => isList(ref) || isArray(ref);
const isIterable = (ref) => typeof ref === "object" && ref !== null && Symbol.iterator in ref;
const isHTMLCode = (ref) => typeof ref === "string" && /^<.*>$/u.test(ref);
const isHexColor = (ref) => typeof ref === "string" && /^#(([0-9a-fA-F]{2}){3,4}|[0-9a-fA-F]{3,4})$/.test(ref);
const isRGBColor = (ref) => typeof ref === "string" && /^rgba?\((\d{1,3},\s*){1,2}?\d{1,3},\s*\d{1,3}(\.\d+)?\)$/.test(ref);
const isUndefined = (ref) => ref === void 0;
const isDefined = (ref) => !isUndefined(ref);
const isEmpty = (ref) => Object.keys(ref).length === 0;
const hasItems = (ref) => !isEmpty(ref);
const isInstance = (classRef, ref) => ref instanceof classRef;
const isNullish = (ref) => isUndefined(ref) || ref === null;
function assertNonNullType(val, type) {
  let valStr;
  try {
    valStr = JSON.stringify(val);
  } catch {
    valStr = String(val);
  }
  if (val === void 0) {
    throw new Error(`Value ${valStr} is undefined!`);
  }
  if (typeof type === "string") {
    if (typeof val !== type) {
      throw new Error(`Value ${valStr} is not a ${type}!`);
    }
  } else if (!(val instanceof type)) {
    throw new Error(`Value ${valStr} is not a ${type.name}!`);
  }
}
const areFuzzyEqual = (val1, val2) => {
  if ([null, void 0].includes(val1) && [null, void 0].includes(val2)) {
    return true;
  }
  if ([null, void 0].includes(val1) || [null, void 0].includes(val2)) {
    return false;
  }
  if (typeof val1 === "number" && typeof val2 === "number") {
    return val1 === val2;
  }
  if (typeof val1 === "boolean" && typeof val2 === "boolean") {
    return val1 === val2;
  }
  if (typeof val1 === "string" && typeof val2 === "string") {
    return val1 === val2;
  }
  if (typeof val1 === "number" && typeof val2 === "string") {
    return val1 === Number(val2);
  }
  if (typeof val1 === "string" && typeof val2 === "number") {
    return Number(val1) === val2;
  }
  if (typeof val1 === "boolean" && typeof val2 === "object") {
    return false;
  }
  if (typeof val1 === "object" && typeof val2 === "boolean") {
    return false;
  }
  if (typeof val1 === "boolean" && typeof val2 === "string") {
    return val1 && val2 !== "" || !val1 && val2 === "";
  }
  if (typeof val1 === "string" && typeof val2 === "boolean") {
    return val2 && val1 !== "" || !val2 && val1 === "";
  }
  if ((typeof val1 === "number" || typeof val1 === "string") && typeof val2 === "object") {
    return false;
  }
  if (typeof val1 === "object" && (typeof val2 === "number" || typeof val2 === "string")) {
    return false;
  }
  if (typeof val1 === "object" && typeof val2 === "object") {
    return val1 === val2;
  }
  return false;
};
const areEqual = (...refs) => {
  do {
    const ref = refs.pop();
    if (refs.length && !areFuzzyEqual(ref, refs[0])) {
      return false;
    }
  } while (refs.length);
  return true;
};
const pFloat = (ref, sigDigits, isStrict = false) => {
  if (typeof ref === "string") {
    ref = parseFloat(ref);
  }
  if (typeof ref === "number") {
    if (isNaN(ref)) {
      return isStrict ? NaN : 0;
    }
    if (isUndefined(sigDigits)) {
      return ref;
    }
    return Math.round(ref * 10 ** sigDigits) / 10 ** sigDigits;
  }
  return isStrict ? NaN : 0;
};
const pInt = (ref, isStrictOrIndex, _arr) => {
  let isStrict = false;
  if (typeof isStrictOrIndex === "boolean") {
    isStrict = isStrictOrIndex;
  }
  return isNaN(pFloat(ref, 0, isStrict)) ? NaN : Math.round(pFloat(ref, 0, isStrict));
};
const pBool = (ref) => {
  if (typeof ref === "boolean") {
    return ref;
  }
  if ([0, null, void 0, ""].includes(ref)) {
    return false;
  }
  if (typeof ref === "string") {
    return !["0", "false", "null", "undefined", ""].includes(ref);
  }
  if (isArray(ref) && ref.length === 0) {
    return false;
  }
  if (isList(ref) && isEmpty(ref)) {
    return false;
  }
  return true;
};
const radToDeg = (rad, isConstrained = true) => {
  rad = isConstrained ? rad % (2 * Math.PI) : rad;
  rad *= 180 / Math.PI;
  return rad;
};
const degToRad = (deg, isConstrained = true) => {
  deg = isConstrained ? deg % 360 : deg;
  deg *= Math.PI / 180;
  return deg;
};
const getKey = (key, obj) => {
  if (key in obj) {
    return obj[key];
  }
  return null;
};
const FILTERS = {
  IsInstance: (classRef) => (item) => typeof classRef === "function" && item instanceof classRef
};
const uCase = (str2) => String(str2).toUpperCase();
const lCase = (str2) => String(str2).toLowerCase();
const sCase = (str2) => {
  let [first, ...rest] = `${str2 ?? ""}`.split(/\s+/);
  first = testRegExp(first, _capWords) ? first : `${uCase(first.charAt(0))}${lCase(first.slice(1))}`;
  if (hasItems(rest)) {
    rest = rest.map((word) => testRegExp(word, _capWords) ? word : lCase(word));
  }
  return [first, ...rest].join(" ").trim();
};
const tCase = (str2) => String(str2).split(/\s/).map((word, i) => i && testRegExp(word, _noCapWords) ? lCase(word) : sCase(word)).join(" ").trim();
const testRegExp = (str2, patterns = [], flags = "gui", isTestingAll = false) => patterns.map((pattern) => pattern instanceof RegExp ? pattern : new RegExp(`\\b${pattern}\\b`, flags))[isTestingAll ? "every" : "some"]((pattern) => pattern.test(`${str2}`));
const regExtract = (ref, pattern, flags) => {
  const splitFlags = [];
  [...(flags ?? "").replace(/g/g, ""), "u"].forEach((flag) => {
    if (flag && !splitFlags.includes(flag)) {
      splitFlags.push(flag);
    }
  });
  const isGrouping = /[)(]/.test(pattern.toString().replace(/\\\)|\\\(/g, ""));
  if (isGrouping) {
    splitFlags.push("g");
  }
  flags = splitFlags.join("");
  pattern = new RegExp(pattern, flags);
  const matches = RegExp(pattern).exec(`${ref}`) || [];
  return isGrouping ? Array.from(matches) : matches.pop();
};
const unhyphenate = (str2) => `${str2}`.replace(/[\u00AD\u200B]/gu, "");
const parseArticles = (str2) => `${str2}`.replace(/\b([aA])\s([aeiouAEIOU])/gu, "$1n $2");
const pluralize = (singular, num = 2, plural) => {
  if (pFloat(num) === 1) {
    return singular;
  }
  return plural ?? `${singular.replace(/y$/, "ie").replace(/s$/, "se")}s`;
};
const oxfordize = (items, useOxfordComma = true, andString = "and") => {
  if (items.length === 0) {
    return "";
  }
  if (items.length === 1) {
    return `${items[0]}`;
  }
  const lastItem = items.pop();
  return [
    items.join(", "),
    useOxfordComma ? "," : "",
    ` ${andString} `,
    lastItem
  ].join("");
};
const ellipsize = (text, maxLength) => {
  const str2 = String(text);
  return str2.length > maxLength ? `${str2.slice(0, maxLength - 3)}…` : str2;
};
const pad = (text, minLength, delim = " ") => {
  const str2 = `${text}`;
  if (str2.length < minLength) {
    return `${delim.repeat(minLength - str2.length)}${str2}`;
  }
  return str2;
};
const toKey = (text) => (text ?? "").toLowerCase().replace(/ /g, "-").replace(/default/, "DEFAULT");
const signNum = (num, delim = "", zeroSign = "+") => {
  let sign;
  const parsedNum = pFloat(num);
  if (parsedNum < 0) {
    sign = "-";
  } else if (parsedNum === 0) {
    sign = zeroSign;
  } else {
    sign = "+";
  }
  return `${sign}${delim}${Math.abs(parsedNum)}`;
};
const padNum = (num, numDecDigits, includePlus = false) => {
  const prefix = includePlus && num >= 0 ? "+" : "";
  const [leftDigits, rightDigits] = `${pFloat(num)}`.split(/\./);
  if (getType(rightDigits) === "int") {
    if (rightDigits.length > numDecDigits) {
      return `${prefix}${pFloat(num, numDecDigits)}`;
    } else if (rightDigits.length < numDecDigits) {
      return `${prefix}${leftDigits}.${rightDigits}${"0".repeat(numDecDigits - rightDigits.length)}`;
    } else {
      return `${prefix}${pFloat(num)}`;
    }
  }
  return `${prefix}${leftDigits}.${"0".repeat(numDecDigits)}`;
};
const stringifyNum = (num) => {
  var _a2;
  if (pFloat(num) === 0) {
    return "0";
  }
  const stringyNum = lCase(num).replace(/[^\d.e+-]/g, "");
  const base = regExtract(stringyNum, /^-?[\d.]+/);
  const exp = pInt(regExtract(stringyNum, /e([+-]?\d+)$/));
  if (typeof base === "string" && typeof exp === "string") {
    let baseInts = regExtract(base, /^-?(\d+)/);
    let baseDecs = regExtract(base, /\.(\d+)/);
    if (isArray(baseInts) && isArray(baseDecs)) {
      baseInts = (_a2 = baseInts.pop()) == null ? void 0 : _a2.replace(/^0+/, "");
      baseDecs = lCase(baseDecs == null ? void 0 : baseDecs.pop()).replace(/0+$/, "");
      if (!isUndefined(baseInts) && !isUndefined(baseDecs)) {
        const numFinalInts = Math.max(0, baseInts.length + exp);
        const numFinalDecs = Math.max(0, baseDecs.length - exp);
        const finalInts = [
          baseInts.slice(0, numFinalInts),
          baseDecs.slice(0, Math.max(0, exp))
        ].join("") || "0";
        const finalDecs = [
          baseInts.length - numFinalInts > 0 ? baseInts.slice(baseInts.length - numFinalInts - 1) : "",
          baseDecs.slice(baseDecs.length - numFinalDecs)
        ].join("");
        return [
          stringyNum.startsWith("-") ? "-" : "",
          finalInts,
          "0".repeat(Math.max(0, numFinalInts - finalInts.length)),
          finalDecs.length ? "." : "",
          "0".repeat(Math.max(0, numFinalDecs - finalDecs.length)),
          finalDecs
        ].join("");
      }
    }
  }
  return `${num}`;
};
const verbalizeNum = (num) => {
  var _a2;
  num = stringifyNum(num);
  const getTier = (trioNum) => {
    if (trioNum < _numberWords.tiers.length) {
      return _numberWords.tiers[trioNum];
    }
    return [
      _numberWords.bigPrefixes[trioNum % 10 - 1],
      _numberWords.bigSuffixes[Math.floor(trioNum / 10)]
    ].join("");
  };
  const parseThreeDigits = (trio) => {
    if (pInt(trio) === 0) {
      return "";
    }
    const digits = `${trio}`.split("").map((digit) => pInt(digit));
    let result = "";
    if (digits.length === 3) {
      const hundreds = digits.shift();
      if (isUndefined(hundreds)) {
        throw new Error(`[U.verbalizeNum] Undefined digit in trio '${digits.join("")}'.`);
      }
      result += hundreds > 0 ? `${_numberWords.ones[hundreds]} hundred` : "";
      if (hundreds && (digits[0] || digits[1])) {
        result += " and ";
      }
    }
    if (pInt(digits.join("")) <= _numberWords.ones.length) {
      result += _numberWords.ones[pInt(digits.join(""))];
    } else {
      const tens = _numberWords.tens[pInt(digits.shift())];
      const ones = pInt(digits[0]) > 0 ? `-${_numberWords.ones[pInt(digits[0])]}` : "";
      result += `${tens}${ones}`;
    }
    return result;
  };
  const numWords = [];
  if (num.startsWith("-")) {
    numWords.push("negative");
  }
  const [integers, decimals] = num.replace(/[,\s-]/g, "").split(".");
  const intArray = ((_a2 = [...integers.split("")].reverse().join("").match(/.{1,3}/g)) == null ? void 0 : _a2.map((v) => [...v.split("")].reverse().join(""))) ?? [];
  const intStrings = [];
  while (intArray.length) {
    const thisTrio = intArray.pop();
    if (thisTrio) {
      const theseWords = parseThreeDigits(thisTrio);
      if (theseWords) {
        intStrings.push(`${theseWords} ${getTier(intArray.length)}`);
      }
    }
  }
  numWords.push(intStrings.join(", ").trim());
  if (getType(decimals) === "int") {
    if (integers === "0") {
      numWords.push("zero");
    }
    numWords.push("point");
    for (const digit of decimals.split("")) {
      numWords.push(_numberWords.ones[pInt(digit)]);
    }
  }
  return numWords.join(" ");
};
const ordinalizeNum = (num, isReturningWords = false) => {
  if (isReturningWords) {
    const [numText, suffix] = RegExp(/.*?[-\s]?(\w*)$/i).exec(lCase(verbalizeNum(num))) ?? ["", ""];
    return numText.replace(
      new RegExp(`${suffix}$`),
      suffix in _ordinals ? _ordinals[suffix] : `${suffix}th`
    );
  }
  if (/(\.)|(1[1-3]$)/.test(`${num}`)) {
    return `${num}th`;
  }
  return `${num}${["th", "st", "nd", "rd", "th", "th", "th", "th", "th", "th"][pInt(`${num}`.charAt(`${num}`.length - 1))]}`;
};
const romanizeNum = (num, isUsingGroupedChars = true) => {
  if (isFloat(num)) {
    throw new Error(`Error: Can't Romanize Floats (${num})`);
  }
  if (num >= 4e5) {
    throw new Error(`Error: Can't Romanize >= 400,000 (${num})`);
  }
  if (num < 0) {
    throw new Error(`Error: Can't Romanize Negative Numbers (${num})`);
  }
  if (num === 0) {
    return "0";
  }
  const romanRef = _romanNumerals[isUsingGroupedChars ? "grouped" : "ungrouped"];
  const romanNum = [...stringifyNum(num).split("")].reverse().map((digit, i) => romanRef[i][pInt(digit)]).reverse().join("");
  return isUsingGroupedChars ? romanNum.replace(/ⅩⅠ/gu, "Ⅺ").replace(/ⅩⅡ/gu, "Ⅻ") : romanNum;
};
const loremIpsum = (numWords = 200) => {
  const lrWordList = _loremIpsumText.split(/\n?\s+/g);
  const words = [...lrWordList[randNum(0, lrWordList.length - 1)]];
  while (words.length < numWords) {
    words.push(...lrWordList);
  }
  words.length = numWords;
  return `${sCase(words.join(" ")).trim().replace(/[^a-z\s]*$/ui, "")}.`;
};
const randString = (length = 5) => Array.from({ length }).map(() => String.fromCharCode(randInt(...["a", "z"].map((char) => char.charCodeAt(0))))).join("");
const randWord = (numWords = 1, wordList = _randomWords) => Array.from({ length: numWords }).map(() => randElem([...wordList])).join(" ");
const getUID = (id) => {
  const indexNum = Math.max(
    0,
    ...UUIDLOG.filter(([genericID]) => genericID.startsWith(id)).map(([, , num]) => num)
  ) + 1;
  const uuid = indexNum === 1 ? id : `${id}_${indexNum}`;
  UUIDLOG.push([id, uuid, indexNum]);
  eLog.log(`UUIDify(${id}) --> [${uuid}, ${indexNum}]`);
  Object.assign(globalThis, { UUIDLOG });
  return uuid;
};
const fuzzyMatch = (val1, val2) => {
  const [str1, str2] = [val1, val2].map((val) => lCase(String(val).replace(/[^a-zA-Z0-9.+-]/g, "").trim()));
  return str1.length > 0 && str1 === str2;
};
const isIn = (needle, haystack = [], fuzziness = 0) => {
  const SearchTests = [
    (ndl, item) => new RegExp(`^${ndl}$`, "gu").test(`${item}`),
    (ndl, item) => new RegExp(`^${ndl}$`, "gui").test(`${item}`)
  ];
  if (fuzziness >= 1) {
    const fuzzyTests = [
      (ndl, item) => new RegExp(`^${ndl}`, "gui").test(`${item}`),
      (ndl, item) => new RegExp(`${ndl}$`, "gui").test(`${item}`),
      (ndl, item) => new RegExp(`${ndl}`, "gui").test(`${item}`),
      (ndl, item) => new RegExp(`${item}`, "gui").test(`${ndl}`)
    ];
    SearchTests.push(...fuzzyTests);
    if (fuzziness >= 2) {
      SearchTests.push(...fuzzyTests.map((func) => (ndl, item) => func(`${ndl}`.replace(/\W/g, ""), `${item}`.replace(/\W/gu, ""))));
      if (fuzziness >= 3) {
        SearchTests.push(() => false);
      }
    }
  }
  const searchNeedle = `${needle}`;
  const searchStack = (() => {
    if (isArray(haystack)) {
      return [...haystack];
    }
    if (isList(haystack)) {
      return Object.keys(haystack);
    }
    try {
      return Array.from(haystack);
    } catch {
      throw new Error(`Haystack type must be [list, array], not ${typeof haystack}: ${JSON.stringify(haystack)}`);
    }
  })();
  if (!isArray(searchStack)) {
    return false;
  }
  let matchIndex = -1;
  while (!isPosInt(matchIndex)) {
    const testFunc = SearchTests.shift();
    if (!testFunc) {
      return false;
    }
    matchIndex = searchStack.findIndex((item) => testFunc(searchNeedle, `${item}`));
  }
  if (isPosInt(matchIndex)) {
    return isList(haystack) ? Object.values(haystack)[matchIndex] : haystack[matchIndex];
  }
  return false;
};
const isInExact = (needle, haystack) => isIn(needle, haystack, 0);
const randNum = (min, max, snap3 = 0) => gsapWithCSS.utils.random(min, max, snap3);
const randInt = (min, max) => randNum(min, max, 1);
const coinFlip = () => randNum(0, 1, 1) === 1;
const cycleNum = (num, [min = 0, max = Infinity] = []) => gsapWithCSS.utils.wrap(min, max, num);
const clampNum = (num, [min = 0, max = Infinity] = []) => gsapWithCSS.utils.clamp(min, max, num);
const cycleAngle = (angle, range = [0, 360]) => cycleNum(angle, range);
const roundNum = (num, sigDigits = 0) => sigDigits === 0 ? pInt(num) : pFloat(num, sigDigits);
const sum = (...nums) => Object.values(nums.flat()).reduce((num, tot) => tot + num, 0);
const average = (...nums) => sum(...nums) / nums.flat().length;
const getDistance = ({ x: x1, y: y1 }, { x: x2, y: y2 }) => ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5;
const getAngle = ({ x: x1, y: y1 }, { x: x2, y: y2 }, { x: xO, y: yO } = { x: 0, y: 0 }, range = [0, 360]) => {
  x1 -= xO;
  y1 -= yO;
  x2 -= xO;
  y2 -= yO;
  return cycleAngle(radToDeg(Math.atan2(y2 - y1, x2 - x1)), range);
};
const getAngleDelta = (angleStart, angleEnd, range = [0, 360]) => cycleAngle(angleEnd - angleStart, range);
const getBoundingRectangle = (arrayOfShapes) => {
  let minX = Infinity;
  let minY = Infinity;
  let maxX = -Infinity;
  let maxY = -Infinity;
  for (const shape of arrayOfShapes) {
    let shapeMinX;
    let shapeMinY;
    let shapeMaxX;
    let shapeMaxY;
    if (shape.radius !== void 0) {
      shapeMinX = shape.x - shape.radius;
      shapeMinY = shape.y - shape.radius;
      shapeMaxX = shape.x + shape.radius;
      shapeMaxY = shape.y + shape.radius;
    } else if (shape.size !== void 0) {
      shapeMinX = (shape.x - shape.size) / 2;
      shapeMinY = (shape.y - shape.size) / 2;
      shapeMaxX = (shape.x + shape.size) / 2;
      shapeMaxY = (shape.y + shape.size) / 2;
    } else if (shape.width !== void 0 || shape.height !== void 0) {
      shape.width ?? (shape.width = shape.height);
      shape.height ?? (shape.height = shape.width);
      shapeMinX = (shape.x - shape.width) / 2;
      shapeMinY = (shape.y - shape.height) / 2;
      shapeMaxX = (shape.x + shape.width) / 2;
      shapeMaxY = (shape.y + shape.height) / 2;
    } else {
      throw new Error(`[getBoundingRectangle] Error: shape must be a circle, square, or rectangle, not ${JSON.stringify(shape)}`);
    }
    minX = Math.min(minX, shapeMinX);
    minY = Math.min(minY, shapeMinY);
    maxX = Math.max(maxX, shapeMaxX);
    maxY = Math.max(maxY, shapeMaxY);
  }
  const width = maxX - minX;
  const height = maxY - minY;
  const x = (minX + width) / 2;
  const y = (minY + height) / 2;
  return { x, y, width, height };
};
const randElem = (array) => gsapWithCSS.utils.random(array);
const randIndex = (array) => randInt(0, array.length - 1);
const makeIntRange = (min, max) => {
  const intRange = [];
  for (let i = min; i <= max; i++) {
    intRange.push(i);
  }
  return intRange;
};
const makeCycler = (array, index = 0) => {
  const wrapper = gsapWithCSS.utils.wrap(array);
  index--;
  return function* () {
    while (true) {
      index++;
      yield wrapper(index);
    }
  }();
};
function getLast(array) {
  array = Object.values(array);
  if (array.length === 0) {
    throw new Error("Cannot get last element of an empty array.");
  }
  return array[array.length - 1];
}
const unique = (array) => {
  const returnArray = [];
  array.forEach((item) => {
    if (!returnArray.includes(item)) {
      returnArray.push(item);
    }
  });
  return returnArray;
};
const group = (array, key) => {
  const returnObj = {};
  array.forEach((item) => {
    const returnKey = item[key];
    let returnVal = returnObj[returnKey];
    if (!returnVal) {
      returnVal = [];
      returnObj[returnKey] = returnVal;
    }
    returnVal.push(item);
  });
  return returnObj;
};
const sample = (array, numElems = 1, isUniqueOnly = true, uniqueTestFunc = (e, a) => !a.includes(e)) => {
  const elems = [];
  let overloadCounter = 0;
  while (elems.length < numElems && overloadCounter < 1e6) {
    const randomElem = randElem(array);
    if (isUniqueOnly && uniqueTestFunc(randomElem, elems)) {
      elems.push(randomElem);
    }
    overloadCounter++;
  }
  return elems;
};
const removeFirst = (array, element) => array.splice(array.findIndex((v) => v === element));
function pullElement(array, checkFunc) {
  let testFunction;
  if (typeof checkFunc !== "function") {
    testFunction = (_v) => _v === checkFunc;
  } else {
    testFunction = checkFunc;
  }
  const index = array.findIndex((v, i, a) => testFunction(v, i, a));
  if (index === -1) {
    return void 0;
  }
  return array.splice(index, 1).pop();
}
const pullIndex = (array, index) => pullElement(array, (_, i) => i === index);
const subGroup = (array, groupSize) => {
  const subArrays = [];
  while (array.length > groupSize) {
    const subArray = [];
    while (subArray.length < groupSize) {
      subArray.push(array.shift());
    }
    subArrays.push(subArray);
  }
  subArrays.push(array);
  return subArrays;
};
const shuffle2 = (array) => {
  let currentIndex = array.length;
  let randomIndex;
  while (currentIndex !== 0) {
    randomIndex = Math.floor(Math.random() * currentIndex);
    currentIndex--;
    [array[currentIndex], array[randomIndex]] = [
      array[randomIndex],
      array[currentIndex]
    ];
  }
  return array;
};
const toArray2 = gsapWithCSS.utils.toArray;
const checkVal = ({ k, v }, checkTest) => {
  if (isFunc(checkTest)) {
    if (isDefined(v)) {
      return checkTest(v, k);
    }
    return checkTest(k);
  }
  return new RegExp(`${checkTest}`).test(`${v}`);
};
const remove = (obj, checkTest) => {
  if (isArray(obj)) {
    const index = obj.findIndex((v) => checkVal({ v }, checkTest));
    if (index >= 0) {
      return removeElementFromArray(obj, index);
    }
  } else if (isList(obj)) {
    const [remKey] = Object.entries(obj).find(([k, v]) => checkVal({ k, v }, checkTest)) ?? [];
    if (remKey) {
      return removeElementFromList(obj, remKey);
    }
  }
  return false;
};
const removeElementFromArray = (array, index) => {
  let remVal;
  for (let i = 0; i <= array.length; i++) {
    if (i === index) {
      remVal = array.shift();
    } else {
      array.push(array.shift());
    }
  }
  return remVal;
};
const removeElementFromList = (list, key) => {
  const remVal = list[key];
  delete list[key];
  return remVal;
};
const replace = (obj, checkTest, repVal) => {
  let repKey;
  if (isList(obj)) {
    [repKey] = Object.entries(obj).find((v) => checkVal({ v }, checkTest)) || [false];
    if (repKey === false) {
      return false;
    }
  } else if (isArray(obj)) {
    repKey = obj.findIndex((v) => checkVal({ v }, checkTest));
    if (repKey === -1) {
      return false;
    }
  }
  if (typeof repKey !== "number") {
    repKey = `${repKey}`;
  }
  if (typeof repVal === "function") {
    obj[repKey] = repVal(obj[repKey], repKey);
  } else {
    obj[repKey] = repVal;
  }
  return true;
};
const objClean = (data, remVals = [void 0, null, "", {}, []]) => {
  const remStrings = remVals.map((rVal) => JSON.stringify(rVal));
  if (remStrings.includes(JSON.stringify(data)) || remVals.includes(data)) {
    return "KILL";
  }
  if (Array.isArray(data)) {
    const newData = data.map((elem) => objClean(elem, remVals)).filter((elem) => elem !== "KILL");
    return Array.isArray(newData) && newData.length ? newData : "KILL";
  }
  if (data && typeof data === "object" && JSON.stringify(data).startsWith("{")) {
    const newData = Object.entries(data).map(([key, val]) => [key, objClean(val, remVals)]).filter(([, val]) => val !== "KILL");
    return newData.length ? Object.fromEntries(newData) : "KILL";
  }
  return data;
};
const partition$1 = (obj, predicate = () => true) => [
  objFilter(obj, predicate),
  objFilter(obj, (v, k) => !predicate(v, k))
];
const zip = (keys, values) => {
  if (keys.length !== values.length) {
    throw new Error("The arrays must be of equal length.");
  }
  if (new Set(keys).size !== keys.length) {
    throw new Error("The keys must be unique.");
  }
  const result = {};
  keys.forEach((key, i) => {
    result[key] = values[i];
  });
  return result;
};
function objMap(obj, keyFunc, valFunc) {
  let valFuncTyped = valFunc;
  let keyFuncTyped = keyFunc;
  if (!valFuncTyped) {
    valFuncTyped = keyFunc;
    keyFuncTyped = false;
  }
  if (!keyFuncTyped) {
    keyFuncTyped = (k) => k;
  }
  if (Array.isArray(obj)) {
    return obj.map(valFuncTyped);
  }
  return Object.fromEntries(Object.entries(obj).map(([key, val]) => {
    assertNonNullType(valFuncTyped, "function");
    return [keyFuncTyped(key, val), valFuncTyped(val, key)];
  }));
}
const objSize = (obj) => {
  if (isSimpleObj(obj)) {
    return Object.keys(obj).length;
  }
  if (isArray(obj)) {
    return obj.length;
  }
  if (obj === false || obj === null || obj === void 0) {
    return 0;
  }
  return 1;
};
function objFindKey(obj, keyFunc, valFunc) {
  if (!valFunc) {
    valFunc = keyFunc;
    keyFunc = false;
  }
  if (isArray(obj)) {
    return obj.findIndex(valFunc);
  }
  const kFunc = keyFunc || (() => true);
  const vFunc = valFunc || (() => true);
  const validEntry = Object.entries(obj).find(([k, v]) => kFunc(k, v) && vFunc(v, k));
  if (validEntry) {
    return validEntry[0];
  }
  return false;
}
const objFilter = (obj, keyFunc, valFunc, isMutating = false) => {
  if (!valFunc) {
    valFunc = keyFunc;
    keyFunc = false;
  }
  if (isArray(obj)) {
    const keptValues = obj.filter(valFunc);
    if (isMutating) {
      obj.splice(0, obj.length, ...keptValues);
      return obj;
    }
    return keptValues;
  }
  const kFunc = keyFunc || (() => true);
  const vFunc = valFunc || (() => true);
  if (isMutating) {
    const entriesToRemove = Object.entries(obj).filter(([key, val]) => !(kFunc(key, val) && vFunc(val, key)));
    for (const [key] of entriesToRemove) {
      delete obj[key];
    }
    return obj;
  }
  return Object.fromEntries(
    Object.entries(obj).filter(([key, val]) => kFunc(key, val) && vFunc(val, key))
  );
};
const objForEach = (obj, func) => {
  if (isArray(obj)) {
    obj.forEach(func);
  } else {
    Object.entries(obj).forEach(([key, val]) => func(val, key));
  }
};
const objCompact = (obj, removeWhiteList = [void 0, null], isMutating = false) => objFilter(obj, (val) => !removeWhiteList.includes(val), void 0, isMutating);
const objClone = (obj, isStrictlySafe = false) => {
  const cloneArray = (arr) => [...arr];
  const cloneObject = (o) => ({ ...o });
  try {
    return JSON.parse(JSON.stringify(obj));
  } catch (err) {
    if (isStrictlySafe) {
      throw err;
    }
    if (Array.isArray(obj)) {
      return cloneArray(obj);
    }
    if (typeof obj === "object") {
      return cloneObject(obj);
    }
  }
  return obj;
};
function objMerge(target, source, {
  isMutatingOk = false,
  isStrictlySafe = false,
  isConcatenatingArrays = true,
  isReplacingArrays = false
} = {}) {
  target = isMutatingOk ? target : objClone(target, isStrictlySafe);
  if (source && typeof source === "object" && "id" in source && isDocID(source.id) || isUndefined(target)) {
    return source;
  }
  if (isUndefined(source)) {
    return target;
  }
  if (!isIndex(source)) {
    return target;
  }
  for (const [key, val] of Object.entries(source)) {
    const targetVal = target[key];
    if (isReplacingArrays && isArray(targetVal) && isArray(val)) {
      target[key] = val;
    } else if (isConcatenatingArrays && isArray(targetVal) && isArray(val)) {
      target[key].push(...val);
    } else if (val !== null && typeof val === "object") {
      if (isUndefined(targetVal) && !(val instanceof Application)) {
        target[key] = new (Object.getPrototypeOf(val)).constructor();
      }
      target[key] = objMerge(
        target[key],
        val,
        { isMutatingOk: true, isStrictlySafe }
      );
    } else {
      target[key] = val;
    }
  }
  return target;
}
function objDiff(obj1, obj2) {
  const diff = {};
  const bothObj1AndObj2Keys = Object.keys(obj2).filter((key) => Object.hasOwn(obj2, key) && Object.hasOwn(obj1, key));
  const onlyObj2Keys = Object.keys(obj2).filter((key) => Object.hasOwn(obj2, key) && !Object.hasOwn(obj1, key));
  for (const key of bothObj1AndObj2Keys) {
    if (typeof obj1[key] === "object" && typeof obj2[key] === "object" && !Array.isArray(obj1[key]) && !Array.isArray(obj2[key])) {
      const nestedDiff = objDiff(obj1[key], obj2[key]);
      if (Object.keys(nestedDiff).length > 0) {
        diff[key] = nestedDiff;
      }
    } else if (Array.isArray(obj1[key]) && Array.isArray(obj2[key])) {
      const array1 = obj1[key];
      const array2 = obj2[key];
      if (array1.toString() !== array2.toString()) {
        diff[key] = obj2[key];
      }
    } else if (obj1[key] !== obj2[key]) {
      diff[key] = obj2[key];
    }
  }
  for (const key of onlyObj2Keys) {
    diff[`-=${key}`] = obj2[key];
  }
  return diff;
}
const objExpand = (obj) => {
  const expObj = {};
  for (const [key, val] of Object.entries(obj)) {
    if (isList(val)) {
      const expandedVal = objExpand(val);
      setProperty(expObj, key, expandedVal);
    } else {
      setProperty(expObj, key, val);
    }
  }
  function arrayify(o) {
    if (isList(o)) {
      if (/^\d+$/.test(Object.keys(o).join(""))) {
        return Object.values(o).map(arrayify);
      }
      return objMap(o, (v) => arrayify(v));
    }
    if (isArray(o)) {
      return o.map(arrayify);
    }
    return o;
  }
  return arrayify(expObj);
};
const objFlatten = (obj) => {
  const flatObj = {};
  for (const [key, val] of Object.entries(obj)) {
    if ((isArray(val) || isList(val)) && hasItems(val)) {
      for (const [subKey, subVal] of Object.entries(objFlatten(val))) {
        flatObj[`${key}.${subKey}`] = subVal;
      }
    } else {
      flatObj[key] = val;
    }
  }
  return flatObj;
};
function objNullify(obj) {
  if (!isIndex(obj)) {
    return obj;
  }
  if (Array.isArray(obj)) {
    obj.forEach((_, i) => {
      obj[i] = null;
    });
    return obj;
  }
  Object.keys(obj).forEach((objKey) => {
    obj[objKey] = null;
  });
  return obj;
}
function objFreezeProps(data, ...keysOrSchema) {
  const firstArg = keysOrSchema[0];
  if (firstArg instanceof Object && !Array.isArray(firstArg)) {
    const schema = firstArg;
    for (const key in schema) {
      if (data[key] === void 0) {
        throw new Error(`Missing value for ${key}`);
      }
    }
  } else {
    for (const key of keysOrSchema) {
      if (data[key] === void 0) {
        throw new Error(`Missing value for ${String(key)}`);
      }
    }
  }
  return data;
}
const getDynamicFunc = (funcName, func, context3) => {
  if (typeof func === "function") {
    const dFunc = { [funcName](...args) {
      return func(...args);
    } }[funcName];
    return context3 ? dFunc.bind(context3) : dFunc;
  }
  return false;
};
const withLog = (fn) => {
  return (...args) => {
    console.log(`calling ${fn.name}`);
    return fn(...args);
  };
};
const changeContainer = (elem, container, isCloning = false) => {
  elem = $(elem)[0];
  container = $(container)[0];
  const curContainer = $(elem).parent()[0];
  const curPosition = {
    x: gsapWithCSS.getProperty(elem, "x"),
    y: gsapWithCSS.getProperty(elem, "y")
  };
  const relPos = MotionPathPlugin.convertCoordinates(
    curContainer,
    container,
    curPosition
  );
  if (isCloning) {
    elem = $(elem).clone()[0];
  }
  $(elem).appendTo($(container));
  gsapWithCSS.set(elem, relPos);
  return elem;
};
const adjustTextContainerAspectRatio = (textContainer, targetRatio, maxHeight, maxWidth, minFontSize = 8) => {
  textContainer = $(textContainer)[0];
  if (!maxWidth) {
    textContainer.style.setProperty("width", "max-content", "important");
  } else {
    textContainer.style.setProperty("width", `${maxWidth}px`, "important");
  }
  function recurAdjustment() {
    textContainer = $(textContainer)[0];
    const newFontSize = parseFloat(style.fontSize) * 0.8;
    const newLineHeight = parseFloat(style.lineHeight) * 0.8;
    if (newFontSize < minFontSize) {
      return false;
    }
    textContainer.style.fontSize = `${newFontSize}px`;
    textContainer.style.lineHeight = `${newLineHeight}px`;
    return adjustTextContainerAspectRatio(textContainer, targetRatio, lineCount ?? maxHeight, maxWidth, minFontSize);
  }
  const style = window.getComputedStyle(textContainer);
  const lineHeight = parseFloat(style.lineHeight);
  let lineCount = void 0;
  if (isInt(maxHeight) && maxHeight < lineHeight) {
    lineCount = maxHeight;
  }
  const initialWidth = parseFloat(style.width);
  let bestWidth = initialWidth;
  let isAtMaxLineCount = false;
  for (let lines = 1; ; lines++) {
    const expectedHeight = lineHeight * lines;
    const expectedWidth = initialWidth / lines;
    const expectedRatio = expectedWidth / expectedHeight;
    if (expectedRatio < targetRatio) {
      break;
    }
    if (isInt(lineCount)) {
      if (lines > lineCount && recurAdjustment()) {
        return;
      }
      break;
    } else if (maxHeight && expectedHeight > maxHeight) {
      if (recurAdjustment()) {
        return;
      }
      break;
    }
    bestWidth = expectedWidth;
    if (isInt(lineCount) && lines === lineCount) {
      isAtMaxLineCount = true;
      break;
    }
  }
  if (!isAtMaxLineCount && maxWidth && bestWidth > maxWidth && recurAdjustment()) {
    return;
  }
  textContainer.style.setProperty("width", `${bestWidth}px`, "important");
};
const getMutableRect = (rect) => ({
  x: rect.x,
  y: rect.y,
  width: rect.width,
  height: rect.height,
  top: rect.top,
  right: rect.right,
  bottom: rect.bottom,
  left: rect.left
});
const getSvgCode = (svgDotKey, svgPathKeys) => {
  const svgData = getProperty(SVGDATA, svgDotKey);
  if (!svgData) {
    return "";
  }
  const { viewBox, paths, classes } = svgData;
  svgPathKeys ?? (svgPathKeys = Object.keys(paths).join("|"));
  if (typeof svgPathKeys === "string") {
    svgPathKeys = svgPathKeys.split("|");
  }
  return [
    `<svg viewBox="${viewBox}">`,
    ...svgPathKeys.map((path) => `<path class="${path} ${(classes == null ? void 0 : classes[path]) ?? ""}" d="${paths[path] ?? ""}" />`),
    "</svg>"
  ].join("\n");
};
const getRawCirclePath = (r, { x: xO, y: yO } = { x: 0, y: 0 }) => {
  [r, xO, yO] = [r, xO, yO].map((val) => roundNum(val, 2));
  const [b1, b2] = [0.4475 * r, (1 - 0.4475) * r];
  const [xT, yT] = [xO, yO - r];
  return [[
    ...[xT, yT],
    ...[b2, 0, r, b1, r, r],
    ...[0, b2, -b1, r, -r, r],
    ...[-b2, 0, -r, -b1, -r, -r],
    ...[0, -b2, b1, -r, r, -r]
  ]];
};
const drawCirclePath = (radius, origin) => {
  const [[xT, yT, ...segments]] = getRawCirclePath(radius, origin);
  const path = [`m ${xT} ${yT}`];
  segments.forEach((coord, i) => {
    if (i % 6 === 0) {
      path.push("c");
    }
    path.push(coord);
  });
  path.push("z");
  return path.join(" ");
};
const getColorVals = (red, green, blue, alpha) => {
  var _a2;
  if (isRGBColor(red)) {
    [red, green, blue, alpha] = red.replace(/[^\d.,]/g, "").split(/,/).map((color) => isUndefined(color) ? void 0 : parseFloat(color));
  }
  if (isHexColor(red)) {
    if ([4, 5].includes(red.length)) {
      red = red.replace(/([^#])/g, "$1$1");
    }
    [red, green, blue, alpha] = ((_a2 = red.match(/[^#]{2}/g)) == null ? void 0 : _a2.map((val) => parseInt(val, 16))) ?? [];
  }
  if ([red, green, blue].every((color) => /^\d+$/.test(`${color}`))) {
    return [red, green, blue, alpha].filter((color) => /^[\d.]+$/.test(`${color}`));
  }
  return null;
};
const getRGBString = (red, green, blue, alpha) => {
  if (isRGBColor(red) || isHexColor(red)) {
    [red, green, blue, alpha] = getColorVals(red) ?? [];
  }
  if ([red, green, blue].every((color) => /^[.\d]+$/.test(`${color}`))) {
    let colorString = "rgb";
    const colors = [red, green, blue];
    if (/^[.\d]+$/.test(`${alpha}`)) {
      colors.push(alpha >= 1 ? pInt(alpha) : pFloat(alpha, 2));
      colorString += "a";
    }
    return `${colorString}(${colors.join(", ")})`;
  }
  return null;
};
const getHEXString = (red, green, blue) => {
  function componentToHex(c) {
    const hex = c.toString(16);
    return hex.length === 1 ? `0${hex}` : hex;
  }
  if (isHexColor(red)) {
    return red;
  }
  if (isRGBColor(red)) {
    [red, green, blue] = getColorVals(red) ?? [];
  }
  if (isDefined(red) && isDefined(green) && isDefined(blue) && [red, green, blue].every((color) => /^[.\d]+$/.test(`${color}`))) {
    return `#${componentToHex(red ?? 0)}${componentToHex(green ?? 0)}${componentToHex(blue ?? 0)}`;
  }
  return null;
};
const getContrastingColor = (...colorVals) => {
  const [red, green, blue] = getColorVals(...colorVals) ?? [];
  if ([red, green, blue].every(isNumber)) {
    const YIQ = (red * 299 + green * 587 + blue * 114) / 1e3;
    return YIQ >= 128 ? "rgba(0, 0, 0, 1)" : "rgba(255, 255, 255, 0.8)";
  }
  return null;
};
const getRandomColor = () => getRGBString(
  gsapWithCSS.utils.random(0, 255, 1),
  gsapWithCSS.utils.random(0, 255, 1),
  gsapWithCSS.utils.random(0, 255, 1)
);
const getSiblings = (elem) => {
  const siblings = [];
  if (!elem.parentNode) {
    return siblings;
  }
  Array.from(elem.parentNode.children).forEach((sibling) => {
    if (sibling !== elem) {
      siblings.push(sibling);
    }
  });
  return siblings;
};
const escapeHTML = (str2) => typeof str2 === "string" ? str2.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/[`']/g, "&#039;") : str2;
function extractComputedStyles(element) {
  if (!(element instanceof Element)) {
    element = element[0];
  }
  const style = window.getComputedStyle(element);
  const styleObject = {};
  for (let i = 0; i < style.length; i++) {
    const prop = style[i];
    styleObject[prop] = style.getPropertyValue(prop);
  }
  return JSON.stringify(styleObject);
}
function compareComputedStyles(savedStyles, newElement) {
  if (typeof savedStyles === "string") {
    savedStyles = JSON.parse(savedStyles);
  }
  const newStyles = JSON.parse(extractComputedStyles(newElement));
  const differences = [];
  const allProps = /* @__PURE__ */ new Set([...Object.keys(savedStyles), ...Object.keys(newStyles)]);
  allProps.forEach((prop) => {
    const oldStyle = savedStyles[prop];
    const newStyle = newStyles[prop];
    if (oldStyle !== newStyle) {
      differences.push(`Property: ${prop}, Old: ${oldStyle}, New: ${newStyle}`);
    }
  });
  return differences;
}
const testFuncPerformance = (func, ...params) => {
  const start = performance.now();
  let tally = 0;
  const handleResult = () => {
    if (performance.now() - start < 1e4) {
      runFunc();
      tally++;
    } else {
      const elapsedTime = performance.now() - start;
      const timePerCall = roundNum(elapsedTime / tally / 4e3, 4);
      eLog.checkLog3("performance", `[TestPerformance] Function Ran ${tally} Times in ${roundNum(elapsedTime / 1e3, 4)}s, Averaging ${timePerCall}s per Call`);
    }
  };
  const runFunc = () => {
    const result = func(...params);
    if (result instanceof Promise) {
      result.then(handleResult);
    } else {
      handleResult();
    }
  };
  runFunc();
};
const set = (targets, vars) => gsapWithCSS.set(targets, vars);
function get(target, property, unit) {
  if (unit) {
    const propVal = regExtract(gsapWithCSS.getProperty(target, property, unit), /[\d.]+/);
    if (typeof propVal === "string") {
      return pFloat(propVal);
    }
    throw new Error(`Unable to extract property '${property}' in '${unit}' units from ${target}`);
  }
  return gsapWithCSS.getProperty(target, property);
}
const getGSAngleDelta = (startAngle, endAngle) => signNum(roundNum(getAngleDelta(startAngle, endAngle), 2)).replace(/^(.)/, "$1=");
const getNearestLabel = (tl, matchTest) => {
  if (!(tl instanceof gsapWithCSS.core.Timeline)) {
    return void 0;
  }
  if (!objSize(tl.labels)) {
    return void 0;
  }
  if (typeof matchTest === "string") {
    matchTest = new RegExp(matchTest);
  }
  const labelTimes = Object.entries(tl.labels).filter(([label]) => {
    return matchTest instanceof RegExp ? matchTest.test(label) : true;
  }).sort((a, b) => a[1] - b[1]);
  const nearestTime = gsapWithCSS.utils.snap(labelTimes.map(([_label, time]) => time), tl.time());
  const [nearestLabel] = labelTimes.find(([_label, time]) => time === nearestTime);
  return nearestLabel;
};
const reverseRepeatingTimeline = (tl) => {
  if (tl.repeat() === -1) {
    tl.totalTime(tl.time());
  } else {
    const [tw] = tl.getChildren(false, true, true, tl.time());
    if ((tw instanceof gsapWithCSS.core.Timeline || tw instanceof gsapWithCSS.core.Tween) && tw.repeat() === -1) {
      tw.totalTime(tw.time());
    }
    tl.reverse();
  }
  return tl;
};
const sleep$1 = (duration) => new Promise(
  (resolve) => {
    setTimeout(resolve, duration >= 100 ? duration : duration * 1e3);
  }
);
function waitFor(waitForTarget) {
  return new Promise(
    (resolve, reject) => {
      if (waitForTarget instanceof Promise || waitForTarget instanceof gsapWithCSS.core.Animation) {
        waitForTarget.then(() => resolve()).catch(reject);
      } else if (Array.isArray(waitForTarget)) {
        Promise.all(waitForTarget.map((target) => waitFor(target))).then(() => resolve()).catch(reject);
      } else {
        resolve();
      }
    }
  );
}
const EventHandlers = {
  onSelectChange: async (inst, event) => {
    const elem = event.currentTarget;
    const { action, dtype, target, flagTarget } = elem.dataset;
    if (!action) {
      throw new Error("Select elements require a data-action attribute.");
    }
    if (!target && !flagTarget) {
      throw new Error("Select elements require a 'data-target' or 'data-flag-target' attribute.");
    }
    const dataType = lCase(dtype);
    let value;
    switch (dataType) {
      case "number":
        value = pFloat(elem.value);
        break;
      case "boolean":
        value = lCase(`${elem.value}`) === "true";
        break;
      case "string":
        value = `${elem.value}`;
        break;
      default: {
        if (isNumString(value)) {
          throw new Error(`You must set 'data-dtype="Number"' for <select> elements with number values.`);
        }
        if (isBooleanString(value)) {
          throw new Error(`You must set 'data-dtype="Boolean"' for <select> elements with boolean values.`);
        }
        value = `${elem.value}`;
        break;
      }
    }
    if (target) {
      await inst.document.update({ [target]: value });
    } else if (flagTarget) {
      if (elem.value === "") {
        await inst.document.unsetFlag(C.SYSTEM_ID, flagTarget);
      } else {
        await inst.document.setFlag(C.SYSTEM_ID, flagTarget, value);
      }
    }
  }
};
const isDocID = (ref) => typeof ref === "string" && /^[A-Za-z0-9]{16}$/.test(ref);
const isDocUUID = (ref) => {
  if (typeof ref !== "string") {
    return false;
  }
  const [docName, docID] = ref.split(/\./);
  if (!isDocID(docID)) {
    return false;
  }
  return game.collections.has(docName);
};
const isDotKey = (ref) => typeof ref === "string";
const isTargetKey = (ref) => {
  if (!isDotKey(ref)) {
    return false;
  }
  if (["name", "img", "id", "_id"].includes(ref)) {
    return true;
  }
  if (ref.startsWith("system")) {
    return true;
  }
  if (ref.startsWith("flag")) {
    return true;
  }
  return false;
};
const isTargetFlagKey = (ref) => {
  if (!isDotKey(ref)) {
    return false;
  }
  if (isTargetKey(ref)) {
    return false;
  }
  return true;
};
const parseDocRefToUUID = (ref) => {
  var _a2;
  if (isDocUUID(ref)) {
    return ref;
  } else if (isDocID(ref)) {
    const doc = (_a2 = game.collections.find((collection) => collection.has(ref))) == null ? void 0 : _a2.get(ref);
    if (doc && "uuid" in doc) {
      return doc.uuid;
    }
    throw new Error(`[U.parseDocRefToUUID] Unable to find document with id '${ref}'`);
  } else if (ref && typeof ref === "object" && "uuid" in ref && typeof ref.uuid === "string") {
    return ref.uuid;
  }
  throw new Error(`[U.parseDocRefToUUID] Unrecognized reference: '${ref}'`);
};
const loc = (locRef, formatDict = {}) => {
  if (/[a-z]/.test(locRef)) {
    locRef = locRef.replace(new RegExp(`^(${C.SYSTEM_ID}.)*`), `${C.SYSTEM_ID}.`);
  }
  if (typeof game.i18n.localize(locRef) === "string") {
    for (const [key, val] of Object.entries(formatDict)) {
      formatDict[key] = loc(val);
    }
    return game.i18n.format(locRef, formatDict) || game.i18n.localize(locRef) || locRef;
  }
  return locRef;
};
const getSetting = (setting, submenu) => {
  const settingPath = [submenu, setting].filter(isDefined).join(".");
  if (game.settings.settings.has(`${C.SYSTEM_ID}.${settingPath}`)) {
    return game.settings.get(C.SYSTEM_ID, settingPath);
  }
  return void 0;
};
function getTemplatePath(subFolder, fileName) {
  if (typeof fileName === "string") {
    return `${C.TEMPLATE_ROOT}/${subFolder}/${fileName.replace(/\..*$/, "")}.hbs`;
  }
  return fileName.map((fName) => getTemplatePath(subFolder, fName));
}
function displayImageSelector(callback, pathRoot = `systems/${C.SYSTEM_ID}/assets`, position = { top: 200, left: 200 }) {
  const fp = new FilePicker({
    type: "image",
    activeSource: "public",
    displayMode: "tiles",
    callback,
    top: position.top ?? 200 + 40,
    left: position.left ?? 200 + 10
  });
  return fp.browse(pathRoot);
}
const U = {
  // ████████ GETTERS: Basic Data Lookup & Retrieval ████████
  GMID,
  getUID,
  // ████████ TYPES: Type Checking, Validation, Conversion, Casting ████████
  isNumber,
  isNumString,
  isBooleanString,
  isSimpleObj,
  isList,
  isArray,
  isFunc,
  isInt,
  isFloat,
  isPosInt,
  isIterable,
  isHTMLCode,
  isRGBColor,
  isHexColor,
  isUndefined,
  isDefined,
  isEmpty,
  hasItems,
  isInstance,
  isNullish,
  areEqual,
  areFuzzyEqual,
  pFloat,
  pInt,
  pBool,
  radToDeg,
  degToRad,
  getKey,
  assertNonNullType,
  FILTERS,
  // ████████ REGEXP: Regular Expressions, Replacing, Matching ████████
  testRegExp,
  regExtract,
  // ████████ STRINGS: String Parsing, Manipulation, Conversion ████████
  // ░░░░░░░ Case Conversion ░░░░░░░
  uCase,
  lCase,
  sCase,
  tCase,
  // ░░░░░░░ Formatting ░░░░░░░
  /* hyphenate, */
  unhyphenate,
  pluralize,
  oxfordize,
  ellipsize,
  pad,
  toKey,
  parseArticles,
  signNum,
  padNum,
  stringifyNum,
  verbalizeNum,
  ordinalizeNum,
  romanizeNum,
  // ░░░░░░░ Content ░░░░░░░
  loremIpsum,
  randString,
  randWord,
  // ████████ SEARCHING: Searching Various Data Types w/ Fuzzy Matching ████████
  fuzzyMatch,
  isIn,
  isInExact,
  // ████████ NUMBERS: Number Casting, Mathematics, Conversion ████████
  randNum,
  randInt,
  coinFlip,
  cycleNum,
  cycleAngle,
  roundNum,
  clampNum,
  sum,
  average,
  // ░░░░░░░ Positioning ░░░░░░░
  getDistance,
  getAngle,
  getAngleDelta,
  getBoundingRectangle,
  // ████████ ARRAYS: Array Manipulation ████████
  randElem,
  randIndex,
  makeIntRange,
  makeCycler,
  unique,
  group,
  sample,
  getLast,
  removeFirst,
  pullElement,
  pullIndex,
  subGroup,
  shuffle: shuffle2,
  toArray: toArray2,
  // ████████ OBJECTS: Manipulation of Simple Key/Val Objects ████████
  remove,
  replace,
  partition: partition$1,
  zip,
  objClean,
  objSize,
  objMap,
  objFindKey,
  objFilter,
  objForEach,
  objCompact,
  objClone,
  objMerge,
  objDiff,
  objExpand,
  objFlatten,
  objNullify,
  objFreezeProps,
  // ████████ FUNCTIONS: Function Wrapping, Queuing, Manipulation ████████
  getDynamicFunc,
  withLog,
  // ████████ HTML: Parsing HTML Code, Manipulating DOM Objects ████████
  getSvgCode,
  changeContainer,
  adjustTextContainerAspectRatio,
  getMutableRect,
  getRawCirclePath,
  drawCirclePath,
  getColorVals,
  getRGBString,
  getHEXString,
  getContrastingColor,
  getRandomColor,
  getSiblings,
  escapeHTML,
  extractComputedStyles,
  compareComputedStyles,
  // ████████ PERFORMANCE: Performance Testing & Metrics ████████
  testFuncPerformance,
  // ░░░░░░░ GreenSock ░░░░░░░
  gsap: gsapWithCSS,
  get,
  set,
  getGSAngleDelta,
  getNearestLabel,
  reverseRepeatingTimeline,
  /* to, from, fromTo, */
  /* TextPlugin, Flip, */
  MotionPathPlugin,
  // ████████ ASYNC: Async Functions, Asynchronous Flow Control ████████
  sleep: sleep$1,
  waitFor,
  // EVENT HANDLERS
  EventHandlers,
  // ░░░░░░░ SYSTEM: System-Specific Functions (Requires Configuration of System ID in constants.js) ░░░░░░░
  isDocID,
  isDocUUID,
  isDotKey,
  isTargetKey,
  isTargetFlagKey,
  parseDocRefToUUID,
  loc,
  getSetting,
  getTemplatePath,
  displayImageSelector
};
const ColorNums = {
  "white": {
    "bright": [
      255,
      255,
      255
    ],
    "normal": [
      200,
      200,
      200
    ]
  },
  "grey": {
    "bright": [
      158,
      158,
      158
    ],
    "normal": [
      116,
      116,
      116
    ],
    "dark": [
      73,
      73,
      73
    ]
  },
  "black": {
    "normal": [
      30,
      30,
      30
    ],
    "dark": [
      0,
      0,
      0
    ]
  },
  "gold": {
    "bright": [
      255,
      216,
      44
    ],
    "normal": [
      215,
      175,
      0
    ],
    "dark": [
      165,
      134,
      0
    ],
    "darkest": [
      103,
      83,
      0
    ]
  },
  "red": {
    "bright": [
      255,
      0,
      0
    ],
    "normal": [
      200,
      0,
      0
    ],
    "dark": [
      150,
      0,
      0
    ],
    "darkest": [
      50,
      0,
      0
    ],
    "black": [
      25,
      0,
      0
    ]
  },
  "green": {
    "bright": [
      20,
      220,
      60
    ],
    "normal": [
      0,
      204,
      0
    ],
    "dark": [
      0,
      122,
      0
    ],
    "darkest": [
      0,
      60,
      0
    ]
  },
  "blue": {
    "bright": [
      0,
      224,
      224
    ],
    "normal": [
      52,
      213,
      213
    ],
    "dark": [
      0,
      118,
      118
    ],
    "darkest": [
      0,
      77,
      77
    ]
  }
};
const cssFullShifts = {
  // Maps missing brightness values to other hue/brightness combinations
  white: {
    dark: ["grey", "bright"],
    darkest: ["grey", "normal"]
  },
  grey: {
    brightest: ["white", "normal"],
    darkest: ["black", "normal"]
  },
  black: {
    brightest: ["grey", "normal"],
    bright: ["grey", "dark"]
  }
};
function getColor(hue, brightness = "normal", opacity = 1) {
  var _a2, _b, _c, _d, _e, _f, _g;
  const originals = { hue, brightness };
  let rgbVals = [];
  const cNums = ColorNums;
  if (!cNums[hue]) {
    throw new Error(`Unrecognized color: "${hue}"`);
  }
  const hueData = cNums[hue];
  if (!hueData[brightness]) {
    const cssBrightnessShifts = {
      brightest: ["bright"],
      darkest: ["dark"],
      black: ["darkest", "dark"]
    };
    if ((_a2 = cssFullShifts[hue]) == null ? void 0 : _a2[brightness]) {
      [hue, brightness] = (_b = cssFullShifts[hue]) == null ? void 0 : _b[brightness];
    } else if (brightness in cssBrightnessShifts) {
      const brightVals = cssBrightnessShifts[brightness];
      while (!((_c = cNums[hue]) == null ? void 0 : _c[brightness]) && brightVals.length) {
        brightness = brightVals.shift();
        if (!((_d = cNums[hue]) == null ? void 0 : _d[brightness]) && ((_e = cssFullShifts[hue]) == null ? void 0 : _e[brightness])) {
          [hue, brightness] = (_f = cssFullShifts[hue]) == null ? void 0 : _f[brightness];
        }
      }
    }
  }
  rgbVals = (_g = cNums[hue]) == null ? void 0 : _g[brightness];
  if (!(rgbVals == null ? void 0 : rgbVals.length)) {
    throw new Error(`Unable to parse color "${originals.hue}-${originals.brightness}" (${hue}-${brightness})`);
  }
  return `rgba(${rgbVals.join(", ")}, ${opacity})`;
}
async function preloadHandlebarsTemplates() {
  const templatePaths = [
    // General Components
    "systems/eunos-blades/templates/components/toggle-icon.hbs",
    "systems/eunos-blades/templates/components/button-icon.hbs",
    "systems/eunos-blades/templates/components/dotline.hbs",
    "systems/eunos-blades/templates/components/armor.hbs",
    "systems/eunos-blades/templates/components/comp.hbs",
    "systems/eunos-blades/templates/components/select.hbs",
    "systems/eunos-blades/templates/components/portrait.hbs",
    "systems/eunos-blades/templates/components/clock.hbs",
    "systems/eunos-blades/templates/components/roll-collab-mod.hbs",
    "systems/eunos-blades/templates/components/slide-out-controls.hbs",
    "systems/eunos-blades/templates/components/consequence.hbs",
    "systems/eunos-blades/templates/components/consequence-accepted.hbs",
    // Partials
    "systems/eunos-blades/templates/parts/tier-block.hbs",
    "systems/eunos-blades/templates/parts/turf-list.hbs",
    "systems/eunos-blades/templates/parts/cohort-block.hbs",
    "systems/eunos-blades/templates/parts/roll-opposition-creator.hbs",
    "systems/eunos-blades/templates/parts/active-effects.hbs",
    "systems/eunos-blades/templates/parts/gm-pc-summary.hbs",
    "systems/eunos-blades/templates/components/clock-key.hbs"
  ];
  return loadTemplates(templatePaths);
}
const handlebarHelpers = {
  randString(param1 = 10) {
    return U.randString(param1);
  },
  test(param1, operator, param2) {
    const stringMap = {
      true: true,
      false: false,
      null: null,
      undefined: void 0
    };
    if (["!", "not", "=??"].includes(String(param1))) {
      [operator, param1] = [String(param1), operator];
    }
    if (typeof param1 === "string" && param1 in stringMap) {
      param1 = stringMap[param1];
    }
    if (typeof param2 === "string" && param2 in stringMap) {
      param2 = stringMap[param2];
    }
    switch (operator) {
      case "!":
      case "not": {
        return !param1;
      }
      case "=??": {
        return [void 0, null].includes(param1);
      }
      case "&&": {
        return param1 && param2;
      }
      case "||": {
        return param1 || param2;
      }
      case "==": {
        return U.areFuzzyEqual(param1, param2);
      }
      case "===": {
        return param1 === param2;
      }
      case "!=":
      case "!==": {
        return param1 !== param2;
      }
      case ">": {
        return typeof param1 === "number" && typeof param2 === "number" && param1 > param2;
      }
      case "<": {
        return typeof param1 === "number" && typeof param2 === "number" && param1 < param2;
      }
      case ">=": {
        return typeof param1 === "number" && typeof param2 === "number" && param1 >= param2;
      }
      case "<=": {
        return typeof param1 === "number" && typeof param2 === "number" && param1 <= param2;
      }
      case "??": {
        return param1 ?? param2;
      }
      case "includes": {
        return Array.isArray(param1) && param1.includes(param2);
      }
      case "in": {
        if (Array.isArray(param2)) {
          return param2.includes(param1);
        }
        if (U.isList(param2) && (typeof param1 === "number" || typeof param1 === "string")) {
          return param1 in param2;
        }
        if (typeof param2 === "string") {
          return new RegExp(String(param1), "gu").test(String(param2));
        }
        return false;
      }
      default: {
        return false;
      }
    }
  },
  calc(...params) {
    const calcs = {
      "+": (p1, p2) => U.pInt(p1) + U.pInt(p2),
      "-": (p1, p2) => U.pInt(p1) - U.pInt(p2),
      "*": (p1, p2) => U.pInt(p1) * U.pInt(p2),
      "/": (p1, p2) => U.pInt(p1) / U.pInt(p2),
      "%": (p1, p2) => U.pInt(p1) % U.pInt(p2),
      "max": (p1, p2) => Math.max(U.pInt(p1), U.pInt(p2)),
      "min": (p1, p2) => Math.min(U.pInt(p1), U.pInt(p2)),
      "ceil": (p1) => Math.ceil(U.pFloat(p1)),
      "floor": (p1) => Math.floor(U.pFloat(p1))
    };
    const [param1, operator, param2] = typeof params[0] === "string" && params[0] in calcs ? [params[1], params[0]] : params;
    return calcs[operator](param1, param2);
  },
  isIn(...args) {
    const [testStr, ...contents] = args;
    return contents.includes(testStr);
  },
  case(mode, str2) {
    switch (mode) {
      case "upper":
        return U.uCase(str2);
      case "lower":
        return U.lCase(str2);
      case "sentence":
        return U.sCase(str2);
      case "title":
        return U.tCase(str2);
      default:
        return str2;
    }
  },
  romanize(val) {
    return U.romanizeNum(U.pInt(val));
  },
  count(param) {
    if (Array.isArray(param) || U.isList(param)) {
      return Object.values(param).filter((val) => val !== null && val !== void 0).length;
    } else if (typeof param === "string") {
      return param.length;
    }
    return param ? 1 : 0;
  },
  // Concat helper
  // Usage: (concat 'first 'second')
  concat(...args) {
    let outStr = "";
    for (const arg of args) {
      if (typeof arg === "string" || typeof arg === "number") {
        outStr += arg;
      }
    }
    return outStr;
  },
  // Merge helper - To merge additional properties into a template's context
  merge(context3, ...args) {
    args.pop();
    return args.reduce((acc, val) => Object.assign(acc, val), context3);
  },
  // For loop: {{#for [from = 0, to, stepSize = 1]}}<html content, this = index>{{/for}}
  for: (...args) => {
    const options = args.pop();
    let [from, to, stepSize] = args;
    from = U.pInt(from);
    to = U.pInt(to);
    stepSize = U.pInt(stepSize) || 1;
    if (from > to) {
      return "";
    }
    let html = "";
    for (let i = parseInt(from || 0, 10); i <= parseInt(to || 0, 10); i += stepSize) {
      html += options.fn(i);
    }
    return html;
  },
  signNum(num) {
    return U.signNum(num);
  },
  compileSvg(...args) {
    const [svgDotKey, svgPaths] = args;
    return U.getSvgCode(svgDotKey, svgPaths);
  },
  eLog(...args) {
    args.pop();
    let dbLevel = 3;
    if ([0, 1, 2, 3, 4, 5].includes(args[0])) {
      dbLevel = args.shift();
    }
    eLog.hbsLog(...args, dbLevel);
  },
  // Does the name of this turf block represent a standard 'Turf' claim?
  isTurfBlock: (name) => U.fuzzyMatch(name, "Turf"),
  // Which other connection does this connector overlap with?
  getConnectorPartner: (index, direction) => {
    index = parseInt(`${index}`, 10);
    const partners = {
      1: { right: 2, bottom: 6 },
      2: { left: 1, right: 3, bottom: 7 },
      3: { left: 2, right: 4, bottom: 8 },
      4: { left: 3, right: 5, bottom: 9 },
      5: { left: 4, bottom: 10 },
      6: { top: 1, right: 7, bottom: 11 },
      7: { top: 2, left: 6, right: 8, bottom: 12 },
      8: { top: 3, left: 7, right: 9, bottom: 13 },
      9: { top: 4, left: 8, right: 10, bottom: 14 },
      10: { top: 5, left: 9, bottom: 15 },
      11: { top: 6, right: 12 },
      12: { top: 7, left: 11, right: 13 },
      13: { top: 8, left: 12, right: 14 },
      14: { top: 9, left: 13, right: 15 },
      15: { top: 10, left: 14 }
    };
    const partnerDir = { left: "right", right: "left", top: "bottom", bottom: "top" }[direction];
    const partnerNum = partners[index][direction] ?? 0;
    if (partnerNum) {
      return `${partnerNum}-${partnerDir}`;
    }
    return null;
  },
  // Is the value Turf side.
  isTurfOnEdge: (index, direction) => {
    index = parseInt(`${index}`, 10);
    const edges = {
      1: ["top", "left"],
      2: ["top"],
      3: ["top"],
      4: ["top"],
      5: ["top", "right"],
      6: ["left"],
      7: [],
      8: [],
      9: [],
      10: ["right"],
      11: ["left", "bottom"],
      12: ["bottom"],
      13: ["bottom"],
      14: ["bottom"],
      15: ["right", "bottom"]
    };
    if (!(index in edges)) {
      return true;
    }
    return edges[index].includes(direction);
  },
  // Multiboxes
  multiboxes(selected, options) {
    let html = options.fn(this);
    selected = [selected].flat(1);
    selected.forEach((selectedVal) => {
      if (selectedVal !== false) {
        const escapedValue = RegExp.escape(Handlebars.escapeExpression(String(selectedVal)));
        const rgx = new RegExp(` value="${escapedValue}"`);
        html = html.replace(rgx, '$& checked="checked"');
      }
    });
    return html;
  },
  repturf: (turfsAmount, options) => {
    let html = options.fn(void 0);
    let turfsAmountInt = parseInt(turfsAmount, 10);
    if (turfsAmountInt > 6) {
      turfsAmountInt = 6;
    }
    for (let i = 13 - turfsAmountInt; i <= 12; i++) {
      const rgx = new RegExp(` value="${i}"`);
      html = html.replace(rgx, '$& disabled="disabled"');
    }
    return html;
  }
};
handlebarHelpers.eLog1 = function(...args) {
  handlebarHelpers.eLog(...[1, ...args.slice(0, 7)]);
};
handlebarHelpers.eLog2 = function(...args) {
  handlebarHelpers.eLog(...[2, ...args.slice(0, 7)]);
};
handlebarHelpers.eLog3 = function(...args) {
  handlebarHelpers.eLog(...[3, ...args.slice(0, 7)]);
};
handlebarHelpers.eLog4 = function(...args) {
  handlebarHelpers.eLog(...[4, ...args.slice(0, 7)]);
};
handlebarHelpers.eLog5 = function(...args) {
  handlebarHelpers.eLog(...[5, ...args.slice(0, 7)]);
};
function registerHandlebarHelpers() {
  Object.entries(handlebarHelpers).forEach(([name, func]) => Handlebars.registerHelper(name, func));
}
class DebugSettingsSubmenu extends FormApplication {
  constructor(object = {}, formApplicationOptions = {}) {
    super(object, formApplicationOptions);
  }
  /**
  * Default Options for this FormApplication
  */
  static get defaultOptions() {
    return mergeObject(super.defaultOptions, {
      id: "debug-settings-menu",
      title: "Debug Settings",
      popOut: true,
      template: "systems/eunos-blades/templates/settings/debug-settings.hbs",
      classes: ["eunos-blades", "settings"],
      width: 500,
      closeOnSubmit: true,
      submitOnChange: false,
      submitOnClose: true
    });
  }
  /**
  * Provide data to the template
  */
  getData() {
    return game.settings.get("eunos-blades", "debugSettings");
  }
  /**
   * Executes on form submission.
   * @param _event - the form submission event
   * @param formData - the form data
   */
  async _updateObject(_event, formData) {
    if (!formData) {
      return;
    }
    const data = expandObject(formData);
    game.settings.set("eunos-blades", "debugSettings", data);
  }
}
class OpenAISettingsSubmenu extends FormApplication {
  constructor(object = {}, formApplicationOptions = {}) {
    super(object, formApplicationOptions);
  }
  /**
  * Default Options for this FormApplication
  */
  static get defaultOptions() {
    return mergeObject(super.defaultOptions, {
      id: "openai-settings-menu",
      title: "Open AI Settings",
      popOut: true,
      template: "systems/eunos-blades/templates/settings/openai-settings.hbs",
      classes: ["eunos-blades", "settings"],
      width: 500,
      closeOnSubmit: true,
      submitOnChange: false,
      submitOnClose: true
    });
  }
  /**
  * Provide data to the template
  */
  getData() {
    return game.settings.get("eunos-blades", "openAISettings");
  }
  /**
   * Executes on form submission.
   * @param _event - the form submission event
   * @param formData - the form data
   */
  async _updateObject(_event, formData) {
    if (!formData) {
      return;
    }
    const data = expandObject(formData);
    game.settings.set("eunos-blades", "openAISettings", data);
  }
}
const registerSettings = function() {
  game.settings.registerMenu("eunos-blades", "debugSettingsMenu", {
    name: "Debug Settings",
    label: "Open Debug Settings",
    hint: "Configure settings related to debugging.",
    icon: "fa-duotone fa-ban-bug",
    type: DebugSettingsSubmenu,
    restricted: true
  });
  game.settings.register("eunos-blades", "debugSettings", {
    scope: "world",
    config: false,
    type: Object,
    default: {
      debugLevel: 3,
      debugHooks: false,
      whitelist: "",
      blacklist: ""
    }
  });
  game.settings.registerMenu("eunos-blades", "openAISettingsMenu", {
    name: "OpenAI Settings",
    label: "Open AI Integration",
    hint: "Configure settings related to integration with AI for content generation during play.",
    icon: "fa-duotone fa-brain-circuit",
    type: OpenAISettingsSubmenu,
    restricted: true
  });
  game.settings.register("eunos-blades", "openAISettings", {
    scope: "world",
    config: false,
    type: Object,
    default: {
      apiKey: "",
      models: {
        text: "gpt-3.5-turbo",
        speech: "tts-1-hd",
        image: "gpt-4-vision-preview"
      },
      fileID: ""
    }
  });
  game.settings.register("eunos-blades", "systemMigrationVersion", {
    name: "System Migration Version",
    scope: "world",
    config: false,
    type: Number,
    default: 0
  });
};
function initTinyMCEStyles() {
  CONFIG.TinyMCE = {
    ...CONFIG.TinyMCE,
    ...{
      skin: false,
      // skin_url:                    "systems/eunos-blades/tinymce/skin",
      content_css: "systems/eunos-blades/tinymce/tinymce.css",
      font_css: "systems/eunos-blades/fonts.css",
      max_height: 500,
      min_height: 100,
      autoresize_overflow_padding: 0,
      autoresize_bottom_margin: 0,
      // 25,
      menubar: false,
      statusbar: false,
      // True,
      elementPath: true,
      branding: false,
      resize: false,
      plugins: "lists image table code save autoresize searchreplace quickbars template",
      save_enablewhendirty: false,
      // Table_default_styles: {},
      style_formats: [
        {
          title: "Headings",
          items: [
            { title: "Heading 1", block: "h1", wrapper: false },
            { title: "Heading 2", block: "h2", wrapper: false },
            { title: "Heading 3", block: "h3", wrapper: false },
            { title: "Heading 4", block: "h4", wrapper: false }
          ]
        },
        {
          title: "Blocks",
          items: [
            { title: "Paragraph", block: "p", wrapper: false },
            { title: "Block Quote", block: "blockquote", wrapper: true }
            // {title: "Secret", block: "span", classes: "text-secret", attributes: {"data-is-secret": "true"}, wrapper: false}
          ]
        },
        {
          title: "Inline",
          items: [
            { title: "Bold", inline: "b", wrapper: false },
            { title: "Italics", inline: "i", wrapper: false },
            { title: "Underline", inline: "u", wrapper: false },
            { title: "Secret", inline: "span", classes: "text-secret", attributes: { "data-is-secret": "true" }, wrapper: false }
          ]
        }
      ],
      style_formats_merge: false,
      toolbar: "styles | searchreplace | formatting alignment lists elements | removeformat | code | save",
      toolbar_groups: {
        formatting: {
          icon: "color-picker",
          tooltip: "Formatting",
          items: "bold italic underline"
        },
        alignment: {
          icon: "align-left",
          tooltip: "Alignment",
          items: "alignleft aligncenter alignright alignjustify | outdent indent"
        },
        lists: {
          icon: "unordered-list",
          tooltip: "Lists",
          items: "bullist numlist"
        },
        elements: {
          icon: "duplicate",
          tooltip: "Insert Element",
          items: "tableinsertdialog image hr | template"
        }
      },
      toolbar_mode: "floating",
      quickbars_link_toolbar: false,
      quickbars_selection_toolbar: "styles | bold italic underline",
      quickbars_insert_toolbar: "hr image table",
      quickbars_table_toolbar: "tableprops tabledelete | tableinsertrowbefore tableinsertrowafter tabledeleterow | tableinsertcolbefore tableinsertcolafter tabledeletecol"
    }
  };
}
function initCanvasStyles() {
  CONFIG.canvasTextStyle = new PIXI.TextStyle({
    align: "center",
    dropShadow: true,
    dropShadowAngle: U.degToRad(45),
    dropShadowBlur: 8,
    dropShadowColor: getColor("black"),
    dropShadowDistance: 4,
    fill: [
      getColor("white", "bright"),
      getColor("grey", "bright")
    ],
    fillGradientType: 1,
    fillGradientStops: [
      0,
      0.3
    ],
    fontFamily: "Kirsty",
    fontSize: 32,
    letterSpacing: 2,
    lineHeight: 32,
    lineJoin: "round",
    padding: 4,
    stroke: getColor("black", "dark"),
    strokeThickness: 3,
    trim: true,
    whiteSpace: "normal",
    wordWrap: true,
    wordWrapWidth: 0.1
  });
}
function initDOMStyles() {
  $("body.vtt.game.system-eunos-blades").append(`<div id="backsplash" style="height: 100%; width: 100%; position: absolute; z-index: -1; background: linear-gradient(35deg, ${getColor("grey")}, ${getColor("black")});"></div>`);
  $("#interface").append(`<div class="lightning-border-container">
    </div>`);
}
const gsapPlugins = [
  TextPlugin,
  Flip,
  MotionPathPlugin,
  Draggable,
  // SplitText,
  Observer$1,
  CustomEase
  //   CustomWiggle,
  //   CustomBounce,
  //   EasePack
];
const gsapEffects = {
  // #region CLOCK KEYS
  keyDrop: {
    effect: (clockKey, config3) => {
      const [keyContainer] = $(clockKey).closest(".clock-key-container");
      return U.gsap.timeline({
        onComplete() {
          if (config3.callback) {
            config3.callback();
          }
        }
      }).fromTo(keyContainer, {
        y: config3.yShift
      }, {
        y: 0,
        autoAlpha: 1,
        ease: "bounce",
        duration: config3.duration
      });
    },
    defaults: {
      duration: 1,
      yShift: -800
    },
    extendTimeline: true
  },
  keyPull: {
    effect: (clockKey, config3) => {
      const [keyContainer] = $(clockKey).closest(".clock-key-container");
      return U.gsap.timeline({
        onComplete() {
          if (config3.callback) {
            config3.callback();
          }
        }
      }).to(keyContainer, {
        y: config3.yDelta,
        ease: config3.ease,
        duration: 0.75 * config3.duration
      }).to(keyContainer, {
        opacity: 0,
        ease: "power2.out",
        duration: 0.25 * config3.duration
      }, 0.75 * config3.duration);
    },
    defaults: {
      yDelta: -800,
      duration: 1,
      ease: "back.in(1)"
    },
    extendTimeline: true
  },
  keyControlPanelFlip: {
    effect: (target, config3) => {
      return U.gsap.timeline({
        delay: config3.delay,
        onStart() {
          if (target) {
            const target$ = $(target);
            const nextSibling$ = target$.next(".clock-control-flipper");
            if (nextSibling$.length) {
              U.gsap.effects.keyControlPanelFlip(nextSibling$[0], {
                ...config3,
                delay: 0.15
              });
            }
          }
        }
      }).to(target, {
        rotateX: config3.angle,
        duration: 0.5,
        ease: "back.inOut(2)"
      });
    },
    defaults: {
      angle: 180,
      delay: 0
    },
    extendTimeline: true
  },
  // #endregion
  // #region CHAT CONSEQUENCE EFFECTS
  csqEnter: {
    effect: (csqContainer, config3) => {
      const csqRoot = U.gsap.utils.selector(csqContainer);
      const csqIconCircle = csqRoot(".consequence-icon-circle.base-consequence");
      const csqBaseTypeElem = csqRoot(".consequence-type.base-consequence");
      const csqAcceptTypeElem = csqRoot(".consequence-type.accept-consequence");
      const csqBaseNameElem = csqRoot(".consequence-name.base-consequence");
      const csqAcceptNameElem = csqRoot(".consequence-name.accept-consequence");
      const tl = U.gsap.timeline({ paused: true, defaults: {} });
      if (csqAcceptTypeElem.length > 0) {
        tl.set(csqAcceptTypeElem, { opacity: 0 }, 0);
      }
      if (csqAcceptNameElem.length > 0) {
        tl.set(csqAcceptNameElem, { opacity: 0 }, 0);
      }
      if (csqBaseTypeElem.length > 0) {
        tl.fromTo(csqBaseTypeElem, {
          opacity: 1
        }, {
          opacity: 0,
          duration: 0.25,
          ease: "sine"
        }, 0);
      }
      if (csqAcceptTypeElem.length > 0) {
        tl.fromTo(csqAcceptTypeElem, {
          opacity: 0
        }, {
          opacity: 1,
          duration: 0.25,
          ease: "sine"
        }, 0);
      }
      if (csqBaseNameElem.length > 0) {
        tl.fromTo(csqBaseNameElem, {
          opacity: 1
        }, {
          opacity: 0,
          duration: 0.25,
          ease: "sine"
        }, 0);
      }
      if (csqAcceptNameElem.length > 0) {
        tl.fromTo(csqAcceptNameElem, {
          opacity: 0
        }, {
          opacity: 1,
          duration: 0.25,
          ease: "sine"
        }, 0);
      }
      if (csqContainer) {
        tl.fromTo(csqContainer, {
          filter: "brightness(1)"
        }, {
          filter: `brightness(${config3.brightness})`,
          duration: config3.duration / 3,
          ease: "none"
        }, 0);
      }
      if (csqIconCircle.length > 0) {
        tl.fromTo(csqIconCircle, {
          scale: 0.75,
          outlineColor: getColor("black", "dark"),
          outlineWidth: 0
        }, {
          scale: 0.85,
          outlineColor: getColor("grey"),
          outlineWidth: 1,
          duration: 0.55,
          ease: "sine.out"
        }, 0);
      }
      return tl;
    },
    defaults: {
      brightness: 1.5,
      duration: 0.5,
      scale: 1.5,
      stagger: 0.05,
      ease: "sine",
      easeStrength: 1.5
    }
  },
  csqClickIcon: {
    effect: (csqIconContainer, config3) => {
      const csqContainer = $(csqIconContainer).closest(".comp.consequence-display-container");
      const csqRoot = U.gsap.utils.selector(csqContainer[0]);
      const iconRoot = U.gsap.utils.selector(csqIconContainer);
      const csqBackgroundImg = csqRoot(".consequence-bg-image");
      const csqInteractionPads = csqRoot(".consequence-interaction-pad");
      const csqIconCircleBase = iconRoot(".consequence-icon-circle.base-consequence");
      const csqIconCircleAccept = iconRoot(".consequence-icon-circle.accept-consequence");
      const csqButtonContainers = iconRoot(".consequence-button-container");
      const tl = U.gsap.timeline({
        paused: true,
        onComplete() {
          $(csqInteractionPads).css("pointerEvents", "auto");
        },
        onReverseComplete() {
          $(csqInteractionPads).css("pointerEvents", "none");
        }
      });
      if (csqBackgroundImg.length) {
        tl.fromTo(csqBackgroundImg, {
          xPercent: 110,
          yPercent: -50
        }, {
          xPercent: -60,
          yPercent: -50,
          duration: 0.5,
          ease: "back"
        }, 0);
      }
      if (csqIconCircleBase.length > 0) {
        tl.fromTo(csqIconCircleBase, {
          opacity: 1
        }, {
          opacity: 0,
          duration: 0.25,
          ease: "sine.out"
        }, 0);
      }
      if (csqIconCircleAccept.length > 0) {
        tl.fromTo(csqIconCircleAccept, {
          opacity: 0
        }, {
          opacity: 1,
          duration: 0.15,
          ease: "sine"
        }, 0).fromTo(csqIconCircleAccept, {
          outlineWidth: 1,
          scale: 0.85
        }, {
          outlineWidth: 2,
          scale: 1,
          duration: 0.25,
          ease: "sine"
        }, 0.175);
      }
      if (csqButtonContainers.length > 0) {
        tl.fromTo(csqButtonContainers, {
          scale: config3.scale,
          opacity: 0,
          filter: "blur(25px)"
        }, {
          scale: 1,
          opacity: 1,
          filter: "blur(0px)",
          stagger: config3.stagger,
          duration: config3.duration,
          ease: `${config3.ease}.inOut(${config3.easeStrength})`
        }, 0);
      }
      return tl;
    },
    defaults: {
      duration: 0.5,
      scale: 1.5,
      stagger: 0.05,
      ease: "sine",
      easeStrength: 1.5
    }
  },
  csqEnterRight: {
    effect: (csqContainer) => {
      const csqRoot = U.gsap.utils.selector(csqContainer);
      const typeLine = csqRoot(".consequence-type-container .consequence-type.accept-consequence");
      const typeLineBg = csqRoot(".consequence-type-container .consequence-type-bg.accept-consequence");
      const buttonRoot = U.gsap.utils.selector(csqRoot(".consequence-button-container.consequence-accept-button-container"));
      const buttonBg = buttonRoot(".consequence-button-bg");
      const buttonIcon = buttonRoot(".button-icon i");
      const buttonLabel = buttonRoot(".consequence-button-label");
      const tl = U.gsap.timeline({ paused: true, defaults: {} });
      if (typeLine.length > 0) {
        tl.fromTo(
          typeLine,
          {
            color: getColor("red")
          },
          {
            color: getColor("white"),
            duration: 0.5,
            ease: "sine.inOut"
          },
          0
        );
      }
      if (typeLineBg.length > 0) {
        tl.fromTo(typeLineBg, {
          x: 5,
          scaleX: 0,
          color: getColor("red"),
          skewX: 0
        }, {
          scaleX: 1,
          skewX: -45,
          color: getColor("red"),
          duration: 0.5,
          ease: "back.out"
        }, 0);
      }
      if (buttonBg.length > 0) {
        tl.fromTo(buttonBg, {
          scaleX: 0,
          color: getColor("red"),
          skewX: 0
        }, {
          x: 0,
          scaleX: 1,
          skewX: -45,
          color: getColor("red"),
          duration: 0.25,
          ease: "back.out"
        }, 0);
      }
      if (buttonIcon.length > 0) {
        tl.fromTo(
          buttonIcon,
          {
            color: getColor("grey"),
            opacity: 0.75,
            scale: 1
          },
          {
            color: getColor("black", "dark"),
            scale: 1.25,
            opacity: 1,
            duration: 0.5,
            ease: "sine"
          },
          0
        );
      }
      if (buttonLabel.length > 0) {
        tl.fromTo(
          buttonLabel,
          {
            color: getColor("grey"),
            fontWeight: 400,
            scale: 1
          },
          {
            color: getColor("black", "dark"),
            fontWeight: 800,
            duration: 0.75,
            ease: "sine"
          },
          0
        );
      }
      return tl;
    },
    defaults: {}
  },
  csqEnterLeft: {
    effect: (csqContainer) => {
      const csqRoot = U.gsap.utils.selector(csqContainer);
      const typeLine = csqRoot(".consequence-type-container .consequence-type.accept-consequence");
      const nameLine = csqRoot(".consequence-name-container .consequence-name.accept-consequence");
      const acceptIconCircle = csqRoot(".consequence-icon-circle.accept-consequence");
      const acceptButton = csqRoot(".consequence-button-container.consequence-accept-button-container");
      const tl = U.gsap.timeline({ paused: true, defaults: {} });
      if (typeLine.length > 0) {
        tl.to(
          typeLine,
          {
            opacity: 0,
            duration: 0.15,
            ease: "sine.inOut"
          },
          0
        );
      }
      if (nameLine.length > 0) {
        tl.to(nameLine, {
          opacity: 0,
          duration: 0.15,
          ease: "sine.inOut"
        }, 0);
      }
      if (acceptIconCircle.length > 0) {
        tl.to(
          acceptIconCircle,
          {
            opacity: 0,
            duration: 0.15,
            ease: "sine.inOut"
          },
          0
        );
      }
      if (acceptButton.length > 0) {
        tl.fromTo(
          acceptButton,
          {
            opacity: 1
          },
          {
            opacity: 0,
            duration: 0.25,
            ease: "sine.inOut"
          },
          0
        );
      }
      return tl;
    },
    defaults: {}
  },
  csqEnterSubLeft: {
    effect: (csqContainer, config3) => {
      const csqRoot = U.gsap.utils.selector(csqContainer);
      const iconCircle = csqRoot(`.consequence-icon-circle.${config3.type}-consequence`);
      const typeLine = csqRoot(`.consequence-type-container .consequence-type.${config3.type}-consequence`);
      const nameLine = csqRoot(`.consequence-name.${config3.type}-consequence`);
      const footerBg = csqRoot(`.consequence-footer-container .consequence-footer-bg.${config3.type}-consequence`);
      const specialFooterMsg = csqRoot(`.consequence-footer-container .consequence-footer-message.${config3.type}-consequence`);
      const tl = U.gsap.timeline({ paused: true, defaults: {} });
      if (iconCircle.length > 0) {
        tl.fromTo(iconCircle, {
          opacity: 0
        }, {
          opacity: 1,
          duration: 0.5,
          ease: "back.out"
        }, 0);
      }
      if (typeLine.length > 0) {
        tl.fromTo(typeLine, {
          opacity: 0
        }, {
          opacity: 1,
          duration: 0.5,
          ease: "back.out"
        }, 0);
      }
      if (nameLine.length > 0) {
        tl.fromTo(nameLine, {
          scaleX: 0
        }, {
          scaleX: 1,
          duration: 0.5,
          ease: "back.inOut"
        }, 0);
      }
      if (footerBg.length > 0) {
        tl.fromTo(footerBg, {
          scaleX: 0,
          skewX: 0,
          opacity: 1
        }, {
          scaleX: 1,
          skewX: -45,
          opacity: 1,
          duration: 0.5,
          ease: "back.inOut"
        }, 0);
      }
      if (specialFooterMsg.length > 0) {
        tl.fromTo(specialFooterMsg, {
          scaleX: 0,
          opacity: 1
        }, {
          scaleX: 1,
          opacity: 1,
          duration: 0.5,
          ease: "back.inOut"
        }, 0);
      }
      if (csqRoot(`.consequence-button-container.consequence-${config3.type}-button-container`).length > 0) {
        const buttonRoot = U.gsap.utils.selector(csqRoot(`.consequence-button-container.consequence-${config3.type}-button-container`));
        const buttonBg = buttonRoot(".consequence-button-bg");
        const buttonIcon = buttonRoot(".button-icon i");
        const buttonLabel = buttonRoot(".consequence-button-label");
        if (buttonBg.length > 0) {
          tl.fromTo(buttonBg, {
            scaleX: 0,
            skewX: 0,
            opacity: 1
          }, {
            scaleX: 1,
            skewX: -45,
            opacity: 1,
            duration: 0.5,
            ease: "back.inOut"
          }, 0);
        }
        if (buttonIcon.length > 0) {
          tl.fromTo(
            buttonIcon,
            {
              color: getColor("grey"),
              opacity: 0.75,
              scale: 1
            },
            {
              color: getColor("black", "dark"),
              scale: 1.25,
              opacity: 1,
              duration: 0.5,
              ease: "sine"
            },
            0
          );
        }
        if (buttonLabel.length > 0) {
          tl.fromTo(
            buttonLabel,
            {
              color: getColor("grey"),
              fontWeight: 400,
              scale: 1
            },
            {
              color: getColor("black", "dark"),
              fontWeight: 800,
              duration: 0.75,
              ease: "sine"
            },
            0
          );
        }
      }
      return tl;
    },
    defaults: {}
  },
  // #endregion
  // #region CHARACTER SHEET EFFECTS
  fillCoins: {
    effect: (targets, config3) => {
      return U.gsap.to(
        targets,
        {
          duration: config3.duration / 2,
          scale: config3.scale,
          filter: config3.filter,
          ease: config3.ease,
          stagger: {
            amount: 0.25,
            from: "start",
            repeat: 1,
            yoyo: true
          }
        }
      );
    },
    defaults: {
      duration: 1,
      scale: 1,
      filter: "saturate(1) brightness(2)",
      ease: "power2.in"
    },
    extendTimeline: true
  },
  // #endregion
  // #region GENERAL: 'blurRemove', 'hoverTooltip', 'textJitter'
  blurRemove: {
    effect: (targets, config3) => U.gsap.timeline({ stagger: config3.stagger }).to(
      targets,
      {
        skewX: config3.skewX,
        duration: config3.duration / 2,
        ease: "power4.out"
      }
    ).to(
      targets,
      {
        x: config3.x,
        marginBottom: config3.ignoreMargin ? void 0 : function(_i, target) {
          return U.get(target, "height") * -1;
        },
        marginRight: config3.ignoreMargin ? void 0 : function(_i, target) {
          return U.get(target, "width") * -1;
        },
        scale: config3.scale,
        filter: `blur(${config3.blur}px)`,
        duration: 3 / 4 * config3.duration
      },
      config3.duration / 4
    ).to(
      targets,
      {
        autoAlpha: 0,
        duration: config3.duration / 2,
        ease: "power3.in"
      },
      config3.duration / 2
    ),
    defaults: {
      ignoreMargin: false,
      skewX: -20,
      duration: 0.5,
      x: "+=300",
      scale: 1.5,
      blur: 10,
      stagger: 0
    },
    extendTimeline: true
  },
  blurReveal: {
    effect: (targets, config3) => U.gsap.timeline().fromTo(
      targets,
      {
        x: config3.x,
        marginBottom: config3.ignoreMargin ? void 0 : function(_i, target) {
          return U.get(target, "height") * -1;
        },
        marginRight: config3.ignoreMargin ? void 0 : function(_i, target) {
          return U.get(target, "width") * -1;
        },
        scale: config3.scale,
        filter: `blur(${config3.blur}px)`
      },
      {
        x: 0,
        marginBottom: 0,
        marginRight: 0,
        scale: 1,
        filter: "blur(0px)",
        duration: 3 / 4 * config3.duration
      },
      0
    ).fromTo(
      targets,
      {
        autoAlpha: 0
      },
      {
        autoAlpha: 1,
        duration: config3.duration / 2,
        ease: "power3.in"
      },
      0
    ).fromTo(
      targets,
      {
        skewX: config3.skewX
      },
      {
        skewX: 0,
        duration: config3.duration / 2,
        ease: "power4.out"
      },
      config3.duration / 2
    ),
    defaults: {
      ignoreMargin: false,
      skewX: -20,
      duration: 0.5,
      x: "+=300",
      scale: 1.5,
      blur: 10
    },
    extendTimeline: true
  },
  scaleUpReveal: {
    effect: (target, config3) => U.gsap.timeline().fromTo(target, {
      autoAlpha: 0,
      scale: 0.5 * config3.scale
    }, {
      autoAlpha: 1,
      scale: config3.scale,
      duration: config3.duration,
      ease: config3.ease
    }),
    defaults: {
      scale: 1,
      duration: 0.5,
      ease: "power2"
    },
    extendTimeline: true
  },
  scaleDownRemove: {
    effect: (target, config3) => U.gsap.timeline().to(target, {
      autoAlpha: 0,
      scale: 0.5 * config3.scale,
      duration: config3.duration,
      ease: config3.ease
    }),
    defaults: {
      scale: 1,
      duration: 0.5,
      ease: "power2"
    },
    extendTimeline: true
  },
  blurRevealTooltip: {
    effect: (target, config3) => {
      if (!target) {
        throw new Error(`blurRevealTooltip effect: tooltip element is ${target === null ? "null" : typeof target}`);
      }
      const tooltip$ = $(target);
      const tTipFrom = { autoAlpha: 0 };
      return U.gsap.timeline({
        paused: true,
        delay: 0.25,
        onInterrupt: config3.onInterrupt
      }).from(
        tooltip$,
        {
          ...tTipFrom,
          duration: config3.duration,
          ease: config3.ease
        }
      );
    },
    defaults: {
      scale: 1.25,
      blurStrength: 5,
      ease: "sine",
      duration: 0.25,
      onInterrupt: void 0,
      tooltipDirection: "top"
    },
    extendTimeline: true
  },
  textJitter: {
    effect: (target, config3) => {
      const [targetElem] = $(target);
      if (!targetElem) {
        throw new Error("textJitter effect: target not found");
      }
      const split = new SplitText(targetElem, { type: "chars" });
      return U.gsap.timeline().to(targetElem, {
        autoAlpha: 1,
        duration: config3.duration,
        ease: "none"
      }).fromTo(split.chars, {
        y: -config3.yAmp
      }, {
        y: config3.yAmp,
        duration: config3.duration,
        ease: "sine.inOut",
        stagger: {
          repeat: -1,
          yoyo: true,
          from: "random",
          each: config3.stagger
        }
      }, 0).fromTo(split.chars, {
        rotateZ: -config3.rotateAmp
      }, {
        rotateZ: config3.rotateAmp,
        duration: config3.duration,
        ease: CustomWiggle.create("myWiggle", { wiggles: 10, type: "random" }),
        stagger: {
          repeat: -1,
          from: "random",
          yoyo: true,
          each: config3.stagger
        }
      }, 0);
    },
    defaults: {
      yAmp: 2,
      rotateAmp: 2,
      duration: 1,
      stagger: 0.05
    },
    extendTimeline: true
  }
  // #endregion
};
function Initialize() {
  if (gsapPlugins.length) {
    U.gsap.config({
      nullTargetWarn: true
    });
    U.gsap.registerPlugin(...gsapPlugins);
    Object.assign(
      globalThis,
      {
        TextPlugin,
        Flip,
        MotionPathPlugin,
        Dragger: Draggable,
        // SplitText,
        Observer: Observer$1,
        CustomEase
        // CustomWiggle,
        // CustomBounce,
        // EasePack
      }
    );
  }
  Object.entries(gsapEffects).forEach(([name, effect]) => {
    U.gsap.registerEffect(Object.assign(effect, { name }));
  });
}
function ApplyTooltipAnimations(html) {
  html.find(".tooltip-trigger").each((_, el) => {
    const tooltipElem = $(el).find(".tooltip")[0] ?? $(el).next(".tooltip")[0];
    if (!tooltipElem) {
      return;
    }
    const tooltip$ = $(tooltipElem);
    const tooltipContainer$ = tooltip$.parent();
    if (tooltipContainer$.css("position") !== "relative" && tooltipContainer$.css("position") !== "absolute") {
      tooltipContainer$.css("position", "relative");
    }
    tooltip$.css("position", "absolute");
    const tooltipID = `tooltip-${randomID()}`;
    tooltip$.attr("id", tooltipID);
    if (tooltip$.hasClass("tooltip-wide")) {
      U.adjustTextContainerAspectRatio(tooltipElem, 6);
    }
    $(el).on({
      mouseenter() {
        game.eunoblades.Director.displayTooltip(tooltipElem);
      },
      mouseleave() {
        game.eunoblades.Director.clearTooltip(tooltipID, true);
      }
    });
  });
}
const G = U.gsap;
const _BladesTargetLink = class _BladesTargetLink {
  constructor(dataOrConfig, parentLinkData) {
    __privateAdd(this, _updateTargetViaMerge);
    __privateAdd(this, _updateTargetPropVal);
    __publicField(this, "_id");
    __publicField(this, "_targetID");
    __publicField(this, "_targetKey");
    __publicField(this, "_targetFlagKey");
    __publicField(this, "_isScopingById", true);
    __publicField(this, "_initialSchema");
    __publicField(this, "_target");
    __publicField(this, "initPromise");
    __publicField(this, "isInitPromiseResolved", false);
    var _a2;
    let linkData;
    let schema;
    const subclassConstructor = this.constructor;
    if (subclassConstructor.IsValidData(dataOrConfig)) {
      ({ linkData } = subclassConstructor.PartitionSchemaData(dataOrConfig));
      const target2 = fromUuidSync(linkData.targetID);
      if (!target2) {
        throw new Error(`[new BladesTargetLink()] Unable to resolve target from uuid '${linkData.targetID}'`);
      }
      if ("targetKey" in linkData) {
        schema = getProperty(target2, `${linkData.targetKey}.${linkData.id}`);
      } else {
        schema = target2.getFlag(C.SYSTEM_ID, `${linkData.targetFlagKey}.${linkData.id}`);
      }
      this.isInitPromiseResolved = true;
    } else {
      const parsedData = __privateMethod(_a2 = _BladesTargetLink, _ParseConfigToData, ParseConfigToData_fn).call(_a2, dataOrConfig, parentLinkData);
      let partialSchema;
      ({ linkData, partialSchema } = subclassConstructor.PartitionSchemaData(parsedData));
      schema = subclassConstructor._ApplySchemaDefaults(partialSchema);
    }
    this._id = linkData.id;
    this._targetID = linkData.targetID;
    if ("targetKey" in linkData) {
      this._targetKey = linkData.targetKey;
    } else {
      this._targetFlagKey = linkData.targetFlagKey;
    }
    const target = fromUuidSync(this.targetID);
    if (!target) {
      throw new Error(`[new BladesTargetLink()] Unable to resolve target from uuid '${this._targetID}'`);
    }
    this._target = target;
    this._initialSchema = schema;
  }
  // #region STATIC METHODS ~
  static get ValidTargetClasses() {
    return [
      BladesActor$1,
      BladesItem$1,
      BladesChat$1,
      User
    ];
  }
  static IsValidConfig(ref) {
    return U.isSimpleObj(ref) && (U.isDocID(ref.target) || U.isDocUUID(ref.target) || U.isDocID(ref.targetID) || U.isDocUUID(ref.targetID) || this.ValidTargetClasses.some((cls) => ref.target instanceof cls)) && (U.isTargetKey(ref.targetKey) || U.isTargetFlagKey(ref.targetFlagKey)) && !(U.isTargetKey(ref.targetKey) && U.isTargetFlagKey(ref.targetFlagKey));
  }
  static IsValidData(ref) {
    return U.isSimpleObj(ref) && U.isDocID(ref.id) && U.isDocUUID(ref.targetID) && (U.isTargetKey(ref.targetKey) || U.isTargetFlagKey(ref.targetFlagKey)) && !(U.isTargetKey(ref.targetKey) && U.isTargetFlagKey(ref.targetFlagKey));
  }
  static BuildLinkConfig(partialConfig) {
    if ("target" in partialConfig) {
      if ("targetKey" in partialConfig) {
        return {
          target: partialConfig.target,
          targetKey: partialConfig.targetKey,
          isScopingById: partialConfig.isScopingById
        };
      } else if ("targetFlagKey" in partialConfig) {
        return {
          target: partialConfig.target,
          targetFlagKey: partialConfig.targetFlagKey,
          isScopingById: partialConfig.isScopingById
        };
      }
      throw new Error("[BladesTargetLink.BuildConfig] Must provide a targetKey or targetFlagKey.");
    } else if ("targetID" in partialConfig) {
      if ("targetKey" in partialConfig) {
        return {
          targetID: partialConfig.targetID,
          targetKey: partialConfig.targetKey,
          isScopingById: partialConfig.isScopingById
        };
      } else if ("targetFlagKey" in partialConfig) {
        return {
          targetID: partialConfig.targetID,
          targetFlagKey: partialConfig.targetFlagKey,
          isScopingById: partialConfig.isScopingById
        };
      }
      throw new Error("[BladesTargetLink.BuildConfig] Must provide a targetKey or targetFlagKey.");
    }
    throw new Error("[BladesTargetLink.BuildConfig] Must provide a target or targetID.");
  }
  /**
   * This static method parses the provided data into a format suitable for BladesTargetLink.
   * Subclasses can override this method to include their own parse logic.
   * If the provided data is already valid, it is returned as is.
   * Otherwise, the data is passed to the private #ParseConfig method for further processing.
   * Note: The 'id' property is defined at the return step, within #ParseConfig: Subclass
   * functionality that depends on the id property should be placed after the super call to this method.
   *
   * @template Schema - The data schema required by the subclass.
   * @param {(BladesTargetLink.Config | BladesTargetLink.Data) & Partial<Schema>} data - The data to be parsed.
   * @returns {BladesTargetLink.Data & Partial<Schema>} - The parsed data, suitable for BladesTargetLink.
   */
  static ParseConfigToData(data, parentLinkData) {
    if (this.IsValidData(data)) {
      return __privateMethod(this, _ParseChildLinkData, ParseChildLinkData_fn).call(this, data, parentLinkData);
    }
    return __privateMethod(this, _ParseConfigToData, ParseConfigToData_fn).call(this, data, parentLinkData);
  }
  static PartitionSchemaData(dataOrConfig) {
    const {
      id,
      target,
      targetID,
      targetKey,
      targetFlagKey,
      isScopingById,
      ...schemaData
    } = dataOrConfig;
    const partialSchema = schemaData;
    if (U.isDocID(id)) {
      if (!this.IsValidData({ id, targetID, targetKey, targetFlagKey, isScopingById })) {
        eLog.error("BladesTargetLink", "Bad Constructor DATA", { dataOrConfig });
        throw new Error("[new BladesTargetLink()] Bad Constructor DATA (see log)");
      }
      let linkData;
      if (targetKey) {
        linkData = { id, targetID, targetKey, isScopingById: isScopingById ?? true };
      } else if (targetFlagKey) {
        linkData = { id, targetID, targetFlagKey, isScopingById: isScopingById ?? true };
      } else {
        eLog.error("BladesTargetLink", "Bad Constructor DATA", { dataOrConfig });
        throw new Error("[BladesTargetLink.PartitionSchemaData] Bad Constructor DATA (see log)");
      }
      return {
        linkData,
        partialSchema
      };
    }
    return {
      linkConfig: this.BuildLinkConfig({
        ...{ isScopingById: isScopingById ?? true },
        ..."targetID" in dataOrConfig ? { targetID: dataOrConfig.targetID } : { target: dataOrConfig.target },
        ..."targetKey" in dataOrConfig ? { targetKey: dataOrConfig.targetKey } : { targetFlagKey: dataOrConfig.targetFlagKey }
      }),
      partialSchema
    };
  }
  static _ApplySchemaDefaults(schemaData) {
    return this.ApplySchemaDefaults(schemaData);
  }
  /**
  * This static method applies defaults to any values missing from the class' data Schema.
  * 'Schema' is defined by subclasses to BladesTargetLink.
  * Subclasses must override this method to apply their own defaults.
  *
  * @template Schema - The data schema required by the subclass.
  * @param {Partial<Schema>} schemaData - Schema data overriding the defaults.
  * @returns {Schema} - The schema data with defaults applied.
  * @throws {Error} - Throws an error if this method is not overridden in a subclass.
  */
  static ApplySchemaDefaults(schemaData) {
    throw new Error("[BladesTargetLink.ApplySchemaDefaults] Static Method ApplySchemaDefaults must be overridden in subclass");
  }
  /**
   * Creates a new instance of BladesTargetLink and initializes it with the provided configuration.
   * The configuration is parsed into a data object which is then used to initialize the target link.
   * The function logs the parsed data for debugging purposes.
   *
   * @template Schema - The schema type parameter that extends the data structure.
   * @param {BladesTargetLink.Config & Partial<Schema>} config - The configuration object containing both the target link configuration and the schema configuration.
   *
   * @returns {Promise<BladesTargetLink<Schema> & BladesTargetLink.Subclass<Schema>>} - A promise that resolves to a new instance of BladesTargetLink, initialized with the provided data.
   *
   * @throws {Error} - Throws an error if the initialization of the target link fails.
   */
  static async Create(config3, parentLinkData) {
    const tLink = new this(config3, parentLinkData);
    await tLink.initTargetLink();
    return tLink;
  }
  // #endregion
  // #region GETTERS ~
  get isGM() {
    return game.user.isGM;
  }
  get id() {
    return this._id;
  }
  get targetID() {
    return this._targetID;
  }
  get targetKey() {
    return this._targetKey;
  }
  get targetFlagKey() {
    return this._targetFlagKey;
  }
  get isScopingById() {
    return this._isScopingById;
  }
  get initialSchema() {
    return this._initialSchema;
  }
  get targetKeyPrefix() {
    if (!this.targetKey) {
      return void 0;
    }
    if (!this.isScopingById) {
      return this.targetKey;
    }
    return this.targetKey ? `${this.targetKey}.${this.id}` : void 0;
  }
  get targetKeyNullPrefix() {
    if (!this.targetKey) {
      return void 0;
    }
    if (this.isScopingById) {
      return `${this.targetKey}.-=${this.id}`;
    }
    if (/^.+\..+$/g.test(this.targetKey)) {
      return this.targetKey.replace(/\.([^.]+)$/, ".-=$1");
    }
    throw new Error(`[BladesTargetLink.targetKeyNullPrefix] Can't Nullify TargetKey '${this.targetKey}'`);
  }
  get targetFlagKeyPrefix() {
    if (!this.targetFlagKey) {
      return void 0;
    }
    if (!this.isScopingById) {
      return this.targetFlagKey;
    }
    return this.targetFlagKey ? `${this.targetFlagKey}.${this.id}` : void 0;
  }
  get isLinkInitialized() {
    return this.isInitPromiseResolved;
  }
  get linkData() {
    if (this.targetKey) {
      return {
        id: this.id,
        targetID: this.targetID,
        targetKey: this.targetKey,
        isScopingById: this.isScopingById
      };
    }
    if (this.targetFlagKey) {
      return {
        id: this.id,
        targetID: this.targetID,
        targetFlagKey: this.targetFlagKey,
        isScopingById: this.isScopingById
      };
    }
    throw new Error(`[BladesTargetLink.linkData] Missing targetKey and targetFlagKey for '${this.id}'`);
  }
  get target() {
    return this._target;
  }
  get localData() {
    return {
      ...this.initialSchema,
      ...this.linkData
    };
  }
  get data() {
    if (this.isLinkInitialized) {
      let data;
      if (this.targetFlagKeyPrefix) {
        data = this.target.getFlag(C.SYSTEM_ID, this.targetFlagKeyPrefix);
      } else if (this.targetKeyPrefix) {
        data = getProperty(this.target, this.targetKeyPrefix);
      }
      if (!data) {
        throw new Error("[BladesTargetLink.data] Error retrieving data.");
      }
      return data;
    } else {
      eLog.warn("BladesTargetLink", "Attempt to access data of uninitiated BladesTargetLink: Returning local data only.", { bladesTargetLink: this, localData: this.localData });
      return this.localData;
    }
  }
  // #endregion
  // #region ASYNC UPDATE & DELETE METHODS ~
  getDotKeyToProp(prop, isNullifying = false) {
    if (this.targetKeyPrefix) {
      if (prop === void 0) {
        return isNullifying ? this.targetKeyNullPrefix : this.targetKeyPrefix;
      }
      return `${this.targetKeyPrefix}.${isNullifying ? "-=" : ""}${prop}`;
    }
    if (this.targetFlagKeyPrefix) {
      if (prop === void 0) {
        return this.targetFlagKeyPrefix;
      }
      return `${this.targetFlagKeyPrefix}.${prop}`;
    }
    throw new Error("[BladesTargetLink.getDotKeyToProp()] Missing 'targetKeyPrefix' and 'targetFlagKeyPrefix'");
  }
  getFlagParamsToProp(prop) {
    return [C.SYSTEM_ID, this.getDotKeyToProp(prop)];
  }
  async updateTargetFlag(prop, val) {
    if (!this.targetFlagKeyPrefix) {
      return;
    }
    if (val === null) {
      await this.target.unsetFlag(...this.getFlagParamsToProp(prop));
    } else if (this.target instanceof BladesActor$1) {
      await this.target.setFlag(...this.getFlagParamsToProp(prop), val);
    } else if (this.target instanceof BladesItem$1) {
      await this.target.setFlag(...this.getFlagParamsToProp(prop), val);
    } else if (this.target instanceof User) {
      await this.target.setFlag(...this.getFlagParamsToProp(prop), val);
    } else if (this.target instanceof BladesChat$1) {
      await this.target.setFlag(...this.getFlagParamsToProp(prop), val);
    }
  }
  async updateTargetKey(prop, val) {
    if (!this.targetKeyPrefix) {
      return;
    }
    await this.target.update({ [this.getDotKeyToProp(prop, val === null)]: val }, { render: false });
  }
  /**
   * Initializes a target link by updating the target's data with the provided data object.
   * If a targetKey is provided, the data is updated directly on the target.
   * If a targetFlagKey is provided, the data is set as a flag on the target.
   *
   * This method need only be run once, when the document is first created and its data must be written to server storage.
   * External functions can synchronously check the status of initialization via the isInitPromiseResolved property, while
   * asynchronous functions can await the initPromise property.
   *
   * TargetLink documents whose data already exists in server storage can be constructed directly (i.e. new BladesTargetLink(data))
   * without needing to call this method.
   *
   * @param {BladesTargetLink.Data & Schema} data - The combined data object containing both the target link data and the schema data.
   * @returns {Promise<void>} - A promise that resolves when the server update is complete.
   */
  async initTargetLink() {
    this.isInitPromiseResolved = false;
    const data = {
      ...this.linkData,
      ...this.initialSchema
    };
    this.initPromise = new Promise((resolve, reject) => {
      if (this.targetKeyPrefix) {
        const updateData = mergeObject(
          getProperty(this.target, this.targetKeyPrefix) ?? {},
          data
        );
        this.target.update({ [this.targetKeyPrefix]: updateData }, { render: false }).then(() => {
          this.isInitPromiseResolved = true;
          resolve();
        }).catch(reject);
      } else if (this.targetFlagKeyPrefix) {
        const updateData = mergeObject(
          this.target.getFlag(C.SYSTEM_ID, this.targetFlagKeyPrefix) ?? {},
          data
        );
        this.target.setFlag(C.SYSTEM_ID, this.targetFlagKeyPrefix, updateData).then(() => {
          this.isInitPromiseResolved = true;
          resolve();
        }).catch(reject);
      } else {
        reject();
      }
    });
    return this.initPromise;
  }
  async updateTarget(propOrData, valOrWaitFor, waitFor2) {
    if (typeof propOrData === "string") {
      if (getProperty(this.data, propOrData) === valOrWaitFor) {
        return;
      }
      return __privateMethod(this, _updateTargetPropVal, updateTargetPropVal_fn).call(this, propOrData, valOrWaitFor, waitFor2);
    }
    if (typeof propOrData === "object") {
      return __privateMethod(this, _updateTargetViaMerge, updateTargetViaMerge_fn).call(this, propOrData, valOrWaitFor);
    } else {
      throw new Error(`[BladesTargetLink.updateTarget()] Bad updateData for id '${this.id}': ${propOrData}`);
    }
  }
  async updateTargetData(val, waitFor2) {
    if (val) {
      val = {
        ...val,
        ...this.linkData
      };
    }
    await U.waitFor([this.initPromise, waitFor2]);
    if (this.targetFlagKeyPrefix) {
      await this.updateTargetFlag(void 0, val);
    } else {
      await this.updateTargetKey(void 0, val);
    }
  }
  async delete(collection, waitFor2) {
    if (collection) {
      collection.delete(this.id);
    }
    await U.waitFor([this.initPromise, waitFor2]);
    await this.updateTargetData(null);
  }
  // #endregion
};
_ParseChildLinkData = new WeakSet();
ParseChildLinkData_fn = function(childData, parentLinkData) {
  if (!parentLinkData) {
    return childData;
  }
  const keyPrefixParts = "targetKey" in parentLinkData ? [parentLinkData.targetKey] : [parentLinkData.targetFlagKey];
  if (parentLinkData.isScopingById) {
    keyPrefixParts.push(parentLinkData.id);
  }
  const keyPrefix = keyPrefixParts.join(".");
  if ("targetKey" in childData && "targetKey" in parentLinkData) {
    if (childData.targetKey.startsWith(`${keyPrefix}.`)) {
      childData.targetKey = childData.targetKey.slice(keyPrefix.length + 1);
    }
    childData.targetKey = [
      parentLinkData.targetKey,
      parentLinkData.isScopingById ? parentLinkData.id : void 0,
      childData.targetKey
    ].filter(Boolean).join(".");
  } else if ("targetFlagKey" in childData && "targetFlagKey" in parentLinkData) {
    if (childData.targetFlagKey.startsWith(`${keyPrefix}.`)) {
      childData.targetFlagKey = childData.targetFlagKey.slice(keyPrefix.length + 1);
    }
    childData.targetFlagKey = [
      parentLinkData.targetFlagKey,
      parentLinkData.isScopingById ? parentLinkData.id : void 0,
      childData.targetFlagKey
    ].filter(Boolean).join(".");
  } else {
    throw new Error("[BladesTargetLink.ParseChildLinkData] targetKey/targetFlagKey mismatch between provided partialConfig and parentLinkData.");
  }
  return childData;
};
_ParseConfigToData = new WeakSet();
ParseConfigToData_fn = function(config3, parentLinkData) {
  if (this.IsValidData(config3)) {
    return this.ParseConfigToData(config3, parentLinkData);
  }
  const { linkConfig, partialSchema } = this.PartitionSchemaData(config3);
  const fullConfig = this.BuildLinkConfig(linkConfig);
  if ("targetKey" in fullConfig) {
    return this.ParseConfigToData({
      id: randomID(),
      ...partialSchema,
      targetID: U.parseDocRefToUUID("target" in fullConfig ? fullConfig.target : fullConfig.targetID),
      targetKey: fullConfig.targetKey
    }, parentLinkData);
  }
  return this.ParseConfigToData({
    id: randomID(),
    ...partialSchema,
    targetID: U.parseDocRefToUUID("target" in fullConfig ? fullConfig.target : fullConfig.targetID),
    targetFlagKey: fullConfig.targetFlagKey
  }, parentLinkData);
};
_updateTargetViaMerge = new WeakSet();
updateTargetViaMerge_fn = async function(updateData, waitFor2) {
  await U.waitFor(waitFor2);
  if (this.targetKeyPrefix) {
    updateData = U.objMap(updateData, false, (key) => `${this.targetKeyPrefix || this.targetFlagKeyPrefix}.${String(key)}`);
    return this.target.update(updateData, { render: false });
  } else if (this.targetFlagKeyPrefix) {
    const existingFlagData = this.target.getFlag(C.SYSTEM_ID, this.targetFlagKeyPrefix) ?? {};
    const flattenedFlagData = flattenObject(existingFlagData);
    const mergedFlagData = mergeObject(flattenedFlagData, updateData);
    return this.target.setFlag(C.SYSTEM_ID, this.targetFlagKeyPrefix, mergedFlagData);
  } else {
    throw new Error(`[BladesTargetLink.#updateTargetViaMerge] Unable to update target data for BladesTargetLink id '${this.id}': Missing both 'targetKeyPrefix' and 'targetFlagKeyPrefix'`);
  }
};
_updateTargetPropVal = new WeakSet();
updateTargetPropVal_fn = async function(prop, val, waitFor2) {
  await U.waitFor(waitFor2);
  if (this.targetKeyPrefix) {
    return this.target.update({ [`${this.targetKeyPrefix}.${prop}`]: val });
  } else if (this.targetFlagKeyPrefix) {
    return this.updateTargetFlag(prop, val);
  }
};
__privateAdd(_BladesTargetLink, _ParseChildLinkData);
/**
 * This private static method is used to transform a configuration object into a data object for BladesTargetLink.
 * It checks if the provided configuration object is already valid data, and if so, returns it directly.
 * Otherwise, it partitions the configuration object into link-specific configuration and additional schema data,
 * constructs a full link configuration, and then creates a data object with a new random ID and the target UUID.
 * The method ensures that either 'targetKey' or 'targetFlagKey' is present and throws an error if the configuration is invalid.
 *
 * @template Schema - The additional schema data required by the subclass.
 * @param {BladesTargetLink.Config | BladesTargetLink.Data & Partial<Schema>} config - The configuration object that may contain BladesTargetLink properties and any subclass-specific schema data.
 * @returns {BladesTargetLink.Data & Partial<Schema>} - The fully constructed data object with necessary properties for BladesTargetLink.
 * @throws {Error} - Throws an error if the configuration object is invalid, lacks a target reference, or if both 'targetKey' and 'targetFlagKey' are provided.
 */
__privateAdd(_BladesTargetLink, _ParseConfigToData);
let BladesTargetLink = _BladesTargetLink;
function isElemPosData(obj) {
  return U.isList(obj) && typeof obj.x === "number" && typeof obj.y === "number" && typeof obj.width === "number" && typeof obj.height === "number";
}
class BladesClockKey extends BladesTargetLink {
  constructor(dataOrConfig) {
    super(dataOrConfig);
    __publicField(this, "positionDragger");
    game.eunoblades.ClockKeys.set(this.id, this);
    Object.values(dataOrConfig.clocksData ?? {}).forEach((clockData) => new BladesClock(clockData));
  }
  // #region STATIC METHODS ~
  static Initialize() {
    function registerClockKeys(doc) {
      if ("clocksData" in doc.system) {
        Object.values(doc.system.clocksData ?? {}).forEach((keyData) => {
          try {
            new BladesClockKey(keyData);
          } catch (err) {
            eLog.error("BladesClockKey", "[BladesClockKey.Initialize] Error initializing clock key.", err, keyData);
          }
        });
      }
    }
    game.items.contents.filter(
      (item) => BladesItem$1.IsType(
        item,
        BladesItemType.clock_keeper,
        BladesItemType.project,
        BladesItemType.cohort_gang,
        BladesItemType.cohort_expert,
        BladesItemType.ritual,
        BladesItemType.design,
        BladesItemType.location,
        BladesItemType.score
      )
    ).forEach(registerClockKeys);
    game.actors.contents.filter(
      (actor) => BladesActor$1.IsType(
        actor,
        BladesActorType.pc,
        BladesActorType.faction
      )
    ).forEach(registerClockKeys);
    return loadTemplates([
      "systems/eunos-blades/templates/components/clock-key.hbs",
      "systems/eunos-blades/templates/components/clock.hbs"
    ]);
  }
  static ApplySchemaDefaults(schemaData) {
    return {
      name: "",
      isVisible: false,
      isNameVisible: false,
      isSpotlit: false,
      clocksData: {},
      sceneIDs: [],
      displayMode: ClockKeyDisplayMode.full,
      oneKeyIndex: U.gsap.utils.random(0, 4, 1),
      ...schemaData
    };
  }
  static async Create(config3, _parentLinkData, clocksInitialData = []) {
    if (clocksInitialData.length > 6) {
      eLog.error("BladesClockKey", "[BladesClockKey.Create] Too many clock configs! (Max 6.) Eliminating extras.", clocksInitialData);
      clocksInitialData = clocksInitialData.slice(0, 6);
    } else if (clocksInitialData.length === 0) {
      clocksInitialData.push({});
    }
    const tempLink = new BladesTargetLink(config3);
    if (tempLink.targetKeyPrefix) {
      config3.clocksData = Object.fromEntries(
        clocksInitialData.map((cSchema, i) => {
          const cData = BladesClock.ParseConfigToData({
            ...BladesClock.ApplySchemaDefaults(cSchema),
            index: i,
            targetID: tempLink.targetID,
            targetKey: `${tempLink.targetKeyPrefix}.clocksData`,
            isScopingById: true
          });
          return [
            cData.id,
            cData
          ];
        })
      );
    } else if (tempLink.targetFlagKeyPrefix) {
      config3.clocksData = Object.fromEntries(
        clocksInitialData.map((cSchema, i) => {
          const cData = BladesClock.ParseConfigToData({
            ...BladesClock.ApplySchemaDefaults(cSchema),
            targetID: tempLink.targetID,
            targetFlagKey: `${tempLink.targetFlagKeyPrefix}.clocksData`,
            isScopingById: true
          });
          return [
            cData.id,
            cData
          ];
        })
      );
    } else {
      throw new Error("BladesClockKey.Create: No targetKey or targetFlagKey provided.");
    }
    const clockKeyLink = await super.Create(tempLink.data);
    const clockKey = new BladesClockKey(clockKeyLink.data);
    clockKey.renderTargetAndKeeper();
    return clockKey;
  }
  static GetFromElement(elem) {
    const keyElem$ = $(elem).closest(".clock-key-container").find(".clock-key");
    if (keyElem$.length === 0) {
      return void 0;
    }
    const clockKeyID = keyElem$.attr("id");
    if (!clockKeyID) {
      return void 0;
    }
    return game.eunoblades.ClockKeys.get(clockKeyID);
  }
  // #endregion
  // #region GETTERS & SETTERS ~
  // #region -- Shortcut Schema Getters ~
  get data() {
    return this.linkData;
  }
  get name() {
    return this.data.name;
  }
  set name(val) {
    this.updateTarget("name", val).then(() => {
      this.renderTargetAndKeeper();
    });
  }
  get isVisible() {
    return this.data.isVisible;
  }
  set isVisible(val) {
    this.updateTarget("isVisible", U.pBool(val)).then(() => {
      this.renderTargetAndKeeper();
    });
  }
  get isNameVisible() {
    return this.data.isNameVisible;
  }
  set isNameVisible(val) {
    this.updateTarget("isNameVisible", U.pBool(val)).then(() => {
      this.renderTargetAndKeeper();
    });
  }
  get isSpotlit() {
    return this.data.isSpotlit;
  }
  set isSpotlit(val) {
    this.updateTarget("isSpotlit", val).then(() => {
      this.renderTargetAndKeeper();
    });
  }
  get clocksData() {
    return this.data.clocksData;
  }
  get displayMode() {
    return this.data.displayMode;
  }
  get oneKeyIndex() {
    let { oneKeyIndex } = this.data;
    if (!oneKeyIndex) {
      oneKeyIndex = U.gsap.utils.random(0, 4, 1);
      this.updateTarget("oneKeyIndex", oneKeyIndex).then(() => {
        this.renderTargetAndKeeper();
      });
    }
    return oneKeyIndex;
  }
  get sceneIDs() {
    return this.data.sceneIDs ?? [];
  }
  get overlayPosition() {
    var _a2;
    return (_a2 = this.data.overlayPosition) == null ? void 0 : _a2[game.scenes.current.id];
  }
  set overlayPosition(val) {
    if (val) {
      this.updateTarget(`overlayPosition.${game.scenes.current.id}`, val).then(() => {
        this.renderTargetAndKeeper();
      });
    } else {
      this.updateTarget(`overlayPosition.-=${game.scenes.current.id}`, null).then(() => {
        this.renderTargetAndKeeper();
      });
    }
  }
  // #endregion
  get clocks() {
    return new Collection(
      Object.entries(this.clocksData).sort((a, b) => a[1].index - b[1].index).map(([id, data]) => {
        return [id, new BladesClock(data)];
      })
    );
  }
  getClockByID(clockID) {
    return this.clocks.get(clockID);
  }
  getClockByIndex(index) {
    return this.clocks.find((clock) => clock.index === index);
  }
  get size() {
    return this.clocks.size;
  }
  get isComplete() {
    return Array.from(this.clocks).every((clock) => clock.isComplete);
  }
  get isClockKeeperKey() {
    return this.target instanceof BladesClockKeeper$1;
  }
  get isFactionKey() {
    return this.target instanceof BladesFaction$1;
  }
  get isProjectKey() {
    return this.target instanceof BladesProject$1;
  }
  get isScoreKey() {
    return this.target instanceof BladesScore$1;
  }
  get visibleClocks() {
    return this.clocks.filter((clock) => clock.isVisible);
  }
  get activeClocks() {
    return this.visibleClocks.filter((clock) => clock.isActive);
  }
  get inProgressClocks() {
    return this.visibleClocks.filter((clock) => !clock.isComplete && clock.value > 0);
  }
  get unstartedClocks() {
    return this.visibleClocks.filter((clock) => clock.value === 0);
  }
  get completedClocks() {
    return this.visibleClocks.filter((clock) => clock.isComplete);
  }
  get currentClock() {
    if (this.activeClocks.length > 0) {
      return this.getEarliestClock(this.activeClocks);
    }
    if (this.completedClocks.length > 0) {
      return this.getLatestClock(this.completedClocks);
    }
    if (this.visibleClocks.length > 0) {
      return this.getEarliestClock(this.visibleClocks);
    }
    return this.getEarliestClock(Array.from(this.clocks));
  }
  get fullDisplayPosData() {
    const x = this.svgData.width / 2;
    const y = this.svgData.height / 2;
    return {
      x,
      y,
      width: this.svgData.width,
      height: this.svgData.height
    };
  }
  get clocksDisplayPosData() {
    return this.getClocksBoundingBox(Array.from(this.clocks));
  }
  get visibleClocksDisplayPosData() {
    return this.getClocksBoundingBox(this.visibleClocks);
  }
  get activeClocksDisplayPosData() {
    return this.getClocksBoundingBox(this.activeClocks);
  }
  getClocksBoundingBox(clocks) {
    const { size, ...allClocksPosData } = this.svgData.clocks;
    const clocksPosData = Object.fromEntries(
      Object.entries(allClocksPosData).filter(([index]) => clocks.map((clock) => clock.index).includes(U.pInt(index))).map(([index, posData]) => [U.pInt(index), posData])
    );
    const clockWidthPosData = Object.values(clocksPosData).sort((a, b) => a.x - b.x);
    const clockHeightPosData = Object.values(clocksPosData).sort((a, b) => a.y - b.y);
    const xLowest = clockWidthPosData[0].x;
    const xHighest = clockWidthPosData[clockWidthPosData.length - 1].x;
    const yLowest = clockHeightPosData[0].y;
    const yHighest = clockHeightPosData[clockHeightPosData.length - 1].y;
    return {
      // Determine the center point in both x and y axes
      x: (xLowest + xHighest) / 2,
      y: (yLowest + yHighest) / 2,
      // Determine height and width of bounding box, accounting for clock size
      width: xHighest - xLowest + size,
      height: yHighest - yLowest + size
    };
  }
  /** This function accepts any number of arrays of BladesClock, then returns an array
   * containing those BladesClock instances that appear in ALL provided arrays.
   */
  getClocksIn(...clockArrays) {
    if (clockArrays.length === 0)
      return [];
    return clockArrays.reduce((acc, currentArray) => {
      return acc.filter((clock) => currentArray.includes(clock));
    });
  }
  /** This function accepts an array of BladesClock, and returns the BladesClock
   * instance with the lowest index property.
   */
  getEarliestClock(clockArray) {
    if (clockArray.length) {
      return clockArray.sort((a, b) => a.index - b.index)[0];
    }
    return void 0;
  }
  /** This function accepts an array of BladesClock, and returns the BladesClock
   * instance with the highest index property.
   */
  getLatestClock(clockArray) {
    if (clockArray.length) {
      return clockArray.sort((a, b) => b.index - a.index)[0];
    }
    return void 0;
  }
  isInScene(sceneID = game.scenes.current.id) {
    return this.sceneIDs.includes(sceneID);
  }
  get isInCurrentScene() {
    return this.isInScene(game.scenes.current.id);
  }
  get displaySelectOptions() {
    const options = [
      { value: ClockKeyDisplayMode.full, display: "Full Key" },
      { value: ClockKeyDisplayMode.clocks, display: "Clocks" },
      { value: ClockKeyDisplayMode.activeClocks, display: "Active Clocks" }
    ];
    for (let i = 0; i < this.size; i++) {
      options.push(...[
        { value: i, display: `Clock #${i}` },
        { value: `present${i}`, display: `Present Clock #${i}` }
      ]);
    }
    return options;
  }
  // parseClockConfig(config: BladesClock.Config, indexOverride?: ClockIndex): BladesClock.Data {
  //   if (this.size === 6) {throw new Error("Cannot add a clock to a clock key with 6 clocks.");}
  //   if (indexOverride !== undefined && indexOverride < 0) {throw new Error("Cannot add a clock with a negative index.");}
  //   // Remove target so it doesn't conflict with key's targetID
  //   // delete config.target;
  //   const {target, targetID, targetKey, targetFlagKey, ...partialSchema} = config;
  //   const linkData: BladesTargetLink.LinkData = this.targetKey
  //     ? {
  //       targetID: this.targetID,
  //       targetKey: `${this.targetKeyPrefix}.clocksData` as TargetKey
  //     }
  //     : {
  //       targetID: this.targetID,
  //       targetFlagKey: `${this.targetFlagKeyPrefix}.clocksData` as TargetFlagKey
  //     };
  //   // Derive clock's targetID and targetKey/targetFlagKey from key's values
  //   data.targetID = this.targetID;
  //   if (this.targetKey) {
  //     data.targetKey = `${this.targetKeyPrefix}.clocksData` as TargetKey;
  //   } else if (this.targetFlagKey) {
  //     data.targetFlagKey = `${this.targetFlagKeyPrefix}.clocksData` as TargetFlagKey;
  //   }
  //   // Assign 'parentKeyID' and 'index'
  //   config.parentKeyID = this.id;
  //   config.index = indexOverride ?? this.size;
  //   // Parse config to full data object
  //   return BladesClock.ApplySchemaDefaults(
  //     BladesClock.ParseConfigToData(config as BladesClock.Config)
  //   );
  // }
  // #endregion
  // #region HTML INTERACTION ~
  // #region Get Elements$ ~
  getElemFromDisplayContext(displayContext) {
    let elem$;
    const DOM$ = $(".vtt.game.system-eunos-blades");
    switch (displayContext) {
      case ClockDisplayContext.overlay: {
        elem$ = DOM$.find(`#blades-overlay #${this.id}`);
        break;
      }
      case ClockDisplayContext.pcSheet: {
        elem$ = DOM$.find(`.actor.sheet .pc #${this.id}`);
        break;
      }
      case ClockDisplayContext.factionSheet: {
        elem$ = DOM$.find(`.actor.sheet .faction #${this.id}`);
        break;
      }
      case ClockDisplayContext.projectSheet: {
        elem$ = DOM$.find(`.item.sheet .project #${this.id}`);
        break;
      }
      case ClockDisplayContext.scoreSheet: {
        elem$ = DOM$.find(`.item.sheet .score #${this.id}`);
        break;
      }
      case ClockDisplayContext.rollCollab: {
        elem$ = DOM$.find(`.roll-collab-sheet #${this.id}`);
        break;
      }
      case ClockDisplayContext.chatMessage: {
        elem$ = DOM$.find(`#chat #${this.id}`);
        break;
      }
    }
    if (!elem$.length) {
      throw new Error(`[BladesClockKey.getElemFromDisplayContext] Error elem$ not found for key '${this.id}' for display context '${displayContext}'.`);
    }
    return elem$;
  }
  getElements$(displayContext) {
    let elem$;
    if (typeof displayContext === "string") {
      displayContext = this.getElemFromDisplayContext(displayContext);
    }
    elem$ = $(displayContext).find(`#${this.id}`);
    if (!elem$.length) {
      elem$ = $(displayContext).closest(`#${this.id}`);
    }
    if (!(elem$ == null ? void 0 : elem$.length)) {
      throw new Error(`[BladesClockKey.getElements$] Cannot find elements for display context '${displayContext}' of clockKey '${this.id}'.`);
    }
    const keyElems$ = {
      elem$
    };
    if (!elem$.length) {
      throw new Error(`[BladesClockKey.renderClockKey] Error '.clock-key-container' not found for key '${this.id}'.`);
    }
    keyElems$.container$ = elem$.closest(".clock-key-container");
    const imgContainer$ = elem$.find(".key-image-container");
    if (!imgContainer$.length) {
      throw new Error(`[BladesClockKey.renderClockKey] Error '.key-image-container' not found for key '${this.id}'.`);
    }
    keyElems$.imgContainer$ = imgContainer$;
    const label$ = elem$.find(".key-label");
    if (!label$.length) {
      throw new Error(`[BladesClockKey.renderClockKey] Error label$ not found for key '${this.id}'.`);
    }
    keyElems$.label$ = label$;
    const factionLabel$ = elem$.find(".faction-label");
    if (factionLabel$.length) {
      keyElems$.factionLabel$ = factionLabel$;
    }
    const projectLabel$ = elem$.find(".project-label");
    if (projectLabel$.length) {
      keyElems$.projectLabel$ = projectLabel$;
    }
    const scoreLabel$ = elem$.find(".score-label");
    if (scoreLabel$.length) {
      keyElems$.scoreLabel$ = scoreLabel$;
    }
    this.clocks.forEach((clock) => {
      keyElems$.clocks ?? (keyElems$.clocks = {});
      keyElems$.clocks[clock.id] = clock.getElements$(displayContext);
    });
    eLog.checkLog3("BladesClockKey", "Clock Key Elements", keyElems$);
    return keyElems$;
  }
  // #endregion
  // #region Initial Rendering ~
  async renderTo(parentElem) {
    const parent$ = $(parentElem);
    if (!parent$.length) {
      throw new Error(`[BladesClockKey.renderClockKeyTo] Error parent element not provided for key '${this.id}'.`);
    }
    const clockKeyHTML = await renderTemplate(
      "systems/eunos-blades/templates/components/clock-key.hbs",
      this
    );
    $(clockKeyHTML).appendTo(parent$);
  }
  /**
   * This function generates a partial GSAP.TweenVars object that will display the key in a given mode within the bounds of a provided container.
   *
   * @param {ClockKeyDisplayMode | number} [displayMode="full"] - The display mode. Options include:
   * - "full" - displays the entire clock key
   * - "clocks" - zooms in to display only the clocks
   * - "activeClocks" - zooms in to the active clocks
   * - "presentN" (where N is a clock index number) - zooms in to the clock at index N, and presents whichever side has the next available segment towards the camera.
   * - A clock index number - zooms in to the clock at index N
   *
   * @param {HTMLElement | JQuery<HTMLElement> | {x: number, y: number, width: number, height: number}} [container$] - The container within which the key will be displayed.
   * This can be:
   * - An HTMLElement
   * - A JQuery<HTMLElement>
   * - A {x, y, width, height} position definition
   * If not provided, it defaults to the clock key's container element (only if the key is already rendered in the DOM).
   *
   * @returns {gsap.TweenVars} - A partial GSAP.TweenVars object that describes how to display the key in the given mode within the bounds of the provided container. The returned object may include the following properties:
   * - 'scale' (number): A multiple to be applied to scale at "full" display mode.
   * - 'top' (number): A delta vertical shift from "full" display mode position.
   * - 'left' (number): A delta horizontal shift from "full" display mode position.
   * - 'transformOrigin': An absolute value.
   * - 'rotationZ': An absolute value for the keySwing axis.
   * - 'rotationY': An absolute value for rotation in/out of the screen.
   * Any variables left undefined default to "full" display mode.
   */
  getVarsForDisplayMode(keyElems$, displayMode = ClockKeyDisplayMode.full, container$) {
    const keyTweenVars = {};
    const keyImgContTweenVars = {};
    container$ ?? (container$ = keyElems$.container$);
    let targetPosData;
    if (container$ instanceof HTMLElement || container$ instanceof jQuery) {
      const containerPosData = U.gsap.getProperty($(container$)[0]);
      targetPosData = {
        x: containerPosData("x"),
        y: containerPosData("y"),
        width: containerPosData("width"),
        height: containerPosData("height")
      };
    } else if (isElemPosData(container$)) {
      targetPosData = container$;
    } else {
      throw new Error(`[BladesClockKey.getVarsForDisplayMode] Error container$ '${container$}' is not a valid type.`);
    }
    let presentingClock;
    let focusPosData;
    switch (displayMode) {
      case ClockKeyDisplayMode.full: {
        focusPosData = {
          x: this.svgData.width / 2,
          y: this.svgData.height / 2,
          width: this.svgData.width,
          height: this.svgData.height
        };
        break;
      }
      case ClockKeyDisplayMode.clocks: {
        focusPosData = this.getClocksBoundingBox(Array.from(this.clocks));
        break;
      }
      case ClockKeyDisplayMode.activeClocks: {
        focusPosData = this.getClocksBoundingBox(this.getClocksIn(this.activeClocks, this.visibleClocks));
        break;
      }
      case ClockKeyDisplayMode.presentCurrentClock: {
        presentingClock = this.currentClock;
        displayMode = presentingClock.index;
      }
      default: {
        if (typeof displayMode === "string" && displayMode.startsWith("present")) {
          displayMode = U.pInt(displayMode.toString().slice(7));
          presentingClock = this.getClockByIndex(displayMode);
        }
        if (!U.isInt(displayMode) || displayMode < 0 || displayMode >= this.size) {
          throw new Error(`[BladesClockKey.getVarsForDisplayMode] Error display mode '${displayMode}' is not a valid clock index for key '${this.id}'.`);
        }
        const focusClockData = this.svgData.clocks[displayMode];
        focusPosData = {
          x: focusClockData.x,
          y: focusClockData.y,
          width: this.svgData.clocks.size,
          height: this.svgData.clocks.size
        };
        break;
      }
    }
    keyTweenVars.scale = Math.min(
      targetPosData.height / focusPosData.height,
      targetPosData.width / focusPosData.width
    );
    keyImgContTweenVars.top = 0.5 * C.ClockKeySquareSize - focusPosData.y;
    keyImgContTweenVars.left = 0.5 * C.ClockKeySquareSize - focusPosData.x;
    keyImgContTweenVars.transformOrigin = `${focusPosData.x}px ${focusPosData.y}px`;
    keyImgContTweenVars.rotateY = 0;
    if (presentingClock) {
      keyTweenVars.scale *= 2;
      if (presentingClock.getActiveSide() === "left") {
        keyImgContTweenVars.rotateY = 30;
        keyImgContTweenVars.left += this.size === 1 ? 45 : 25;
      } else if (presentingClock.getActiveSide() === "right") {
        keyImgContTweenVars.rotateY = -30;
        keyImgContTweenVars.left -= this.size === 1 ? 45 : 25;
      }
    }
    return { keyTweenVars, keyImgContTweenVars };
  }
  // public fitKeyToContainer(
  //   keyElems$: ClockKeyElems$,
  //   posOverrides?: Partial<ElemPosData & {
  //     xShift: number,
  //     yShift: number,
  //     scaleMult: number
  //   }>
  // ) {
  //   const {container$, elem$, imgContainer$} = keyElems$;
  //   // Get position data for the container$ element (x, y, width, height)
  //   const keyPosition: ElemPosData = {
  //     x: U.gsap.getProperty(container$[0], "x") as number,
  //     y: U.gsap.getProperty(container$[0], "y") as number,
  //     width: U.gsap.getProperty(container$[0], "width") as number,
  //     height: U.gsap.getProperty(container$[0], "height") as number
  //   };
  //   const {xShift, yShift, scaleMult, ...focusPosOverrides} = posOverrides ?? {};
  //   const focusPosition: ElemPosData = {
  //     ...this.fullDisplayPosData,
  //     ...focusPosOverrides
  //   };
  //   eLog.checkLog3("BladesClockKey", "[BladesClockKey] Key Positions", {
  //     keyPosition,
  //     focusPosition,
  //     widthScale: keyPosition.width / focusPosition.width,
  //     heightScale: keyPosition.height / focusPosition.height
  //   });
  //   // Apply scale factor to elem$ to fit default key position inside container$
  //   U.gsap.set(elem$, {
  //     scale: Math.min(
  //       keyPosition.width / focusPosition.width,
  //       keyPosition.height / focusPosition.height
  //     ) * (scaleMult ?? 1)
  //   });
  //   // Apply top, left and transformOrigin value to keyImgContainer, accounting for x/yPercent -50
  //   U.gsap.set(imgContainer$, {
  //     top: (0.5 * C.ClockKeySquareSize) - focusPosition.y + (yShift ?? 0),
  //     left: (0.5 * C.ClockKeySquareSize) - focusPosition.x + (xShift ?? 0),
  //     transformOrigin: `${focusPosition.x + (xShift ?? 0)}px ${focusPosition.y + (yShift ?? 0)}px`
  //   });
  // }
  formatLabels(keyElems$) {
    const { label$, clocks, factionLabel$, projectLabel$, scoreLabel$ } = keyElems$;
    [
      [label$, 2, 4],
      factionLabel$ ? [factionLabel$, 2, 2] : void 0,
      projectLabel$ ? [projectLabel$, 2, 2] : void 0,
      scoreLabel$ ? [scoreLabel$, 2, 2] : void 0,
      ...this.clocks.map((clock) => [clocks[clock.id].clockLabel$, 2.5, 3])
    ].filter(Boolean).forEach(([labelElem$, aspectRatio, maxLines]) => {
      U.adjustTextContainerAspectRatio(labelElem$, aspectRatio, maxLines);
    });
  }
  setToDisplayMode(keyElems$, displayMode, isUpdatingTarget = true) {
    const { keyTweenVars, keyImgContTweenVars } = this.getVarsForDisplayMode(keyElems$, displayMode);
    U.gsap.set(keyElems$.elem$, keyTweenVars);
    U.gsap.set(keyElems$.imgContainer$, keyImgContTweenVars);
    if (isUpdatingTarget && displayMode !== this.displayMode) {
      this.updateTarget("displayMode", displayMode);
    }
  }
  initElementsInContext(html, displayMode, isUpdatingTarget = true) {
    const keyElems$ = this.getElements$(html);
    displayMode ?? (displayMode = this.displayMode);
    this.setToDisplayMode(keyElems$, displayMode, isUpdatingTarget);
    this.formatLabels(keyElems$);
    if (displayMode.toString().startsWith("present") || Number.isInteger(displayMode)) {
      U.gsap.to(keyElems$.container$.find(".clock-label, .clock-key-label"), { autoAlpha: 0, duration: 0 });
    }
    return keyElems$;
  }
  // #endregion
  async addToScene(sceneID = game.scenes.current.id) {
    if (this.isInScene(sceneID)) {
      return;
    }
    const { sceneIDs } = this;
    sceneIDs.push(sceneID);
    await this.updateTarget({
      isVisible: false,
      sceneIDs
    });
    this.renderTargetAndKeeper();
  }
  async removeFromScene(sceneID = game.scenes.current.id) {
    if (!this.isInScene(sceneID)) {
      return;
    }
    const { sceneIDs } = this;
    U.remove(sceneIDs, sceneID);
    await this.updateTarget("sceneIDs", sceneIDs);
    this.renderTargetAndKeeper();
  }
  closeClockKey({ container$ }) {
    container$.remove();
  }
  get svgData() {
    if (this.size === 0) {
      throw new Error("[BladesClockKey.svgData] Error size is 0.");
    }
    const keyData = ClockKey_SVGDATA[this.size];
    let path;
    if (this.size === 1 && keyData.paths) {
      path = keyData.paths[this.oneKeyIndex];
    } else if (keyData.path) {
      path = keyData.path;
    } else {
      throw new Error("[BladesClockKey.svgData] Error path is not defined.");
    }
    return {
      width: keyData.width,
      height: keyData.height,
      path,
      clocks: keyData.clocks
    };
  }
  isInOverlay(elem) {
    return $(elem).hasClass(".overlay-section") || $(elem).closest(".overlay-section").length > 0;
  }
  get keyHeight() {
    return this.svgData.height;
  }
  get keyWidth() {
    return this.svgData.width;
  }
  get keyViewbox() {
    return `0 0 ${this.svgData.width} ${this.svgData.height}`;
  }
  get keyPath() {
    return this.svgData.path;
  }
  get clockSize() {
    return this.svgData.clocks.size;
  }
  getClockPosition(clockIndex = 0) {
    if (clockIndex > this.size) {
      throw new Error(`[BladesClockKey.getClockPosition] Error clockIndex '${clockIndex}' is greater than key size '${this.size}'.`);
    }
    if (clockIndex < 0) {
      throw new Error(`[BladesClockKey.getClockPosition] Error clockIndex '${clockIndex}' is less than 0.`);
    }
    return this.svgData.clocks[clockIndex];
  }
  removePositionDragger() {
    var _a2, _b;
    (_a2 = this.positionDragger) == null ? void 0 : _a2.target.remove();
    (_b = this.positionDragger) == null ? void 0 : _b.kill();
    delete this.positionDragger;
  }
  spawnPositionDragger(containerElem$ = game.eunoblades.Director.clockKeySection$) {
    const self2 = this;
    if (this.positionDragger) {
      this.removePositionDragger();
    }
    const dragElem$ = $(`<div id="Dragger-${this.id}" class="clock-key-container clock-key-dragger" data-size="${this.size}"></div>`).appendTo(containerElem$);
    if (this.overlayPosition) {
      dragElem$.css({
        left: this.overlayPosition.x,
        top: this.overlayPosition.y
      });
    }
    this.positionDragger = new Draggable(dragElem$, {
      type: "top,left",
      onDragStart() {
        $(this.target).css("background", "rgba(255, 255, 0, 0.25)");
        $(this.target).css("outlineColor", "rgba(255, 255, 0, 1)");
      },
      onDragEnd() {
        $(this.target).css("background", "rgba(255, 0, 255, 0.25)");
        $(this.target).css("outlineColor", "rgba(255, 0, 255, 1)");
        self2.overlayPosition = { x: this.endX, y: this.endY };
      }
    });
  }
  switchToMode(keyElems$, displayMode, extendKeyVars = {}, extendKeyContainerVars = {}, isUpdatingTarget = true, callback) {
    const { elem$, imgContainer$ } = keyElems$;
    const { keyTweenVars, keyImgContTweenVars } = this.getVarsForDisplayMode(keyElems$, displayMode);
    const currentDisplayMode = this.displayMode;
    const randomID2 = U.gsap.utils.random(1, 1e3, 1);
    return U.gsap.timeline({
      callbackScope: this,
      paused: true,
      onStart() {
        eLog.checkLog2("BladesClockKey", `switchToMode #${randomID2} - START`, { key: this, keyElems$, displayMode });
      },
      onComplete() {
        eLog.checkLog3("BladesClockKey", `switchToMode #${randomID2} - COMPLETE`, { key: this, keyElems$, displayMode });
        if (isUpdatingTarget && displayMode !== this.currentDisplayMode) {
          this.updateTarget("displayMode", displayMode).then(() => callback == null ? void 0 : callback());
        } else {
          callback == null ? void 0 : callback();
        }
      },
      onReverseComplete() {
        eLog.checkLog3("BladesClockKey", `switchToMode #${randomID2} - REVERSE COMPLETE`, { key: this, keyElems$, displayMode });
        if (isUpdatingTarget) {
          this.updateTarget("displayMode", currentDisplayMode);
        }
      }
    }).to(elem$, { ...keyTweenVars, ...extendKeyVars }, 0).to(imgContainer$, { ...keyImgContTweenVars, ...extendKeyContainerVars }, 0);
  }
  // #endregion
  // #region ANIMATED UPDATES (Both GM-Only AND Socket Calls)
  //    #region   > SOCKET CALLS: _SocketCall / static _SocketResponse / _Animation
  fadeInName_Animation(keyElems$) {
    if (!this.name) {
      return void 0;
    }
    return U.gsap.effects.blurReveal(keyElems$.label$, {
      ignoreMargin: true,
      duration: 0.75
    });
  }
  async fadeInName_SocketCall(displayContext) {
    if (!game.user.isGM) {
      return;
    }
    socketlib.system.executeForEveryone("fadeInName_SocketCall", displayContext, this.id);
  }
  static fadeInName_SocketResponse(displayContext, keyID) {
    const key = game.eunoblades.ClockKeys.get(keyID);
    if (!key) {
      return;
    }
    key.fadeInName_Animation(key.getElements$(displayContext));
  }
  fadeOutName_Animation(keyElems$) {
    if (!this.name) {
      return void 0;
    }
    return U.gsap.effects.blurRemove(keyElems$.label$, {
      ignoreMargin: true,
      duration: 0.75
    });
  }
  async fadeOutName_SocketCall(displayContext) {
    if (!game.user.isGM) {
      return;
    }
    this.fadeOutName_Animation(this.getElements$(displayContext));
    socketlib.system.executeForOthers("fadeOutName_SocketCall", displayContext, this.id);
  }
  static fadeOutName_SocketResponse(displayContext, keyID) {
    const key = game.eunoblades.ClockKeys.get(keyID);
    if (!key) {
      return;
    }
    key.fadeOutName_Animation(key.getElements$(displayContext));
  }
  //    #endregion
  // #endregion
  // #region Adding & Removing Clocks ~
  async updateClockIndices() {
    await this.updateTarget("clocksData", Object.fromEntries(
      Object.entries(this.clocksData).map(([id, data], index) => [id, { ...data, index }])
    ));
    return this.clocks;
  }
  async addClock(clockSchema = {}) {
    const cData = BladesClock.ParseConfigToData({
      ...BladesClock.ApplySchemaDefaults(clockSchema),
      index: this.size,
      targetID: this.targetID,
      targetKey: `${this.targetKeyPrefix}.clocksData`,
      isScopingById: true
    });
    await this.updateTarget(`clocksData.${cData.id}`, cData);
    void this.clocks;
    this.renderTargetAndKeeper();
  }
  async deleteClock(clockID) {
    var _a2, _b;
    if (this.size <= 1) {
      throw new Error("[BladesClockKey.deleteClock()] Cannot reduce number of clocks below 1!");
    }
    clockID ?? (clockID = (_a2 = Array.from(this.clocks).pop()) == null ? void 0 : _a2.id);
    if (!clockID) {
      return;
    }
    await ((_b = this.getClockByID(clockID)) == null ? void 0 : _b.delete());
    await this.updateClockIndices();
    void this.clocks;
  }
  // #endregion
  // #region OVERRIDES: Async Update Methods
  renderTargetAndKeeper() {
    var _a2;
    this.renderTarget();
    (_a2 = game.eunoblades.ClockKeeper.sheet) == null ? void 0 : _a2.render();
  }
  renderTarget() {
    var _a2;
    (_a2 = this.target.sheet) == null ? void 0 : _a2.render();
  }
  // #endregion
}
class BladesClock extends BladesTargetLink {
  // #region STATIC METHODS ~
  static ApplySchemaDefaults(schemaData) {
    const namedValueMax = {
      name: schemaData.name ?? "",
      value: schemaData.value ?? 0,
      max: schemaData.max ?? 8
    };
    return {
      index: 0,
      color: ClockColor.white,
      isVisible: !U.isInt(schemaData.index) || schemaData.index === 0,
      isNameVisible: false,
      isHighlighted: false,
      isActive: !U.isInt(schemaData.index) || schemaData.index === 0,
      ...schemaData,
      ...namedValueMax
    };
  }
  // #endregion
  // #region GETTERS & SETTERS ~
  get canEdit() {
    console.log("NOTE: All Clocks currently Editable; see line 71 of BladesClock.ts");
    return this.isVisible && this.isActive;
  }
  get data() {
    return this.linkData;
  }
  get name() {
    return this.data.name;
  }
  set name(val) {
    this.updateTarget("name", val).then(() => {
      this.parentKey.renderTargetAndKeeper();
    });
  }
  get value() {
    return U.pInt(this.data.value);
  }
  set value(val) {
    this.updateTarget("value", U.pInt(val)).then(() => {
      this.parentKey.renderTargetAndKeeper();
    });
  }
  get max() {
    return U.pInt(this.data.max);
  }
  set max(val) {
    this.updateTarget("max", U.pInt(val)).then(() => {
      this.parentKey.renderTargetAndKeeper();
    });
  }
  get color() {
    return this.data.color ?? ClockColor.white;
  }
  set color(val) {
    this.updateTarget("color", val).then(() => {
      this.parentKey.renderTargetAndKeeper();
    });
  }
  get isActive() {
    return U.pBool(this.data.isActive);
  }
  set isActive(val) {
    this.updateTarget("isActive", U.pBool(val)).then(() => {
      this.parentKey.renderTargetAndKeeper();
    });
  }
  get parentKey() {
    const pKey = game.eunoblades.ClockKeys.get(this.data.parentKeyID);
    if (!pKey) {
      throw new Error(`[BladesClockKey.parentKey] No parent key found for clock ${this.id}`);
    }
    return pKey;
  }
  get isNameVisible() {
    return U.pBool(this.data.isNameVisible);
  }
  set isNameVisible(val) {
    this.updateTarget("isNameVisible", U.pBool(val)).then(() => {
      this.parentKey.renderTargetAndKeeper();
    });
  }
  get isVisible() {
    return U.pBool(this.data.isVisible);
  }
  set isVisible(val) {
    this.updateTarget("isVisible", U.pBool(val)).then(() => {
      this.parentKey.renderTargetAndKeeper();
    });
  }
  get isHighlighted() {
    return U.pBool(this.data.isHighlighted);
  }
  set isHighlighted(val) {
    this.updateTarget("isHighlighted", U.pBool(val)).then(() => {
      this.parentKey.renderTargetAndKeeper();
    });
  }
  get index() {
    return U.pInt(this.data.index);
  }
  set index(val) {
    this.updateTarget("index", U.pInt(val)).then(() => {
      this.parentKey.renderTargetAndKeeper();
    });
  }
  get isEmpty() {
    return this.value === 0;
  }
  get isComplete() {
    return this.value >= this.max;
  }
  get rollOppClock() {
    return this;
  }
  get rollOppName() {
    return this.name;
  }
  get rollOppType() {
    return "clock";
  }
  get colorSelectOptions() {
    return [
      { value: ClockColor.white, display: "🔘" },
      { value: ClockColor.yellow, display: "📀" },
      { value: ClockColor.cyan, display: "🔵" },
      { value: ClockColor.red, display: "🔴" }
    ];
  }
  get maxSelectOptions() {
    return [
      { value: 2, display: 2 },
      { value: 3, display: 3 },
      { value: 4, display: 4 },
      { value: 5, display: 5 },
      { value: 6, display: 6 },
      { value: 8, display: 8 },
      { value: 10, display: 10 },
      { value: 12, display: 12 }
    ];
  }
  get valueSelectOptions() {
    const returnVals = [];
    for (let i = 0; i <= this.max; i++) {
      returnVals.push({ value: i, display: i });
    }
    return returnVals;
  }
  // Returns which hemisphere of the clock will show the final change if segmentDelta segments are added/removed.
  getActiveSide(segmentDelta = 0) {
    const finalClockValue = Math.min(this.max, Math.max(0, this.value + segmentDelta));
    const halfClockValue = this.max / 2;
    if (segmentDelta === 0) {
      return finalClockValue >= halfClockValue ? "left" : "right";
    }
    return finalClockValue > halfClockValue ? "left" : "right";
  }
  // #endregion
  // #region HTML INTERACTION ~
  getElemFromDisplayContext(displayContext) {
    let elem$;
    const DOM$ = $(".vtt.game.system-eunos-blades");
    switch (displayContext) {
      case ClockDisplayContext.overlay: {
        elem$ = DOM$.find(`#blades-overlay #${this.id}`);
        break;
      }
      case ClockDisplayContext.pcSheet: {
        elem$ = DOM$.find(`.actor.sheet .pc #${this.id}`);
        break;
      }
      case ClockDisplayContext.factionSheet: {
        elem$ = DOM$.find(`.actor.sheet .faction #${this.id}`);
        break;
      }
      case ClockDisplayContext.projectSheet: {
        elem$ = DOM$.find(`.item.sheet .project #${this.id}`);
        break;
      }
      case ClockDisplayContext.scoreSheet: {
        elem$ = DOM$.find(`.item.sheet .score #${this.id}`);
        break;
      }
      case ClockDisplayContext.rollCollab: {
        elem$ = DOM$.find(`.roll-collab-sheet #${this.id}`);
        break;
      }
      case ClockDisplayContext.chatMessage: {
        elem$ = DOM$.find(`#chat #${this.id}`);
        break;
      }
    }
    if (!elem$.length) {
      throw new Error(`[BladesClockKey.getElemFromDisplayContext] Error elem$ not found for key '${this.id}' for display context '${displayContext}'.`);
    }
    return elem$;
  }
  getElements$(displayContext) {
    let elem$;
    if (typeof displayContext === "string") {
      displayContext = this.getElemFromDisplayContext(displayContext);
    }
    elem$ = $(displayContext).find(`#${this.id}`);
    if (!elem$.length) {
      elem$ = $(displayContext).closest(`#${this.id}`);
    }
    if (!(elem$ == null ? void 0 : elem$.length)) {
      throw new Error(`[BladesClock.getElements$] Cannot find elements for display context '${displayContext}' of clock '${this.id}' of key '${this.parentKey.id}'.`);
    }
    const clockElems$ = {
      clockElem$: elem$
    };
    const container$ = elem$.closest(".clock-container");
    if (!container$.length) {
      throw new Error(`[BladesClock.getElements$] Error '.clock-container' not found for clock '${this.id}' of key '${this.parentKey.id}'.`);
    }
    clockElems$.clockContainer$ = container$;
    const label$ = elem$.find(".clock-label");
    if (!label$.length) {
      throw new Error(`[BladesClock.getElements$] Error '.clock-label' not found for clock '${this.id}' of key '${this.parentKey.id}'.`);
    }
    clockElems$.clockLabel$ = label$;
    const bg$ = elem$.find(".clock-bg");
    if (!bg$.length) {
      throw new Error(`[BladesClock.getElements$] Error '.clock-bg' not found for clock '${this.id}' of key '${this.parentKey.id}'.`);
    }
    clockElems$.bg$ = bg$;
    const frame$ = elem$.find(".clock-frame");
    if (!frame$.length) {
      throw new Error(`[BladesClock.getElements$] Error '.clock-frame' not found for clock '${this.id}' of key '${this.parentKey.id}'.`);
    }
    clockElems$.frame$ = frame$;
    const fill$ = elem$.find(".clock-fill");
    if (!fill$.length) {
      throw new Error(`[BladesClock.getElements$] Error '.clock-fill' not found for clock '${this.id}' of key '${this.parentKey.id}'.`);
    }
    clockElems$.fill$ = fill$;
    const glow$ = elem$.find(".clock-glow");
    if (!glow$.length) {
      throw new Error(`[BladesClock.getElements$] Error '.clock-glow' not found for clock '${this.id}' of key '${this.parentKey.id}'.`);
    }
    clockElems$.glow$ = glow$;
    const cover$ = elem$.find(".clock-cover");
    if (!cover$.length) {
      throw new Error(`[BladesClock.getElements$] Error '.clock-cover' not found for clock '${this.id}' of key '${this.parentKey.id}'.`);
    }
    clockElems$.cover$ = cover$;
    const oneSegments$ = elem$.find(".clock-one-segment");
    if (oneSegments$.length !== 3) {
      throw new Error(`[BladesClock.getElements$] Error '.clock-one-segment' elements not found for clock '${this.id}' of key '${this.parentKey.id}'.`);
    }
    clockElems$.oneSegments$ = oneSegments$;
    return clockElems$;
  }
  // #endregion
  // #region ANIMATED UPDATES (Both GM-Only AND Socket Calls)
  reveal_Animation(clockElems$, callback) {
    const fadeInElements = [
      clockElems$.frame$,
      clockElems$.fill$
    ].filter((el$) => el$ !== void 0);
    const tl = U.gsap.timeline({
      callbackScope: this,
      onComplete() {
        callback == null ? void 0 : callback();
      }
    });
    tl.to(clockElems$.cover$, { scale: 2, autoAlpha: 0, duration: 0.5, ease: "power2" });
    tl.fromTo(fadeInElements, {
      autoAlpha: 0,
      scale: 2
    }, {
      autoAlpha: 1,
      scale: 1,
      duration: 0.5,
      stagger: 0.2,
      ease: "power2"
    });
    if (this.name && this.isNameVisible) {
      tl.blurReveal(clockElems$.clockLabel$, {
        ignoreMargin: true,
        duration: 0.75
      }, "<+0.05");
    }
    if (this.isHighlighted) {
      tl.scaleUpReveal(clockElems$.glow$, {
        scale: 3,
        duration: 0.5
      }, "<+0.05");
    }
    if (this.isActive) {
      tl.add(() => this.activate_Animation(clockElems$), "<+0.05");
    } else {
      tl.add(() => this.deactivate_Animation(clockElems$), "<+0.05");
    }
    return tl;
  }
  async reveal_SocketCall(displayContext) {
    if (!game.user.isGM) {
      return;
    }
    socketlib.system.executeForEveryone("reveal_SocketCall", displayContext, this.parentKey.id, this.index);
  }
  static reveal_SocketResponse(displayContext, keyID, index) {
    const key = game.eunoblades.ClockKeys.get(keyID);
    if (!(key == null ? void 0 : key.isVisible)) {
      return;
    }
    const clock = key.getClockByIndex(index);
    if (!clock) {
      return;
    }
    const clockElems$ = clock.getElements$(displayContext);
    clock.reveal_Animation(clockElems$);
  }
  hide_Animation(clockElems$, callback) {
    const fadeOutElements = [
      clockElems$.frame$,
      clockElems$.fill$
    ].filter((el$) => el$ !== void 0);
    const tl = U.gsap.timeline({
      callbackScope: this,
      onComplete() {
        callback == null ? void 0 : callback();
      }
    });
    tl.to(fadeOutElements, {
      autoAlpha: 0,
      scale: 2,
      duration: 0.5,
      stagger: 0.2,
      ease: "power2"
    });
    if (this.name && this.isNameVisible) {
      tl.blurRemove(clockElems$.clockLabel$, {
        ignoreMargin: true,
        duration: 0.75
      }, "<+0.05");
    }
    if (this.isHighlighted) {
      tl.scaleDownRemove(clockElems$.glow$, {
        scale: 3,
        duration: 0.5
      }, "<+0.05");
    }
    tl.to(clockElems$.cover$, { scale: 1, autoAlpha: 1, duration: 0.5, ease: "power2" });
    return tl;
  }
  async hide_SocketCall(displayContext) {
    if (!game.user.isGM) {
      return;
    }
    socketlib.system.executeForEveryone("hide_SocketCall", displayContext, this.parentKey.id, this.index);
  }
  static hide_SocketResponse(displayContext, keyID, index) {
    const key = game.eunoblades.ClockKeys.get(keyID);
    if (!(key == null ? void 0 : key.isVisible)) {
      return;
    }
    const clock = key.getClockByIndex(index);
    if (!clock) {
      return;
    }
    const clockElems$ = clock.getElements$(displayContext);
    clock.hide_Animation(clockElems$);
  }
  activate_Animation(clockElems$, callback) {
    U.gsap.to(clockElems$.bg$, { autoAlpha: 1, duration: 0.5, ease: "power2" });
    U.gsap.to(clockElems$.frame$, {
      filter: "brightness(0.5)",
      duration: 0.5,
      ease: "power2",
      onComplete: callback
    });
  }
  async activate_SocketCall(displayContext) {
    if (!game.user.isGM) {
      return;
    }
    socketlib.system.executeForEveryone("activate_SocketCall", displayContext, this.parentKey.id, this.index);
  }
  static activate_SocketResponse(displayContext, keyID, index) {
    const key = game.eunoblades.ClockKeys.get(keyID);
    if (!(key == null ? void 0 : key.isVisible)) {
      return;
    }
    const clock = key.getClockByIndex(index);
    if (!clock) {
      return;
    }
    clock.activate_Animation(clock.getElements$(displayContext));
  }
  deactivate_Animation(clockElems$, callback) {
    U.gsap.to(clockElems$.bg$, { autoAlpha: 0, duration: 0.5, ease: "power2" });
    U.gsap.to(clockElems$.frame$, {
      filter: "brightness(1) blur(5px)",
      duration: 0.5,
      ease: "power2",
      onComplete: callback
    });
  }
  async deactivate_SocketCall(displayContext) {
    if (!game.user.isGM) {
      return;
    }
    socketlib.system.executeForEveryone("deactivate_SocketCall", displayContext, this.parentKey.id, this.index);
  }
  static deactivate_SocketResponse(displayContext, keyID, index) {
    const key = game.eunoblades.ClockKeys.get(keyID);
    if (!(key == null ? void 0 : key.isVisible)) {
      return;
    }
    const clock = key.getClockByIndex(index);
    if (!clock) {
      return;
    }
    clock.deactivate_Animation(clock.getElements$(displayContext));
  }
  fadeInClockName_Animation(clockElems$) {
    U.gsap.effects.blurReveal(clockElems$.clockLabel$, {
      ignoreMargin: true,
      duration: 0.75
    });
  }
  async fadeInClockName_SocketCall(displayContext) {
    if (!game.user.isGM) {
      return;
    }
    socketlib.system.executeForEveryone("fadeInClockName_SocketCall", displayContext, this.parentKey.id, this.index);
  }
  static fadeInClockName_SocketResponse(displayContext, keyID, index) {
    const key = game.eunoblades.ClockKeys.get(keyID);
    if (!(key == null ? void 0 : key.isVisible)) {
      return;
    }
    const clock = key.getClockByIndex(index);
    if (!clock) {
      return;
    }
    clock.fadeInClockName_Animation(clock.getElements$(displayContext));
  }
  fadeOutClockName_Animation(clockElems$) {
    U.gsap.effects.blurRemove(clockElems$.clockLabel$, {
      ignoreMargin: true,
      duration: 0.75
    });
  }
  async fadeOutClockName_SocketCall(displayContext) {
    if (!game.user.isGM) {
      return;
    }
    socketlib.system.executeForEveryone("fadeOutClockName_SocketCall", displayContext, this.parentKey.id, this.index);
  }
  static fadeOutClockName_SocketResponse(displayContext, keyID, index) {
    const key = game.eunoblades.ClockKeys.get(keyID);
    if (!(key == null ? void 0 : key.isVisible)) {
      return;
    }
    const clock = key.getClockByIndex(index);
    if (!clock) {
      return;
    }
    clock.fadeOutClockName_Animation(clock.getElements$(displayContext));
  }
  highlight_Animation(clockElems$) {
    U.gsap.effects.scaleUpReveal(clockElems$.glow$, {
      duration: 0.5,
      scale: 3
    });
  }
  async highlight_SocketCall(displayContext) {
    if (!game.user.isGM) {
      return;
    }
    socketlib.system.executeForEveryone("highlight_SocketCall", displayContext, this.parentKey.id, this.index);
  }
  static highlight_SocketResponse(displayContext, keyID, index) {
    const key = game.eunoblades.ClockKeys.get(keyID);
    if (!(key == null ? void 0 : key.isVisible)) {
      return;
    }
    const clock = key.getClockByIndex(index);
    if (!clock) {
      return;
    }
    clock.highlight_Animation(clock.getElements$(displayContext));
  }
  unhighlight_Animation(clockElems$) {
    U.gsap.effects.scaleDownRemove(clockElems$.glow$, {
      duration: 0.5,
      scale: 3
    });
  }
  async unhighlight_SocketCall(displayContext) {
    if (!game.user.isGM) {
      return;
    }
    socketlib.system.executeForEveryone("unhighlight_SocketCall", displayContext, this.parentKey.id, this.index);
  }
  static unhighlight_SocketResponse(displayContext, keyID, index) {
    const key = game.eunoblades.ClockKeys.get(keyID);
    if (!(key == null ? void 0 : key.isVisible)) {
      return;
    }
    const clock = key.getClockByIndex(index);
    if (!clock) {
      return;
    }
    clock.unhighlight_Animation(clock.getElements$(displayContext));
  }
  getRotationOfSegment(segment) {
    const stepSize = 360 / this.max;
    return stepSize * (segment - 1);
  }
  initOneSegments(clockElems$, segmentNums, isReversing) {
    if (segmentNums.length > 3) {
      throw new Error(`Too many segments: [${segmentNums.join(", ")}]`);
    }
    const oneSegs = [...clockElems$.oneSegments$];
    const oneSegsToAnimate = Array.from(clockElems$.oneSegments$).slice(0, segmentNums.length);
    for (const segmentNum of segmentNums) {
      const oneSegment = oneSegs.shift();
      U.gsap.set(oneSegment, {
        rotation: this.getRotationOfSegment(segmentNum),
        autoAlpha: isReversing ? 1 : 0
      });
    }
    if (isReversing) {
      clockElems$.clockElem$.attr("data-value", U.getLast(segmentNums) - 1);
    }
    return oneSegsToAnimate;
  }
  changeSegments_Animation(clockElems$, startVal, endVal, callback) {
    startVal = U.gsap.utils.clamp(0, this.max, startVal);
    endVal = U.gsap.utils.clamp(0, this.max, endVal);
    let delta = endVal - startVal;
    if (delta === 0) {
      return;
    }
    const segmentNums = [];
    if (delta < 0) {
      while (Math.abs(delta) > startVal) {
        delta++;
      }
      for (let i = startVal; i > endVal; i--) {
        segmentNums.push(i);
      }
    } else {
      while (endVal > this.max) {
        delta--;
      }
      for (let i = startVal + 1; i <= endVal; i++) {
        segmentNums.push(i);
      }
    }
    const segmentsToAnimate = this.initOneSegments(clockElems$, segmentNums, startVal > endVal);
    eLog.checkLog3("BladesClock", "changeSegments_Animation", { clockElems$, delta, segmentNums, startVal, endVal, segmentsToAnimate });
    const tl = U.gsap.timeline();
    if (delta > 0) {
      tl.fromTo(segmentsToAnimate, {
        autoAlpha: 0,
        scale: 2
      }, {
        autoAlpha: 1,
        scale: 1,
        duration: 0.5,
        stagger: 0.2,
        ease: "power2",
        callbackScope: this,
        onComplete() {
          clockElems$.clockElem$.attr("data-value", endVal);
          U.gsap.to(segmentsToAnimate, {
            autoAlpha: 0,
            duration: 0.5,
            stagger: 0.2
            // onComplete() {
            //   // Return clock key to original size and focus
            //   clockFocusTimeline.reverse();
            // }
          });
        }
      });
    } else {
      tl.fromTo(segmentsToAnimate, {
        autoAlpha: 1,
        scale: 1
      }, {
        autoAlpha: 0,
        scale: 2,
        duration: 0.5,
        stagger: 0.2,
        ease: "power2"
        // onComplete() {
        //   // Return clock key to original size and focus
        //   clockFocusTimeline.reverse();
        // }
      });
    }
    return tl;
  }
  async changeSegments_SocketCall(displayContext, startVal, endVal) {
    if (!game.user.isGM) {
      return;
    }
    startVal = U.gsap.utils.clamp(0, this.max, startVal);
    endVal = U.gsap.utils.clamp(0, this.max, endVal);
    socketlib.system.executeForEveryone("changeSegments_SocketCall", displayContext, this.parentKey.id, this.index, startVal, endVal);
  }
  static changeSegments_SocketResponse(displayContext, keyID, index, startVal, endVal) {
    const key = game.eunoblades.ClockKeys.get(keyID);
    if (!(key == null ? void 0 : key.isVisible)) {
      return;
    }
    const clock = key.getClockByIndex(index);
    if (!clock) {
      return;
    }
    clock.changeSegments_Animation(clock.getElements$(displayContext), startVal, endVal);
  }
  // #endregion
  // #region Adding/Removing Clock Segments ~
  // Returns number of segments beyond max (or 0, if max not met)
  async fillSegments(count, isSilent = false) {
    const clockOverflow = Math.max(0, this.value + count - this.max);
    count = Math.min(this.value + count, this.max) - this.value;
    if (count === 0) {
      return clockOverflow;
    }
    await this.updateTarget("value", this.value + count);
    if (!isSilent) {
      this.parentKey.renderTargetAndKeeper();
    }
    return clockOverflow;
  }
  // Returns (positive) number of segments removed
  // in excess of the number of segments in the clock
  async clearSegments(count, isSilent = false) {
    const clockOverflow = Math.max(0, count - this.value);
    count = Math.min(this.value, count);
    if (count === 0) {
      return clockOverflow;
    }
    await this.updateTarget("value", this.value - count);
    if (!isSilent) {
      this.parentKey.renderTargetAndKeeper();
    }
    return clockOverflow;
  }
  async delete() {
    const { parentKey } = this;
    await super.delete(false);
    parentKey.updateClockIndices();
  }
  // #endregion
}
const _BladesDirector = class _BladesDirector {
  constructor() {
    __publicField(this, "_id");
    // #endregion
    // #endregion
    // #region OVERLAY ~
    // #region  >> Overlay Elements$ ~
    __publicField(this, "_overlayContainer");
    __publicField(this, "_overlayContainer$");
    // - As with notifications: placeholder animation until something more final can be coded.
    // #endregion
    // #region TOOLTIPS ~
    __publicField(this, "_tooltipObserver");
    // _tooltipElems: Map<string, JQuery> = new Map<string, JQuery>();
    __publicField(this, "_displayedTooltipID");
    this._id = randomID();
  }
  static getInstance() {
    _BladesDirector.instance ?? (_BladesDirector.instance = new _BladesDirector());
    return _BladesDirector.instance;
  }
  // #endregion
  static async Initialize() {
    var _a2, _b, _c;
    if (game.user.isGM) {
      $("body").addClass("user-gm");
    }
    Hooks.on("renderApplication", async () => {
      game.eunoblades.Director.initClockKeySection(true);
      if (game.user.isGM) {
        await game.eunoblades.ClockKeeper.update({ "system.targetScene": game.scenes.current.id });
        game.eunoblades.ClockKeeper.render();
      }
    });
    if (((_a2 = game.modules) == null ? void 0 : _a2.has("pause-text")) && ((_c = (_b = game.modules) == null ? void 0 : _b.get("pause-text")) == null ? void 0 : _c.active)) {
      const pauseSettings = game.settings.get("pause-text", "allSettings");
      const rumors = C.Rumors.map((rumor) => `${rumor}`).join("\n");
      if (rumors !== pauseSettings.allText) {
        console.log("Refreshing Pause Text");
        pauseSettings.allText = rumors;
        game.settings.set("pause-text", "allSettings", pauseSettings);
      }
    }
    return loadTemplates([
      "systems/eunos-blades/templates/overlay/blades-overlay.hbs",
      "systems/eunos-blades/templates/overlay/location.hbs",
      "systems/eunos-blades/templates/overlay/score-panel.hbs",
      "systems/eunos-blades/templates/overlay/npc-portrait.hbs",
      "systems/eunos-blades/templates/overlay/pc-portrait.hbs",
      "systems/eunos-blades/templates/overlay/cohort-portrait.hbs",
      "systems/eunos-blades/templates/overlay/crew-status-bar.hbs",
      "systems/eunos-blades/templates/overlay/game-phase-bar.hbs",
      "systems/eunos-blades/templates/overlay/notices/push.hbs"
    ]);
  }
  // #region   >>  Sockets ~
  static InitSockets() {
    const director = _BladesDirector.getInstance();
    socketlib.system.register("renderOverlay_SocketCall", director.renderOverlay_SocketResponse.bind(director));
    director.initClockSockets();
    director.initScorePanelSockets();
    director.initLocationSockets();
    director.initNPCSockets();
    director.initPCSockets();
    director.initCohortSockets();
    director.initCrewSockets();
    director.initNotificationSockets();
    director.initTransitionSockets();
  }
  get overlayContainer() {
    if (!this._overlayContainer) {
      [this._overlayContainer] = $("#blades-overlay");
    }
    if (!this._overlayContainer) {
      $("body.vtt").append('<section id="blades-overlay"></section>');
      [this._overlayContainer] = $("#blades-overlay");
    }
    return this._overlayContainer;
  }
  get overlayContainer$() {
    if (!this._overlayContainer$) {
      this._overlayContainer$ = $(this.overlayContainer);
    }
    return this._overlayContainer$;
  }
  get clockKeySection$() {
    return this.overlayContainer$.find(".overlay-section-clock-keys");
  }
  get locationSection$() {
    return this.overlayContainer$.find(".overlay-section-location");
  }
  get scorePanelSection$() {
    return this.overlayContainer$.find(".overlay-section-score-panel");
  }
  get npcSection$() {
    return this.overlayContainer$.find(".overlay-section-npcs");
  }
  get playerSection$() {
    return this.overlayContainer$.find(".overlay-section-players");
  }
  get crewSection$() {
    return this.overlayContainer$.find(".overlay-section-crew");
  }
  get notificationSection$() {
    return this.overlayContainer$.find(".overlay-section-notifications");
  }
  get transitionSection$() {
    return this.overlayContainer$.find(".overlay-section-transitions");
  }
  get tooltipSection$() {
    return this.overlayContainer$.find(".overlay-section-tooltips");
  }
  get svgData() {
    return ClockKey_SVGDATA;
  }
  // #endregion
  // #region  >> Rendering ~
  renderOverlay_SocketCall() {
    if (!game.user.isGM) {
      return;
    }
    if (!this.overlayContainer) {
      return;
    }
    socketlib.system.executeForEveryone("renderOverlay_SocketCall");
  }
  async renderOverlay_SocketResponse() {
    const overlayContent = await renderTemplate(
      "systems/eunos-blades/templates/overlay/blades-overlay.hbs",
      this
    );
    this.overlayContainer$.empty().append(overlayContent);
    this.initClockKeySection();
    this.initTooltipSection();
  }
  // #endregion
  // #endregion
  // #region CLOCKS & CLOCK KEYS ~
  // #region   >> INITIALIZATION ~
  initClockKeySection(isResetting = false) {
    if (isResetting) {
      this.clockKeySection$.empty();
    }
    const visibleSceneKeys = U.shuffle(this.sceneKeys.filter((key) => key.isVisible));
    let staggerDelay = 0;
    while (visibleSceneKeys.length) {
      const key = visibleSceneKeys.shift();
      if (key) {
        setTimeout(() => this.renderClockKey(key), staggerDelay * 1e3);
        staggerDelay += 0.5;
      }
    }
    setTimeout(() => {
    }, staggerDelay * 1e3);
  }
  initClockSockets() {
    socketlib.system.register("renderClockKey_SocketCall", _BladesDirector.renderClockKey_SocketResponse.bind(_BladesDirector));
    socketlib.system.register("pullKey_SocketCall", _BladesDirector.pullKey_SocketResponse.bind(_BladesDirector));
    socketlib.system.register("fadeInName_SocketCall", BladesClockKey.fadeInName_SocketResponse.bind(BladesClockKey));
    socketlib.system.register("fadeOutName_SocketCall", BladesClockKey.fadeOutName_SocketResponse.bind(BladesClockKey));
    socketlib.system.register("reveal_SocketCall", BladesClock.reveal_SocketResponse.bind(BladesClock));
    socketlib.system.register("hide_SocketCall", BladesClock.hide_SocketResponse.bind(BladesClock));
    socketlib.system.register("activate_SocketCall", BladesClock.activate_SocketResponse.bind(BladesClock));
    socketlib.system.register("deactivate_SocketCall", BladesClock.deactivate_SocketResponse.bind(BladesClock));
    socketlib.system.register("fadeInClockName_SocketCall", BladesClock.fadeInClockName_SocketResponse.bind(BladesClock));
    socketlib.system.register("fadeOutClockName_SocketCall", BladesClock.fadeOutClockName_SocketResponse.bind(BladesClock));
    socketlib.system.register("highlight_SocketCall", BladesClock.highlight_SocketResponse.bind(BladesClock));
    socketlib.system.register("unhighlight_SocketCall", BladesClock.unhighlight_SocketResponse.bind(BladesClock));
    socketlib.system.register("changeSegments_SocketCall", BladesClock.changeSegments_SocketResponse.bind(BladesClock));
  }
  // #endregion
  get sceneKeys() {
    return game.eunoblades.ClockKeeper.getSceneKeys(game.scenes.current.id);
  }
  // #region   >> Rendering (Dropping) Clock Keys ~
  dropKey_Animation(key, keyElems$) {
    const {
      container$,
      label$,
      imgContainer$,
      clocks
    } = keyElems$ ?? key.getElements$(game.eunoblades.Director.clockKeySection$);
    const keySwingTimeline = imgContainer$.data("keySwingTimeline");
    const tl = U.gsap.timeline().call(() => {
      keySwingTimeline.seek("NEUTRAL").play();
    }).from(container$, {
      y: -800,
      ease: "bounce",
      duration: 1
    }, 0).to(container$, { autoAlpha: 1, duration: 0.5, ease: "power2" }, 0);
    key.visibleClocks.forEach((clock, i) => {
      tl.add(
        () => {
          clock.reveal_Animation(clocks[clock.id]);
        },
        i === 0 ? ">" : "<+0.15"
      );
    });
    if (key.name && key.isNameVisible) {
      tl.blurReveal(label$, {
        ignoreMargin: true,
        duration: 0.75
      }, "<+0.05");
    }
  }
  prepareClockKeyTimelines(key, keyElems$) {
    const { container$, imgContainer$, elem$, label$, clocks } = keyElems$;
    U.gsap.set(container$, { pointerEvents: "auto" });
    U.gsap.set(elem$, { filter: "brightness(1)" });
    U.gsap.set(imgContainer$, { transformOrigin: "50% 10%" });
    const keyElemScale = U.gsap.getProperty(container$[0], "scale");
    imgContainer$.data(
      "keySwingTimeline",
      U.gsap.timeline({ paused: true, repeat: -1, yoyo: true }).fromTo(imgContainer$, { rotateZ: -1 }, { rotateZ: 1, duration: 3, ease: "sine.inOut" }).addLabel("NEUTRAL", 1.5).seek("NEUTRAL")
    );
    container$.data(
      "hoverOverTimeline",
      U.gsap.timeline({
        paused: true,
        data: { key, imgContainer$, label$, isNameRevealed: false },
        onStart() {
          this.data.imgContainer$.data("keySwingTimeline").tweenTo("NEUTRAL", {
            duration: 0.25,
            ease: "back.out(1.5)"
          });
          if (this.data.key.name && !this.data.key.isNameVisible) {
            this.data.isNameRevealed = true;
            U.gsap.effects.blurReveal(this.data.label$, {
              ignoreMargin: true,
              duration: 0.5
            });
          }
        },
        onReverseComplete() {
          this.data.imgContainer$.data("keySwingTimeline").seek("NEUTRAL").play();
          if (this.data.isNameRevealed) {
            this.data.isNameRevealed = false;
            U.gsap.effects.blurRemove(this.data.label$, {
              ignoreMargin: true,
              duration: 0.5
            });
          }
        }
      }).to(elem$, { filter: "brightness(1.5)", scale: keyElemScale * 1.25, duration: 0.5, ease: "sine" })
    );
    key.clocks.forEach((clock) => {
      const { clockContainer$, clockLabel$, clockElem$ } = clocks[clock.id];
      if (!(clockContainer$ == null ? void 0 : clockContainer$.length)) {
        throw new Error(`[BladesDirector.prepareClockKeyTimelines] Error clockContainer$ not found for clock '${clock.id}' of key '${key.id}'.`);
      }
      U.gsap.set(clockContainer$, { pointerEvents: "auto" });
      clockContainer$.data(
        "hoverOverTimeline",
        U.gsap.timeline({
          paused: true,
          data: { clock, clockLabel$, isNameRevealed: false },
          onStart() {
            if (this.data.clock.name && !this.data.clock.isNameVisible) {
              this.data.isNameRevealed = true;
              U.gsap.effects.blurReveal(this.data.clockLabel$, {
                ignoreMargin: true,
                duration: 0.5
              });
            }
          },
          onReverseComplete() {
            if (this.data.isNameRevealed) {
              this.data.isNameRevealed = false;
              U.gsap.effects.blurRemove(this.data.clockLabel$, {
                ignoreMargin: true,
                duration: 0.5
              });
            }
          }
        }).to(clockElem$, { filter: "brightness(1.5)", scale: 1.25, duration: 0.25, ease: "sine" })
      );
    });
  }
  async activateClockKeyListeners(key, keyElems$) {
    const { container$, clocks } = keyElems$;
    if (game.user.isGM) {
      container$.on("dblclick", async () => {
        var _a2;
        (_a2 = game.eunoblades.ClockKeeper.sheet) == null ? void 0 : _a2.render(true);
      });
      container$.on("contextmenu", async () => {
        this.pullKey_SocketCall(key.id);
        key.updateTarget("isVisible", false);
      });
    } else {
      container$.on("mouseenter", () => {
        container$.data("hoverOverTimeline").play();
      }).on("mouseleave", () => {
        container$.data("hoverOverTimeline").reverse();
      });
      key.clocks.forEach((clock) => {
        const { clockContainer$ } = clocks[clock.id];
        clockContainer$.on("mouseenter", () => {
          if (clock.isVisible) {
            clockContainer$.data("hoverOverTimeline").play();
          }
        }).on("mouseleave", () => {
          if (clock.isVisible) {
            clockContainer$.data("hoverOverTimeline").reverse();
          }
        });
      });
    }
  }
  async renderClockKey(key) {
    await key.renderTo(this.clockKeySection$);
    if (key.positionDragger) {
      key.removePositionDragger();
    }
    const keyElems$ = key.initElementsInContext(this.clockKeySection$, ClockKeyDisplayMode.full);
    if (key.overlayPosition) {
      U.gsap.set(keyElems$.container$, {
        left: key.overlayPosition.x,
        top: key.overlayPosition.y
      });
    }
    this.prepareClockKeyTimelines(key, keyElems$);
    this.activateClockKeyListeners(key, keyElems$);
    this.dropKey_Animation(key, keyElems$);
  }
  async renderClockKey_SocketCall(keyID) {
    if (!game.user.isGM) {
      return;
    }
    socketlib.system.executeForEveryone("renderClockKey_SocketCall", keyID);
  }
  static async renderClockKey_SocketResponse(keyID) {
    const key = game.eunoblades.ClockKeys.get(keyID);
    if (!key) {
      return;
    }
    game.eunoblades.Director.renderClockKey(key);
  }
  // #endregion
  // #region   >> Un-Rendering (Pulling) Clock Keys ~
  pullKey_Animation(key) {
    const { container$ } = key.getElements$(game.eunoblades.Director.clockKeySection$);
    U.gsap.timeline().to(container$, {
      y: -800,
      ease: "back.in(1)",
      duration: 0.75
    }).to(container$, {
      opacity: 0,
      ease: "power2.out",
      duration: 0.25
    }, 0.75).call(() => {
      container$.remove();
    });
  }
  async pullKey_SocketCall(keyID) {
    if (!game.user.isGM) {
      return;
    }
    socketlib.system.executeForEveryone("pullKey_SocketCall", keyID);
  }
  static pullKey_SocketResponse(keyID) {
    const key = game.eunoblades.ClockKeys.get(keyID);
    if (!key) {
      return;
    }
    game.eunoblades.Director.pullKey_Animation(key);
  }
  // #endregion
  // #endregion
  // #region SCORE PANEL ~
  // #region   >> INITIALIZATION ~
  initScorePanelSockets() {
  }
  // #endregion
  // ## Score Details
  // - Small panel overlapping corner of Location
  // - Engagement roll result
  // - Plan & Detail
  // - Target tier
  activateScorePanelListeners() {
  }
  // #endregion
  // #region LOCATIONS ~
  // #region   >> INITIALIZATION ~
  initLocationSockets() {
  }
  // #endregion
  // ## Locations
  // - District wrapper/header
  // - Faction wrapper/footer
  // - Location main
  // - Slide-scroll of sublocations
  activateLocationListeners() {
  }
  // #endregion
  // #region NPCs ~
  // #region   >> INITIALIZATION ~
  initNPCSockets() {
  }
  // #endregion// ## NPCs
  // - Linked to a location: When location is displayed, so are they.  *(Can be linked to District wrapper, main Location, or sublocations)*
  // - Portrait images close to the central location display, hover-over popups provide more detailed information from sheet or `BladesScore` instance
  activateNPCListeners() {
  }
  // #endregion
  // #region PCs, COHORTs, CREW ~
  // #region   >> INITIALIZATION ~
  initPCSockets() {
  }
  initCohortSockets() {
  }
  initCrewSockets() {
  }
  // #endregion
  // ## PCs
  // - Display panels along bottom
  // - Signal lights
  activatePCListeners() {
  }
  // ## Cohorts
  // - Smaller panels alongside the PCs
  activateCohortListeners() {
  }
  // ## Crew
  // - Limited information displayed, maybe bar beneath PCs showing Heat, Wanted Level…
  activateCrewListeners() {
  }
  // #endregion
  // #region NOTIFICATIONS ~
  // #region   >> INITIALIZATION ~
  initNotificationSockets() {
    socketlib.system.register("pushNotice_SocketCall", _BladesDirector.pushNotice_SocketResponse.bind(_BladesDirector));
  }
  // #endregion
  _isNoticeForUser(user, target) {
    var _a2, _b;
    return game.user.isGM || [
      user.id,
      user.name,
      (_a2 = user.character) == null ? void 0 : _a2.id,
      (_b = user.character) == null ? void 0 : _b.name
    ].includes(target);
  }
  pushNotice_SocketCall(targets, config3) {
    const pushID = randomID();
    if (typeof targets === "string") {
      if (targets === "ALL") {
        return socketlib.system.executeForEveryone("pushNotice_SocketCall", pushID, config3);
      } else if (targets === "GM") {
        return socketlib.system.executeForAllGMs("pushNotice_SocketCall", pushID, config3);
      } else {
        targets = game.users.filter((user) => this._isNoticeForUser(user, targets)).map((user) => user.id);
      }
    }
    if (targets.length > 0) {
      return socketlib.system.executeForUsers("pushNotice_SocketCall", targets, pushID, config3);
    }
    return void 0;
  }
  static async pushNotice_SocketResponse(pushID, config3) {
    const director = game.eunoblades.Director;
    const pushElem$ = $(await renderTemplate("systems/eunos-blades/templates/overlay/notices/push.hbs", {
      id: pushID,
      ...config3
    })).appendTo(director.notificationSection$).on("click", (event) => {
      director.removePush(event.currentTarget);
    }).on("contextmenu", (event) => {
      director.removeAndClear(event.currentTarget);
    });
    U.gsap.fromTo(
      pushElem$,
      {
        x: 200,
        skewX: 20,
        autoAlpha: 0,
        filter: "blur(10px)"
      },
      {
        x: 0,
        skewX: 0,
        autoAlpha: 1,
        filter: "blur(0px)",
        duration: 0.5,
        ease: "back"
      }
    );
  }
  async removePush(target) {
    U.gsap.to(
      target,
      {
        x: "+=200",
        autoAlpha: 0,
        ease: "power2",
        duration: 0.5,
        onComplete() {
          $(target).remove();
        }
      }
    );
  }
  async removeAndClear(target) {
    const targets = $(target).prevAll().get().reverse();
    targets.unshift(target);
    U.gsap.to(
      targets,
      {
        x: "+=200",
        autoAlpha: 0,
        ease: "power2",
        duration: 0.5,
        stagger: {
          each: 0.5,
          from: "start",
          ease: "power1.inOut"
        },
        onComplete() {
          targets.forEach((targ) => $(targ).remove());
        }
      }
    );
  }
  // #endregion
  // #region TRANSITIONS ~
  // #region   >> INITIALIZATION ~
  initTransitionSockets() {
  }
  // #endregion
  // ## Transitions
  async advanceGamePhase(phase) {
    var _a2;
    const nextPhase = U.gsap.utils.wrap(
      Object.values(BladesPhase),
      Object.values(BladesPhase).indexOf(phase ?? ((_a2 = game.eunoblades.Tracker) == null ? void 0 : _a2.phase) ?? BladesPhase.Freeplay) + 1
    );
    console.log(`NEXT PHASE TRIGGERED: ${nextPhase}`);
  }
  getTooltipFinalRect(tooltip$, trigger$, side, padding = 15) {
    const tooltipRect = U.getMutableRect(tooltip$[0].getBoundingClientRect());
    const triggerRect = U.getMutableRect(trigger$[0].getBoundingClientRect());
    const triggerCenter = {
      x: triggerRect.left + 0.5 * triggerRect.width,
      y: triggerRect.top + 0.5 * triggerRect.height
    };
    switch (side) {
      case "top": {
        tooltipRect.bottom = triggerRect.top - padding;
        tooltipRect.top = tooltipRect.bottom - tooltipRect.height;
        tooltipRect.right = triggerCenter.x + 0.5 * tooltipRect.width;
        tooltipRect.left = tooltipRect.right - tooltipRect.width;
        break;
      }
      case "left": {
        tooltipRect.right = triggerRect.left - padding;
        tooltipRect.left = tooltipRect.right - tooltipRect.width;
        tooltipRect.bottom = triggerCenter.y + 0.5 * tooltipRect.height;
        tooltipRect.top = tooltipRect.bottom - tooltipRect.height;
        break;
      }
      case "right": {
        tooltipRect.left = triggerRect.right + padding;
        tooltipRect.right = tooltipRect.left + tooltipRect.width;
        tooltipRect.bottom = triggerCenter.y + 0.5 * tooltipRect.height;
        tooltipRect.top = tooltipRect.bottom - tooltipRect.height;
        break;
      }
      case "bottom": {
        tooltipRect.top = triggerRect.bottom + padding;
        tooltipRect.bottom = tooltipRect.top + tooltipRect.height;
        tooltipRect.right = triggerCenter.x + 0.5 * tooltipRect.width;
        tooltipRect.left = tooltipRect.right - tooltipRect.width;
        break;
      }
    }
    tooltipRect.x = tooltipRect.left;
    tooltipRect.y = tooltipRect.top;
    return tooltipRect;
  }
  /**
  * Calculates the necessary adjustments to make one DOMRect fit entirely within another.
  * @param innerRect The DOMRect to adjust to fit within the outerRect.
  * @param outerRect The DOMRect that should contain the innerRect.
  * @returns A Partial<DOMRect> with properties x and y indicating the necessary adjustments, or an empty object if no adjustment is needed.
  * @throws Error if innerRect is larger than outerRect in either dimension.
  */
  getAdjustedTooltipFinalRect(tooltipRect, side, padding = 25) {
    const containerRect = U.getMutableRect(this.tooltipSection$[0].getBoundingClientRect());
    containerRect.left = containerRect.left + padding;
    containerRect.right = containerRect.right - padding;
    containerRect.width = containerRect.width - 2 * padding;
    containerRect.top = containerRect.top + padding;
    containerRect.bottom = containerRect.bottom - padding;
    containerRect.height = containerRect.height - 2 * padding;
    if (tooltipRect.width > containerRect.width || tooltipRect.height > containerRect.height) {
      throw new Error("innerRect is larger than outerRect and cannot be made to fit.");
    }
    let deltaX = 0;
    let deltaY = 0;
    if (tooltipRect.x < containerRect.x) {
      deltaX = containerRect.x - tooltipRect.x;
    } else if (tooltipRect.right > containerRect.right) {
      deltaX = containerRect.right - tooltipRect.right;
    }
    if (tooltipRect.y < containerRect.y) {
      deltaY = containerRect.y - tooltipRect.y;
    } else if (tooltipRect.bottom > containerRect.bottom) {
      deltaY = containerRect.bottom - tooltipRect.bottom;
    }
    switch (side) {
      case "top": {
        if (deltaY > 0) {
          eLog.error("[adjustTooltipFinalRect] Error adjusting tooltip position.", { tooltipRect, side, padding, containerRect, deltaX, deltaY });
          throw new Error(`[adjustTooltipFinalRect] "top"-aligned tooltip requires shift down (deltaY = ${deltaY}`);
        }
        break;
      }
      case "bottom": {
        if (deltaY < 0) {
          eLog.error("[adjustTooltipFinalRect] Error adjusting tooltip position.", { tooltipRect, side, padding, containerRect, deltaX, deltaY });
          throw new Error(`[adjustTooltipFinalRect] "bottom"-aligned tooltip requires shift up (deltaY = ${deltaY}`);
        }
        break;
      }
      case "left": {
        if (deltaX > 0) {
          eLog.error("[adjustTooltipFinalRect] Error adjusting tooltip position.", { tooltipRect, side, padding, containerRect, deltaX, deltaY });
          throw new Error(`[adjustTooltipFinalRect] "left"-aligned tooltip requires shift right (deltaX = ${deltaX}`);
        }
        break;
      }
      case "right": {
        if (deltaX < 0) {
          eLog.error("[adjustTooltipFinalRect] Error adjusting tooltip position.", { tooltipRect, side, padding, containerRect, deltaX, deltaY });
          throw new Error(`[adjustTooltipFinalRect] "right"-aligned tooltip requires shift left (deltaX = ${deltaX}`);
        }
        break;
      }
    }
    tooltipRect.left += deltaX;
    tooltipRect.right += deltaX;
    tooltipRect.x += deltaX;
    tooltipRect.top += deltaY;
    tooltipRect.bottom += deltaY;
    tooltipRect.y += deltaY;
    return { ...tooltipRect };
  }
  canTooltipFit(tooltip$, trigger$, side, padding = 50) {
    const tooltipRect = this.getTooltipFinalRect(tooltip$, trigger$, side);
    const containerRect = this.tooltipSection$[0].getBoundingClientRect();
    if (["top", "left"].includes(side)) {
      if (tooltipRect[side] >= containerRect[side] + padding) {
        return true;
      }
    } else if (tooltipRect[side] < containerRect[side] - padding) {
      return true;
    }
    return false;
  }
  /**
   * Adjusts the tooltip's position to ensure it remains within its parent container using jQuery methods.
   * @param tooltip - The tooltip element, which can be either an HTMLElement or a JQuery.
   */
  getTooltipSide(tooltip$, trigger$) {
    if (tooltip$.css("position") !== "absolute") {
      throw new Error("Tooltip position must be 'absolute'.");
    }
    const preferredSides = [
      "top",
      "left",
      "right",
      "bottom"
    ];
    const side = preferredSides.find((pSide) => this.canTooltipFit(tooltip$, trigger$, pSide));
    if (!side) {
      throw new Error("Unable to determine side for tooltip.");
    }
    return side;
  }
  async displayTooltip(tooltip) {
    var _a2;
    if (!tooltip.id) {
      throw new Error("Tooltip must have an ID to be cloned to the overlay.");
    }
    if (tooltip.id === this._displayedTooltipID) {
      eLog.error("displayTooltip", `Tooltip with id '${tooltip.id}' already displayed: Not re-rendering.`);
      return;
    }
    this._displayedTooltipID = tooltip.id;
    const tooltip$ = $(tooltip);
    const trigger$ = tooltip$.closest(".tooltip-trigger");
    await this.clearTooltips();
    const ttClone$ = $(U.changeContainer(
      tooltip,
      this.tooltipSection$[0],
      true
    ));
    const side = this.getTooltipSide(ttClone$, trigger$);
    const tooltipAdjustedRect = { ...this.getAdjustedTooltipFinalRect(this.getTooltipFinalRect(ttClone$, trigger$, side), side) };
    U.set(ttClone$, { y: tooltipAdjustedRect.top, x: tooltipAdjustedRect.left });
    const revealTimeline = U.gsap.effects.blurRevealTooltip(
      ttClone$[0],
      {
        // onInterrupt() { ttClone$.remove(); },
        tooltipDirection: side,
        trigger$,
        tTipSource$: $(tooltip)
      }
    );
    ttClone$.data("revealTimeline", revealTimeline);
    (_a2 = ttClone$.data("revealTimeline")) == null ? void 0 : _a2.play();
  }
  async clearTooltip(tooltipID, isClearingIfTweening = true) {
    if (tooltipID === this._displayedTooltipID) {
      delete this._displayedTooltipID;
    }
    const ttElem$ = this.tooltipSection$.find(`#${tooltipID}`);
    if (!ttElem$.length) {
      return;
    }
    const ttTimeline = ttElem$.data("revealTimeline");
    if (ttTimeline.isActive() && !isClearingIfTweening) {
      return;
    }
    await new Promise((resolve) => {
      if (ttTimeline.progress() === 0) {
        resolve();
      }
      ttTimeline.eventCallback("onReverseComplete", () => {
        resolve();
      });
      ttTimeline.reverse();
    });
    U.gsap.killTweensOf(ttElem$);
    ttElem$.remove();
  }
  async clearTooltips() {
    const self2 = this;
    return Promise.all(
      Array.from(self2.tooltipSection$.find(".tooltip")).map((ttElem) => {
        const ttElem$ = $(ttElem);
        const ttID = ttElem$.attr("id");
        if (!ttID) {
          eLog.error("clearTooltips", "Cloned tooltip without ID", ttElem$);
          throw new Error("[BladesDirector.clearTooltips] Cloned tooltip missing ID. See log for details.");
        }
        return self2.clearTooltip(ttID, true);
      })
    );
  }
  initTooltipSection() {
    var _a2;
    const self2 = this;
    this.clearTooltips();
    (_a2 = this._tooltipObserver) == null ? void 0 : _a2.kill();
    const throttle = (func, timeLimit, distanceLimit) => {
      let lastRan;
      let lastPos;
      return function(obs) {
        const now = Date.now();
        const thisPos = { x: obs.x, y: obs.y };
        if (!lastRan || now - lastRan >= timeLimit) {
          if (!lastPos || U.getDistance(lastPos, thisPos) >= distanceLimit) {
            func(obs);
          }
          lastRan = now;
          lastPos = thisPos;
        }
      };
    };
    this._tooltipObserver = Observer.create({
      type: "touch, pointer",
      onMove: throttle(() => {
        self2.clearTooltips();
      }, 200, 100),
      onClick: () => {
        self2.clearTooltips();
      }
    });
  }
  // #endregion
};
// #region INITIALIZATION ~
// #region   >>  Single-Instance Factory Construction ~
__publicField(_BladesDirector, "instance");
let BladesDirector = _BladesDirector;
class BladesConsequence extends BladesTargetLink {
  // #region Static Methods ~
  static async Initialize() {
    if (!game.messages) {
      throw new Error("[BladesConsequence] Messages Not Ready!");
    }
    return (await Promise.all(game.messages.contents.map(async (msg) => msg.rollConsequences))).flat();
  }
  /**
  * Checks if the given value is valid consequence data for a Resistance Roll.
  * @param val The value to check.
  * @param isCheckingResistedTo If the check is being recursively applied to the 'resistTo' value.
  * @returns True if the val is valid BladesConsequence.Data, false otherwise.
  */
  static IsValidConsequenceData(val, isCheckingResistedTo = false) {
    if (!U.isList(val)) {
      return false;
    }
    if (typeof val.type !== "string" || !(val.type in ConsequenceType)) {
      return false;
    }
    if (typeof val.name !== "string") {
      return false;
    }
    if (isCheckingResistedTo) {
      return true;
    }
    if (val.attribute && (typeof val.attribute !== "string" || !(val.attribute in AttributeTrait))) {
      return false;
    }
    if (!this.IsValidConsequenceData(val.resistTo, true)) {
      return false;
    }
    return true;
  }
  static ApplySchemaDefaults(schemaData) {
    if (!schemaData.primaryID) {
      throw new Error("A primaryID is required for BladesConsequence.Schema");
    }
    if (typeof schemaData.name === "string" && (!schemaData.name && schemaData.type !== ConsequenceType.None)) {
      throw new Error(`A name must be provided for non-None-type consequences (${schemaData.name}).`);
    }
    return {
      name: "",
      type: ConsequenceType.None,
      ...schemaData
    };
  }
  static GetCsqTypeValue(cType, rollData) {
    if (cType === ConsequenceType.WorsePosition) {
      if (!rollData) {
        throw new Error(`Cannot resolve consequence type value for '${cType}' without roll data.`);
      }
      let position;
      if ("rollPositionFinal" in rollData) {
        position = rollData.rollPositionFinal;
      } else if ("position" in rollData) {
        position = rollData.position;
      }
      if (!position) {
        throw new Error(`Cannot resolve consequence type value for '${cType}' without roll data that includes final position data.`);
      }
      return {
        [Position.controlled]: 1,
        [Position.risky]: 2,
        [Position.desperate]: 0
      }[position];
    }
    if (cType === ConsequenceType.ReducedEffect) {
      if (!rollData) {
        throw new Error(`Cannot resolve consequence type value for '${cType}' without roll data.`);
      }
      let effect;
      if ("rollEffectFinal" in rollData) {
        effect = rollData.rollEffectFinal;
      } else if ("effect" in rollData) {
        effect = rollData.effect;
      }
      if (!effect) {
        throw new Error(`Cannot resolve consequence type value for '${cType}' without roll data that includes final effect data.`);
      }
      return {
        [Effect.extreme]: 1,
        [Effect.great]: 1,
        [Effect.standard]: 1,
        [Effect.limited]: 2,
        [Effect.zero]: 0
      }[effect];
    }
    return C.ConsequenceValues[cType];
  }
  // #endregion
  // #region *** GETTERS *** ~
  // #region Getters (Target Data) ~
  get primaryID() {
    var _a2;
    return this.data.primaryID ?? ((_a2 = this.parentConsequence) == null ? void 0 : _a2.primaryID);
  }
  get parentCsqID() {
    return this.data.parentCsqID;
  }
  get name() {
    return this.data.name;
  }
  get type() {
    return this.data.type;
  }
  get attribute() {
    var _a2;
    return this.data.attribute ?? ((_a2 = this.parentConsequence) == null ? void 0 : _a2.attribute);
  }
  get attributeVal() {
    var _a2;
    return this.data.attributeVal ?? ((_a2 = this.parentConsequence) == null ? void 0 : _a2.attributeVal);
  }
  get specialFooterMsg() {
    var _a2;
    return this.data.specialFooterMsg ?? ((_a2 = this.parentConsequence) == null ? void 0 : _a2.specialFooterMsg);
  }
  // #endregion
  // #region Getters (Derived Data) ~
  get primary() {
    const primary = fromUuidSync(this.primaryID);
    if (!BladesRollPrimary.IsDoc(primary)) {
      throw new Error(`Could not find primary with UUID '${this.primaryID}'`);
    }
    if (this.roll) {
      return new BladesRollPrimary(this.roll, primary);
    }
    return new BladesRollPrimary(primary);
  }
  get parentConsequence() {
    if (!this.parentCsqID) {
      return void 0;
    }
    const parentCsq = game.eunoblades.Consequences.get(this.parentCsqID);
    if (!parentCsq) {
      throw new Error(`Error locating parent consequence with id '${this.parentCsqID}'`);
    }
    return parentCsq;
  }
  get typeDisplay() {
    return C.ConsequenceDisplay[this.type];
  }
  get icon() {
    return C.ConsequenceIcons[this.type];
  }
  get value() {
    return BladesConsequence.GetCsqTypeValue(this.type, this);
  }
  // #endregion
  // #region Getters (Resolved Roll Data that Applied This Consequence) ~
  get rollData() {
    var _a2;
    return this.data.actionRollData ?? ((_a2 = this.parentConsequence) == null ? void 0 : _a2.rollData);
  }
  get roll() {
    if (!this.rollData) {
      return void 0;
    }
    return game.eunoblades.Rolls.get(this.rollData.id) ?? new BladesRoll$1({
      ...this.rollData,
      isScopingById: false
    });
  }
  get position() {
    var _a2;
    return (_a2 = this.roll) == null ? void 0 : _a2.rollPositionFinal;
  }
  get effect() {
    var _a2;
    return (_a2 = this.roll) == null ? void 0 : _a2.rollEffectFinal;
  }
  get result() {
    var _a2;
    return (_a2 = this.roll) == null ? void 0 : _a2.rollResultFinal;
  }
  // #endregion
  // #region Getters (Resistibility & Acceptance Status) ~
  isResistible() {
    return Boolean(this.type !== ConsequenceType.None && !this.isAccepted && this.data.resistSchema);
  }
  get resistanceModes() {
    return this.data.resistanceModes ?? [];
  }
  get wasResisted() {
    return Boolean(this.resistanceModes.length);
  }
  get wasResistedByRoll() {
    return this.resistanceModes.includes("resist");
  }
  get wasResistedByArmor() {
    return this.resistanceModes.includes("armor");
  }
  get wasResistedBySpecialArmor() {
    var _a2;
    return (_a2 = this.resistanceModes) == null ? void 0 : _a2.includes("special");
  }
  get canResistWithRoll() {
    if (!this.isResistible()) {
      return false;
    }
    if (!BladesPC$1.IsType(this.primary.rollPrimaryDoc)) {
      return false;
    }
    if (this.wasResistedByRoll) {
      return false;
    }
    return true;
  }
  get canResistWithArmor() {
    if (!this.isResistible()) {
      return false;
    }
    if (!this.data.canResistWithArmor) {
      return false;
    }
    return this.primary.availableArmorCount > 0;
  }
  get canResistWithSpecial() {
    if (!this.isResistible()) {
      return false;
    }
    if (!this.data.canResistWithSpecial) {
      return false;
    }
    if (!BladesPC$1.IsType(this.primary.rollPrimaryDoc)) {
      return false;
    }
    if (this.wasResistedBySpecialArmor) {
      return false;
    }
    return this.primary.hasSpecialArmor;
  }
  get resistWithRollNegates() {
    if (!this.canResistWithRoll) {
      return false;
    }
    if (this.wasResisted) {
      return true;
    }
    return Boolean(this.data.resistWithRollNegates);
  }
  get resistWithArmorNegates() {
    if (!this.canResistWithArmor) {
      return false;
    }
    if (this.wasResisted) {
      return true;
    }
    return Boolean(this.data.resistWithArmorNegates);
  }
  get resistWithSpecialNegates() {
    if (!this.canResistWithSpecial) {
      return false;
    }
    if (this.wasResisted) {
      return true;
    }
    return Boolean(this.data.resistWithSpecialNegates);
  }
  get isAccepted() {
    return "acceptanceMode" in this.data;
  }
  get acceptanceMode() {
    return this.data.acceptanceMode;
  }
  // #endregion
  // #endregion
  // #region *** RESISTING CONSEQUENCES ***
  // #region Constructing Resistable Consequence Schema
  get noneSchema() {
    return {
      name: "",
      type: ConsequenceType.None,
      primaryID: this.primaryID
    };
  }
  get resistSchema() {
    if (!this.isResistible()) {
      return void 0;
    }
    const resSchema = {
      name: this.data.resistSchema.name,
      type: this.data.resistSchema.type,
      primaryID: this.primaryID,
      resistSchema: {
        name: "",
        type: ConsequenceType.None
      },
      resistanceModes: this.resistanceModes,
      resistWithRollNegates: true,
      attribute: this.attribute,
      attributeVal: this.attributeVal,
      canResistWithArmor: this.canResistWithArmor,
      resistWithArmorNegates: true,
      canResistWithSpecial: this.canResistWithSpecial,
      resistWithSpecialNegates: true,
      specialFooterMsg: this.specialFooterMsg
    };
    if (this.wasResisted) {
      resSchema.name = "";
      resSchema.type = ConsequenceType.None;
      delete resSchema.resistSchema;
      resSchema.canResistWithArmor = false;
      resSchema.canResistWithSpecial = false;
    }
    return resSchema;
  }
  // #endregion
  async resistConsequence(resistMode, rollInstance) {
    if (!this.isResistible()) {
      throw new Error("Cannot resist a consequence that is not resistible.");
    }
    const updateData = {
      resistanceModes: this.resistanceModes,
      ...this.resistSchema
    };
    updateData.resistanceModes.push(resistMode);
    updateData.parentCsqID = void 0;
    if (resistMode === "resist") {
      if (!(rollInstance == null ? void 0 : rollInstance.isResolved)) {
        throw new Error("Cannot transform to resisted consequence without a resolved resistance roll instance.");
      }
      updateData.resistanceRollData = rollInstance.data;
    }
    if (this.wasResisted || updateData.type === ConsequenceType.None) {
      updateData.acceptanceMode = "base";
    } else if (resistMode === "resist" && !this.canResistWithArmor && !this.canResistWithSpecial) {
      updateData.acceptanceMode = resistMode;
    }
    await this.updateTargetData(updateData);
    if (updateData.acceptanceMode) {
      socketlib.system.executeForEveryone("acceptConsequence_SocketCall", this.id);
    } else {
      socketlib.system.executeForEveryone("resistConsequence_SocketCall", this.id);
    }
  }
  // #endregion
  // #region *** ACCEPTING CONSEQUENCES ***
  async acceptConsequence() {
    if (this.isAccepted) {
      return;
    }
    await this.updateTarget("acceptanceMode", U.getLast(this.resistanceModes) ?? "accept");
    socketlib.system.executeForEveryone("acceptConsequence_SocketCall", this.id);
  }
  async applyConsequenceEffects() {
    if (/Harm/.test(this.type)) {
      this.primary.applyHarm(
        U.pInt(this.type.substring(this.type.length - 1)),
        this.name
      );
    } else if (this.type === ConsequenceType.WorsePosition) {
      this.primary.applyWorsePosition();
    } else if (this.type === ConsequenceType.ReducedEffect) {
      const curIndex = Object.values(Effect).findIndex((val) => val === this.effect);
      if (curIndex >= 1) {
        const newEffect = Object.values(Effect)[curIndex - 1];
        await this.updateTarget("rollData.rollEffectFinal", newEffect);
      }
    }
  }
  // #endregion
  // #region === CONSTRUCTOR === ~
  // constructor(
  //   config: BladesConsequence.Config,
  //   parentCsq?: BladesConsequence.Data
  // )
  // constructor(
  //   data: BladesConsequence.Data
  // )
  // constructor(
  //   schema: Partial<BladesConsequence.Schema>,
  //   parentCsq: BladesConsequence.Data
  // )
  // constructor(
  //   dataConfigOrSchema: BladesConsequence.Config | BladesConsequence.Data | Partial<BladesConsequence.Schema>,
  //   parentCsq?: BladesConsequence.Data
  // ) {
  //   // If a parentCsq is provided...
  //   if (parentCsq) {
  //     super({
  //       ...BladesTargetLink.BuildLinkConfig(parentCsq),
  //       ...dataConfigOrSchema
  //     });
  //   } else {
  //     super(dataConfigOrSchema as BladesConsequence.Config | BladesConsequence.Data);
  //   }
  // }
  // #endregion
  // #region *** HTML INTERACTION ***
  // #region *** BladesDialog *** ~
  // #endregion
  // #region *** BladesChat *** ~
  static ApplyChatListeners(message) {
    const html$ = message.elem$;
    html$.find(".comp.consequence-display-container").each((_i, csqContainer) => {
      if (!$(csqContainer).hasClass("consequence-accepted")) {
        const iconContainer$ = $(csqContainer).find(".consequence-icon-container");
        const rightInteractionPad$ = $(csqContainer).find(".interaction-pad-right");
        const leftInteractionPad$ = $(csqContainer).find(".interaction-pad-left");
        const resistInteractionPad$ = $(csqContainer).find(".interaction-pad-left-resist");
        const armorInteractionPad$ = $(csqContainer).find(".interaction-pad-left-armor");
        const specialInteractionPad$ = $(csqContainer).find(".interaction-pad-left-special");
        $(csqContainer).data("hoverTimeline", U.gsap.effects.csqEnter(csqContainer));
        $(csqContainer).on({
          mouseenter: function() {
            $(csqContainer).css("z-index", 10);
            $(csqContainer).data("hoverTimeline").play();
          },
          mouseleave: function() {
            if (!(iconContainer$.data("isToggled") || iconContainer$.data("isTogglingOn")) || iconContainer$.data("isTogglingOff")) {
              $(csqContainer).data("hoverTimeline").reverse().then(() => {
                $(csqContainer).css("z-index", "");
              });
            }
          }
        });
        iconContainer$.data("clickTimeline", U.gsap.effects.csqClickIcon(iconContainer$[0]));
        iconContainer$.on({
          click: function() {
            if (iconContainer$.data("isToggled") || iconContainer$.data("isTogglingOn")) {
              iconContainer$.data("isTogglingOn", false);
              iconContainer$.data("isTogglingOff", true);
              iconContainer$.data("clickTimeline").reverse().then(() => {
                iconContainer$.data("isTogglingOff", false);
                iconContainer$.data("isToggled", false);
              });
            } else {
              iconContainer$.data("isTogglingOn", true);
              iconContainer$.data("isTogglingOff", false);
              Array.from($(csqContainer).siblings(".consequence-display-container")).forEach((containerElem) => {
                const iContainer$ = $(containerElem).find(".consequence-icon-container");
                if ((iContainer$ == null ? void 0 : iContainer$.data("isToggled")) || (iContainer$ == null ? void 0 : iContainer$.data("isTogglingOn"))) {
                  iContainer$.data("isTogglingOn", false);
                  iContainer$.data("isTogglingOff", true);
                  iContainer$.data("clickTimeline").reverse().then(() => {
                    iContainer$.data("isTogglingOff", false);
                    iContainer$.data("isToggled", false);
                    $(containerElem).data("hoverTimeline").reverse().then(() => {
                      $(containerElem).css("z-index", "");
                    });
                  });
                }
              });
              iconContainer$.data("clickTimeline").play().then(() => {
                iconContainer$.data("isTogglingOn", false);
                iconContainer$.data("isToggled", true);
              });
            }
          }
        });
        rightInteractionPad$.data("hoverTimeline", U.gsap.effects.csqEnterRight(csqContainer));
        rightInteractionPad$.on({
          mouseenter: function() {
            if (iconContainer$.data("isToggled")) {
              rightInteractionPad$.data("hoverTimeline").play();
            }
          },
          mouseleave: function() {
            rightInteractionPad$.data("hoverTimeline").reverse();
          }
        });
        leftInteractionPad$.data("hoverTimeline", U.gsap.effects.csqEnterLeft(csqContainer));
        leftInteractionPad$.on({
          mouseenter: function() {
            if (iconContainer$.data("isToggled")) {
              leftInteractionPad$.data("hoverTimeline").play();
            }
          },
          mouseleave: function() {
            leftInteractionPad$.data("hoverTimeline").reverse();
          }
        });
        resistInteractionPad$.data("hoverTimeline", U.gsap.effects.csqEnterSubLeft(csqContainer, { type: "resist" }));
        resistInteractionPad$.on({
          mouseenter: function() {
            if (iconContainer$.data("isToggled")) {
              resistInteractionPad$.data("hoverTimeline").play();
            }
          },
          mouseleave: function() {
            if (iconContainer$.data("isToggled")) {
              resistInteractionPad$.data("hoverTimeline").reverse();
            }
          }
        });
        armorInteractionPad$.data("hoverTimeline", U.gsap.effects.csqEnterSubLeft(csqContainer, { type: "armor" }));
        armorInteractionPad$.on({
          mouseenter: function() {
            if (iconContainer$.data("isToggled")) {
              armorInteractionPad$.data("hoverTimeline").play();
            }
          },
          mouseleave: function() {
            if (iconContainer$.data("isToggled")) {
              armorInteractionPad$.data("hoverTimeline").reverse();
            }
          }
        });
        specialInteractionPad$.data("hoverTimeline", U.gsap.effects.csqEnterSubLeft(csqContainer, { type: "special" }));
        specialInteractionPad$.on({
          mouseenter: function() {
            if (iconContainer$.data("isToggled")) {
              specialInteractionPad$.data("hoverTimeline").play();
            }
          },
          mouseleave: function() {
            if (iconContainer$.data("isToggled")) {
              specialInteractionPad$.data("hoverTimeline").reverse();
            }
          }
        });
      }
    });
  }
  // #endregion
  // #endregion
}
var SelectionCategory = /* @__PURE__ */ ((SelectionCategory2) => {
  SelectionCategory2["Heritage"] = "Heritage";
  SelectionCategory2["Background"] = "Background";
  SelectionCategory2["Vice"] = "Vice";
  SelectionCategory2["Playbook"] = "Playbook";
  SelectionCategory2["Reputation"] = "Reputation";
  SelectionCategory2["Preferred_Op"] = "Preferred_Op";
  SelectionCategory2["Gear"] = "Gear";
  SelectionCategory2["Ability"] = "Ability";
  SelectionCategory2["Faction"] = "Faction";
  SelectionCategory2["Upgrade"] = "Upgrade";
  SelectionCategory2["Cohort_Gang"] = "Cohort_Gang";
  SelectionCategory2["Cohort_Expert"] = "Cohort_Expert";
  SelectionCategory2["Feature"] = "Feature";
  SelectionCategory2["Stricture"] = "Stricture";
  SelectionCategory2["VicePurveyor"] = "VicePurveyor";
  SelectionCategory2["Acquaintance"] = "Acquaintance";
  SelectionCategory2["Friend"] = "Friend";
  SelectionCategory2["Rival"] = "Rival";
  SelectionCategory2["Crew"] = "Crew";
  SelectionCategory2["Member"] = "Member";
  SelectionCategory2["Contact"] = "Contact";
  return SelectionCategory2;
})(SelectionCategory || {});
class BladesDialog extends Dialog {
  constructor(data, options) {
    super(data, options);
    __publicField(this, "parent");
    __publicField(this, "tabs");
    __publicField(this, "dialogType");
    __publicField(this, "tags", []);
    __publicField(this, "width");
    __publicField(this, "docType");
    // csqData?: Record<
    // Position,
    // Record<
    //   RollResult.partial|RollResult.fail,
    //   Record<
    //     string,
    //     BladesRoll.ConsequenceData
    //     >
    //   >
    // >;
    __publicField(this, "prompt");
    __publicField(this, "target");
    __publicField(this, "flagTarget");
    this.dialogType = data.dialogType ?? "Selection";
    this.parent = data.parent;
    this.width = (options == null ? void 0 : options.width) ?? 500;
    this.prompt = data.prompt;
    this.target = data.target;
    this.flagTarget = data.flagTarget;
    switch (this.dialogType) {
      case "Input":
        return;
      case "Selection":
        this.constructSelectionData(
          data
          /* , options */
        );
        return;
      default:
        throw new Error(`Unrecognized type for BladesDialog constructor: '${this.dialogType}'`);
    }
  }
  static get defaultOptions() {
    return foundry.utils.mergeObject(super.defaultOptions, {
      classes: ["eunos-blades", "sheet", "dialog"],
      width: "auto",
      height: "auto",
      tabs: [{ navSelector: ".nav-tabs", contentSelector: ".tab-content", initial: "front" }]
    });
  }
  static Initialize() {
    return loadTemplates([
      "systems/eunos-blades/templates/dialog-selection.hbs",
      "systems/eunos-blades/templates/dialog-consequence.hbs",
      "systems/eunos-blades/templates/dialog-input.hbs",
      "systems/eunos-blades/templates/parts/dialog-consequence-block.hbs"
    ]);
  }
  static async DisplaySimpleInputDialog(parent, prompt, target, flagTarget) {
    const app = new BladesDialog({
      parent,
      title: parent instanceof BladesRoll$1 ? "Roll Input" : `${parent.name}: Input`,
      dialogType: "Input",
      content: "",
      prompt,
      target,
      flagTarget,
      buttons: {
        apply: {
          icon: '<i class="fa-solid fa-arrow-down-to-arc"></i>',
          label: "Apply",
          callback: (html) => app
          //   .writeToRollInstance(html as JQuery<HTMLElement>)
        },
        cancel: {
          icon: '<i class="fas fa-times"></i>',
          label: game.i18n.localize("Cancel"),
          callback: (html) => {
            eLog.checkLog3("dialog", "Callback Scope", { this: app, html });
            return false;
          }
        }
      },
      default: "apply"
    }, { classes: ["eunos-blades", "sheet", "dialog", "simple-input-dialog"] });
    return app._render(true, { width: app.width }).then(() => eLog.checkLog3("dialog", "Input Dialog Instance", { this: app }));
  }
  static async DisplaySelectionDialog(parent, title, docType, tabs, tags) {
    const app = new BladesDialog({
      parent,
      title,
      docType,
      tabs,
      tags: tags == null ? void 0 : tags.filter((tag) => tag !== ""),
      content: "",
      buttons: {
        cancel: {
          icon: '<i class="fas fa-times"></i>',
          label: game.i18n.localize("Cancel"),
          callback: (html) => {
            eLog.checkLog3("dialog", "Callback Scope", { this: this, html });
            return false;
          }
        }
      },
      default: "cancel"
    });
    return app.hasItems ? app.render(true, { width: app.width }) : void 0;
  }
  // static async DisplayRollConsequenceDialog(rollInst: BladesRoll) {
  // const app: BladesDialog = new BladesDialog({
  //   parent: rollInst,
  //   title: "Consequences",
  //   dialogType: BladesDialogType.Consequence,
  //   content: "",
  //   buttons: {
  //     apply: {
  //       icon: '<i class="fa-solid fa-arrow-down-to-arc"></i>',
  //       label: "Apply",
  //       callback: (html: HTMLElement|JQuery<HTMLElement>) => (app as BladesDialog)
  //         .writeToRollInstance(html as JQuery<HTMLElement>)
  //     },
  //     cancel: {
  //       icon: '<i class="fas fa-times"></i>',
  //       label: game.i18n.localize("Cancel"),
  //       callback: (html: JQuery|HTMLElement) => {
  //         eLog.checkLog3("dialog", "Callback Scope", {this: app, html});
  //         return false;
  //       }
  //     }
  //   },
  //   default: "apply"
  // }, {classes: ["eunos-blades", "sheet", "dialog", "consequence-dialog"]});
  // return app._render(true, {width: app.width}).then(() => eLog.checkLog3("dialog", "Dialog Instance", {this: app}));
  // }
  get template() {
    return `systems/eunos-blades/templates/dialog-${U.lCase(this.dialogType)}.hbs`;
  }
  get hasItems() {
    return Object.values(this.tabs ?? []).some((tabItems) => tabItems.length > 0);
  }
  constructSelectionData(data) {
    const validTabs = [];
    if (!data.tabs) {
      return;
    }
    for (const [tabName, tabItems] of Object.entries(data.tabs)) {
      if (tabItems.length === 0) {
        delete data.tabs[tabName];
      } else {
        validTabs.push(tabName);
      }
    }
    if (validTabs.length === 1 && !("Main" in data.tabs)) {
      data.tabs.Main = [...data.tabs[validTabs[0]]];
      delete data.tabs[validTabs[0]];
    }
    this.docType = data.docType;
    this.tabs = data.tabs;
    this.tags = data.tags ?? [];
    this.width = 150 * Math.ceil(Math.sqrt(Object.values(data.tabs)[0].length));
  }
  // constructConsequenceData(data: BladesDialog.Data/* , options?: Partial<BladesDialog.Options> */) {
  //   eLog.checkLog3("dialog", "constructConsequenceData", {incoming: {...data}});
  //   if (!(this.parent instanceof BladesRoll)) { throw new Error("Cannot call 'constructConsequenceData' without a rollInst parent!"); }
  //   // Get existing consequence data, if any, on roll instance
  //   const rollCsqData = this.parent.data.consequenceData ?? {};
  //   // Extend consequence data by applying new blank consequence instances,
  //   //   so at least three csq entries are available for each position/result combination
  //   (Object.values(Position) as Position[]).forEach((rollPos: Position) => {
  //     rollCsqData[rollPos] ??= {
  //       [RollResult.partial]: {},
  //       [RollResult.fail]: {}
  //     };
  //     ([RollResult.partial, RollResult.fail] as const).forEach((rollResult: RollResult.partial|RollResult.fail) => {
  //       rollCsqData[rollPos] ??= {};
  //       rollCsqData[rollPos][rollResult] ??= {};
  //       while (Object.values(rollCsqData[rollPos][rollResult as RollResult.partial|RollResult.fail]).length < 3) {
  //         const blankCsqData: BladesConsequence.Data = {
  //           id: randomID() as IDString,
  //           name: "",
  //           type: "",
  //           attribute: ""
  //         };
  //         rollCsqData[rollPos][rollResult as RollResult.partial|RollResult.fail][blankCsqData.id] = blankCsqData;
  //       }
  //     });
  //   });
  //   this._consequenceAI = new BladesAI(AGENTS.ConsequenceAdjuster);
  //   return rollCsqData;
  // }
  getData() {
    const data = super.getData();
    switch (this.dialogType) {
      case "Input":
        return this.prepareInputData(data);
      case "Selection":
        return this.prepareSelectionData(data);
      default:
        return null;
    }
  }
  prepareInputData(data) {
    data.prompt = this.prompt;
    data.target = this.target;
    data.flagTarget = this.flagTarget;
    return data;
  }
  prepareSelectionData(data) {
    data.title = this.title;
    data.tabs = this.tabs;
    data.docType = this.docType;
    data.tags = this.tags;
    return data;
  }
  // prepareConsequenceData(data: BladesDialog.Data) {
  //   eLog.checkLog3("dialog", "prepareConsequenceData this.csqData", {...this.csqData});
  //   eLog.checkLog3("dialog", "prepareConsequenceData", {incoming: {...data}});
  //   data.consequenceData = this.csqData;
  //   data.consequenceTypeOptions = this.consequenceTypeOptions;
  //   data.consequenceTypeOptionsAll = Object.keys(C.ConsequenceDisplay)
  //     .map((cType) => ({value: cType, display: cType}));
  //   data.consequenceAttributeOptions = [
  //     {value: AttributeTrait.insight, display: "Insight"},
  //     {value: AttributeTrait.prowess, display: "Prowess"},
  //     {value: AttributeTrait.resolve, display: "Resolve"}
  //   ];
  //   eLog.checkLog3("dialog", "prepareConsequenceData", {outgoing: {...data}});
  //   return data;
  // }
  // get consequenceTypeOptions(): Record<
  //   Position,
  //   Record<
  //     RollResult.partial|RollResult.fail,
  //     Array<BladesSelectOption<string, ConsequenceType>>
  //   >
  //   > {
  //   if (this.parent instanceof BladesRoll) {
  //     const returnData: Partial<Record<
  //     Position,
  //     Record<
  //       RollResult.partial|RollResult.fail,
  //       Array<BladesSelectOption<string, ConsequenceType>>
  //     >
  //   >> = {};
  //     [Position.controlled, Position.risky, Position.desperate].forEach((pos) => {
  //       returnData[pos] = {
  //         [RollResult.partial]: C.Consequences[pos][RollResult.partial]
  //           .map((cType) => ({value: cType, display: cType})),
  //         [RollResult.fail]: C.Consequences[pos][RollResult.fail]
  //           .map((cType) => ({value: cType, display: cType}))
  //       };
  //     });
  //     return returnData as Record<
  //     Position,
  //     Record<
  //       RollResult.partial|RollResult.fail,
  //       Array<BladesSelectOption<string, ConsequenceType>>
  //     >
  //   >;
  //   }
  //   return {} as never;
  // }
  updateInputText(inputElem$) {
    const value = inputElem$.val();
    if (this.parent instanceof BladesRoll$1) {
      const flagTarget = inputElem$.data("flagTarget");
      eLog.checkLog3("dialog", "updateInputText", { value, flagTarget });
      this.parent.updateTarget(flagTarget, value).then(() => this.parent.renderRollCollab_SocketCall());
    } else if (this.parent instanceof BladesItem$1 || this.parent instanceof BladesActor$1) {
      this.parent.update({ [inputElem$.data("target")]: inputElem$.val() });
    }
  }
  // updateConsequenceType(csqElem$: JQuery<HTMLElement>, cData: BladesConsequence.Data) {
  //   const type$ = csqElem$.find(".roll-consequence-type-select") as JQuery<HTMLSelectElement>;
  //   const typeVal = type$.val() as string|undefined;
  //   if (typeVal && typeVal in ConsequenceType) {
  //     cData.type = typeVal as ConsequenceType;
  //     cData.icon = C.ConsequenceIcons[cData.type];
  //     cData.typeDisplay = C.ConsequenceDisplay[cData.type];
  //   }
  // }
  // updateConsequenceAttribute(csqElem$: JQuery<HTMLElement>, cData: BladesConsequence.Data) {
  //   if (/Insight/.exec(cData.type)) { cData.attribute = AttributeTrait.insight; }
  //   else if (/Prowess/.exec(cData.type)) { cData.attribute = AttributeTrait.prowess; }
  //   else if (/Resolve/.exec(cData.type)) { cData.attribute = AttributeTrait.resolve; }
  //   else {
  //     const attribute$ = csqElem$.find(".roll-consequence-attribute-select") as JQuery<HTMLSelectElement>;
  //     const attrVal = attribute$.val() as AttributeTrait|undefined;
  //     if (attrVal) {
  //       cData.attribute = attrVal;
  //     }
  //   }
  // }
  // updateConsequenceAttributeVal(cData: BladesConsequence.Data) {
  //   if (this.parent.rollPrimaryDoc instanceof BladesPC) {
  //     cData.attributeVal = this.parent.rollPrimaryDoc.attributes[cData.attribute as AttributeTrait];
  //   } else if (this.parent.rollPrimaryDoc?.parent instanceof BladesPC) {
  //     cData.attributeVal = this.parent.rollPrimaryDoc.parent.attributes[cData.attribute as AttributeTrait];
  //   } else {
  //     eLog.error(`Unable to get attribute from rollPrimaryDoc '${this.parent.rollPrimaryDoc?.name}' of type '${this.parent.rollPrimaryDoc?.rollPrimaryType}' (may need to log via flags if either of the previous show 'undefined'.`);
  //   }
  // }
  // getSelectedResistOption(cData: BladesConsequence.Data): BladesConsequence|false {
  //   return cData.resistTo
  //     ? new BladesConsequence(cData.resistTo)
  //     : false;
  // }
  // updateConsequenceResist(csqElem$: JQuery<HTMLElement>, cData: BladesConsequence.Data) {
  //   const resistOptions: Record<string, BladesRoll.ConsequenceResistOption> = cData.resistOptions ?? {};
  //   // If consequence is already minimal, toggle resistNegates to true and set 'resistTo' to None-type
  //   const minimalCsqTypes = Object.entries(C.ResistedConsequenceTypes)
  //     .filter(([_, rCsqType]) => rCsqType === ConsequenceType.None)
  //     .map(([csqType]) => csqType as ConsequenceType);
  //   if (minimalCsqTypes.includes(cData.type as ConsequenceType)) {
  //     cData.resistNegates = true;
  //     const noneCsq = BladesConsequence.None;
  //     cData.resistOptions = {[noneCsq.id]: noneCsq};
  //     cData.resistTo = noneCsq;
  //     return;
  //   } else {
  //     // Clear 'resistTo' (will be redetermined below)
  //     delete cData.resistTo;
  //     delete cData.resistNegates;
  //     csqElem$.find(".consequence-resist-option").each((_, elem) => {
  //       const resCsqID = $(elem).data("csq-id");
  //       resistOptions[resCsqID] ??= {id: resCsqID, name: "", type: undefined, isSelected: false};
  //       // Update Resistance Option Type
  //       const resType$ = $(elem).find(".roll-consequence-type-select") as JQuery<HTMLSelectElement>;
  //       const resTypeVal = resType$.val() as string|undefined;
  //       if (resTypeVal && resTypeVal in ConsequenceType) {
  //         resistOptions[resCsqID].type = resTypeVal as ConsequenceType;
  //         resistOptions[resCsqID].icon = C.ConsequenceIcons[resistOptions[resCsqID].type as ConsequenceType];
  //         resistOptions[resCsqID].typeDisplay = C.ConsequenceDisplay[resistOptions[resCsqID].type as ConsequenceType];
  //       }
  //       // Update Resistance Option Name
  //       const resName$ = $(elem).find(".consequence-name") as JQuery<HTMLInputElement>;
  //       const resNameVal = resName$.val();
  //       resistOptions[resCsqID].name = resNameVal ?? "";
  //       // If this is selected, update 'resistTo' data as well
  //       if (resistOptions[resCsqID].isSelected) {
  //         cData.resistTo = resistOptions[resCsqID];
  //       }
  //     });
  //   }
  //   cData.resistOptions = resistOptions;
  // }
  // updateConsequenceArmorResist(_csqElem$: JQuery<HTMLElement>, cData: BladesConsequence.Data) {
  //   // If consequence is already minimal, toggle armorNegates to true and set 'armorTo' to None-type
  //   const minimalCsqTypes = Object.entries(C.ResistedConsequenceTypes)
  //     .filter(([_, rCsqType]) => rCsqType === ConsequenceType.None)
  //     .map(([csqType]) => csqType as ConsequenceType);
  //   if (minimalCsqTypes.includes(cData.type as ConsequenceType)) {
  //     cData.armorNegates = true;
  //     cData.armorTo = BladesConsequence.None;
  //   } else {
  //     delete cData.armorNegates;
  //     cData.armorTo = this.getSelectedResistOption(cData);
  //   }
  // }
  // updateConsequenceSpecialArmorResist(_csqElem$: JQuery<HTMLElement>, cData: BladesConsequence.Data) {
  //   // If consequence is already minimal, toggle specialArmorNegates to true and set 'specialTo' to None-type
  //   const minimalCsqTypes = Object.entries(C.ResistedConsequenceTypes)
  //     .filter(([_, rCsqType]) => rCsqType === ConsequenceType.None)
  //     .map(([csqType]) => csqType as ConsequenceType);
  //   if (minimalCsqTypes.includes(cData.type as ConsequenceType)) {
  //     cData.specialArmorNegates = true;
  //     cData.specialTo = BladesConsequence.None;
  //   } else {
  //     delete cData.specialArmorNegates;
  //     cData.specialArmorNegates ??= false;
  //     cData.specialTo = this.getSelectedResistOption(cData);
  //   }
  // }
  // updateConsequenceData(
  //   html: JQuery<HTMLElement|HTMLInputElement>,
  //   cData: BladesConsequence.Data
  // ) {
  //   const csqElem$ = html.find(`.roll-consequence-row[data-csq-id='${cData.id}']`);
  //   // Update Type
  //   this.updateConsequenceType(csqElem$, cData);
  //   // Update Name
  //   if (cData.type === ConsequenceType.None) {
  //     cData.name = "";
  //   } else {
  //     const name$ = csqElem$.find(".consequence-name") as JQuery<HTMLInputElement>;
  //     const nameVal = name$.val();
  //     cData.name = nameVal ?? "";
  //   }
  //   // Update Resistance Attribute
  //   this.updateConsequenceAttribute(csqElem$, cData);
  //   this.updateConsequenceAttributeVal(cData);
  //   // Update Resistance Options
  //   this.updateConsequenceResist(csqElem$, cData);
  //   // Update Armor Options
  //   if ((<BladesRoll> this.parent).canResistWithArmor(cData)) {
  //     cData.isDisplayingArmorToggle = true;
  //     this.updateConsequenceArmorResist(csqElem$, cData);
  //   } else {
  //     cData.isDisplayingArmorToggle = false;
  //   }
  //   // Update Special Armor Options
  //   if ((<BladesRoll> this.parent).canResistWithSpecialArmor(cData)) {
  //     cData.isDisplayingSpecialArmorToggle = true;
  //     this.updateConsequenceSpecialArmorResist(csqElem$, cData);
  //   } else {
  //     cData.isDisplayingSpecialArmorToggle = false;
  //   }
  //   return cData;
  // }
  // updateConsequenceDialog(html: JQuery<HTMLElement|HTMLInputElement>, isRendering = true) {
  //   if (!(this.parent instanceof BladesRoll)) { return; }
  //   if (!this.csqData) { return; }
  //   eLog.checkLog3("dialog", "updateConsequenceDialog() this.csqData INCOMING", {...this.csqData});
  //   const {csqData} = this;
  //   const {rollPrimaryDoc} = this.parent;
  //   if (!(rollPrimaryDoc instanceof BladesPC)) { return; }
  //   (Object.keys(csqData) as Position[]).forEach((rollPos) => {
  //     const positionCsqData = csqData[rollPos];
  //     (Object.keys(csqData[rollPos]) as [RollResult.partial, RollResult.fail]).forEach((rollResult) => {
  //       positionCsqData[rollResult] = U.objMap(
  //         positionCsqData[rollResult],
  //         (cData: BladesConsequence.Data) => this.updateConsequenceData(html, cData)
  //       );
  //     });
  //     csqData[rollPos] = positionCsqData;
  //   });
  //   this.csqData = csqData;
  //   eLog.checkLog3("dialog", "updateConsequenceDialog() this.csqData OUTGOING", {...this.csqData});
  //   if (isRendering) {
  //     this.render();
  //   }
  // }
  // async writeToRollInstance(html: JQuery<HTMLElement>) {
  // if (this.parent instanceof BladesRoll) {
  // this.updateConsequenceDialog(html, false);
  // await this.parent.updateTarget("consequenceData", this.csqData);
  // }
  // }
  // _consequenceAI?: BladesAI;
  // getCsqDataFromElem(elem: HTMLElement, paramCount = 3): string[] {
  //   const dataAction = elem.dataset.action;
  //   if (dataAction) {
  //     const params = dataAction.split(/-/).reverse().slice(0, paramCount);
  //     return params.reverse();
  //   }
  //   return [];
  // }
  // async queryAI(event: ClickEvent) {
  //   if (!this.csqData) { return; }
  //   // If the AI generator has not been initialized, do so.
  //   if (!this._consequenceAI) {
  //     this._consequenceAI = new BladesAI(AGENTS.ConsequenceAdjuster);
  //   }
  //   const [rollPosition, rollResult, csqID] = this.getCsqDataFromElem(event.currentTarget);
  //   const csqName: string|undefined =
  //     this.csqData[rollPosition as Position][rollResult as RollResult.partial|RollResult.fail][csqID]?.name;
  //   if (csqName) {
  //     const response = await this._consequenceAI?.query(csqName, csqName);
  //     if (response) {
  //       this.refreshResistanceOptions(rollPosition as Position, rollResult as RollResult.partial|RollResult.fail, csqID, response.split("|"));
  //     }
  //   }
  // }
  // async spawnBlankResistOption(event: ClickEvent) {
  //   if (!this.csqData) { return; }
  //   const [rollPosition, rollResult, csqID] = this.getCsqDataFromElem(event.currentTarget);
  //   const rCsqID = randomID() as IDString;
  //   this.csqData[rollPosition as Position][rollResult as RollResult.partial|RollResult.fail][csqID]
  //     .resistOptions = {
  //       [rCsqID]: {
  //         id: rCsqID,
  //         name: "",
  //         type: undefined,
  //         isSelected: true
  //       }
  //     };
  //   this.render();
  // }
  // async setFlagVal(target: string, value: unknown) {
  //   if (this.parent instanceof BladesRoll) {
  //     await this.parent.updateTarget(target, value);
  //   }
  // }
  // async refreshResistanceOptions(rollPosition: Position, rollResult: RollResult, cID: string, rOptions: string[]) {
  //   if (!this.csqData) { return; }
  //   const cData = this.csqData[rollPosition][rollResult as RollResult.partial|RollResult.fail][cID];
  //   if (!cData) { return; }
  //   const cType = cData.type as keyof typeof C["ResistedConsequenceTypes"];
  //   const rType = C.ResistedConsequenceTypes[cType] ?? undefined;
  //   const resistOptions: Record<string, BladesRoll.ConsequenceResistOption> = {};
  //   for (let i = 0; i < rOptions.length; i++) {
  //     const rID = randomID() as IDString;
  //     resistOptions[rID] = {
  //       id: rID,
  //       name: rOptions[i],
  //       isSelected: false
  //     };
  //     if (rType) {
  //       resistOptions[rID].type = rType;
  //       resistOptions[rID].typeDisplay = C.ConsequenceDisplay[rType];
  //       resistOptions[rID].icon = C.ConsequenceIcons[rType];
  //     }
  //   }
  //   this.csqData[rollPosition][rollResult as RollResult.partial|RollResult.fail][cID].resistOptions = resistOptions;
  //   eLog.checkLog3("dialog", "addResistanceOptions() this.csqData", {...this.csqData});
  //   this.render();
  // }
  // async selectResistOption(event: ClickEvent) {
  //   if (!this.csqData) { return; }
  //   const [rollPosition, rollResult, csqID, resID] = this.getCsqDataFromElem(event.currentTarget, 4);
  //   eLog.checkLog3("dialog", "... Action Passed", {rollResult, csqIndex: csqID, resIndex: resID});
  //   // Get consequence data
  //   const cData = this.csqData[rollPosition as Position][rollResult as RollResult.partial|RollResult.fail][csqID];
  //   cData.resistOptions ??= {};
  //   // Toggle clicked resistance option
  //   cData.resistOptions[resID].isSelected = !cData.resistOptions[resID].isSelected;
  //   // If resistance option is now selected...
  //   if (cData.resistOptions[resID].isSelected) {
  //     // ... deselect & hide other options
  //     Object.keys(cData.resistOptions)
  //       .filter((key) => key !== resID)
  //       .forEach((key) => {
  //         Object.assign(cData.resistOptions?.[key] ?? {}, {isSelected: false, isVisible: false});
  //       });
  //     // ... and set 'resistTo' to this consequence.
  //     cData.resistTo = cData.resistOptions[resID];
  //   } else {
  //     // Otherwise, set 'resistTo' to false...
  //     cData.resistTo = false;
  //     // ... and unhide other options.
  //     Object.keys(cData.resistOptions)
  //       .filter((key) => key !== resID)
  //       .forEach((key) => {
  //         Object.assign(cData.resistOptions?.[key] ?? {}, {isVisible: true});
  //       });
  //   }
  //   // Assign new cData instance.
  //   this.csqData[rollPosition as Position][rollResult as RollResult.partial|RollResult.fail][csqID] = cData;
  //   this.render();
  // }
  // async clearResistOptions(event: ContextMenuEvent) {
  //   if (!this.csqData) { return; }
  //   const [rollPosition, rollResult, csqID] = this.getCsqDataFromElem(event.currentTarget);
  //   this.csqData[rollPosition as Position][rollResult as RollResult.partial|RollResult.fail][csqID].resistOptions = {};
  //   this.render();
  // }
  // async toggleArmor(event: ClickEvent) {
  //   if (!this.csqData) { return; }
  //   const [rollPosition, rollResult, csqID] = this.getCsqDataFromElem(event.currentTarget);
  //   const cData = this.csqData[rollPosition as Position][rollResult as RollResult.partial|RollResult.fail][csqID];
  //   cData.canArmor = !cData.canArmor;
  //   this.render();
  // }
  // async toggleSpecialArmor(event: ClickEvent) {
  //   if (!this.csqData) { return; }
  //   const [rollPosition, rollResult, csqID] = this.getCsqDataFromElem(event.currentTarget);
  //   const cData = this.csqData[rollPosition as Position][rollResult as RollResult.partial|RollResult.fail][csqID];
  //   cData.canSpecialArmor = !cData.canSpecialArmor;
  //   this.render();
  // }
  activateListeners(html) {
    super.activateListeners(html);
    ApplyTooltipAnimations(html);
    switch (this.dialogType) {
      case "Input":
        this.activateInputListeners(html);
        break;
      case "Selection":
        this.activateSelectionListeners(html);
        break;
    }
  }
  activateInputListeners(html) {
    html.find("textarea").on({ change: (event) => this.updateInputText($(event.currentTarget)) });
  }
  activateSelectionListeners(html) {
    const self2 = this;
    html.find(".nav-tabs .tab-selector").on("click", (event) => {
      const tabIndex = U.pInt($(event.currentTarget).data("tab"));
      const numItems = Object.values(self2.tabs ?? [])[tabIndex].length;
      const width = U.pInt(150 * Math.ceil(Math.sqrt(numItems)));
      eLog.checkLog3("nav", "Nav Tab Size Recalculation", { tabIndex, numItems, width });
      this.render(false, { width });
    });
    html.find("[data-item-id]").on("click", function() {
      if ($(this).parent().hasClass("locked")) {
        return;
      }
      const docId = $(this).data("itemId");
      const docType = $(this).data("docType");
      eLog.checkLog("dialog", "[BladesDialog] on Click", { elem: this, docId, docType, parent: self2.parent });
      if (self2.parent instanceof BladesActor$1) {
        if (docType === "Actor") {
          self2.parent.addSubActor(docId, self2.tags);
        } else if (docType === "Item") {
          self2.parent.addSubItem(docId);
        }
      }
      self2.close();
    });
  }
  async close() {
    $("#eunos-blades-tooltips > *").remove();
    super.close();
  }
  // activateConsequenceListeners(html: JQuery<HTMLElement>) {
  // html.find("input").on({change: () => this.updateConsequenceDialog(html)});
  // html.find("select").on({change: () => this.updateConsequenceDialog(html)});
  // html.find('[data-action^="ai-query"]').on({
  //   click: (event) => this.queryAI(event),
  //   contextmenu: (event) => this.clearResistOptions(event)
  // });
  // html.find('[data-action^="blank-option"]').on({
  //   click: (event) => this.spawnBlankResistOption(event),
  //   contextmenu: (event) => this.clearResistOptions(event)
  // });
  // html.find('[data-action^="gm-select-toggle"]').on({click: (event) => this.selectResistOption(event) });
  // html.find('[data-action^="toggle-armor"]').on({click: (event) => this.toggleArmor(event) });
  // html.find('[data-action^="toggle-special"]').on({click: (event) => this.toggleSpecialArmor(event) });
  // }
}
function isAction(trait) {
  return Boolean(trait && typeof trait === "string" && U.lCase(trait) in ActionTrait);
}
function isAttribute(trait) {
  return Boolean(trait && typeof trait === "string" && U.lCase(trait) in AttributeTrait);
}
function isFactor(trait) {
  return Boolean(trait && typeof trait === "string" && U.lCase(trait) in Factor);
}
function isModStatus(str2) {
  return typeof str2 === "string" && str2 in RollModStatus;
}
function isParticipantSection(section) {
  return [
    RollModSection.roll,
    RollModSection.position,
    RollModSection.effect
  ].includes(section);
}
function isParticipantSubSection(subSection) {
  if (subSection.startsWith("Group_")) {
    return true;
  }
  if (["Assist", "Setup"].includes(subSection)) {
    return true;
  }
  return false;
}
class BladesRollMod extends BladesTargetLink {
  constructor(modData, rollInstance) {
    super(modData);
    __publicField(this, "_rollInstance");
    this._rollInstance = rollInstance;
    if (!game.eunoblades.RollMods.has(this.id)) {
      game.eunoblades.RollMods.set(this.id, this);
    }
  }
  static ApplySchemaDefaults(schemaData) {
    if (!schemaData.name) {
      throw new Error("name is required for BladesRollMod.Schema");
    }
    return {
      key: `${schemaData.name}-positive-roll`,
      modType: RollModType.general,
      section: RollModSection.roll,
      posNeg: "positive",
      base_status: RollModStatus.Hidden,
      value: 1,
      tooltip: "",
      ...schemaData
    };
  }
  static get GMOnlyModStatuses() {
    return [RollModStatus.ForcedOn, RollModStatus.ForcedOff, RollModStatus.Hidden];
  }
  static getSchemaFromStrings(mStrings) {
    const nameString = U.pullElement(mStrings, (v) => typeof v === "string" && /^na/i.test(v));
    const nameVal = typeof nameString === "string" && nameString.replace(/^.*:/, "");
    if (!nameVal) {
      throw new Error(`RollMod Missing Name: '${mStrings.join("@")}'`);
    }
    const catString = U.pullElement(mStrings, (v) => typeof v === "string" && /^cat/i.test(v));
    const catVal = typeof catString === "string" && catString.replace(/^.*:/, "");
    if (!catVal || !(catVal in RollModSection)) {
      throw new Error(`RollMod Missing Category: '${mStrings.join("@")}'`);
    }
    const posNegString = U.pullElement(mStrings, (v) => typeof v === "string" && /^p/i.test(v)) ?? "posNeg:positive";
    const posNegVal = posNegString.replace(/^.*:/, "");
    return {
      key: `${nameVal}-${posNegVal}-${catVal}`,
      name: nameVal,
      section: catVal,
      posNeg: posNegVal,
      base_status: RollModStatus.ToggledOff,
      modType: RollModType.general,
      tooltip: "",
      value: 1,
      ...Object.fromEntries(
        mStrings.map(getModParameterKeyVal)
      )
    };
    function getModParameterKeyVal(mString) {
      const [keyString, valString] = mString.split(/:/);
      let val = /\|/.test(valString) ? valString.split(/\|/) : valString;
      let key;
      if (/^stat/i.test(keyString)) {
        key = "base_status";
      } else if (/^val/i.test(keyString)) {
        key = "value";
      } else if (/^eff|^ekey/i.test(keyString)) {
        key = "effectKeys";
      } else if (/^side|^ss/i.test(keyString)) {
        key = "sideString";
      } else if (/^s.*ame/i.test(keyString)) {
        key = "source_name";
      } else if (/^tool|^tip/i.test(keyString)) {
        key = "tooltip";
      } else if (/^ty/i.test(keyString)) {
        key = "modType";
      } else if (/^c.{0,10}r?.{0,3}ty/i.test(keyString)) {
        key = "conditionalRollTypes";
      } else if (/^a.{0,3}r?.{0,3}y/i.test(keyString)) {
        key = "autoRollTypes";
      } else if (/^p.{0,10}r?.{0,3}y/i.test(keyString)) {
        key = "participantRollTypes";
      } else if (/^c.{0,10}r?.{0,3}tr/i.test(keyString)) {
        key = "conditionalRollTraits";
      } else if (/^a.{0,3}r?.{0,3}tr/i.test(keyString)) {
        key = "autoRollTraits";
      } else if (/^p.{0,10}r?.{0,3}tr/i.test(keyString)) {
        key = "participantRollTypes";
      } else {
        throw new Error(`Bad Roll Mod Key: ${keyString}`);
      }
      if (key === "base_status" && val === "Conditional") {
        val = RollModStatus.Hidden;
      }
      let valProcessed;
      if (["value"].includes(key)) {
        valProcessed = U.pInt(val);
      } else if (["effectKeys", "conditionalRollTypes", "autoRollTypes", "conditionalRollTraits", "autoRollTraits"].includes(key)) {
        valProcessed = [val].flat();
      } else {
        valProcessed = val.replace(/%COLON%/g, ":");
      }
      return [key, valProcessed];
    }
  }
  static ParseDocModsToSchemaSet(doc) {
    if (doc instanceof BladesChat$1) {
      throw new Error("BladesRollMod.ParseDocRollMods cannot be called on a BladesChat document.");
    }
    const { roll_mods } = doc.system;
    if (!roll_mods || roll_mods.length === 0) {
      return [];
    }
    return roll_mods.filter((elem) => Boolean(elem && typeof elem === "string")).map((modString) => this.getSchemaFromStrings(modString.split(/@/)));
  }
  // public isRerendering = false;
  get status() {
    if (this.userStatus && BladesRollMod.GMOnlyModStatuses.includes(this.userStatus)) {
      return this.userStatus;
    }
    if (this.heldStatus && [RollModStatus.ToggledOff, RollModStatus.ToggledOn].includes(this.heldStatus)) {
      return this.userStatus ?? this.heldStatus;
    }
    return this.heldStatus ?? this.userStatus ?? this.baseStatus;
  }
  get isActive() {
    return [RollModStatus.ToggledOn, RollModStatus.ForcedOn].includes(this.status);
  }
  get isVisible() {
    return this.status !== RollModStatus.Hidden;
  }
  // get flagParams() {
  //   return [C.SYSTEM_ID, `rollCollab.rollModsData.${this.id}`] as const;}
  // async setUserStatusFlag(val: RollModStatus | undefined) {
  // }
  get isConditional() {
    return [
      ...this.conditionalRollTraits,
      ...this.autoRollTraits,
      ...this.participantRollTraits,
      ...this.conditionalRollTypes,
      ...this.autoRollTypes,
      ...this.participantRollTypes
    ].length > 0;
  }
  get isInInactiveBlock() {
    if (game.user.isGM) {
      return [RollModStatus.Hidden, RollModStatus.ForcedOff, RollModStatus.ToggledOff].includes(this.status) && (this.isConditional || this.modType === RollModType.ability);
    }
    return [RollModStatus.ForcedOff, RollModStatus.ToggledOff].includes(this.status) && (this.isConditional || this.modType === RollModType.ability);
  }
  get isPush() {
    return Boolean(U.lCase(this.name) === "push" || this.effectKeys.find((eKey) => eKey === "Is-Push"));
  }
  get isBasicPush() {
    return U.lCase(this.name) === "push";
  }
  get stressCost() {
    const costKeys = this.effectKeys.filter((key) => key.startsWith("Cost-Stress"));
    if (costKeys.length === 0) {
      return 0;
    }
    let stressCost = 0;
    costKeys.forEach((key) => {
      const [thisParam] = (key.split(/-/) ?? []).slice(1);
      const [_, valStr] = (/([A-Za-z]+)(\d*)/.exec(thisParam) ?? []).slice(1);
      stressCost += U.pInt(valStr);
    });
    return stressCost;
  }
  isValidForRollType() {
    switch (this.rollInstance.rollType) {
      case RollType.Action: {
        return true;
      }
      case RollType.Resistance:
      case RollType.Fortune:
      case RollType.IndulgeVice: {
        if (this.isPush || ["bargain", "setup", "assist", "potency"].includes(U.lCase(this.name))) {
          return false;
        }
        return true;
      }
      default:
        return false;
    }
  }
  /**
   * Checks if any types or traits apply to the roll instance.
   * @param {AnyRollType[]} types The types to check.
   * @param {RollTrait[]} traits The traits to check.
   * @returns {boolean} - Returns true if any types or traits apply, false otherwise.
   */
  checkTypesOrTraits(types, traits) {
    const rollTypes = [this.rollInstance.rollType, this.rollInstance.rollSubType, this.rollInstance.rollDowntimeAction].filter((rType) => Boolean(rType));
    const typesApply = !this.rollInstance.isParticipantRoll && types.length === 0 || rollTypes.some((rType) => types.includes(rType));
    const traitsApply = !this.rollInstance.isParticipantRoll && traits.length === 0 || this.rollInstance.rollTrait && traits.includes(this.rollInstance.rollTrait);
    return Boolean(typesApply && traitsApply);
  }
  _doAutoTypesApply() {
    if (this.autoRollTypes.includes(this.rollInstance.rollType)) {
      return true;
    }
    if (this.rollInstance.rollSubType && this.autoRollTypes.includes(this.rollInstance.rollSubType)) {
      return true;
    }
    if (this.rollInstance.rollDowntimeAction && this.autoRollTypes.includes(this.rollInstance.rollDowntimeAction)) {
      return true;
    }
    return false;
  }
  /**
   * Sets the conditional status of the roll mod instance.
   * @returns {boolean} - Returns false if the status is ForcedOn or ToggledOff, true if the status is Hidden.
   */
  setConditionalStatus() {
    if (!this.isConditional) {
      return false;
    }
    if (this._doAutoTypesApply()) {
      this.heldStatus = RollModStatus.ForcedOn;
      return false;
    }
    if (this.rollInstance.rollTrait && this.autoRollTraits.includes(this.rollInstance.rollTrait)) {
      this.heldStatus = RollModStatus.ForcedOn;
      return false;
    }
    if (this.checkTypesOrTraits(this.conditionalRollTypes, this.conditionalRollTraits)) {
      this.heldStatus = RollModStatus.ToggledOff;
      return false;
    }
    if (this.rollInstance.isParticipantRoll && this.checkTypesOrTraits(this.participantRollTypes, this.participantRollTraits)) {
      this.heldStatus = RollModStatus.ToggledOff;
      return false;
    }
    this.heldStatus = RollModStatus.Hidden;
    return true;
  }
  /**
   * Sets the auto-reveal/enable status of the roll mod instance.
   * @returns {boolean} - Returns false if the status is ForcedOn or ToggledOff, true if the status is Hidden.
   */
  setAutoStatus() {
    const holdKeys = this.effectKeys.filter((key) => key.startsWith("Auto"));
    if (holdKeys.length === 0) {
      return false;
    }
    for (const key of holdKeys) {
      const [thisKey, thisParam] = key.split(/-/) ?? [];
      if (U.lCase(thisParam) in Position && this.rollInstance.rollPositionFinal === U.lCase(thisParam)) {
        if (thisKey === "AutoRevealOn") {
          this.heldStatus = RollModStatus.ToggledOff;
          return false;
        } else if (thisKey === "AutoEnableOn") {
          this.heldStatus = RollModStatus.ForcedOn;
          return false;
        }
      }
    }
    this.heldStatus = RollModStatus.Hidden;
    return true;
  }
  /**
   * Sets the relevancy status of the roll mod instance (i.e. hides irrelevant rollMods).
   * @returns {boolean} - Returns true if mod is irrelevant and status is Hidden, false otherwise.
   */
  setRelevancyStatus() {
    const holdKeys = this.effectKeys.filter((key) => /^Negate|^Increase/.test(key));
    if (holdKeys.length === 0) {
      return false;
    }
    const relevantKeys = holdKeys.filter((key) => {
      const [thisKey, thisParam] = key.split(/-/) ?? [];
      if (thisKey === "Negate") {
        const negateOperations = {
          PushCost: () => this.rollInstance.isPushed(),
          QualityPenalty: () => {
            var _a2, _b;
            return this.rollInstance.isTraitRelevant(Factor.quality) && (((_a2 = this.rollInstance.rollFactors.source[Factor.quality]) == null ? void 0 : _a2.value) ?? 0) < (((_b = this.rollInstance.rollFactors.opposition[Factor.quality]) == null ? void 0 : _b.value) ?? 0);
          },
          ScalePenalty: () => {
            var _a2, _b;
            return this.rollInstance.isTraitRelevant(Factor.scale) && (((_a2 = this.rollInstance.rollFactors.source[Factor.scale]) == null ? void 0 : _a2.value) ?? 0) < (((_b = this.rollInstance.rollFactors.opposition[Factor.scale]) == null ? void 0 : _b.value) ?? 0);
          },
          TierPenalty: () => {
            var _a2, _b;
            return this.rollInstance.isTraitRelevant(Factor.tier) && (((_a2 = this.rollInstance.rollFactors.source[Factor.tier]) == null ? void 0 : _a2.value) ?? 0) < (((_b = this.rollInstance.rollFactors.opposition[Factor.tier]) == null ? void 0 : _b.value) ?? 0);
          }
        };
        if (Object.hasOwn(negateOperations, thisParam)) {
          return negateOperations[thisParam]();
        } else {
          throw new Error(`Unrecognized Negate parameter: ${thisParam}`);
        }
      } else if (thisKey === "Increase") {
        const [_, traitStr] = /(\w+)\d+/.exec(thisParam) ?? [];
        return this.rollInstance.isTraitRelevant(traitStr);
      } else {
        throw new Error(`Unrecognized Function Key: ${thisKey}`);
      }
    });
    if (relevantKeys.length === 0) {
      this.heldStatus = RollModStatus.Hidden;
      return true;
    }
    return false;
  }
  /**
   * Sets the payable status of the roll mod instance (i.e. forces off rollMods the primary can't pay for).
   * @returns {boolean} - Returns true if mod is unpayable and status is ForcedOff, false otherwise.
   */
  setPayableStatus() {
    const holdKeys = this.effectKeys.filter((key) => key.startsWith("Cost"));
    if (holdKeys.length === 0) {
      return false;
    }
    const payableKeys = holdKeys.filter((key) => {
      const [thisParam] = (key.split(/-/) ?? []).slice(1);
      const [traitStr, valStr] = (/([A-Za-z]+)(\d*)/.exec(thisParam) ?? []).slice(1);
      const { rollPrimaryDoc } = this.rollInstance.rollPrimary ?? {};
      if (!BladesRollPrimary.IsDoc(rollPrimaryDoc)) {
        return false;
      }
      switch (traitStr) {
        case "SpecialArmor": {
          return BladesActor$1.IsType(rollPrimaryDoc, BladesActorType.pc) && rollPrimaryDoc.system.armor.active.special && !rollPrimaryDoc.system.armor.checked.special;
        }
        case "Stress": {
          const val = U.pInt(valStr);
          return BladesActor$1.IsType(rollPrimaryDoc, BladesActorType.pc) && rollPrimaryDoc.system.stress.max - rollPrimaryDoc.system.stress.value >= val;
        }
        case "Heat": {
          return BladesPC$1.IsType(rollPrimaryDoc) && BladesCrew$1.IsType(rollPrimaryDoc.crew) || BladesCrew$1.IsType(
            rollPrimaryDoc
          );
        }
        default:
          throw new Error(`Unrecognize Payable Key: ${traitStr}`);
      }
    });
    if (payableKeys.length === 0) {
      this.heldStatus = RollModStatus.ForcedOff;
      return true;
    }
    return false;
  }
  applyRollModEffectKeys() {
    if (!this.isActive) {
      return;
    }
    const holdKeyParams = this.effectKeys.filter((key) => /^Negate|^Increase/.test(key)).map((key) => key.split(/-/));
    if (holdKeyParams.length === 0) {
      return;
    }
    holdKeyParams.forEach(([key, param]) => {
      if (key === "Negate") {
        const negateOperations = {
          PushCost: () => {
            this.rollInstance.negatePushCost();
          },
          QualityPenalty: () => {
            this.rollInstance.negateFactorPenalty(Factor.quality);
          },
          ScalePenalty: () => {
            this.rollInstance.negateFactorPenalty(Factor.scale);
          },
          TierPenalty: () => {
            this.rollInstance.negateFactorPenalty(Factor.tier);
          }
        };
        if (Object.hasOwn(negateOperations, param)) {
          return negateOperations[param]();
        } else {
          throw new Error(`Unrecognized Negate parameter: ${param}`);
        }
      } else if (key === "Increase") {
        const [_, traitStr] = /(\w+)\d+/.exec(param) ?? [];
        return this.rollInstance.isTraitRelevant(traitStr);
      } else {
        throw new Error(`Unrecognized Function Key: ${key} (key: ${key})`);
      }
    });
  }
  get selectOptions() {
    if (this.modType !== RollModType.teamwork) {
      return null;
    }
    if (this.name === "Assist" || this.name === "Setup") {
      return this.rollInstance.rollParticipantSelectOptions[this.name];
    } else if (this.name.startsWith("Group_")) {
      return this.rollInstance.rollParticipantSelectOptions.Group;
    }
    return null;
  }
  get selectedParticipant() {
    if (this.modType !== RollModType.teamwork) {
      return null;
    }
    return this.rollInstance.getRollParticipant(this.section, this.name);
  }
  get allFlagData() {
    return this.rollInstance.data;
  }
  get costs() {
    if (!this.isActive) {
      return void 0;
    }
    const holdKeys = this.effectKeys.filter((key) => key.startsWith("Cost"));
    if (holdKeys.length === 0) {
      return void 0;
    }
    return holdKeys.map((key) => {
      const [thisParam] = (key.split(/-/) ?? []).slice(1);
      const [traitStr, valStr] = (/([A-Za-z]+)(\d*)/.exec(thisParam) ?? []).slice(1);
      let label = this.name;
      if (this.isBasicPush) {
        if (this.posNeg === "negative") {
          label = `${this.name} (<span class='red-bright'>To Act</span>)`;
        } else {
          const effect = this.section === RollModSection.roll ? "+1d" : "+1 effect";
          label = `${this.name} (<span class='gold-bright'>${effect}</span>)`;
        }
      }
      return {
        id: this.id,
        label,
        costType: traitStr,
        costAmount: valStr ? U.pInt(valStr) : 1
      };
    });
  }
  get rollInstance() {
    return this._rollInstance;
  }
  get rollId() {
    return this.rollInstance.id;
  }
  get name() {
    return this.data.name;
  }
  get modType() {
    return this.data.modType;
  }
  get sourceName() {
    return this.data.source_name ?? this.data.name;
  }
  get section() {
    return this.data.section;
  }
  get posNeg() {
    return this.data.posNeg;
  }
  get isRendered() {
    return this.rollInstance.isRendered;
  }
  get userStatus() {
    return this.data.user_status;
  }
  set userStatus(val) {
    if (val === this.userStatus) {
      return;
    }
    if (!val || val === this.baseStatus) {
      val = null;
    } else {
      if (!game.user.isGM && (BladesRollMod.GMOnlyModStatuses.includes(val) || this.userStatus && BladesRollMod.GMOnlyModStatuses.includes(this.userStatus))) {
        return;
      }
      const oldStatus = this.statusReport;
      this.updateTarget("user_status", val).then(() => {
        eLog.checkLog3("rollModStatus", `[set USER] ${this.name} Status Change: ${oldStatus["!STATUS"]} -> ${this.status} (val = ${val})`, {
          from: oldStatus.comps,
          to: this.statusReport.comps
        });
      });
    }
  }
  // @ts-expect-error Why aren't I able to simply pass the function parameters through to the superclass?
  async updateTarget(...args) {
    await super.updateTarget(...args);
    this.rollInstance.renderRollCollab_SocketCall();
  }
  get elem$() {
    return this.rollInstance.elem$.find(`#${this.id}`);
  }
  get elem() {
    return this.elem$[0];
  }
  get statusReport() {
    return {
      "!STATUS": this.status,
      "comps": `[B:${this.baseStatus}], [U:${this.userStatus}], [H:${this.heldStatus}]`
    };
  }
  get baseStatus() {
    return this.data.base_status;
  }
  get heldStatus() {
    return this.data.held_status;
  }
  set heldStatus(val) {
    if (val === this.heldStatus) {
      return;
    }
    const oldStatus = this.statusReport;
    this.updateTarget("held_status", val || null).then(() => {
      eLog.checkLog3("rollModStatus", `[set HELD] ${this.name} Status Change: ${oldStatus["!STATUS"]} -> ${this.status} (val = ${val})`, {
        from: oldStatus.comps,
        to: this.statusReport.comps
      });
    });
  }
  get value() {
    return this.data.value;
  }
  get effectKeys() {
    return this.data.effectKeys ?? [];
  }
  get sideString() {
    if (this.data.sideString) {
      return this.data.sideString;
    }
    if (this.selectedParticipant) {
      return this.selectedParticipant.rollParticipantName;
    }
    return void 0;
  }
  get tooltip() {
    let parsedTooltip = this.data.tooltip.replace(/%COLON%/g, ":");
    if (parsedTooltip.includes("%DOC_NAME%")) {
      parsedTooltip = parsedTooltip.replace(
        /%DOC_NAME%/g,
        this.selectedParticipant ? this.selectedParticipant.rollParticipantName : "an Ally"
      );
    }
    if (parsedTooltip.includes("@OPPOSITION_NAME@")) {
      parsedTooltip = parsedTooltip.replace(
        /@OPPOSITION_NAME@/g,
        this.rollInstance.rollOpposition ? this.rollInstance.rollOpposition.rollOppName : "Your Opposition"
      );
    }
    return parsedTooltip;
  }
  get conditionalRollTypes() {
    return this.data.conditionalRollTypes ?? [];
  }
  get autoRollTypes() {
    return this.data.autoRollTypes ?? [];
  }
  get participantRollTypes() {
    return this.data.participantRollTypes ?? [];
  }
  get conditionalRollTraits() {
    return this.data.conditionalRollTraits ?? [];
  }
  get autoRollTraits() {
    return this.data.autoRollTraits ?? [];
  }
  get participantRollTraits() {
    return this.data.participantRollTraits ?? [];
  }
}
class BladesRollPrimary {
  constructor(...args) {
    // #endregion
    __publicField(this, "rollInstance");
    __publicField(this, "rollPrimaryID");
    __publicField(this, "_rollPrimaryDoc");
    __publicField(this, "rollPrimaryName");
    __publicField(this, "rollPrimaryType");
    __publicField(this, "rollPrimaryImg");
    __publicField(this, "rollPrimaryModsSchemaSet");
    __publicField(this, "rollFactors");
    let primaryData = false;
    let primaryDoc = false;
    if (args[0] instanceof BladesRoll) {
      this.rollInstance = args[0];
      args.shift();
    }
    if (BladesRollPrimary.IsDoc(args[0])) {
      primaryDoc = args[0];
    } else if (BladesRollPrimary.IsValidData(args[0])) {
      primaryData = args[0];
    } else if (U.isList(args[0])) {
      if ("rollPrimaryID" in args[0]) {
        primaryDoc = BladesRollPrimary.GetDoc(args[0].rollPrimaryID);
      } else if ("rollPrimaryName" in args[0]) {
        primaryDoc = BladesRollPrimary.GetDoc(args[0].rollPrimaryName);
      }
    }
    if (primaryDoc && !BladesRollPrimary.IsValidData(primaryData)) {
      primaryData = {
        rollPrimaryID: primaryDoc.rollPrimaryID,
        rollPrimaryName: primaryDoc.rollPrimaryName,
        rollPrimaryType: primaryDoc.rollPrimaryType,
        rollPrimaryImg: primaryDoc.rollPrimaryImg,
        rollPrimaryModsSchemaSet: primaryDoc.rollPrimaryModsSchemaSet,
        rollFactors: primaryDoc.rollFactors
      };
    }
    if (!BladesRollPrimary.IsValidData(primaryData) && !BladesRollPrimary.IsDoc(primaryDoc) && this.rollInstance) {
      primaryData = this.rollInstance.rollPrimary.data;
    }
    if (!BladesRollPrimary.IsValidData(primaryData)) {
      throw new Error(`[BladesRoll.constructor] Failed to resolve primary data from provided arguments: ${JSON.stringify(args)}`);
    }
    const {
      rollPrimaryID,
      rollPrimaryName,
      rollPrimaryType,
      rollPrimaryImg,
      rollPrimaryModsSchemaSet,
      rollFactors
    } = primaryData;
    this.rollPrimaryID = rollPrimaryID;
    if (!rollPrimaryName) {
      throw new Error("Must include a rollPrimaryName when constructing a BladesRollPrimary object.");
    }
    if (!rollPrimaryImg) {
      throw new Error("Must include a rollPrimaryImg when constructing a BladesRollPrimary object.");
    }
    if (!rollPrimaryType) {
      throw new Error("Must include a rollPrimaryType when constructing a BladesRollPrimary object.");
    }
    if (!rollFactors) {
      throw new Error("Must include a rollFactors when constructing a BladesRollPrimary object.");
    }
    this.rollPrimaryName = rollPrimaryName;
    this.rollPrimaryType = rollPrimaryType;
    this.rollPrimaryImg = rollPrimaryImg;
    this.rollFactors = rollFactors;
    this.rollPrimaryModsSchemaSet = rollPrimaryModsSchemaSet ?? [];
  }
  // #region Static Methods ~
  static IsValidData(data) {
    if (BladesRollPrimary.IsDoc(data)) {
      return false;
    }
    if (!U.isList(data)) {
      return false;
    }
    if ([
      typeof data.rollPrimaryName,
      typeof data.rollPrimaryType,
      typeof data.rollPrimaryImg
    ].some((type) => type !== "string")) {
      return false;
    }
    if (!Array.isArray(data.rollPrimaryModsSchemaSet)) {
      return false;
    }
    if (!U.isList(data.rollFactors)) {
      return false;
    }
    if (data.rollPrimaryID && typeof data.rollPrimaryID !== "string") {
      return false;
    }
    if (data.rollPrimaryDoc && !BladesRollPrimary.IsDoc(data.rollPrimaryDoc)) {
      return false;
    }
    return true;
  }
  static GetDoc(docRef) {
    let doc = docRef;
    if (typeof docRef === "string") {
      doc = game.actors.get(docRef) ?? game.items.get(docRef) ?? game.actors.getName(docRef) ?? game.items.getName(docRef);
    }
    return BladesRollPrimary.IsDoc(doc) && doc;
  }
  static IsDoc(doc) {
    return BladesActor$1.IsType(doc, BladesActorType.pc, BladesActorType.crew) || BladesItem$1.IsType(doc, BladesItemType.cohort_expert, BladesItemType.cohort_gang, BladesItemType.gm_tracker);
  }
  static GetDataFromDoc(doc) {
    return {
      rollPrimaryID: doc.id,
      rollPrimaryName: doc.name,
      rollPrimaryType: doc.type,
      rollPrimaryImg: doc.img,
      rollPrimaryModsSchemaSet: doc.rollPrimaryModsSchemaSet,
      rollFactors: doc.rollFactors
    };
  }
  static BuildData(config3) {
    if (BladesRollPrimary.IsDoc(config3.rollPrimaryData)) {
      return BladesRollPrimary.GetDataFromDoc(config3.rollPrimaryData);
    }
    if (BladesRollPrimary.IsValidData(config3.rollPrimaryData)) {
      return config3.rollPrimaryData;
    }
    let rollPrimary;
    const rollUser = game.users.get(config3.rollUserID ?? game.user.id);
    if ("target" in config3 && BladesRollPrimary.IsDoc(config3.target)) {
      rollPrimary = config3.target;
    } else if (rollUser && BladesRollPrimary.IsDoc(rollUser.character)) {
      rollPrimary = rollUser.character;
    } else {
      throw new Error("[BladesRollPrimary.BuildData()] A valid source of PrimaryData must be provided to construct a roll.");
    }
    return {
      rollPrimaryID: rollPrimary.rollPrimaryID,
      rollPrimaryName: rollPrimary.rollPrimaryName,
      rollPrimaryType: rollPrimary.rollPrimaryType,
      rollPrimaryImg: rollPrimary.rollPrimaryImg,
      rollPrimaryModsSchemaSet: rollPrimary.rollPrimaryModsSchemaSet,
      rollFactors: rollPrimary.rollFactors
    };
  }
  static Build(config3) {
    return new BladesRollPrimary(this.BuildData(config3));
  }
  get rollPrimaryDoc() {
    if (!this._rollPrimaryDoc) {
      let doc;
      if (this.rollPrimaryID) {
        doc = game.items.get(this.rollPrimaryID) ?? game.actors.get(this.rollPrimaryID);
      }
      if (!doc && this.rollPrimaryName) {
        doc = game.items.getName(this.rollPrimaryName) ?? game.actors.getName(this.rollPrimaryName);
      }
      if (BladesRollPrimary.IsDoc(doc)) {
        this._rollPrimaryDoc = doc;
      }
    }
    return this._rollPrimaryDoc;
  }
  get data() {
    return {
      rollPrimaryID: this.rollPrimaryID,
      rollPrimaryName: this.rollPrimaryName,
      rollPrimaryType: this.rollPrimaryType,
      rollPrimaryImg: this.rollPrimaryImg,
      rollPrimaryModsSchemaSet: this.rollPrimaryModsSchemaSet,
      rollFactors: this.rollFactors
    };
  }
  get isWorsePosition() {
    if (this.rollPrimaryDoc) {
      return this.rollPrimaryDoc.getFlag("eunos-blades", "isWorsePosition") === true;
    }
    return false;
  }
  async applyHarm(amount, name) {
    if (!this.rollPrimaryDoc) {
      return void 0;
    }
    return this.rollPrimaryDoc.applyHarm(amount, name);
  }
  async applyWorsePosition() {
    if (!this.rollPrimaryDoc) {
      return void 0;
    }
    return this.rollPrimaryDoc.applyWorsePosition();
  }
  get hasSpecialArmor() {
    return BladesPC$1.IsType(this.rollPrimaryDoc) && this.rollPrimaryDoc.isSpecialArmorAvailable;
  }
  get availableArmorCount() {
    if (BladesPC$1.IsType(this.rollPrimaryDoc)) {
      return this.rollPrimaryDoc.availableArmor.length;
    } else if (BladesItem$1.IsType(this.rollPrimaryDoc, BladesItemType.cohort_gang, BladesItemType.cohort_expert)) {
      return this.rollPrimaryDoc.system.armor.max - this.rollPrimaryDoc.system.armor.value;
    }
    return 0;
  }
  async spendArmor(count) {
    var _a2;
    if (!this.rollPrimaryDoc) {
      throw new Error("[BladesRollPrimary.spendArmor()] Cannot spend armor when rollPrimaryDoc is not defined.");
    }
    if (count > this.availableArmorCount) {
      throw new Error(`[BladesRollPrimary.spendArmor()] Cannot spend more armor (${count}) than ${(_a2 = this.rollPrimaryDoc) == null ? void 0 : _a2.name} has (${this.availableArmorCount}).`);
    }
    if (BladesPC$1.IsType(this.rollPrimaryDoc)) {
      const armorToSpend = this.rollPrimaryDoc.availableArmor.slice(0, count);
      const updateData = {};
      if (armorToSpend.includes("Light Armor")) {
        updateData["system.armor.active.light"] = true;
        updateData["system.armor.checked.light"] = true;
      }
      if (armorToSpend.includes("Heavy Armor")) {
        updateData["system.armor.active.heavy"] = true;
        updateData["system.armor.checked.heavy"] = true;
      }
      await this.rollPrimaryDoc.update(updateData);
    } else if (BladesItem$1.IsType(this.rollPrimaryDoc, BladesItemType.cohort_gang, BladesItemType.cohort_expert)) {
      await this.rollPrimaryDoc.update({ "system.armor.value": this.rollPrimaryDoc.system.armor.value + count });
    }
  }
  // #endregion
}
class BladesRollOpposition {
  // #region Constructor ~
  constructor(rollInstance, {
    rollOppID,
    rollOppName,
    rollOppSubName,
    rollOppType,
    rollOppImg,
    rollOppModsSchemaSet,
    rollFactors
  } = {}) {
    // #endregion
    __publicField(this, "rollInstance");
    __publicField(this, "rollOppID");
    __publicField(this, "rollOppDoc");
    __publicField(this, "rollOppName");
    __publicField(this, "rollOppSubName");
    __publicField(this, "rollOppType");
    __publicField(this, "rollOppImg");
    __publicField(this, "rollOppModsSchemaSet");
    __publicField(this, "rollFactors");
    this.rollInstance = rollInstance;
    const doc = BladesRollOpposition.GetDoc(rollOppID ?? rollOppName);
    if (doc) {
      this.rollOppDoc = doc;
      rollOppID = doc.rollOppID;
      rollOppName ?? (rollOppName = doc.rollOppName);
      rollOppSubName ?? (rollOppSubName = doc.rollOppSubName);
      rollOppType ?? (rollOppType = doc.rollOppType);
      rollOppImg ?? (rollOppImg = doc.rollOppImg);
      rollOppModsSchemaSet = [
        ...rollOppModsSchemaSet ?? [],
        ...doc.rollOppModsSchemaSet ?? []
      ];
      rollFactors = {
        ...doc.rollFactors,
        ...rollFactors ?? {}
      };
    }
    if (!rollOppName) {
      throw new Error("Must include a rollOppName when constructing a BladesRollOpposition object.");
    }
    if (!rollOppType) {
      throw new Error("Must include a rollOppType when constructing a BladesRollOpposition object.");
    }
    if (!rollFactors) {
      throw new Error("Must include a rollFactors when constructing a BladesRollOpposition object.");
    }
    this.rollOppID = rollOppID;
    this.rollOppName = rollOppName;
    this.rollOppSubName = rollOppSubName;
    this.rollOppType = rollOppType;
    this.rollOppImg = rollOppImg ?? "";
    this.rollOppModsSchemaSet = rollOppModsSchemaSet ?? [];
    this.rollFactors = rollFactors;
  }
  // #region Static Methods ~
  static IsValidData(data) {
    if (BladesRollOpposition.IsDoc(data)) {
      return true;
    }
    return U.isList(data) && typeof data.rollOppName === "string" && typeof data.rollOppType === "string" && typeof data.rollOppImg === "string" && (!data.rollOppSubName || typeof data.rollOppSubName === "string") && (!data.rollOppModsSchemaSet || Array.isArray(data.rollOppModsSchemaSet)) && U.isList(data.rollFactors) && (!data.rollOppID || typeof data.rollOppID === "string");
  }
  static GetDoc(docRef) {
    let doc = docRef;
    if (typeof docRef === "string") {
      doc = game.actors.get(docRef) ?? game.items.get(docRef) ?? game.actors.getName(docRef) ?? game.items.getName(docRef);
    }
    if (BladesRollOpposition.IsDoc(doc)) {
      return doc;
    }
    return false;
  }
  static IsDoc(doc) {
    return BladesActor$1.IsType(
      doc,
      BladesActorType.npc,
      BladesActorType.faction
    ) || BladesItem$1.IsType(
      doc,
      BladesItemType.cohort_expert,
      BladesItemType.cohort_gang
    );
  }
  static GetDataFromDoc(doc) {
    return {
      rollOppID: doc.id,
      rollOppName: doc.name,
      rollOppType: doc.type,
      rollOppImg: doc.img,
      rollOppModsSchemaSet: doc.rollOppModsSchemaSet,
      rollFactors: doc.rollFactors
    };
  }
  // #endregion
  get data() {
    return {
      rollOppID: this.rollOppID,
      rollOppName: this.rollOppName,
      rollOppSubName: this.rollOppSubName,
      rollOppType: this.rollOppType,
      rollOppImg: this.rollOppImg,
      rollOppModsSchemaSet: this.rollOppModsSchemaSet,
      rollFactors: this.rollFactors
    };
  }
  async updateRollFlags() {
    if (!this.rollInstance) {
      return;
    }
    await this.rollInstance.updateTarget("rollOppData", this.data);
    if (this.rollInstance.isRendered) {
      socketlib.system.executeForEveryone("renderRollCollab_SocketCall", this.rollInstance.id);
    }
  }
  refresh() {
    if (!this.rollInstance) {
      return void 0;
    }
    const rollOppFlags = this.rollInstance.data.rollOppData;
    if (rollOppFlags) {
      this.rollOppID = rollOppFlags.rollOppID;
      this.rollOppName = rollOppFlags.rollOppName;
      this.rollOppSubName = rollOppFlags.rollOppSubName;
      this.rollOppType = rollOppFlags.rollOppType;
      this.rollOppImg = rollOppFlags.rollOppImg;
      this.rollOppModsSchemaSet = rollOppFlags.rollOppModsSchemaSet ?? [];
      this.rollFactors = rollOppFlags.rollFactors;
    }
    return this;
  }
}
class BladesRollParticipant {
  constructor(rollInstance, section, subSection, rollParticipantDataOrDoc) {
    // #endregion
    __publicField(this, "rollInstance");
    __publicField(this, "rollParticipantID");
    __publicField(this, "rollParticipantDoc");
    __publicField(this, "rollParticipantName");
    __publicField(this, "rollParticipantType");
    __publicField(this, "rollParticipantIcon");
    __publicField(this, "rollParticipantSection");
    __publicField(this, "rollParticipantSubSection");
    __publicField(this, "rollParticipantModsSchemaSet");
    // As applied to MAIN roll when this participant involved
    __publicField(this, "rollFactors");
    this.rollInstance = rollInstance;
    if (!section) {
      throw new Error("Must include a rollParticipantSection when constructing a BladesRollParticipant object.");
    }
    if (!subSection) {
      throw new Error("Must include a rollParticipantSubSection when constructing a BladesRollParticipant object.");
    }
    this.rollParticipantSection = section;
    this.rollParticipantSubSection = subSection;
    const doc = BladesRollParticipant.IsDoc(rollParticipantDataOrDoc) ? rollParticipantDataOrDoc : BladesRollParticipant.GetDoc(
      rollParticipantDataOrDoc.rollParticipantID ?? rollParticipantDataOrDoc.rollParticipantName
    );
    if (doc) {
      rollParticipantDataOrDoc = doc;
    }
    if (!rollParticipantDataOrDoc.rollParticipantName) {
      throw new Error("Must include a rollParticipantName when constructing a BladesRollParticipant object.");
    }
    if (!rollParticipantDataOrDoc.rollParticipantType) {
      throw new Error("Must include a rollParticipantType when constructing a BladesRollParticipant object.");
    }
    if (!rollParticipantDataOrDoc.rollFactors) {
      throw new Error("Must include a rollFactors when constructing a BladesRollParticipant object.");
    }
    this.rollParticipantID = rollParticipantDataOrDoc.rollParticipantID;
    this.rollParticipantName = rollParticipantDataOrDoc.rollParticipantName;
    this.rollParticipantType = rollParticipantDataOrDoc.rollParticipantType;
    this.rollParticipantIcon = rollParticipantDataOrDoc.rollParticipantIcon ?? "";
    this.rollParticipantModsSchemaSet = rollParticipantDataOrDoc.rollParticipantModsSchemaSet ?? [];
    this.rollFactors = rollParticipantDataOrDoc.rollFactors;
  }
  // #region Static Methods ~
  static IsValidData(data) {
    if (BladesRollParticipant.IsDoc(data)) {
      return true;
    }
    return U.isList(data) && typeof data.rollParticipantName === "string" && typeof data.rollParticipantType === "string" && typeof data.rollParticipantIcon === "string" && (!data.rollParticipantModsSchemaSet || Array.isArray(data.rollParticipantModsSchemaSet)) && U.isList(data.rollFactors) && (!data.rollParticipantID || typeof data.rollParticipantID === "string") && (!data.rollParticipantDoc || BladesRollParticipant.IsDoc(data.rollParticipantDoc));
  }
  static GetDoc(docRef) {
    let doc = docRef;
    if (typeof docRef === "string") {
      doc = game.actors.get(docRef) ?? game.items.get(docRef) ?? game.actors.getName(docRef) ?? game.items.getName(docRef);
    }
    if (BladesRollParticipant.IsDoc(doc)) {
      return doc;
    }
    return false;
  }
  static IsDoc(doc) {
    return BladesActor$1.IsType(doc, BladesActorType.pc, BladesActorType.crew, BladesActorType.npc) || BladesItem$1.IsType(doc, BladesItemType.cohort_expert, BladesItemType.cohort_gang, BladesItemType.gm_tracker);
  }
  // #endregion
  get data() {
    return {
      rollParticipantID: this.rollParticipantID,
      rollParticipantName: this.rollParticipantName,
      rollParticipantType: this.rollParticipantType,
      rollParticipantIcon: this.rollParticipantIcon,
      rollParticipantModsSchemaSet: this.rollParticipantModsSchemaSet,
      rollFactors: this.rollFactors
    };
  }
  async updateRollFlags() {
    await this.rollInstance.updateTarget(`rollParticipantData.${this.rollParticipantSection}.${this.rollParticipantSubSection}`, this.data);
    if (this.rollInstance.isRendered) {
      socketlib.system.executeForEveryone("renderRollCollab_SocketCall", this.rollInstance.id);
    }
  }
  refresh() {
    var _a2;
    const rollParticipantFlagData = (_a2 = this.rollInstance.data.rollParticipantData) == null ? void 0 : _a2[this.rollParticipantSection];
    if (rollParticipantFlagData && this.rollParticipantSubSection in rollParticipantFlagData) {
      const rollParticipantFlags = rollParticipantFlagData[this.rollParticipantSubSection];
      if (rollParticipantFlags) {
        this.rollParticipantID = rollParticipantFlags.rollParticipantID;
        this.rollParticipantName = rollParticipantFlags.rollParticipantName;
        this.rollParticipantType = rollParticipantFlags.rollParticipantType;
        this.rollParticipantIcon = rollParticipantFlags.rollParticipantIcon;
        this.rollParticipantModsSchemaSet = rollParticipantFlags.rollParticipantModsSchemaSet ?? [];
        this.rollFactors = rollParticipantFlags.rollFactors;
      }
    }
    return this;
  }
}
const _BladesRoll = class _BladesRoll extends BladesTargetLink {
  constructor(dataOrConfig) {
    super(dataOrConfig);
    // #endregion
    // #region *** CONSTRUCTOR *** ~
    __publicField(this, "rollPermission");
    __publicField(this, "_rollPrimary");
    __publicField(this, "_rollOpposition");
    __publicField(this, "_rollParticipants");
    __publicField(this, "projectSelectOptions");
    __publicField(this, "_rollTraitValOverride");
    __publicField(this, "_roll");
    __publicField(this, "rollFactorPenaltiesNegated", {});
    __publicField(this, "tempGMBoosts", {});
    __publicField(this, "getModsDelta", (cat) => {
      return U.sum([
        ...this.getActiveRollMods(cat, "positive").map((mod) => mod.value),
        ...this.getActiveRollMods(cat, "negative").map((mod) => -mod.value)
      ]);
    });
    __publicField(this, "_rollMods");
    // #endregion
    // #region *** EVALUATING ROLL *** ~
    // #region DICE ~
    __publicField(this, "_dieVals");
    // #endregion
    // #region *** ROLL COLLAB HTML ELEMENT ***
    __publicField(this, "_elem$");
    __publicField(this, "_overlayPosition", { x: 200, y: 200 });
    // #endregion
    // #region ACTIVATE LISTENERS ~
    __publicField(this, "_positionDragger");
    this.rollPermission = this.data.userPermissions[game.user.id];
    this._rollPrimary = new BladesRollPrimary(this, this.data.rollPrimaryData);
    if (this.data.rollOppData) {
      this._rollOpposition = new BladesRollOpposition(this, this.data.rollOppData);
    } else if (this.data.rollDowntimeAction === DowntimeAction.LongTermProject) {
      this.projectSelectOptions = Array.from(game.items).filter((item) => BladesItem$1.IsType(item, BladesItemType.project)).map((project) => ({ value: project.id ?? "", display: project.name }));
    }
    if (this.data.rollParticipantData) {
      this._rollParticipants = {};
      for (const [rollSection, rollParticipantList] of Object.entries(this.data.rollParticipantData)) {
        if ([RollModSection.roll, RollModSection.position, RollModSection.effect].includes(rollSection) && !U.isEmpty(rollParticipantList)) {
          const sectionParticipants = {};
          for (const [participantType, participantData] of Object.entries(rollParticipantList)) {
            sectionParticipants[participantType] = new BladesRollParticipant(
              this,
              rollSection,
              participantType,
              participantData
            );
          }
          this._rollParticipants[rollSection] = sectionParticipants;
        }
      }
    }
    game.eunoblades.Rolls.set(this.id, this);
  }
  // #region STATIC METHODS: INITIALIZATION & DEFAULTS ~
  static Initialize() {
    return loadTemplates([
      "systems/eunos-blades/templates/roll/partials/roll-collab-gm-number-line.hbs",
      "systems/eunos-blades/templates/roll/partials/roll-collab-gm-select-doc.hbs",
      "systems/eunos-blades/templates/roll/partials/roll-collab-gm-factor-control.hbs",
      "systems/eunos-blades/templates/roll/roll-collab-action.hbs",
      "systems/eunos-blades/templates/roll/roll-collab-action-gm.hbs",
      "systems/eunos-blades/templates/roll/roll-collab-resistance.hbs",
      "systems/eunos-blades/templates/roll/roll-collab-resistance-gm.hbs",
      "systems/eunos-blades/templates/roll/roll-collab-fortune.hbs",
      "systems/eunos-blades/templates/roll/roll-collab-fortune-gm.hbs",
      "systems/eunos-blades/templates/roll/roll-collab-indulgevice.hbs",
      "systems/eunos-blades/templates/roll/roll-collab-indulgevice-gm.hbs"
    ]);
  }
  static InitSockets() {
    socketlib.system.register("constructRollCollab_SocketCall", _BladesRoll.constructRollCollab_SocketResponse.bind(_BladesRoll));
    socketlib.system.register("renderRollCollab_SocketCall", _BladesRoll.renderRollCollab_SocketResponse.bind(_BladesRoll));
    socketlib.system.register("closeRollCollab_SocketCall", _BladesRoll.closeRollCollab_SocketResponse.bind(_BladesRoll));
  }
  static ParseConfigToData(data, parentRollData) {
    const parentRollInst = game.eunoblades.Rolls.get(parentRollData.id);
    if (!parentRollInst) {
      throw new Error(`[BladesRoll.ParseConfigToData] No BladesRoll instance found with id ${parentRollData.id}.`);
    }
    if (data.rollPrimaryData instanceof BladesRollPrimary) {
      data.rollPrimaryData = data.rollPrimaryData.data;
    }
    if (data.rollOppData instanceof BladesRollOpposition) {
      data.rollOppData = data.rollOppData.data;
    }
    if (data.rollParticipantData) {
      if (data.rollParticipantData[RollModSection.roll]) {
        Object.keys(data.rollParticipantData[RollModSection.roll]).forEach((key) => {
          var _a2, _b;
          const thisParticipant = (_b = (_a2 = data.rollParticipantData) == null ? void 0 : _a2[RollModSection.roll]) == null ? void 0 : _b[key];
          if (thisParticipant instanceof BladesRollParticipant) {
            data.rollParticipantData[RollModSection.roll][key] = thisParticipant.data;
          }
        });
      }
      if (data.rollParticipantData[RollModSection.position]) {
        Object.keys(data.rollParticipantData[RollModSection.position]).forEach((key) => {
          var _a2, _b;
          const thisParticipant = (_b = (_a2 = data.rollParticipantData) == null ? void 0 : _a2[RollModSection.position]) == null ? void 0 : _b[key];
          if (thisParticipant instanceof BladesRollParticipant) {
            data.rollParticipantData[RollModSection.position][key] = thisParticipant.data;
          }
        });
      }
      if (data.rollParticipantData[RollModSection.effect]) {
        Object.keys(data.rollParticipantData[RollModSection.effect]).forEach((key) => {
          var _a2, _b;
          const thisParticipant = (_b = (_a2 = data.rollParticipantData) == null ? void 0 : _a2[RollModSection.effect]) == null ? void 0 : _b[key];
          if (thisParticipant instanceof BladesRollParticipant) {
            data.rollParticipantData[RollModSection.effect][key] = thisParticipant.data;
          }
        });
      }
    }
    return super.ParseConfigToData(data);
  }
  static ApplySchemaDefaults(schemaData) {
    if (!schemaData.rollType) {
      throw new Error("Must include a rollType when constructing a BladesRoll object.");
    }
    schemaData.rollPhase ?? (schemaData.rollPhase = RollPhase.Collaboration);
    schemaData.GMBoosts = {
      [Factor.tier]: 0,
      [Factor.quality]: 0,
      [Factor.scale]: 0,
      [Factor.magnitude]: 0,
      ...schemaData.GMBoosts ?? {}
    };
    schemaData.GMOppBoosts = {
      [Factor.tier]: 0,
      [Factor.quality]: 0,
      [Factor.scale]: 0,
      [Factor.magnitude]: 0,
      ...schemaData.GMOppBoosts ?? {}
    };
    schemaData.GMOverrides ?? (schemaData.GMOverrides = {});
    schemaData.userPermissions ?? (schemaData.userPermissions = {});
    if (schemaData.rollPrimaryData instanceof BladesRollPrimary) {
      schemaData.rollPrimaryData = schemaData.rollPrimaryData.data;
    }
    if (schemaData.rollOppData instanceof BladesRollOpposition) {
      schemaData.rollOppData = schemaData.rollOppData.data;
    }
    return schemaData;
  }
  // static override get defaultOptions() {
  //   return foundry.utils.mergeObject(super.defaultOptions, {
  //     classes: ["eunos-blades", "sheet", "roll-collab", game.user.isGM ? "gm-roll-collab" : ""],
  //     template: `systems/eunos-blades/templates/roll/roll-collab${game.user.isGM ? "-gm" : ""}.hbs`,
  //     submitOnChange: true,
  //     width: 500,
  //     dragDrop: [
  //       {dragSelector: null, dropSelector: "[data-action='gm-drop-opposition'"}
  //     ]
  //     // Height: 500
  //   });
  // }
  static get DefaultRollModSchemaSet() {
    return [];
  }
  static GetDieClass(rollType, rollResult, dieVal, dieIndex) {
    switch (rollType) {
      case RollType.Resistance: {
        if (dieVal === 6 && dieIndex <= 1 && rollResult === -1) {
          return "blades-die-critical";
        }
        if (dieIndex === 0) {
          return "blades-die-resistance";
        }
        return "blades-die-fail";
      }
      case RollType.IndulgeVice: {
        if (dieIndex === 0) {
          return "blades-die-indulge-vice";
        }
        return "blades-die-fail";
      }
    }
    if (dieVal === 6 && dieIndex <= 1 && rollResult === RollResult.critical) {
      dieVal++;
    }
    return [
      "",
      "blades-die-fail",
      "blades-die-fail",
      "blades-die-fail",
      "blades-die-partial",
      "blades-die-partial",
      "blades-die-success",
      "blades-die-critical"
    ][dieVal];
  }
  static GetDieImage(rollType, rollResult, dieVal, dieIndex, isGhost = false, isCritical = false) {
    let imgPath = "systems/eunos-blades/assets/dice/image/";
    if (isGhost) {
      imgPath += "ghost-";
    } else if ([RollType.Resistance, RollType.IndulgeVice].includes(rollType)) {
      imgPath += "grad-";
    }
    imgPath += `${dieVal}`;
    if (!isGhost && dieVal === 6 && dieIndex <= 1 && isCritical) {
      imgPath += "-crit";
    }
    imgPath += ".webp";
    return imgPath;
  }
  static get Active() {
    return U.getLast(game.eunoblades.Rolls.filter((roll) => roll.isActive));
  }
  // #endregion
  // #region STATIC METHODS: New Roll Creation ~
  // static Current: Record<string, BladesRoll> = {};
  // static _Active?: BladesRoll;
  // static get Active(): BladesRoll | undefined {
  //   if (BladesRoll._Active) {return BladesRoll._Active;}
  //   if (U.objSize(BladesRoll.Current) > 0) {return U.getLast(Object.values(BladesRoll.Current));}
  //   return undefined;
  // }
  // static set Active(val: BladesRoll | undefined) {
  //   BladesRoll._Active = val;
  // }
  static GetUserPermissions(config3) {
    var _a2, _b, _c, _d;
    const rollPrimaryData = BladesRollPrimary.BuildData(config3);
    if (!rollPrimaryData) {
      throw new Error("[BladesRoll.GetUserPermissions()] Missing rollPrimaryData.");
    }
    const GMUserID = (_a2 = game.users.find((user) => user.isGM)) == null ? void 0 : _a2.id;
    if (!GMUserID) {
      throw new Error("[BladesRoll.GetUserPermissions()] No GM found!");
    }
    const playerUserIDs = game.users.filter((user) => BladesPC$1.IsType(user.character) && !user.isGM && typeof user.id === "string").map((user) => user.id);
    const userIDs = {
      [RollPermissions.GM]: [GMUserID],
      [RollPermissions.Primary]: [],
      [RollPermissions.Participant]: [],
      [RollPermissions.Observer]: []
    };
    const { rollPrimaryDoc } = new BladesRollPrimary(rollPrimaryData);
    if (BladesPC$1.IsType(rollPrimaryDoc) && U.pullElement(playerUserIDs, (_b = rollPrimaryDoc.primaryUser) == null ? void 0 : _b.id)) {
      userIDs[RollPermissions.Primary].push((_c = rollPrimaryDoc.primaryUser) == null ? void 0 : _c.id);
    } else if (BladesCrew$1.IsType(rollPrimaryDoc)) {
      userIDs[RollPermissions.Primary].push(...playerUserIDs);
    } else if (BladesItem$1.IsType(rollPrimaryDoc, BladesItemType.cohort_gang, BladesItemType.cohort_expert)) {
      if (config3.rollUserID === GMUserID) {
        userIDs[RollPermissions.Primary].push(...playerUserIDs);
      } else if (BladesPC$1.IsType(rollPrimaryDoc.parent) && ((_d = rollPrimaryDoc.parent.primaryUser) == null ? void 0 : _d.id)) {
        userIDs[RollPermissions.Primary].push(rollPrimaryDoc.parent.primaryUser.id);
      }
    } else if (BladesGMTracker$1.IsType(rollPrimaryDoc)) {
      userIDs[RollPermissions.Primary].push(GMUserID);
    }
    if (config3.rollParticipantData) {
      userIDs[RollPermissions.Participant].push(...getParticipantDocUserIDs(config3.rollParticipantData, playerUserIDs));
    }
    userIDs[RollPermissions.Observer] = playerUserIDs.filter((uID) => !userIDs[RollPermissions.Participant].includes(uID));
    const userFlagData = {};
    Object.entries(userIDs).forEach(([rollPermission, idsArray]) => {
      for (const id of idsArray) {
        userFlagData[id] = rollPermission;
      }
    });
    return userFlagData;
    function getParticipantDocs(participantData) {
      return Object.values(flattenObject(participantData)).map((pData) => {
        if (BladesRollParticipant.IsDoc(pData)) {
          return pData;
        }
        if (BladesRollParticipant.IsValidData(pData)) {
          if (typeof pData.rollParticipantID === "string") {
            const pDoc = game.actors.get(pData.rollParticipantID) ?? game.items.get(pData.rollParticipantID);
            if (BladesRollParticipant.IsDoc(pDoc)) {
              return pDoc;
            }
          }
        }
        throw new Error(`[getParticipantDocs] Invalid participant data encountered. Data: ${JSON.stringify(pData)}, Expected: "BladesRollParticipant or valid participant data", Function Context: "getParticipantDocs", Participant Data: ${JSON.stringify(participantData)}`);
      });
    }
    function getParticipantDocUserIDs(participantData, unassignedIDs) {
      return getParticipantDocs(participantData).map((pDoc) => {
        var _a3;
        if (BladesPC$1.IsType(pDoc) && typeof ((_a3 = pDoc.primaryUser) == null ? void 0 : _a3.id) === "string") {
          return pDoc.primaryUser.id;
        } else if (BladesCrew$1.IsType(pDoc) || BladesItem$1.IsType(pDoc, BladesItemType.cohort_gang, BladesItemType.cohort_expert)) {
          return unassignedIDs;
        }
        return null;
      }).flat().filter((pUser) => pUser !== null && !userIDs[RollPermissions.Primary].includes(pUser));
    }
  }
  static BuildLinkConfig(config3) {
    const partialLinkConfig = {};
    if ("targetKey" in config3 && config3.targetKey) {
      partialLinkConfig.targetKey = config3.targetKey;
    } else if ("targetFlagKey" in config3 && config3.targetFlagKey) {
      partialLinkConfig.targetFlagKey = config3.targetFlagKey;
    }
    if ("target" in config3) {
      if (U.isDocUUID(config3.target)) {
        partialLinkConfig.targetID = config3.target;
      } else if (U.isDocID(config3.target)) {
        const confTarget = game.actors.get(config3.target) ?? game.items.get(config3.target) ?? game.messages.get(config3.target) ?? game.users.get(config3.target);
        if (confTarget) {
          partialLinkConfig.targetID = confTarget.uuid;
        } else {
          throw new Error(`[BladesRoll.BuildLinkConfig] No target found with id ${config3.target}.`);
        }
      } else {
        partialLinkConfig.targetID = config3.target.uuid;
      }
    } else if ("targetID" in config3) {
      partialLinkConfig.targetID = config3.targetID;
    } else {
      throw new Error("[BladesRoll.BuildLinkConfig] You must provide a valid target or targetID in the config object.");
    }
    if (!partialLinkConfig.targetKey && !partialLinkConfig.targetFlagKey) {
      partialLinkConfig.targetFlagKey = "rollCollab";
    }
    if (BladesTargetLink.IsValidConfig(partialLinkConfig)) {
      return BladesTargetLink.BuildLinkConfig(partialLinkConfig);
    }
    throw new Error("[BladesRoll.BuildLinkConfig] Invalid link config.");
  }
  /**
   * Asynchronously creates a new instance of `BladesRoll` or its subclasses.
   *
   * This generic static method is designed to facilitate the creation of roll instances with
   * configurations specific to the type of roll being created. It ensures that the correct type
   * of roll instance is returned based on the class it's called on, allowing for a flexible and
   * type-safe creation process that can be extended to subclasses of `BladesRoll`.
   *
   * @template C The class on which `New` is called. This class must extend `BladesRoll` and
   * must be constructible with a configuration object that is either a `BladesRoll.Config` or
   * a combination of `BladesTargetLink.Data` and a partial `BladesRoll.Schema`. This ensures
   * that any subclass of `BladesRoll` can use this method to create instances of itself while
   * applying any class-specific configurations or behaviors.
   *
   * @param {BladesRoll.Config} config The configuration object for creating a new roll instance.
   * This configuration includes all necessary data to initialize the roll, such as user permissions,
   * roll type, and any modifications or additional data required for the roll's operation.
   *
   * @returns {Promise<InstanceType<C>>} A promise that resolves to an instance of the class
   * from which `New` was called. This allows for the dynamic creation of roll instances based
   * on the subclass calling the method, ensuring that the returned instance is of the correct type.
   *
   * @example
   * // Assuming `MyCustomRoll` is a subclass of `BladesRoll`
   * MyCustomRoll.New(myConfig).then(instance => {
   *   // `instance` is of type `MyCustomRoll`
   * });
   *
   * @remarks
   * - The method performs several key operations as part of the roll instance creation process:
   *   1. Builds link configuration based on the provided config.
   *   2. Prepares roll user flag data to determine permissions for different users.
   *   3. Validates that a roll type is defined in the config, throwing an error if not.
   *   4. Logs the roll data for debugging or auditing purposes.
   *   5. Constructs and initializes the roll instance, including setting up roll modifications
   *      and sending out socket calls to inform all users about the roll.
   * - This method is central to the dynamic and flexible creation of roll instances within the
   *   system, allowing for easy extension and customization in subclasses of `BladesRoll`.
   */
  static async New(config3) {
    const linkConfig = this.BuildLinkConfig(config3);
    config3.userPermissions = this.GetUserPermissions(config3);
    if (!config3.rollType) {
      throw new Error("rollType must be defined in config");
    }
    eLog.checkLog3("bladesRoll", "BladesRoll.NewRoll()", { config: config3 });
    const rollInst = await this.Create({ ...config3, ...linkConfig });
    if (!rollInst.isInitPromiseResolved) {
      eLog.checkLog3("bladesRoll", "BladesRoll Init Promise NOT Resolved After Awaiting Create");
      await U.waitFor(rollInst.initPromise);
    } else {
      eLog.checkLog3("bladesRoll", "BladesRoll Init Promise Resolved After Awaiting Create");
    }
    rollInst.constructRollCollab_SocketCall(rollInst.linkData);
    return rollInst;
  }
  async initTargetLink() {
    this.initialSchema.rollModsData = this.rollModsDataSet;
    super.initTargetLink();
  }
  get rollModsSchemaSets() {
    var _a2;
    const compiledModSchemaSets = [];
    if (this.rollPrimary) {
      compiledModSchemaSets.push(
        ...this.rollPrimary.rollPrimaryModsSchemaSet.filter((pSchema) => compiledModSchemaSets.every((mSchema) => mSchema.key !== pSchema.key))
      );
    }
    if ((_a2 = this.rollOpposition) == null ? void 0 : _a2.rollOppModsSchemaSet) {
      compiledModSchemaSets.push(
        ...this.rollOpposition.rollOppModsSchemaSet.filter((oSchema) => compiledModSchemaSets.every((mSchema) => mSchema.key !== oSchema.key))
      );
    }
    compiledModSchemaSets.push(...this.constructor.DefaultRollModSchemaSet.filter((dSchema) => compiledModSchemaSets.every((mSchema) => mSchema.key !== dSchema.key)));
    if (this.rollDowntimeAction) {
      compiledModSchemaSets.push({
        key: "HelpFromFriend-positive-roll",
        name: "Help From a Friend",
        section: RollModSection.position,
        base_status: RollModStatus.ToggledOff,
        posNeg: "positive",
        modType: RollModType.general,
        value: 1,
        effectKeys: [],
        tooltip: "<h1>Help From a Friend</h1><p>Add <strong>+1d</strong> if you enlist the help of a friend or contact.</p>"
      });
      if (this.rollDowntimeAction !== DowntimeAction.IndulgeVice) {
        compiledModSchemaSets.push({
          key: "CanBuyResultLevel-positive-after",
          name: "Buying Result Level",
          section: RollModSection.after,
          base_status: RollModStatus.ForcedOn,
          posNeg: "positive",
          modType: RollModType.general,
          value: 0,
          effectKeys: [],
          tooltip: '<h1>Buying Result Level</h1><p>After your roll, you can <strong>increase the result level</strong> by one for each <strong class="gold-bright">Coin</strong> you spend.</p>'
        });
      }
      if (this.rollDowntimeAction === DowntimeAction.AcquireAsset) {
        compiledModSchemaSets.push(
          {
            key: "RepeatPurchase-positive-roll",
            name: "Repeat Purchase",
            section: RollModSection.roll,
            base_status: RollModStatus.ToggledOff,
            posNeg: "positive",
            modType: RollModType.general,
            value: 1,
            effectKeys: [],
            tooltip: "<h1>Repeat Purchase Bonus</h1><p>Add <strong>+1d</strong> if you have previously acquired this asset or service with a <strong>Acquire Asset</strong> Downtime activity.</p>"
          },
          {
            key: "RestrictedItem-negative-after",
            name: "Restricted",
            section: RollModSection.after,
            base_status: RollModStatus.Hidden,
            posNeg: "negative",
            modType: RollModType.general,
            value: 0,
            effectKeys: ["Cost-Heat2"],
            tooltip: '<h1>Restricted</h1><p>Whether contraband goods or dangerous materials, this <strong>Acquire Asset</strong> Downtime activity will add <strong class="red-bright">+2 Heat</strong> to your crew.</p>'
          }
        );
      }
    }
    return compiledModSchemaSets;
  }
  get rollModsDataSet() {
    const { linkData } = this;
    const modLinkConfig = {
      targetID: linkData.targetID,
      isScopingById: true,
      ..."targetKey" in linkData ? { targetKey: `${this.targetKeyPrefix}.rollModsData` } : {},
      ..."targetFlagKey" in linkData ? { targetFlagKey: `${this.targetFlagKeyPrefix}.rollModsData` } : {}
    };
    return Object.fromEntries(
      this.rollModsSchemaSets.map((modSchema) => {
        const modData = BladesTargetLink.ParseConfigToData(
          {
            ...BladesRollMod.ApplySchemaDefaults(modSchema),
            ...modLinkConfig
          }
        );
        return [modData.id, modData];
      })
    );
  }
  // #endregion
  // #region SOCKET CALLS & RESPONSES ~
  static GetRollSubClass(linkData) {
    const targetLink = new BladesTargetLink(linkData);
    switch (targetLink.data.rollType) {
      case RollType.Action:
        return BladesActionRoll;
      case RollType.Fortune: {
        if (targetLink.data.rollSubType === RollSubType.Engagement) {
          return BladesEngagementRoll;
        } else if (targetLink.data.rollSubType === RollSubType.Incarceration) {
          return BladesIncarcerationRoll;
        }
        return BladesFortuneRoll;
      }
      case RollType.Resistance: {
        if (targetLink.data.isInlineResistanceRoll) {
          return BladesInlineResistanceRoll;
        }
        return BladesResistanceRoll;
      }
      case RollType.IndulgeVice:
        return BladesIndulgeViceRoll;
    }
    return _BladesRoll;
  }
  constructRollCollab_SocketCall(linkData) {
    socketlib.system.executeForEveryone("constructRollCollab_SocketCall", linkData);
  }
  static constructRollCollab_SocketResponse(linkData) {
    const rollInst = new (this.GetRollSubClass(linkData))(linkData);
    eLog.checkLog3("rollCollab", "constructRollCollab_SocketResponse()", { params: { linkData }, rollInst });
    this.renderRollCollab_SocketResponse(rollInst.id, true);
  }
  renderRollCollab_SocketCall(isForcing = false) {
    socketlib.system.executeForEveryone("renderRollCollab_SocketCall", this.id, isForcing);
  }
  static renderRollCollab_SocketResponse(id, isForcing = false) {
    const rollInst = game.eunoblades.Rolls.get(id);
    if (!rollInst) {
      throw new Error(`[BladesRoll.renderRollCollab_SocketResponse] No roll found with id ${id}.`);
    }
    if (isForcing || rollInst.isRendered) {
      rollInst.renderRollCollab();
    }
  }
  closeRollCollab_Animation() {
    return U.gsap.effects.blurRemove(this.elem$, { ignoreMargins: true });
  }
  async closeRollCollab_SocketCall() {
    if (!game.user.isGM) {
      return;
    }
    socketlib.system.executeForOthers("closeRollCollab_SocketCall", this.id);
    await U.waitFor(this.closeRollCollab_Animation());
  }
  static closeRollCollab_SocketResponse(id) {
    var _a2;
    (_a2 = game.eunoblades.Rolls.get(id)) == null ? void 0 : _a2.closeRollCollab_Animation();
  }
  // #endregion
  // #region Roll Participation & User Permissions
  async addRollParticipant(participantRef, rollSection, rollSubSection) {
    if (!rollSubSection) {
      rollSubSection = "Assist";
    }
    const participantData = typeof participantRef === "string" ? game.actors.get(participantRef) ?? game.actors.getName(participantRef) ?? game.items.get(participantRef) ?? game.items.getName(participantRef) : participantRef;
    if (!BladesRollParticipant.IsValidData(participantData)) {
      throw new Error("Bad data.");
    }
    const rollParticipant = new BladesRollParticipant(this, rollSection, rollSubSection, participantData);
    await rollParticipant.updateRollFlags();
    if (this.isRendered) {
      socketlib.system.executeForEveryone("renderRollCollab_SocketCall", this.id);
    }
  }
  async removeRollParticipant(rollSection, rollSubSection) {
    await this.updateTarget(`rollParticipantData.${rollSection}.${rollSubSection}`, null);
  }
  async updateUserPermission(_user, _permission) {
  }
  // #endregion
  // #region Basic User Flag Getters/Setters ~
  // get data(): BladesRoll.FlagData {
  //   if (!this.document.getFlag(C.SYSTEM_ID, "rollCollab")) {
  //     throw new Error("[get flags()] No RollCollab Flags Found on User Document");
  //   }
  //   return this.document.getFlag(C.SYSTEM_ID, "rollCollab") as BladesRoll.FlagData;
  // }
  get rollPrimary() {
    return this._rollPrimary;
  }
  get rollPrimaryDoc() {
    return this.rollPrimary.rollPrimaryDoc;
  }
  get rollOpposition() {
    var _a2;
    if (!this._rollOpposition && BladesRollOpposition.IsValidData(this.data.rollOppData)) {
      this._rollOpposition = new BladesRollOpposition(this, this.data.rollOppData);
    }
    return (_a2 = this._rollOpposition) == null ? void 0 : _a2.refresh();
  }
  set rollOpposition(val) {
    if (val === void 0) {
      this._rollOpposition = void 0;
    } else {
      this._rollOpposition = val;
      val.updateRollFlags();
    }
  }
  get rollClockKey() {
    return this.data.rollClockKey ? game.eunoblades.ClockKeys.get(this.data.rollClockKey) : void 0;
  }
  set rollClockKey(val) {
    this.updateTarget("rollClockKeyID", val ?? null);
  }
  /**
   * This method prepares the roll participant data.
   * It iterates over the roll sections (roll, position, effect) and for each section,
   * it creates a new BladesRollParticipant instance for each participant in that section.
   * The created instances are stored in the rollParticipants object.
   */
  prepareRollParticipantData() {
    const participantFlagData = this.data.rollParticipantData;
    if (!participantFlagData) {
      return;
    }
    const rollParticipants = {};
    [
      RollModSection.roll,
      RollModSection.position,
      RollModSection.effect
    ].forEach((rollSection) => {
      const sectionFlagData = participantFlagData[rollSection];
      if (sectionFlagData) {
        const sectionParticipants = {};
        Object.entries(sectionFlagData).forEach(([subSection, subSectionFlagData]) => {
          if (subSectionFlagData) {
            sectionParticipants[subSection] = new BladesRollParticipant(this, rollSection, subSection, subSectionFlagData);
          }
        });
        rollParticipants[rollSection] = sectionParticipants;
      }
    });
    this._rollParticipants = rollParticipants;
  }
  get rollParticipants() {
    return this._rollParticipants;
  }
  getRollParticipant(section, subSection) {
    var _a2;
    if (isParticipantSection(section) && isParticipantSubSection(subSection)) {
      const sectionData = (_a2 = this.rollParticipants) == null ? void 0 : _a2[section];
      if (sectionData) {
        return sectionData[subSection] ?? null;
      }
    }
    return null;
  }
  get rollParticipantSelectOptions() {
    const nonPrimaryPCs = BladesPC$1.All.filter((actor) => actor.hasTag(Tag.PC.ActivePC) && actor.id !== this.rollPrimary.rollPrimaryID).map((actor) => ({ value: actor.id, display: actor.name }));
    return {
      Assist: nonPrimaryPCs,
      Setup: nonPrimaryPCs,
      Group: nonPrimaryPCs
    };
  }
  get rollType() {
    return this.data.rollType;
  }
  get rollSubType() {
    return this.data.rollSubType;
  }
  set rollSubType(val) {
    this.updateTarget("rollSubType", val ?? null);
  }
  get rollPhase() {
    return this.data.rollPhase ?? RollPhase.Collaboration;
  }
  get rollDowntimeAction() {
    return this.data.rollDowntimeAction;
  }
  get rollTrait() {
    return this.data.rollTrait;
  }
  get rollTraitVerb() {
    if (!this.rollTrait) {
      return void 0;
    }
    if (!(this.rollTrait in C.ActionVerbs)) {
      return void 0;
    }
    return C.ActionVerbs[this.rollTrait];
  }
  get rollTraitPastVerb() {
    if (!this.rollTrait) {
      return void 0;
    }
    if (!(this.rollTrait in C.ActionPastVerbs)) {
      return void 0;
    }
    return C.ActionPastVerbs[this.rollTrait];
  }
  get rollTraitValOverride() {
    return this._rollTraitValOverride;
  }
  set rollTraitValOverride(val) {
    this._rollTraitValOverride = val;
  }
  get rollTraitData() {
    var _a2, _b;
    if (BladesActor$1.IsType(this.rollPrimaryDoc, BladesActorType.pc)) {
      if (isAction(this.rollTrait)) {
        return {
          name: this.rollTrait,
          value: this.rollTraitValOverride ?? this.rollPrimaryDoc.actions[this.rollTrait],
          max: this.rollTraitValOverride ?? this.rollPrimaryDoc.actions[this.rollTrait],
          pcTooltip: this.rollPrimaryDoc.rollTraitPCTooltipActions,
          gmTooltip: C.ActionTooltipsGM[this.rollTrait]
        };
      }
      if (isAttribute(this.rollTrait)) {
        return {
          name: this.rollTrait,
          value: this.rollTraitValOverride ?? this.rollPrimaryDoc.attributes[this.rollTrait],
          max: this.rollTraitValOverride ?? this.rollPrimaryDoc.attributes[this.rollTrait],
          pcTooltip: this.rollPrimaryDoc.rollTraitPCTooltipAttributes,
          gmTooltip: C.AttributeTooltips[this.rollTrait]
        };
      }
    }
    if (U.isInt(this.rollTrait)) {
      return {
        name: `+${this.rollTraitValOverride ?? this.rollTrait}`,
        value: this.rollTraitValOverride ?? this.rollTrait,
        max: this.rollTraitValOverride ?? this.rollTrait
      };
    }
    if (isFactor(this.rollTrait)) {
      return {
        name: U.tCase(this.rollTrait),
        value: this.rollTraitValOverride ?? ((_a2 = this.rollPrimary.rollFactors[this.rollTrait]) == null ? void 0 : _a2.value) ?? 0,
        max: this.rollTraitValOverride ?? ((_b = this.rollPrimary.rollFactors[this.rollTrait]) == null ? void 0 : _b.max) ?? 10
      };
    }
    throw new Error(`[get rollTraitData] Invalid rollTrait: '${this.rollTrait}'`);
  }
  get rollTraitOptions() {
    if (BladesActor$1.IsType(this.rollPrimaryDoc, BladesActorType.pc)) {
      if (isAction(this.rollTrait)) {
        return Object.values(ActionTrait).map((action) => ({
          name: U.uCase(action),
          value: action
        }));
      }
      if (isAttribute(this.rollTrait)) {
        return Object.values(AttributeTrait).map((attribute) => ({
          name: U.uCase(attribute),
          value: attribute
        }));
      }
    }
    if (U.isInt(this.rollTrait)) {
      return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10].map((num) => ({
        name: `+${num}`,
        value: num
      }));
    }
    if (isFactor(this.rollTrait)) {
      return [];
    }
    throw new Error(`[get rollTraitOptions] Invalid rollTrait: '${this.rollTrait}'`);
  }
  get posEffectTrade() {
    var _a2;
    return ((_a2 = this.data) == null ? void 0 : _a2.rollPosEffectTrade) ?? false;
  }
  // getFlagVal<T>(flagKey?: string): T | undefined {
  //   if (flagKey) {
  //     return this.document.getFlag(C.SYSTEM_ID, `rollCollab.${flagKey}`.replace(/(rollCollab\.)+/g, "rollCollab.")) as T | undefined;
  //   }
  //   return this.document.getFlag(C.SYSTEM_ID, "rollCollab") as T | undefined;
  // }
  // async setFlagVal(flagKey: string, flagVal: unknown, isRerendering = true) {
  //   await this.document.setFlag(C.SYSTEM_ID, `rollCollab.${flagKey}`.replace(/(rollCollab\.)+/g, "rollCollab."), flagVal);
  //   if (isRerendering) {
  //     socketlib.system.executeForEveryone("renderRollCollab_SocketCall", this.id);
  //   }
  // }
  // async clearFlagVal(flagKey: string, isRerendering = true) {
  //   await this.document.unsetFlag(C.SYSTEM_ID, `rollCollab.${flagKey}`.replace(/(rollCollab\.)+/g, "rollCollab."));
  //   if (isRerendering) {
  //     socketlib.system.executeForEveryone("renderRollCollab_SocketCall", this.id);
  //   }
  // }
  get initialPosition() {
    return this.data.rollPositionInitial ?? Position.risky;
  }
  set initialPosition(val) {
    this.updateTarget("rollPositionInitial", val ?? Position.risky);
  }
  get initialEffect() {
    return this.data.rollEffectInitial ?? Effect.standard;
  }
  set initialEffect(val) {
    this.updateTarget("rollEffectInitial", val ?? Effect.standard);
  }
  get isApplyingConsequences() {
    if (this.rollType !== RollType.Action) {
      return false;
    }
    if (!this.rollResult) {
      return false;
    }
    if (![RollResult.partial, RollResult.fail].includes(this.rollResult)) {
      return false;
    }
    return true;
  }
  // Get rollConsequence() --> For resistance rolls.
  get rollConsequence() {
    const { consequence } = this.data.resistanceData ?? {};
    if (!(consequence == null ? void 0 : consequence.id)) {
      return void 0;
    }
    return game.eunoblades.Consequences.get(consequence.id) ?? new BladesConsequence(consequence);
  }
  // #endregion
  // #region GETTERS: DERIVED DATA ~
  get rollPositionFinal() {
    return Object.values(Position)[U.clampNum(
      Object.values(Position).indexOf(this.initialPosition) + this.getModsDelta(RollModSection.position) + (this.posEffectTrade === "position" ? 1 : 0) + (this.posEffectTrade === "effect" ? -1 : 0),
      [0, 2]
    )];
  }
  get rollEffectFinal() {
    return Object.values(Effect)[U.clampNum(
      Object.values(Effect).indexOf(this.initialEffect) + this.getModsDelta(RollModSection.effect) + (this.posEffectTrade === "effect" ? 1 : 0) + (this.posEffectTrade === "position" ? -1 : 0),
      [0, 4]
    )];
  }
  get rollResultDelta() {
    var _a2;
    return this.getModsDelta(RollModSection.result) + (((_a2 = this.data) == null ? void 0 : _a2.GMBoosts.Result) ?? 0) + (this.tempGMBoosts.Result ?? 0);
  }
  get rollResultFinal() {
    if (this.rollResult === false) {
      return false;
    }
    if (this.rollResultDelta === 0) {
      return this.rollResult;
    }
    switch (this.rollType) {
      case RollType.Action:
      case RollType.Fortune: {
        return Object.values(RollResult).toReversed()[U.clampNum(
          Object.values(RollResult).toReversed().indexOf(this.rollResult) + this.rollResultDelta,
          [0, 3]
        )];
      }
      case RollType.Resistance: {
        if (this.isCritical) {
          return -1;
        }
        return U.clampNum(6 - this.highestDieVal - this.rollResultDelta, [-1, Infinity]);
      }
      case RollType.IndulgeVice: {
        return U.clampNum(this.highestDieVal + this.rollResultDelta, [0, Infinity]);
      }
    }
    return false;
  }
  get finalDicePool() {
    return Math.max(0, this.rollTraitData.value + this.getModsDelta(RollModSection.roll) + (this.data.GMBoosts.Dice ?? 0) + (this.tempGMBoosts.Dice ?? 0));
  }
  get isRollingZero() {
    return Math.max(0, this.rollTraitData.value + this.getModsDelta(RollModSection.roll) + (this.data.GMBoosts.Dice ?? 0) + (this.tempGMBoosts.Dice ?? 0)) <= 0;
  }
  get roll() {
    this._roll ?? (this._roll = new Roll(`${this.isRollingZero ? 2 : this.finalDicePool}d6`, {}));
    return this._roll;
  }
  get rollFactors() {
    const defaultFactors = {
      [Factor.tier]: {
        name: "Tier",
        value: 0,
        max: 0,
        baseVal: 0,
        display: "?",
        isActive: false,
        isPrimary: true,
        isDominant: false,
        highFavorsPC: true,
        cssClasses: "factor-gold"
      },
      [Factor.quality]: {
        name: "Quality",
        value: 0,
        max: 0,
        baseVal: 0,
        display: "?",
        isActive: false,
        isPrimary: false,
        isDominant: false,
        highFavorsPC: true,
        cssClasses: "factor-gold"
      },
      [Factor.scale]: {
        name: "Scale",
        value: 0,
        max: 0,
        baseVal: 0,
        display: "?",
        isActive: false,
        isPrimary: false,
        isDominant: false,
        highFavorsPC: true,
        cssClasses: "factor-gold"
      },
      [Factor.magnitude]: {
        name: "Magnitude",
        value: 0,
        max: 0,
        baseVal: 0,
        display: "?",
        isActive: false,
        isPrimary: false,
        isDominant: false,
        highFavorsPC: true,
        cssClasses: "factor-gold"
      }
    };
    const mergedSourceFactors = U.objMerge(
      U.objMerge(
        defaultFactors,
        this.rollPrimary.rollFactors,
        { isMutatingOk: false }
      ),
      this.data.rollFactorToggles.source,
      { isMutatingOk: false }
    );
    const mergedOppFactors = this.rollOpposition ? U.objMerge(
      U.objMerge(
        defaultFactors,
        this.rollOpposition.rollFactors,
        { isMutatingOk: false }
      ),
      this.data.rollFactorToggles.opposition,
      { isMutatingOk: false }
    ) : {};
    return {
      source: Object.fromEntries(
        Object.entries(mergedSourceFactors).map(([factor, factorData]) => {
          factorData.value += (this.data.GMBoosts[factor] ?? 0) + (this.tempGMBoosts[factor] ?? 0);
          if (factor === Factor.tier) {
            factorData.display = U.romanizeNum(factorData.value);
          } else {
            factorData.display = `${factorData.value}`;
          }
          return [factor, factorData];
        })
      ),
      opposition: Object.fromEntries(
        Object.entries(mergedOppFactors).map(([factor, factorData]) => {
          factorData.value += this.data.GMOppBoosts[factor] ?? 0;
          if (factor === Factor.tier) {
            factorData.display = U.romanizeNum(factorData.value);
          } else {
            factorData.display = `${factorData.value}`;
          }
          return [factor, factorData];
        })
      )
    };
  }
  // #endregion
  // #region ROLL MODS: Getters & Update Method ~
  initRollMods() {
    this.rollTraitValOverride = void 0;
    this.rollFactorPenaltiesNegated = {};
    this.tempGMBoosts = {};
    const initReport = {};
    let initReportCount = 0;
    const watchMod = (label) => {
      if (_BladesRoll.Debug.modWatch === false) {
        return;
      }
      const reportLabel = `(${initReportCount}) == ${label}`;
      const rollMod = this.rollMods.find((mod) => _BladesRoll.Debug.modWatch && _BladesRoll.Debug.modWatch.exec(mod.name));
      if (rollMod) {
        initReport[`${reportLabel} : ${rollMod.status}`] = {
          inst: rollMod,
          data: { ...rollMod.data },
          sourceName: rollMod.sourceName,
          status: {
            ALL: rollMod.status,
            base: rollMod.baseStatus,
            held: rollMod.heldStatus,
            user: rollMod.userStatus
          },
          is: {
            active: rollMod.isActive,
            visible: rollMod.isVisible,
            conditional: rollMod.isConditional,
            inInactiveBlock: rollMod.isInInactiveBlock,
            isPush: rollMod.isPush,
            isBasicPush: rollMod.isBasicPush
          }
        };
      } else {
        initReport[reportLabel] = "MOD NOT FOUND";
      }
      initReportCount++;
    };
    watchMod("INITIAL");
    this._rollMods = this.rollMods.filter((rollMod) => rollMod.isValidForRollType());
    watchMod("ROLLTYPE VALIDATION");
    const conditionalDisablePass = this.rollMods.filter((rollMod) => !rollMod.setConditionalStatus());
    watchMod("DISABLE - CONDITIONAL");
    const autoRevealDisablePass = conditionalDisablePass.filter((rollMod) => !rollMod.setAutoStatus());
    watchMod("DISABLE - AUTO-REVEAL/ENABLE");
    autoRevealDisablePass.forEach((rollMod) => {
      rollMod.setPayableStatus();
    });
    watchMod("DISABLE - PAYABLE");
    const parseForceOnKeys = (mod) => {
      var _a2, _b;
      const holdKeys = mod.effectKeys.filter((key) => key.startsWith("ForceOn"));
      if (holdKeys.length === 0) {
        return;
      }
      while (holdKeys.length) {
        const thisTarget = (_b = (_a2 = holdKeys.pop()) == null ? void 0 : _a2.split(/-/)) == null ? void 0 : _b.pop();
        if (thisTarget === "BestAction") {
          if (BladesPC$1.IsType(this.rollPrimaryDoc)) {
            this.rollTraitValOverride = Math.max(...Object.values(this.rollPrimaryDoc.actions));
          }
        } else {
          const [targetName, targetCat, targetPosNeg] = (thisTarget == null ? void 0 : thisTarget.split(/,/)) ?? [];
          if (!targetName) {
            throw new Error(`No targetName found in thisTarget: ${thisTarget}.`);
          }
          let targetMod = this.getRollModByName(targetName) ?? this.getRollModByName(targetName, targetCat ?? mod.section);
          if (!targetMod && targetName === "Push") {
            [targetMod] = [
              ...this.getActiveBasicPushMods(targetCat ?? mod.section, "negative").filter((m) => m.status === RollModStatus.ToggledOn),
              ...this.getActiveBasicPushMods(targetCat ?? mod.section, "positive").filter((m) => m.status === RollModStatus.ToggledOn),
              ...this.getInactiveBasicPushMods(targetCat ?? mod.section, "positive").filter((m) => m.status === RollModStatus.ToggledOff)
            ];
          }
          targetMod ?? (targetMod = this.getRollModByName(targetName, targetCat ?? mod.section, targetPosNeg ?? mod.posNeg));
          if (!targetMod) {
            throw new Error(`No mod found matching ${targetName}/${targetCat}/${targetPosNeg}`);
          }
          if (!targetMod.isActive) {
            targetMod.heldStatus = RollModStatus.ForcedOn;
            parseForceOnKeys(targetMod);
          } else {
            targetMod.heldStatus = RollModStatus.ForcedOn;
          }
        }
      }
    };
    this.getActiveRollMods().forEach((rollMod) => parseForceOnKeys(rollMod));
    watchMod("FORCE-ON PASS");
    if (this.isForcePushed()) {
      this.getInactivePushMods().filter((mod) => !mod.isBasicPush).forEach((mod) => {
        mod.heldStatus = RollModStatus.ForcedOff;
      });
      watchMod("PUSH-CHECK: FORCE-OFF IS-PUSH");
    }
    [RollModSection.roll, RollModSection.effect].forEach((cat) => {
      if (this.isPushed(cat)) {
        if (cat === RollModSection.roll && this.isPushed(cat, "positive")) {
          const bargainMod = this.getRollModByKey("Bargain-positive-roll");
          if (bargainMod == null ? void 0 : bargainMod.isVisible) {
            bargainMod.heldStatus = RollModStatus.ForcedOff;
          }
        }
        watchMod("PUSH-CHECK: FORCE OFF BARGAIN");
      } else {
        this.getInactivePushMods(cat).filter((mod) => !mod.isBasicPush && ![RollModStatus.Hidden, RollModStatus.ForcedOff].includes(mod.status)).forEach((mod) => {
          mod.heldStatus = RollModStatus.ForcedOff;
        });
        watchMod("PUSH-CHECK: FORCE OFF IS-PUSH");
      }
    });
    this.getVisibleRollMods().forEach((mod) => {
      mod.setRelevancyStatus();
    });
    watchMod("RELEVANCY PASS");
    const activeArmorCostMod = this.getActiveRollMods().find((mod) => mod.effectKeys.includes("Cost-SpecialArmor"));
    if (activeArmorCostMod) {
      this.getVisibleRollMods().filter((mod) => !mod.isActive && mod.effectKeys.includes("Cost-SpecialArmor")).forEach((mod) => {
        mod.heldStatus = RollModStatus.ForcedOff;
      });
      watchMod("OVERPAYMENT PASS");
    }
    if (U.isEmpty(initReport)) {
      return;
    }
    eLog.checkLog2("rollMods", "*** initRollMods() PASS ***", initReport);
  }
  isTraitRelevant(trait) {
    var _a2;
    if (trait in Factor) {
      const { source, opposition } = this.rollFactors;
      return Boolean(trait in source && trait in opposition && ((_a2 = source[trait]) == null ? void 0 : _a2.isActive));
    }
    return false;
  }
  get isParticipantRoll() {
    return this.rollType === RollType.Fortune && !game.user.isGM || this.rollSubType === RollSubType.GroupParticipant;
  }
  negatePushCost() {
    const costlyPushMod = this.getActiveRollMods().find((mod) => mod.isPush && mod.stressCost > 0);
    if (costlyPushMod) {
      U.pullElement(costlyPushMod.effectKeys, (k) => k.startsWith("Cost-Stress"));
    }
  }
  negateFactorPenalty(factor) {
    this.rollFactorPenaltiesNegated[factor] = true;
  }
  isPushed(cat, posNeg) {
    return this.getActiveBasicPushMods(cat, posNeg).length > 0;
  }
  hasOpenPush(cat, posNeg) {
    return this.isPushed(cat) && this.getOpenPushMods(cat, posNeg).length > 0;
  }
  isForcePushed(cat, posNeg) {
    return this.isPushed(cat) && this.getForcedPushMods(cat, posNeg).length > 0;
  }
  get rollCosts() {
    if (!this.isPushed) {
      return 0;
    }
    const harmPush = this.getRollModByKey("Push-negative-roll");
    const rollPush = this.getRollModByKey("Push-positive-roll");
    const effectPush = this.getRollModByKey("Push-positive-effect");
    const negatePushCostMods = this.getActiveRollMods(RollModSection.after, "positive").filter((mod) => mod.effectKeys.includes("Negate-PushCost"));
    return ((harmPush == null ? void 0 : harmPush.isActive) && (harmPush == null ? void 0 : harmPush.stressCost) || 0) + ((rollPush == null ? void 0 : rollPush.isActive) && (rollPush == null ? void 0 : rollPush.stressCost) || 0) + ((effectPush == null ? void 0 : effectPush.isActive) && (effectPush == null ? void 0 : effectPush.stressCost) || 0) - negatePushCostMods.length * 2;
  }
  get rollCostData() {
    return this.getActiveRollMods().map((rollMod) => rollMod.costs ?? []).flat();
  }
  getRollModByID(id) {
    return this.rollMods.find((rollMod) => rollMod.id === id);
  }
  getRollModByName(name, cat, posNeg) {
    const modMatches = this.rollMods.filter((rollMod) => {
      if (U.lCase(rollMod.name) !== U.lCase(name)) {
        return false;
      }
      if (cat && rollMod.section !== cat) {
        return false;
      }
      if (posNeg && rollMod.posNeg !== posNeg) {
        return false;
      }
      return true;
    });
    if (modMatches.length === 0) {
      return void 0;
    }
    if (modMatches.length > 1) {
      return void 0;
    }
    return modMatches[0];
  }
  getRollModByKey(key) {
    return this.rollMods.find((rollMod) => rollMod.data.key === key);
  }
  getRollMods(cat, posNeg) {
    return this.rollMods.filter((rollMod) => (!cat || rollMod.section === cat) && (!posNeg || rollMod.posNeg === posNeg));
  }
  getVisibleRollMods(cat, posNeg) {
    return this.getRollMods(cat, posNeg).filter((rollMod) => rollMod.isVisible);
  }
  getActiveRollMods(cat, posNeg) {
    return this.getRollMods(cat, posNeg).filter((rollMod) => rollMod.isActive);
  }
  getVisibleInactiveRollMods(cat, posNeg) {
    return this.getVisibleRollMods(cat, posNeg).filter((rollMod) => !rollMod.isActive);
  }
  getPushMods(cat, posNeg) {
    return this.getRollMods(cat, posNeg).filter((rollMod) => rollMod.isPush);
  }
  getVisiblePushMods(cat, posNeg) {
    return this.getPushMods(cat, posNeg).filter((rollMod) => rollMod.isVisible);
  }
  getActivePushMods(cat, posNeg) {
    return this.getVisiblePushMods(cat, posNeg).filter((rollMod) => rollMod.isActive);
  }
  getActiveBasicPushMods(cat, posNeg) {
    return this.getActivePushMods(cat, posNeg).filter((rollMod) => rollMod.isBasicPush);
  }
  getInactivePushMods(cat, posNeg) {
    return this.getVisiblePushMods(cat, posNeg).filter((rollMod) => !rollMod.isActive);
  }
  getInactiveBasicPushMods(cat, posNeg) {
    return this.getInactivePushMods(cat, posNeg).filter((rollMod) => rollMod.isBasicPush);
  }
  getForcedPushMods(cat, posNeg) {
    return this.getActivePushMods(cat, posNeg).filter((rollMod) => rollMod.isBasicPush && rollMod.status === RollModStatus.ForcedOn);
  }
  getOpenPushMods(cat, posNeg) {
    return this.getActivePushMods(cat, posNeg).filter((rollMod) => rollMod.isBasicPush && rollMod.status === RollModStatus.ToggledOn);
  }
  /**
   * Compare function for sorting roll mods.
   * @param {BladesRollMod} modA First mod to compare.
   * @param {BladesRollMod} modB Second mod to compare.
   * @returns {number} - Comparison result.
   */
  compareMods(modA, modB) {
    const modOrder = ["Bargain", "Assist", "Setup"];
    if (modA.isBasicPush) {
      return -1;
    }
    if (modB.isBasicPush) {
      return 1;
    }
    if (modA.name === "Bargain" && modA.isActive) {
      return -1;
    }
    if (modB.name === "Bargain" && modB.isActive) {
      return 1;
    }
    if (modA.isPush) {
      return -1;
    }
    if (modB.isPush) {
      return 1;
    }
    const modAIndex = modOrder.indexOf(modA.name);
    const modBIndex = modOrder.indexOf(modB.name);
    if (modAIndex !== -1 && modBIndex !== -1) {
      return modAIndex - modBIndex;
    }
    return modA.name.localeCompare(modB.name);
  }
  get rollMods() {
    if (!this._rollMods) {
      this._rollMods = Object.values(this.data.rollModsData).map((modData) => new BladesRollMod(modData, this));
    }
    return [...this._rollMods].sort((modA, modB) => this.compareMods(modA, modB));
  }
  // #endregion
  // #region CONSEQUENCES: Getting, Accepting, Resisting
  get consequences() {
    var _a2, _b;
    const csqDataSet = (_b = (_a2 = this.data.consequenceData) == null ? void 0 : _a2[this.rollPositionFinal]) == null ? void 0 : _b[this.rollResult];
    if (csqDataSet) {
      return Object.values(csqDataSet).map((csqData) => new BladesConsequence(csqData));
    }
    return [];
  }
  getConsequenceByID(csqID) {
    return this.consequences.find((csq) => csq.id === csqID) ?? false;
  }
  get acceptedConsequences() {
    if ([RollPhase.AwaitingConsequences, RollPhase.Complete].includes(this.rollPhase)) {
      return this.consequences.filter((csq) => csq.isAccepted === true);
    }
    return [];
  }
  get unacceptedConsequences() {
    if (this.rollPhase === RollPhase.AwaitingConsequences) {
      return this.consequences.filter((csq) => csq.isAccepted !== true);
    }
    return [];
  }
  // #endregion
  // #region *** ROLL COLLAB HTML INTERACTION *** ~
  /**
   * Retrieve the data for rendering the base RollCollab sheet.
   * @returns {Promise<object>} The data which can be used to render the HTML of the sheet.
   */
  get context() {
    this.initRollMods();
    this.rollMods.forEach((rollMod) => rollMod.applyRollModEffectKeys());
    return this.getTemplateContext();
  }
  /**
   * Determines if the user is a game master.
   * @returns {boolean} Whether the user is a GM.
   */
  getIsGM() {
    var _a2;
    return ((_a2 = game.eunoblades.Tracker) == null ? void 0 : _a2.system.is_spoofing_player) ? false : game.user.isGM;
  }
  /**
   * Gets the roll costs.
   * @returns {BladesRoll.CostData[]} The roll costs.
   */
  getRollCosts() {
    return this.getActiveRollMods().map((rollMod) => rollMod.costs).flat().filter((costData) => costData !== void 0);
  }
  /**
   * Constructs the sheet data.
   * @param {boolean} isGM If the user is a GM.
   * @param {BladesRoll.CostData[]} rollCosts The roll costs.
   * @returns {BladesRoll.Context} The constructed sheet data.
   */
  getTemplateContext() {
    var _a2;
    const {
      data: rData,
      rollPrimary,
      rollTraitData,
      rollTraitOptions,
      rollClockKey,
      finalDicePool,
      rollPositionFinal,
      rollEffectFinal,
      rollResultDelta,
      rollResultFinal,
      rollMods,
      rollFactors
    } = this;
    if (!rollPrimary) {
      throw new Error("A primary roll source is required for BladesRoll.");
    }
    const baseData = {
      ...this.data,
      cssClass: "roll-collab",
      isGM: this.isGM,
      system: (_a2 = this.rollPrimaryDoc) == null ? void 0 : _a2.system,
      rollMods,
      rollPrimary,
      rollTraitData,
      rollTraitOptions,
      diceTotal: finalDicePool,
      rollOpposition: this.rollOpposition,
      rollParticipants: this.rollParticipants,
      rollParticipantOptions: this.rollParticipantSelectOptions,
      rollEffects: Object.values(Effect),
      rollTraitValOverride: this.rollTraitValOverride,
      rollFactorPenaltiesNegated: this.rollFactorPenaltiesNegated,
      posRollMods: Object.fromEntries(Object.values(RollModSection).map((cat) => [cat, this.getRollMods(cat, "positive")])),
      negRollMods: Object.fromEntries(Object.values(RollModSection).map((cat) => [cat, this.getRollMods(cat, "negative")])),
      hasInactiveConditionals: this.calculateHasInactiveConditionalsData(),
      rollFactors,
      ...this.calculateOddsHTML(finalDicePool, rollResultDelta)
    };
    const GMBoostsData = this.calculateGMBoostsData(rData);
    const positionEffectTradeData = this.calculatePositionEffectTradeData();
    const stressCostDataSet = this.getRollCosts().filter((costData) => costData.costType === "Stress").map((costData) => [costData.label, costData.costAmount]);
    const availableArmor = [];
    if (this.rollPrimaryDoc instanceof BladesPC$1) {
      availableArmor.push(...this.rollPrimaryDoc.availableArmor);
    } else if (BladesItem$1.IsType(
      this.rollPrimaryDoc,
      BladesItemType.cohort_gang,
      BladesItemType.cohort_expert
    )) {
      for (let index = 0; index < this.rollPrimaryDoc.system.armor.value; index++) {
        availableArmor.push("Armor");
      }
    }
    const armorCostDataSet = this.getRollCosts().filter((costData) => costData.costType === "Armor").map((costData, index) => [costData.label, availableArmor[index]]).filter(([_label, armorType]) => armorType !== void 0);
    const specialArmorCostDataSet = this.getRollCosts().filter((costData) => costData.costType === "SpecialArmor").map((costData) => costData.label);
    const userPermission = baseData.userPermissions[game.user.id] ?? RollPermissions.Observer;
    return {
      ...baseData,
      rollPrimary: this.rollPrimary,
      rollPositionFinal,
      rollEffectFinal,
      rollResultFinal,
      rollPositions: Object.values(Position),
      rollEffects: Object.values(Effect),
      rollResultDelta,
      isAffectingResult: rollResultDelta !== 0 || this.getVisibleRollMods(RollModSection.result).length > 0 || this.isGM && this.getRollMods(RollModSection.result).length > 0,
      isAffectingAfter: this.getVisibleRollMods(RollModSection.after).length > 0 || this.isGM && this.getRollMods(RollModSection.after).length > 0,
      ...GMBoostsData,
      ...positionEffectTradeData,
      rollClockKey,
      totalStressCost: stressCostDataSet.reduce((acc, [_label, amount]) => acc + amount, 0),
      totalArmorCost: armorCostDataSet.length,
      stressCosts: stressCostDataSet.length > 0 ? Object.fromEntries(stressCostDataSet) : void 0,
      armorCosts: armorCostDataSet.length > 0 ? Object.fromEntries(armorCostDataSet) : void 0,
      specArmorCost: specialArmorCostDataSet[0],
      userPermission,
      editable: userPermission === RollPermissions.Primary || userPermission === RollPermissions.GM,
      gamePhase: game.eunoblades.Tracker.phase
    };
  }
  // type BladesSelectOption<displayType, valueType = string> = {
  //   value: valueType,
  //   display: displayType
  // };
  // protected processDowntimeActions() {
  //   const downtimeData: Record<string,any>;
  //   if (BladesActor.IsType(this.rollPrimaryDoc, BladesActorType.pc)) {
  //     downtimeData.canDoDowntimeActions = true;
  //     downtimeData.downtimeActionsRemaining = this.rollPrimaryDoc.remainingDowntimeActions;
  //     const availableDowntimeActions: DowntimeAction[] = [];
  //     if (this.rollType === RollType.Action) {
  //       availableDowntimeActions.push(...[
  //         DowntimeAction.AcquireAsset,
  //         DowntimeAction.LongTermProject,
  //         DowntimeAction.Recover,
  //         DowntimeAction.ReduceHeat
  //       ]);
  //     } else if (this.rollType === RollType.Fortune) {
  //       availableDowntimeActions.push(...[
  //         DowntimeAction.
  //       ])
  //     }
  //     downtimeData.downtimeActionOptions =
  //   downtimeActionOptions?: Array<BladesSelectOption<string, DowntimeAction>
  // }
  calculateGMBoostsData(data) {
    return {
      GMBoosts: {
        Dice: data.GMBoosts.Dice ?? 0,
        [Factor.tier]: data.GMBoosts[Factor.tier] ?? 0,
        [Factor.quality]: data.GMBoosts[Factor.quality] ?? 0,
        [Factor.scale]: data.GMBoosts[Factor.scale] ?? 0,
        [Factor.magnitude]: data.GMBoosts[Factor.magnitude] ?? 0,
        Result: data.GMBoosts.Result ?? 0
      },
      GMOppBoosts: {
        [Factor.tier]: data.GMOppBoosts[Factor.tier] ?? 0,
        [Factor.quality]: data.GMOppBoosts[Factor.quality] ?? 0,
        [Factor.scale]: data.GMOppBoosts[Factor.scale] ?? 0,
        [Factor.magnitude]: data.GMOppBoosts[Factor.magnitude] ?? 0
      }
    };
  }
  calculateOddsHTML(diceTotal, rollResultDelta) {
    if (this.rollType === RollType.Resistance) {
      return this.calculateOddsHTML_Resistance(diceTotal);
    }
    return this.calculateOddsHTML_Standard(diceTotal, rollResultDelta);
  }
  /**
   * Calculate odds starting & ending HTML based on given dice total.
   * @param {number} diceTotal Total number of dice.
   * @param {number} rollResultDelta
   * @returns {{oddsHTMLStart: string, oddsHTMLStop: string}} Opening & Closing HTML for odds bar display
   */
  calculateOddsHTML_Standard(diceTotal, rollResultDelta) {
    const oddsColors = {
      crit: "var(--blades-gold)",
      success: "var(--blades-white-bright)",
      partial: "var(--blades-grey)",
      fail: "var(--blades-black-dark)"
    };
    const odds = { ...C.DiceOddsStandard[diceTotal] };
    if (rollResultDelta < 0) {
      for (let i = rollResultDelta; i < 0; i++) {
        oddsColors.crit = oddsColors.success;
        oddsColors.success = oddsColors.partial;
        oddsColors.partial = oddsColors.fail;
      }
    } else if (rollResultDelta > 0) {
      for (let i = 0; i < rollResultDelta; i++) {
        oddsColors.fail = oddsColors.partial;
        oddsColors.partial = oddsColors.success;
        oddsColors.success = oddsColors.crit;
      }
    }
    const resultElements = [];
    Object.entries(odds).reverse().forEach(([result, chance]) => {
      if (chance === 0) {
        return;
      }
      resultElements.push(`<div class="odds-section" style="height: 100%; width: ${chance}%; background: ${oddsColors[result]};">&nbsp;</div>`);
    });
    return {
      oddsHTMLStart: [
        '<div class="roll-odds-section-container">',
        ...resultElements
      ].join("\n"),
      oddsHTMLStop: "</div>"
    };
  }
  /**
   * Calculate odds starting & ending HTML based on given dice total.
   * @param {number} diceTotal Total number of dice.
   * @returns {{oddsHTMLStart: string, oddsHTMLStop: string}} Opening & Closing HTML for odds bar display
   */
  calculateOddsHTML_Resistance(diceTotal) {
    const oddsColors = [
      "var(--blades-gold)",
      // -1
      "var(--blades-white)",
      // 0
      "var(--blades-red)",
      // 1
      "var(--blades-red)",
      // 2
      "var(--blades-red)",
      // 3
      "var(--blades-red)",
      // 4
      "var(--blades-red)"
      // 5
    ].reverse();
    const oddsFilters = [
      "none",
      "none",
      "brightness(0.2)",
      "brightness(0.4)",
      "brightness(0.6)",
      "brightness(0.8)",
      "none"
    ].reverse();
    const odds = [...C.DiceOddsResistance[diceTotal]].reverse();
    const resultElements = [];
    for (let index = 0; index < odds.length; index++) {
      const chance = odds[index];
      if (chance > 0) {
        const color = oddsColors[index];
        const filter = oddsFilters[index];
        resultElements.push(...[
          `<div class="odds-section odds-section-stress" style="height: 100%; width: ${chance}%; background: ${color}; filter: ${filter};">&nbsp;</div>`
        ]);
      }
    }
    return {
      oddsHTMLStart: [
        '<div class="roll-odds-section-container">',
        ...resultElements
      ].join("\n"),
      oddsHTMLStop: "</div>"
    };
  }
  /**
   * Calculate data for position and effect trade.
   * @returns {{canTradePosition: boolean, canTradeEffect: boolean}}
   */
  calculatePositionEffectTradeData() {
    const canTradePosition = this.posEffectTrade === "position" || this.posEffectTrade === false && this.rollPositionFinal !== Position.desperate && this.rollEffectFinal !== Effect.extreme;
    const canTradeEffect = this.posEffectTrade === "effect" || this.posEffectTrade === false && this.rollPositionFinal !== Position.controlled && this.rollEffectFinal !== Effect.zero;
    return { canTradePosition, canTradeEffect };
  }
  /**
   * Calculate data on whether there are any inactive conditionals.
   * @returns {Record<RollModSection, boolean>} - Data on inactive conditionals.
   */
  calculateHasInactiveConditionalsData() {
    const hasInactive = {};
    for (const section of Object.values(RollModSection)) {
      hasInactive[section] = this.getRollMods(section).filter((mod) => mod.isInInactiveBlock).length > 0;
    }
    return hasInactive;
  }
  get dieVals() {
    return this.roll.terms[0].results.map((result) => result.result).sort().reverse();
  }
  // Accounts for rolling zero dice by removing highest.
  get finalDieVals() {
    return this.isRollingZero ? this.dieVals.slice(1) : this.dieVals;
  }
  get finalDiceData() {
    eLog.checkLog3("rollCollab", "[get finalDiceData()]", { roll: this, dieVals: this.dieVals });
    const dieVals = [...this.dieVals];
    const ghostNum = this.isRollingZero ? dieVals.shift() : null;
    const isCritical = dieVals.filter((val) => val === 6).length >= 2;
    const diceData = dieVals.map((val, i) => ({
      value: val,
      dieClass: _BladesRoll.GetDieClass(this.rollType, this.rollResult, val, i),
      dieImage: _BladesRoll.GetDieImage(this.rollType, this.rollResult, val, i, false, isCritical)
    }));
    if (ghostNum) {
      diceData.push({
        value: ghostNum,
        dieClass: "blades-die-ghost",
        dieImage: _BladesRoll.GetDieImage(this.rollType, this.rollResult, ghostNum, diceData.length, true, false)
      });
    }
    return diceData;
  }
  // #endregion
  // #region RESULT GETTERS ~
  get isCritical() {
    return this.finalDieVals.filter((val) => val === 6).length >= 2;
  }
  get isSuccess() {
    return Boolean(!this.isCritical && this.finalDieVals.find((val) => val === 6));
  }
  get isPartial() {
    return Boolean(!this.isCritical && !this.isSuccess && this.finalDieVals.find((val) => val && val >= 4));
  }
  get isFail() {
    return !this.isCritical && !this.isSuccess && !this.isPartial;
  }
  get highestDieVal() {
    return this.finalDieVals[0];
  }
  get rollResult() {
    throw new Error("[BladesRoll.rollResult] Unimplemented by Subclass.");
  }
  // #endregion
  get isResolved() {
    return this.roll.total !== void 0;
  }
  async evaluateRoll() {
    if (this.isResolved) {
      this.closeRollCollab_Animation();
      return this.data;
    }
    this.closeRollCollab_SocketCall();
    eLog.checkLog3("rollCollab", "[resolveRoll()] Before Evaluation", { roll: this, rollData: { ...this.data } });
    await this.roll.evaluate({ async: true });
    return this.updateTargetData({
      ...this.data,
      rollPositionFinal: this.rollPositionFinal,
      rollEffectFinal: this.rollEffectFinal,
      rollResult: this.rollResult,
      rollTraitVerb: this.rollTraitVerb,
      rollTraitPastVerb: this.rollTraitPastVerb,
      finalDiceData: this.finalDiceData,
      rollPhase: this.isApplyingConsequences ? RollPhase.AwaitingConsequences : RollPhase.Complete
    });
  }
  async resolveRollResult() {
    throw new Error("[BladesRoll.resolveRollResult] Unimplemented by Subclass.");
  }
  async outputRollToChat() {
    await BladesChat$1.create({ bladesRoll: this });
  }
  async resolveRoll() {
    await this.evaluateRoll();
    this.resolveRollResult();
    await this.outputRollToChat();
  }
  // #endregion
  // #region *** INTERFACING WITH BLADESCHAT ***
  getSpeaker(chatSpeaker) {
    var _a2;
    const { rollPrimaryID, rollPrimaryName, rollPrimaryType, rollPrimaryDoc } = this.rollPrimary;
    chatSpeaker.alias = rollPrimaryName;
    if ([BladesItemType.cohort_gang, BladesItemType.cohort_expert].includes(rollPrimaryType)) {
      chatSpeaker.actor = ((_a2 = rollPrimaryDoc == null ? void 0 : rollPrimaryDoc.parent) == null ? void 0 : _a2.id) ?? chatSpeaker.actor;
      if ((rollPrimaryDoc == null ? void 0 : rollPrimaryDoc.parent) instanceof BladesPC$1) {
        chatSpeaker.alias = `${chatSpeaker.alias} (${rollPrimaryDoc.parent.name})`;
      }
    } else if ([BladesItemType.gm_tracker, BladesItemType.score].includes(rollPrimaryType)) {
      chatSpeaker.actor = null;
      chatSpeaker.alias = "The Gamemaster";
    } else if (rollPrimaryID) {
      chatSpeaker.actor = rollPrimaryID;
    }
    return chatSpeaker;
  }
  get overlayPosition() {
    return this._overlayPosition;
  }
  set overlayPosition(val) {
    this._overlayPosition = val;
  }
  get elem$() {
    if (this._elem$) {
      return this._elem$;
    }
    const elem$ = $(`#${this.id}`);
    if (elem$.length) {
      this._elem$ = elem$;
    } else {
      this._elem$ = $(`<div id="${this.id}" class="app window-app ${C.SYSTEM_ID} sheet roll-collab${game.user.isGM ? " gm-roll-collab" : ""}"></div>`).appendTo("body");
      this._elem$.css({
        left: `${this.overlayPosition.x}px`,
        top: `${this.overlayPosition.y}px`
      });
    }
    return this._elem$;
  }
  async renderRollCollab() {
    this.prepareRollParticipantData();
    const html = await renderTemplate(this.collabTemplate, this.context);
    this.elem$.html(html);
    this.activateListeners();
  }
  get isRendered() {
    var _a2;
    return Boolean((_a2 = this._elem$) == null ? void 0 : _a2.length);
  }
  get collabTemplate() {
    throw new Error("[BladesRoll.collabTemplate] Unimplemented by Subclass.");
  }
  get chatTemplate() {
    throw new Error("[BladesRoll.chatTemplate] Unimplemented by Subclass.");
  }
  // #region LISTENER FUNCTIONS ~
  // async _handleConsequenceClick(event: ClickEvent) {
  //   const clickTarget$ = $(event.currentTarget);
  //   const csqParent$ = clickTarget$.closest(".comp.consequence-display-container");
  //   const csqID = csqParent$.data("csq-id");
  //   const chatElem$ = csqParent$.closest(".blades-roll");
  //   const chatMessage$ = chatElem$.closest(".chat-message");
  //   const chatID = chatMessage$.data("messageId") as IDString;
  //   const chatMessage = game.messages.get(chatID);
  //   if (!chatMessage) {return;}
  //   const csqs = await BladesConsequence.GetFromChatMessage(chatMessage);
  //   const thisCsq = csqs.find((csq) => csq.id === csqID);
  //   if (!thisCsq) {return;}
  //   switch (clickTarget$.data("action")) {
  //     case "accept-consequence": return thisCsq.resolveAccept();
  //     case "resist-consequence": return thisCsq.resistConsequence();
  //     case "armor-consequence": return thisCsq.resistArmorConsequence();
  //     case "special-consequence": return thisCsq.resistSpecialArmorConsequence();
  //   }
  //   return undefined as never;
  // }
  _toggleRollModClick(event) {
    event.preventDefault();
    const elem$ = $(event.currentTarget);
    const id = elem$.data("id");
    const rollMod = this.getRollModByID(id);
    if (!rollMod) {
      throw new Error(`Unable to find roll mod with id '${id}'`);
    }
    switch (rollMod.status) {
      case RollModStatus.Hidden:
        rollMod.userStatus = RollModStatus.ForcedOff;
        break;
      case RollModStatus.ForcedOff:
        rollMod.userStatus = RollModStatus.ToggledOff;
        break;
      case RollModStatus.ToggledOff:
        rollMod.userStatus = RollModStatus.ToggledOn;
        break;
      case RollModStatus.ToggledOn:
        rollMod.userStatus = game.user.isGM ? RollModStatus.ForcedOn : RollModStatus.ToggledOff;
        break;
      case RollModStatus.ForcedOn:
        rollMod.userStatus = RollModStatus.Hidden;
        break;
      default:
        throw new Error(`Unrecognized RollModStatus: ${rollMod.status}`);
    }
  }
  /**
   * Handles setting of rollMod status via GM pop-out controls
   * @param {ClickEvent} event JQuery click event sent to listener.
   */
  _gmControlSet(event) {
    event.preventDefault();
    if (!game.user.isGM) {
      return;
    }
    const elem$ = $(event.currentTarget);
    const id = elem$.data("id");
    const status = elem$.data("status");
    if (!isModStatus(status) && status !== "Reset") {
      return;
    }
    const rollMod = this.getRollModByID(id);
    if (rollMod) {
      rollMod.userStatus = status === "Reset" ? void 0 : status;
    }
  }
  /**
   * Handles setting values via GM number line (e.g. roll factor boosts/modifications).
   * @param {ClickEvent} event JQuery click event sent to listener.
   */
  async _gmControlSetTargetToValue(event) {
    event.preventDefault();
    if (!game.user.isGM) {
      return;
    }
    const elem$ = $(event.currentTarget);
    const target = elem$.data("target").replace(/flags\.eunos-blades\./, "");
    const value = elem$.data("value");
    await this.updateTarget(target, value);
    socketlib.system.executeForEveryone("renderRollCollab_SocketCall", this.id);
  }
  async _gmControlCycleTarget(event) {
    var _a2;
    event.preventDefault();
    if (!game.user.isGM) {
      return;
    }
    const elem$ = $(event.currentTarget);
    const flagTarget = elem$.data("flagTarget");
    const curVal = elem$.data("curVal");
    const cycleVals = (_a2 = elem$.data("vals")) == null ? void 0 : _a2.split(/\|/);
    if (!cycleVals) {
      throw new Error(`Unable to parse cycle values from data-vals = ${elem$.data("vals")}`);
    }
    const curValIndex = cycleVals.indexOf(curVal);
    if (curValIndex === -1) {
      throw new Error(`Unable to find current value '${curVal}' in cycle values '${elem$.data("vals")}'`);
    }
    let newValIndex = curValIndex + 1;
    if (newValIndex >= cycleVals.length) {
      newValIndex = 0;
    }
    const newVal = cycleVals[newValIndex];
    eLog.checkLog3("gmControlCycleTarget", "gmControlCycleTarget", { flagTarget, curVal, cycleVals, curValIndex, newValIndex, newVal });
    await this.updateTarget(flagTarget, newVal);
  }
  /**
   * Handles resetting value associated with GM number line on a right-click.
   * @param {ClickEvent} event JQuery context menu event sent to listener.
   */
  async _gmControlResetTarget(event) {
    event.preventDefault();
    if (!game.user.isGM) {
      return;
    }
    await this.updateTarget($(event.currentTarget).data("target"), null);
    socketlib.system.executeForEveryone("renderRollCollab_SocketCall", this.id);
  }
  /**
   * Handles setting of baseline rollPosition via GM button line
   * @param {ClickEvent} event JQuery click event sent to listener.
   */
  _gmControlSetPosition(event) {
    event.preventDefault();
    if (!game.user.isGM) {
      return;
    }
    const elem$ = $(event.currentTarget);
    const position = elem$.data("status");
    this.initialPosition = position;
  }
  /**
   * Handles setting of baseline rollPosition via GM button line
   * @param {ClickEvent} event JQuery click event sent to listener.
   */
  _gmControlSetEffect(event) {
    event.preventDefault();
    if (!game.user.isGM) {
      return;
    }
    const elem$ = $(event.currentTarget);
    const effect = elem$.data("status");
    this.initialEffect = effect;
  }
  /**
   * Handles setting of Factor toggles: isActive, isPrimary, highFavorsPC, isDominant
   * @param {ClickEvent} event JQuery click event sent to listener.
   */
  async _gmControlToggleFactor(event) {
    event.preventDefault();
    if (!game.user.isGM) {
      return;
    }
    const elem$ = $(event.currentTarget);
    const target = elem$.data("target");
    const value = !elem$.data("value");
    eLog.checkLog3("toggleFactor", "_gmControlToggleFactor", { event, target, value });
    const factorToggleData = this.data.rollFactorToggles;
    const [thisSource, thisFactor, thisToggle] = target.split(/\./).slice(-3);
    if (!["isActive", "isPrimary", "isDominant", "highFavorsPC"].includes(thisToggle)) {
      await this.updateTarget(target, value);
      socketlib.system.executeForEveryone("renderRollCollab_SocketCall", this.id);
    }
    factorToggleData[thisSource][thisFactor] = {
      ...factorToggleData[thisSource][thisFactor] ?? { display: "" },
      [thisToggle]: value
    };
    switch (thisToggle) {
      case "isDominant":
      case "isPrimary": {
        if (value === true) {
          Object.values(Factor).filter((factor) => factor !== thisFactor).forEach((factor) => {
            var _a2;
            if (((_a2 = factorToggleData[thisSource][factor]) == null ? void 0 : _a2[thisToggle]) === true) {
              factorToggleData[thisSource][factor] = {
                ...factorToggleData[thisSource][factor],
                [thisToggle]: false
              };
            }
          });
        }
        break;
      }
      case "isActive": {
        if (value === true) {
          const otherSource = thisSource === "source" ? "opposition" : "source";
          factorToggleData[otherSource][thisFactor] = {
            ...factorToggleData[otherSource][thisFactor] ?? { display: "" },
            isActive: value
          };
        }
        break;
      }
    }
    await this.updateTarget("rollFactorToggles", factorToggleData);
    socketlib.system.executeForEveryone("renderRollCollab_SocketCall", this.id);
  }
  async _onTextInputBlur(event) {
    const elem = event.target;
    const { action, targetKey } = elem.dataset;
    if (!action) {
      throw new Error("Input text elements require a data-action attribute.");
    }
    if (!targetKey) {
      throw new Error("Input text elements require a 'data-target-key' attribute.");
    }
    await this.updateTarget(targetKey, elem.value);
    socketlib.system.executeForEveryone("renderRollCollab_SocketCall", this.id);
  }
  async _onGMPopupClick(event) {
    const elem$ = $(event.currentTarget);
    const prompt = elem$.data("prompt");
    const flagTarget = elem$.data("flagTarget");
    if (prompt && flagTarget) {
      BladesDialog.DisplaySimpleInputDialog(this, prompt, void 0, flagTarget);
    }
  }
  get positionDragger() {
    if (this._positionDragger) {
      return this._positionDragger;
    }
    return this.spawnPositionDragger();
  }
  spawnPositionDragger() {
    var _a2;
    const self2 = this;
    if (!this._elem$) {
      throw new Error(`[BladesRoll.spawnPositionDragger] No elem$ found for roll ${this.id}.`);
    }
    (_a2 = this._positionDragger) == null ? void 0 : _a2.kill();
    this._positionDragger = new Draggable(this._elem$, {
      type: "top,left",
      trigger: ".window-header.dragger",
      onDragStart() {
        U.gsap.to(this.target, { opacity: 0.25, duration: 0.25, ease: "power2" });
      },
      onDragEnd() {
        U.gsap.to(this.target, { opacity: 1, duration: 0.25, ease: "power2" });
        self2.overlayPosition = { x: this.endX, y: this.endY };
      }
    });
    return this._positionDragger;
  }
  _onPlayerToggleRollMod(event) {
    event.preventDefault();
    const elem$ = $(event.currentTarget);
    const modID = elem$.attr("id");
    const mod = this.getRollModByID(modID);
    if (!mod) {
      throw new Error(`Unable to find roll mod with id '${modID}'`);
    }
    switch (mod.status) {
      case RollModStatus.ToggledOff: {
        mod.userStatus = RollModStatus.ToggledOn;
        break;
      }
      case RollModStatus.ToggledOn: {
        mod.userStatus = RollModStatus.ToggledOff;
        break;
      }
    }
  }
  _onGMToggleRollMod(event) {
    event.preventDefault();
    const eventType = event.type;
    const elem$ = $(event.currentTarget);
    const modID = elem$.attr("id");
    const mod = this.getRollModByID(modID);
    if (!mod) {
      throw new Error(`Unable to find roll mod with id '${modID}'`);
    }
    switch (mod.status) {
      case RollModStatus.Hidden: {
        mod.userStatus = {
          click: RollModStatus.ForcedOn,
          contextmenu: RollModStatus.ToggledOff
        }[eventType];
        break;
      }
      case RollModStatus.ForcedOff: {
        mod.userStatus = {
          click: RollModStatus.ForcedOn,
          contextmenu: RollModStatus.Hidden
        }[eventType];
        break;
      }
      case RollModStatus.ToggledOff: {
        mod.userStatus = {
          click: RollModStatus.ForcedOn,
          contextmenu: RollModStatus.ForcedOff
        }[eventType];
        break;
      }
      case RollModStatus.ToggledOn: {
        mod.userStatus = {
          click: RollModStatus.ForcedOff,
          contextmenu: RollModStatus.ForcedOn
        }[eventType];
        break;
      }
      case RollModStatus.ForcedOn: {
        mod.userStatus = {
          click: RollModStatus.ForcedOff,
          contextmenu: RollModStatus.ToggledOff
        }[eventType];
        break;
      }
    }
  }
  _onClickToRoll(event) {
    event.preventDefault();
    if (this.rollPhase === RollPhase.AwaitingRoll) {
      this.resolveRoll();
    }
  }
  async _onSelectChange(event) {
    event.preventDefault();
    const elem = event.currentTarget;
    const { dtype, docType, targetKey } = elem.dataset;
    if (game.user.isGM && elem.value !== "" && (docType == null ? void 0 : docType.startsWith("BladesRollParticipant"))) {
      const [_, section, subSection] = docType.split(".");
      await this.addRollParticipant(
        elem.value,
        section,
        subSection
      );
      return;
    }
    if (!targetKey) {
      throw new Error("Select elements require a 'data-target-key' attribute.");
    }
    let value;
    switch (U.lCase(dtype)) {
      case "number":
        value = U.pFloat(elem.value);
        break;
      case "boolean":
        value = U.lCase(`${elem.value}`) === "true";
        break;
      case "string":
        value = `${elem.value}`;
        break;
      default: {
        if (U.isNumString(value)) {
          throw new Error(`You must set 'data-dtype="Number"' for <select> elements with number values.`);
        }
        if (U.isBooleanString(value)) {
          throw new Error(`You must set 'data-dtype="Boolean"' for <select> elements with boolean values.`);
        }
        value = `${elem.value}`;
        break;
      }
    }
    await this.updateTarget(targetKey, value);
    socketlib.system.executeForEveryone("renderRollCollab_SocketCall", this.id);
  }
  activateListeners() {
    ApplyTooltipAnimations(this.elem$);
    this.spawnPositionDragger();
    this.elem$.find("[data-action='player-toggle-mod']").on({
      click: game.user.isGM ? this._onGMToggleRollMod.bind(this) : this._onPlayerToggleRollMod.bind(this)
    });
    this.elem$.find("[data-action='player-select']").on({ change: this._onSelectChange.bind(this) });
    this.elem$.find("[data-action='player-trade']").on({
      click: async (event) => {
        await this.updateTarget("rollPosEffectTrade", U.lCase(`${$(event.currentTarget).data("value")}`) === "false");
        socketlib.system.executeForEveryone("renderRollCollab_SocketCall", this.id);
      }
    });
    this.elem$.find("[data-action='player-roll']").on({
      click: this._onClickToRoll.bind(this)
    });
    if (!game.user.isGM) {
      return;
    }
    this.elem$.find("[data-action='player-toggle-mod']").on({
      contextmenu: this._onGMToggleRollMod.bind(this)
    });
    this.elem$.find(".controls-toggle").on({
      click: (event) => {
        event.preventDefault();
        $(event.currentTarget).parents(".controls-panel").toggleClass("active");
      }
    });
    this.elem$.find('[data-action="gm-set"]').on({
      click: this._gmControlSet.bind(this)
    });
    this.elem$.find('[data-action="gm-set-position"]').on({
      click: this._gmControlSetPosition.bind(this)
    });
    this.elem$.find('[data-action="gm-set-effect"]').on({
      click: this._gmControlSetEffect.bind(this)
    });
    this.elem$.find('[data-action="gm-set-target"]').on({
      click: this._gmControlSetTargetToValue.bind(this),
      contextmenu: this._gmControlResetTarget.bind(this)
    });
    this.elem$.find('[data-action="gm-cycle-target"]').on({
      click: this._gmControlCycleTarget.bind(this)
    });
    this.elem$.find('[data-action="gm-toggle-factor"]').on({
      click: this._gmControlToggleFactor.bind(this)
    });
    this.elem$.find("select[data-action='gm-select']").on({ change: this._onSelectChange.bind(this) });
    this.elem$.find('[data-action="gm-text-popup"]').on({ click: this._onGMPopupClick.bind(this) });
    this.elem$.find("[data-action='gm-text-input']").on({ blur: this._onTextInputBlur.bind(this) });
  }
  // #endregion
  // #endregion
  // #region OVERRIDES: _canDragDrop, _onDrop, _onSubmit, close, render ~
  // override _canDragDrop() {
  //   return game.user.isGM;
  // }
  // override _onDrop(event: DragEvent) {
  //   const {uuid} = TextEditor.getDragEventData(event) as {uuid: UUIDString};
  //   const dropDoc = fromUuidSync(uuid);
  //   if (BladesRollOpposition.IsDoc(dropDoc)) {
  //     this.rollOpposition = new BladesRollOpposition(this, {rollOppDoc: dropDoc});
  //   } else if (dropDoc instanceof BladesProject && dropDoc.clockKey) {
  //     // Project dropped on roll: Assign project's clock key to roll.
  //     this.rollClockKey = dropDoc.clockKey;
  //   }
  // }
  async submitChange(prop, val) {
    await this.updateTarget(prop, val);
    socketlib.system.executeForEveryone("renderRollCollab_SocketCall", this.id);
  }
  // #endregion
};
__publicField(_BladesRoll, "Debug", {
  modWatch: false,
  watchRollMod(name) {
    if (typeof name === "string") {
      _BladesRoll.Debug.modWatch = new RegExp(name, "g");
    } else {
      _BladesRoll.Debug.modWatch = false;
    }
  }
});
let BladesRoll = _BladesRoll;
class BladesActionRoll extends BladesRoll {
  /* Not much -- most action roll things will extend to other rolls, but split out things like Position, Effect, default Mods */
  static ApplySchemaDefaults(schemaData) {
    var _a2, _b;
    schemaData.rollType = RollType.Action;
    if (!schemaData.rollPrimaryData) {
      throw new Error("Must include a rollPrimaryData when constructing a BladesActionRoll object.");
    }
    if (!(schemaData.rollTrait === "" || U.isInt(schemaData.rollTrait) || U.lCase(schemaData.rollTrait) in { ...ActionTrait, ...Factor })) {
      throw new Error(`[BladesActionRoll.ApplySchemaDefaults()] Bad RollTrait for Action Roll: ${schemaData.rollTrait}`);
    }
    const fullSchema = super.ApplySchemaDefaults(schemaData);
    const rollPrimary = BladesRollPrimary.Build(fullSchema);
    switch (fullSchema.rollDowntimeAction) {
      case DowntimeAction.AcquireAsset: {
        fullSchema.rollTrait = Factor.tier;
        break;
      }
      case DowntimeAction.LongTermProject: {
        if (!BladesRollOpposition.IsValidData(fullSchema.rollOppData)) {
          throw new Error("No rollOppData provided for LongTermProject roll.");
        }
        if (![
          BladesItemType.project,
          BladesItemType.design
        ].includes(fullSchema.rollOppData.rollOppType)) {
          throw new Error("rollOppType must be 'project' or 'design' for LongTermProject roll.");
        }
        break;
      }
      case DowntimeAction.Recover: {
        if (BladesPC$1.IsType(rollPrimary.rollPrimaryDoc)) {
          if (!rollPrimary.rollPrimaryDoc.abilities.find((ability) => ability.name === "Physiker")) {
            throw new Error("A PC rollPrimary on a Recovery roll must have the Physiker ability.");
          }
          fullSchema.rollTrait = ActionTrait.tinker;
        } else if (((_a2 = rollPrimary.rollPrimaryDoc) == null ? void 0 : _a2.rollPrimaryType) === BladesActorType.npc) {
          fullSchema.rollTrait = Factor.quality;
        } else {
          throw new Error("Only a PC with Physiker or an NPC can be rollPrimary on a Recover roll.");
        }
        break;
      }
      case DowntimeAction.ReduceHeat: {
        let parentCrew = void 0;
        if (rollPrimary.rollPrimaryDoc) {
          const { parent } = rollPrimary.rollPrimaryDoc;
          if (BladesCrew$1.IsType(parent)) {
            parentCrew = parent;
          } else if (BladesPC$1.IsType(parent) && BladesCrew$1.IsType(parent.crew)) {
            parentCrew = parent.crew;
          }
        }
        if (!BladesCrew$1.IsType(parentCrew)) {
          throw new Error(`Could not find crew for rollPrimary '${(_b = rollPrimary.rollPrimaryDoc) == null ? void 0 : _b.rollPrimaryName}'`);
        }
        if (parentCrew.system.heat.value === 0) {
          throw new Error("Attempt to Reduce Heat for a Crew with no Heat.");
        }
        break;
      }
      case void 0:
        break;
      default:
        throw new Error(`Unrecognized Roll Downtime Action: ${fullSchema.rollDowntimeAction}`);
    }
    return {
      rollPositionInitial: Position.risky,
      rollEffectInitial: Effect.standard,
      rollPosEffectTrade: false,
      GMBoosts: {
        [Factor.tier]: 0,
        [Factor.quality]: 0,
        [Factor.scale]: 0,
        [Factor.magnitude]: 0
      },
      GMOppBoosts: {
        [Factor.tier]: 0,
        [Factor.quality]: 0,
        [Factor.scale]: 0,
        [Factor.magnitude]: 0
      },
      GMOverrides: {},
      rollFactorToggles: {
        source: {
          [Factor.tier]: {
            display: "",
            isActive: false,
            isPrimary: false,
            isDominant: false,
            highFavorsPC: true
          },
          [Factor.quality]: {
            display: "",
            isActive: false,
            isPrimary: false,
            isDominant: false,
            highFavorsPC: true
          },
          [Factor.scale]: {
            display: "",
            isActive: false,
            isPrimary: false,
            isDominant: false,
            highFavorsPC: true
          },
          [Factor.magnitude]: {
            display: "",
            isActive: false,
            isPrimary: false,
            isDominant: false,
            highFavorsPC: true
          }
        },
        opposition: {
          [Factor.tier]: {
            display: "",
            isActive: false,
            isPrimary: false,
            isDominant: false,
            highFavorsPC: true
          },
          [Factor.quality]: {
            display: "",
            isActive: false,
            isPrimary: false,
            isDominant: false,
            highFavorsPC: true
          },
          [Factor.scale]: {
            display: "",
            isActive: false,
            isPrimary: false,
            isDominant: false,
            highFavorsPC: true
          },
          [Factor.magnitude]: {
            display: "",
            isActive: false,
            isPrimary: false,
            isDominant: false,
            highFavorsPC: true
          }
        }
      },
      ...fullSchema,
      rollPrimaryData: rollPrimary.data,
      rollOppData: fullSchema.rollOppData instanceof BladesRollOpposition ? fullSchema.rollOppData.data : fullSchema.rollOppData
    };
  }
  static get DefaultRollModSchemaSet() {
    return [
      {
        key: "Push-positive-roll",
        name: "PUSH",
        section: RollModSection.roll,
        base_status: RollModStatus.ToggledOff,
        posNeg: "positive",
        modType: RollModType.general,
        value: 1,
        effectKeys: ["ForceOff-Bargain", "Cost-Stress2"],
        tooltip: "<h1>Push for +1d</h1><p>For <strong class='red-bright'>2 Stress</strong>, add <strong class='gold-bright'>1 die</strong> to your pool.</p><p><em>(You <strong>cannot</strong> also accept a <strong class='red-bright'>Devil's Bargain</strong> to increase your dice pool: It's one or the other.)</em></p>"
      },
      {
        key: "Bargain-positive-roll",
        name: "Bargain",
        section: RollModSection.roll,
        base_status: RollModStatus.Hidden,
        posNeg: "positive",
        modType: RollModType.general,
        value: 1,
        effectKeys: [],
        tooltip: "<h1 class='red-bright'>Devil's Bargain</h1><p>The GM has offered you a <strong class='red-bright'>Devil's Bargain</strong>.</p><p><strong class='red-bright'>Accept the terms</strong> to add <strong class='gold-bright'>1 die</strong> to your pool.</p><p><em>(You <strong>cannot</strong> also <strong>Push for +1d</strong> to increase your dice pool: It's one or the other.)</em></p>"
      },
      {
        key: "Assist-positive-roll",
        name: "Assist",
        section: RollModSection.roll,
        base_status: RollModStatus.Hidden,
        posNeg: "positive",
        modType: RollModType.teamwork,
        value: 1,
        tooltip: "<h1 class='gold-bright'>%DOC_NAME% Assists</h1><p><strong class='gold-bright'>%DOC_NAME%</strong> is <strong>Assisting</strong> your efforts, adding <strong class='gold-bright'>1 die</strong> to your pool.</p>"
      },
      {
        key: "Setup-positive-position",
        name: "Setup",
        section: RollModSection.position,
        base_status: RollModStatus.Hidden,
        posNeg: "positive",
        modType: RollModType.teamwork,
        value: 1,
        tooltip: "<h1 class='gold-bright'>%DOC_NAME% Sets You Up</h1><p><strong class='gold-bright'>%DOC_NAME%</strong> has set you up for success with a preceding <strong>Setup</strong> action, increasing your <strong class='gold-bright'>Position</strong> by one level.</p>"
      },
      {
        key: "Push-positive-effect",
        name: "PUSH",
        section: RollModSection.effect,
        base_status: RollModStatus.ToggledOff,
        posNeg: "positive",
        modType: RollModType.general,
        value: 1,
        effectKeys: ["Cost-Stress2"],
        tooltip: "<h1>Push for Effect</h1><p>For <strong class='red-bright'>2 Stress</strong>, increase your <strong class='gold-bright'>Effect</strong> by one level.</p>"
      },
      {
        key: "Setup-positive-effect",
        name: "Setup",
        section: RollModSection.effect,
        base_status: RollModStatus.Hidden,
        posNeg: "positive",
        modType: RollModType.teamwork,
        value: 1,
        tooltip: "<h1 class='gold-bright'>%DOC_NAME% Sets You Up</h1><p><strong class='gold-bright'>%DOC_NAME%</strong> has set you up for success with a preceding <strong>Setup</strong> action, increasing your <strong class='gold-bright'>Effect</strong> by one level.</p>"
      },
      {
        key: "Potency-positive-effect",
        name: "Potency",
        section: RollModSection.effect,
        base_status: RollModStatus.Hidden,
        posNeg: "positive",
        modType: RollModType.general,
        value: 1,
        tooltip: "<h1>Potency</h1><p>By circumstance or advantage, you have <strong>Potency</strong> in this action, increasing your <strong class='gold-bright'>Effect</strong> by one level.</p>"
      },
      {
        key: "Potency-negative-effect",
        name: "Potency",
        section: RollModSection.effect,
        base_status: RollModStatus.Hidden,
        posNeg: "negative",
        modType: RollModType.general,
        value: 1,
        tooltip: "<h1 class='red-bright'>Potency</h1><p>By circumstance or advantage, <strong class='red-bright'>@OPPOSITION_NAME@</strong> has <strong>Potency</strong> against you, reducing your <strong class='red-bright'>Effect</strong> by one level."
      }
    ];
  }
  /**
   * Asynchronously creates a new instance of this subclass of `BladesRoll`.
   *
   * Overrides the `New` static method from `BladesRoll`, applying subclass-specific configurations
   * to the instance creation process. It ensures that the returned instance is correctly typed
   * and configured for this subclass.
   *
   * @param {BladesRoll.Config} config The configuration object for creating a new roll instance,
   * extended with any subclass-specific configurations or requirements.
   *
   * @returns {Promise<InstanceType<this>>} A promise that resolves to an instance of this subclass.
   *
   * @see {@link BladesRoll.New} for the base method's functionality and the generic creation process
   * for roll instances.
   */
  static async New(config3) {
    const linkConfig = this.BuildLinkConfig(config3);
    const parsedConfig = {
      ...config3,
      ...linkConfig
    };
    parsedConfig.rollPrimaryData = BladesRollPrimary.BuildData(parsedConfig);
    return await super.New(parsedConfig);
  }
  get rollModsSchemaSets() {
    const rollModSchemaSets = super.rollModsSchemaSets;
    if (this.rollPrimary.isWorsePosition) {
      rollModSchemaSets.push({
        key: "WorsePosition-negative-position",
        name: "Worse Position",
        section: RollModSection.position,
        base_status: RollModStatus.ForcedOn,
        posNeg: "negative",
        modType: RollModType.general,
        value: 1,
        effectKeys: [],
        tooltip: "<h1>Worse Position</h1><p>A <strong class='red-bright'>Consequence</strong> on a previous roll has worsened your <strong>Position</strong>.</p>"
      });
    }
    if (this.acceptedConsequences.some((csq) => csq.type === ConsequenceType.ReducedEffect)) {
      rollModSchemaSets.push({
        key: "ReducedEffect-negative-effect",
        name: "Reduced Effect",
        section: RollModSection.effect,
        base_status: RollModStatus.ForcedOn,
        posNeg: "negative",
        modType: RollModType.general,
        value: 1,
        effectKeys: [],
        tooltip: "<h1>Reduced Effect</h1><p>A <strong class='red-bright'>Consequence</strong> has worsened your <strong>Effect</strong>.</p>"
      });
    }
    return rollModSchemaSets;
  }
  get collabTemplate() {
    return `systems/eunos-blades/templates/roll/roll-collab-action${game.user.isGM ? "-gm" : ""}.hbs`;
  }
  get chatTemplate() {
    const templateParts = [
      "systems/eunos-blades/templates/chat/roll-result/action",
      this.rollClockKey ? "-clock" : ""
    ];
    if (this.rollDowntimeAction && [
      DowntimeAction.AcquireAsset,
      // action-acquireasset
      DowntimeAction.ReduceHeat,
      //   action-reduceheat
      DowntimeAction.Recover
      //       action-clock-recover
    ].includes(this.rollDowntimeAction)) {
      templateParts.push(`-${U.lCase(this.rollDowntimeAction)}`);
    } else if (this.rollSubType && [
      RollSubType.GatherInfo
      //      action-gatherinfo
    ].includes(this.rollSubType)) {
      templateParts.push(`-${U.lCase(this.rollSubType)}`);
    }
    templateParts.push(".hbs");
    return templateParts.join("");
  }
  get rollResult() {
    if (!this.isResolved) {
      return false;
    }
    if (this.isCritical) {
      return RollResult.critical;
    }
    if (this.isSuccess) {
      return RollResult.success;
    }
    if (this.isPartial) {
      return RollResult.partial;
    }
    return RollResult.fail;
  }
  async resolveRollResult() {
    var _a2, _b;
    eLog.checkLog2("bladesRoll", "[BladesActionRoll] Costs", this.getRollCosts());
    const armorCost = this.getRollCosts().filter((costData) => costData.costType === "Armor").length;
    if (this.rollPrimaryDoc instanceof BladesPC$1) {
      const stressCost = this.getRollCosts().filter((costData) => costData.costType === "Stress").reduce((acc, costData) => acc + costData.costAmount, 0);
      if (stressCost !== 0) {
        this.rollPrimaryDoc.adjustStress(stressCost);
      }
      const specArmorCost = this.getRollCosts().filter((costData) => costData.costType === "SpecialArmor").length;
      if (specArmorCost !== 0) {
        this.rollPrimaryDoc.spendSpecialArmor();
      }
    }
    if (armorCost !== 0) {
      this.rollPrimary.spendArmor(armorCost);
    }
    if ((_a2 = this.getRollModByKey("WorsePosition-negative-position")) == null ? void 0 : _a2.isActive) {
      (_b = this.rollPrimaryDoc) == null ? void 0 : _b.unsetFlag("eunos-blades", "isWorsePosition");
    }
  }
}
class BladesResistanceRoll extends BladesRoll {
  static ApplySchemaDefaults(config3) {
    var _a2;
    if (!config3.resistanceData || !BladesConsequence.IsValidConsequenceData((_a2 = config3.resistanceData) == null ? void 0 : _a2.consequence)) {
      eLog.error("rollCollab", "[PrepareResistanceRoll] Bad Roll Consequence Data.", config3);
      throw new Error("[PrepareResistanceRoll()] Bad Consequence Data for Resistance Roll");
    }
    config3.rollTrait = config3.resistanceData.consequence.attribute;
    eLog.checkLog3("bladesRoll", "BladesRoll.PrepareResistanceRoll() [1]", { config: config3 });
    return config3;
  }
  /**
   * Asynchronously creates a new instance of this subclass of `BladesRoll`.
   *
   * Overrides the `New` static method from `BladesRoll`, applying subclass-specific configurations
   * to the instance creation process. It ensures that the returned instance is correctly typed
   * and configured for this subclass.
   *
   * @param {BladesRoll.Config} config The configuration object for creating a new roll instance,
   * extended with any subclass-specific configurations or requirements.
   *
   * @returns {Promise<InstanceType<this>>} A promise that resolves to an instance of this subclass.
   *
   * @see {@link BladesRoll.New} for the base method's functionality and the generic creation process
   * for roll instances.
   */
  static async New(config3) {
    const linkConfig = this.BuildLinkConfig(config3);
    const parsedConfig = {
      ...config3,
      ...linkConfig
    };
    return await super.New(parsedConfig);
  }
  get collabTemplate() {
    return `systems/eunos-blades/templates/roll/roll-collab-resistance${game.user.isGM ? "-gm" : ""}.hbs`;
  }
  get chatTemplate() {
    return "systems/eunos-blades/templates/chat/roll-result/resistance.hbs";
  }
  get stressCost() {
    if (!this.isResolved) {
      return 0;
    }
    const dieVals = [...this.finalDieVals];
    if (this.isCritical) {
      return -1;
    }
    return 6 - (dieVals.shift() ?? 0);
  }
  get rollResult() {
    if (!this.isResolved) {
      return false;
    }
    return this.stressCost;
  }
  async resolveRollResult() {
    if (this.rollPrimaryDoc instanceof BladesPC$1 && this.stressCost !== 0) {
      this.rollPrimaryDoc.adjustStress(this.stressCost);
    }
  }
}
class BladesInlineResistanceRoll extends BladesResistanceRoll {
  get chatTemplate() {
    return "systems/eunos-blades/templates/chat/components/inline-resistance.hbs";
  }
}
class BladesFortuneRoll extends BladesRoll {
  static ApplySchemaDefaults(config3) {
    if (!(U.isInt(config3.rollTrait) || U.lCase(config3.rollTrait) in { ...ActionTrait, ...AttributeTrait, ...Factor })) {
      throw new Error(`[PrepareFortuneRoll()] Bad RollTrait for Fortune Roll: ${config3.rollTrait}`);
    }
    return config3;
  }
  /**
   * Asynchronously creates a new instance of this subclass of `BladesRoll`.
   *
   * Overrides the `New` static method from `BladesRoll`, applying subclass-specific configurations
   * to the instance creation process. It ensures that the returned instance is correctly typed
   * and configured for this subclass.
   *
   * @param {BladesRoll.Config} config The configuration object for creating a new roll instance,
   * extended with any subclass-specific configurations or requirements.
   *
   * @returns {Promise<InstanceType<this>>} A promise that resolves to an instance of this subclass.
   *
   * @see {@link BladesRoll.New} for the base method's functionality and the generic creation process
   * for roll instances.
   */
  static async New(config3) {
    const linkConfig = this.BuildLinkConfig(config3);
    const parsedConfig = {
      ...config3,
      ...linkConfig
    };
    return await super.New(parsedConfig);
  }
}
class BladesIndulgeViceRoll extends BladesRoll {
  static ApplySchemaDefaults(config3) {
    var _a2;
    const rollPrimaryDoc = BladesRollPrimary.GetDoc((_a2 = config3.rollPrimaryData) == null ? void 0 : _a2.rollPrimaryID);
    if (!rollPrimaryDoc || !BladesPC$1.IsType(rollPrimaryDoc)) {
      throw new Error("[BladesRoll.PrepareIndulgeViceRollConfig] RollPrimary must be a PC for Indulge Vice rolls.");
    }
    const { attributes } = rollPrimaryDoc;
    const minAttrVal = Math.min(...Object.values(attributes));
    config3.rollTrait = U.sample(
      Object.values(AttributeTrait).filter((attr) => attributes[attr] === minAttrVal)
    )[0];
    config3.rollDowntimeAction = DowntimeAction.IndulgeVice;
    return config3;
  }
  /**
   * Asynchronously creates a new instance of this subclass of `BladesRoll`.
   *
   * Overrides the `New` static method from `BladesRoll`, applying subclass-specific configurations
   * to the instance creation process. It ensures that the returned instance is correctly typed
   * and configured for this subclass.
   *
   * @param {BladesRoll.Config} config The configuration object for creating a new roll instance,
   * extended with any subclass-specific configurations or requirements.
   *
   * @returns {Promise<InstanceType<this>>} A promise that resolves to an instance of this subclass.
   *
   * @see {@link BladesRoll.New} for the base method's functionality and the generic creation process
   * for roll instances.
   */
  static async New(config3) {
    const linkConfig = this.BuildLinkConfig(config3);
    const parsedConfig = {
      ...config3,
      ...linkConfig
    };
    return await super.New(parsedConfig);
  }
  get collabTemplate() {
    return `systems/eunos-blades/templates/roll/roll-collab-indulgevice${game.user.isGM ? "-gm" : ""}.hbs`;
  }
  get chatTemplate() {
    return "systems/eunos-blades/templates/chat/roll-result/indulgevice.hbs";
  }
  get rollResult() {
    if (!this.isResolved) {
      return false;
    }
    return this.highestDieVal;
  }
  async resolveRollResult() {
    if (BladesPC$1.IsType(this.rollPrimaryDoc)) {
      this.rollPrimaryDoc.indulgeStress(this.highestDieVal);
    }
  }
}
class BladesEngagementRoll extends BladesFortuneRoll {
  static get DefaultRollModSchemaSet() {
    return [
      {
        key: "BoldPlan-positive-roll",
        name: "Bold Plan",
        section: RollModSection.roll,
        base_status: RollModStatus.ToggledOff,
        posNeg: "positive",
        modType: RollModType.general,
        value: 1,
        effectKeys: [],
        tooltip: "<h1></h1><p></p>"
      },
      {
        key: "ComplexPlan-negative-roll",
        name: "Complex Plan",
        section: RollModSection.roll,
        base_status: RollModStatus.ToggledOff,
        posNeg: "negative",
        modType: RollModType.general,
        value: 1,
        effectKeys: [],
        tooltip: "<h1></h1><p></p>"
      },
      {
        key: "ExploitWeakness-positive-roll",
        name: "Exploiting a Weakness",
        section: RollModSection.roll,
        base_status: RollModStatus.ToggledOff,
        posNeg: "positive",
        modType: RollModType.general,
        value: 1,
        effectKeys: [],
        tooltip: "<h1></h1><p></p>"
      },
      {
        key: "WellDefended-negative-roll",
        name: "Well-Defended",
        section: RollModSection.roll,
        base_status: RollModStatus.ToggledOff,
        posNeg: "negative",
        modType: RollModType.general,
        value: 1,
        effectKeys: [],
        tooltip: "<h1></h1><p></p>"
      },
      {
        key: "HelpFromFriend-positive-roll",
        name: "Help From a Friend",
        section: RollModSection.position,
        base_status: RollModStatus.ToggledOff,
        posNeg: "positive",
        modType: RollModType.general,
        value: 1,
        effectKeys: [],
        tooltip: "<h1>Help From a Friend</h1><p>Add <strong>+1d</strong> if you enlist the help of a friend or contact.</p>"
      },
      {
        key: "EnemyInterference-negative-roll",
        name: "Enemy Interference",
        section: RollModSection.roll,
        base_status: RollModStatus.ToggledOff,
        posNeg: "negative",
        modType: RollModType.general,
        value: 1,
        effectKeys: [],
        tooltip: "<h1></h1><p></p>"
      }
    ];
  }
  get chatTemplate() {
    return "systems/eunos-blades/templates/chat/roll-result/fortune-engagement.hbs";
  }
}
class BladesIncarcerationRoll extends BladesFortuneRoll {
  get chatTemplate() {
    return "systems/eunos-blades/templates/chat/roll-result/fortune-incarceration.hbs";
  }
}
const BladesRoll$1 = BladesRoll;
class BladesItem extends Item {
  constructor() {
    super(...arguments);
    __publicField(this, "dialogCSSClasses", "");
  }
  // #region Static Overrides: Create ~
  static async create(data, options = {}) {
    if (Array.isArray(data)) {
      data = data[0];
    }
    data.system = data.system ?? {};
    eLog.checkLog2("item", "BladesItem.create(data,options)", { data, options });
    data.system.world_name = data.system.world_name ?? data.name.replace(/[^A-Za-z_0-9 ]/g, "").trim().replace(/ /g, "_");
    return super.create(data, options);
  }
  // #endregion
  // #region BladesDocument Implementation
  static get All() {
    return game.items;
  }
  static Get(itemRef) {
    if (itemRef instanceof BladesItem) {
      return itemRef;
    }
    if (U.isDocID(itemRef)) {
      return BladesItem.All.get(itemRef);
    }
    return BladesItem.All.find((a) => a.system.world_name === itemRef) || BladesItem.All.find((a) => a.name === itemRef);
  }
  static GetTypeWithTags(docType, ...tags) {
    if (Array.isArray(docType)) {
      return docType.map((dType) => BladesItem.All.filter((item) => item.type === dType)).flat();
    }
    return BladesItem.All.filter((item) => item.type === docType).filter((item) => item.hasTag(...tags));
  }
  static IsType(doc, ...types) {
    const typeSet = new Set(types);
    return doc instanceof BladesItem && typeSet.has(doc.type);
  }
  get tags() {
    return this.system.tags ?? [];
  }
  hasTag(...tags) {
    return tags.every((tag) => this.tags.includes(tag));
  }
  async addTag(...tags) {
    const curTags = this.tags;
    tags.forEach((tag) => {
      if (curTags.includes(tag)) {
        return;
      }
      curTags.push(tag);
    });
    await this.update({ "system.tags": curTags });
  }
  async remTag(...tags) {
    const curTags = this.tags.filter((tag) => !tags.includes(tag));
    await this.update({ "system.tags": curTags });
  }
  get tooltip() {
    const tooltipText = [
      this.system.concept,
      this.system.rules,
      this.system.notes
    ].filter(Boolean).join("");
    if (tooltipText) {
      return new Handlebars.SafeString(tooltipText).toString();
    }
    return void 0;
  }
  getFactorTotal(factor) {
    var _a2, _b, _c;
    switch (factor) {
      case Factor.tier: {
        if (BladesItem.IsType(this, BladesItemType.cohort_gang)) {
          return this.system.tier.value + (((_a2 = this.parent) == null ? void 0 : _a2.getFactorTotal(Factor.tier)) ?? 0);
        }
        if (BladesItem.IsType(this, BladesItemType.cohort_expert)) {
          return this.system.tier.value + (((_b = this.parent) == null ? void 0 : _b.getFactorTotal(Factor.tier)) ?? 0);
        }
        if (BladesItem.IsType(this, BladesItemType.gear)) {
          return this.system.tier.value + (((_c = this.parent) == null ? void 0 : _c.getFactorTotal(Factor.tier)) ?? 0);
        }
        return this.system.tier.value;
      }
      case Factor.quality: {
        if (BladesItem.IsType(this, BladesItemType.cohort_gang)) {
          return this.getFactorTotal(Factor.tier) + (this.system.quality_bonus ?? 0);
        }
        if (BladesItem.IsType(this, BladesItemType.cohort_expert)) {
          return this.getFactorTotal(Factor.tier) + (this.system.quality_bonus ?? 0) + 1;
        }
        if (BladesItem.IsType(this, BladesItemType.gear)) {
          let thisQuality = this.getFactorTotal(Factor.tier) + (this.hasTag("Fine") ? 1 : 0);
          if (BladesPC$1.IsType(this.parent)) {
            thisQuality += this.parent.getTaggedItemBonuses(this.tags);
          }
          return thisQuality;
        }
        if (BladesItem.IsType(this, BladesItemType.design)) {
          return this.system.min_quality;
        }
        return this.getFactorTotal(Factor.tier);
      }
      case Factor.scale: {
        if (BladesItem.IsType(this, BladesItemType.cohort_gang)) {
          return this.getFactorTotal(Factor.tier) + (this.system.scale_bonus ?? 0);
        }
        if (BladesItem.IsType(this, BladesItemType.cohort_expert)) {
          return 0 + (this.system.scale_bonus ?? 0);
        }
        return 0;
      }
      case Factor.magnitude: {
        if (BladesItem.IsType(this, BladesItemType.ritual)) {
          return this.system.magnitude.value;
        }
        return 0;
      }
      default:
        return 0;
    }
  }
  // #endregion
  // #region BladesItemDocument Implementation
  async archive() {
    await this.addTag(Tag.System.Archived);
    return this;
  }
  async unarchive() {
    await this.remTag(Tag.System.Archived);
    return this;
  }
  // #endregion
  // #region BladesRoll Implementation
  get rollFactors() {
    const factorsMap = {
      [BladesItemType.cohort_gang]: [Factor.quality, Factor.scale],
      [BladesItemType.cohort_expert]: [Factor.quality, Factor.scale],
      [BladesItemType.gear]: [Factor.quality],
      [BladesItemType.project]: [Factor.quality],
      [BladesItemType.ritual]: [Factor.magnitude],
      [BladesItemType.design]: [Factor.quality]
    };
    if (!factorsMap[this.type]) {
      return {};
    }
    const factors = factorsMap[this.type];
    const factorData = {};
    (factors ?? []).forEach((factor, i) => {
      const factorTotal = this.getFactorTotal(factor);
      factorData[factor] = {
        name: factor,
        value: factorTotal,
        max: factorTotal,
        baseVal: factorTotal,
        display: [Factor.tier, Factor.quality].includes(factor) ? U.romanizeNum(factorTotal) : `${factorTotal}`,
        isActive: i === 0,
        isPrimary: i === 0,
        isDominant: false,
        highFavorsPC: true,
        cssClasses: `factor-gold${i === 0 ? " factor-main" : ""}`
      };
    });
    return factorData;
  }
  // #region BladesRoll.PrimaryDoc Implementation
  get rollPrimaryID() {
    return this.id;
  }
  get rollPrimaryDoc() {
    return this;
  }
  get rollPrimaryName() {
    return this.name;
  }
  get rollPrimaryType() {
    if (![
      BladesItemType.cohort_gang,
      BladesItemType.cohort_expert,
      BladesItemType.gm_tracker,
      BladesItemType.score
    ].includes(this.type)) {
      throw new Error(`BladesItem of type '${this.type}' ("${this.name}") cannot be RollPrimary.`);
    }
    return this.type;
  }
  get rollPrimaryImg() {
    return this.img;
  }
  get rollPrimaryModsSchemaSet() {
    return BladesRollMod.ParseDocModsToSchemaSet(this);
  }
  async applyHarm(amount, _name) {
    if (BladesItem.IsType(this, BladesItemType.cohort_expert, BladesItemType.cohort_gang)) {
      const curHarm = this.system.harm.value;
      let newHarm;
      if (amount > curHarm) {
        newHarm = amount;
      } else {
        newHarm = curHarm + 1;
      }
      const harmVerb = ["is Weakened", "is Impaired", "has been Broken", "has been Killed!"];
      const harmEffect = [
        "They act with Reduced Effect.",
        "They act with Reduced Effect and suffer -1d to all rolls.",
        "They cannot do anything until they recover.",
        "You may replace them during Downtime."
      ];
      BladesDirector.getInstance().pushNotice_SocketCall(
        "ALL",
        {
          title: `${this.name} ${harmVerb[newHarm - 1]}`,
          body: harmEffect[newHarm - 1],
          type: BladesNoticeType.push,
          cssClasses: "harm-alert"
        }
      );
      await this.update({ "system.harm": amount });
    }
  }
  async applyWorsePosition() {
    if (BladesItem.IsType(this, BladesItemType.cohort_expert, BladesItemType.cohort_gang)) {
      this.setFlag("eunos-blades", "isWorsePosition", true);
    }
  }
  // #endregion
  // #region BladesRoll.OppositionDoc Implementation
  get rollOppID() {
    return this.id;
  }
  get rollOppDoc() {
    return this;
  }
  get rollOppImg() {
    return this.img;
  }
  get rollOppName() {
    return this.name;
  }
  get rollOppSubName() {
    return "";
  }
  get rollOppType() {
    if (![
      BladesItemType.cohort_gang,
      BladesItemType.cohort_expert,
      BladesItemType.gm_tracker,
      BladesItemType.score,
      BladesItemType.location,
      BladesItemType.project,
      BladesItemType.design,
      BladesItemType.ritual
    ].includes(this.type)) {
      throw new Error(`BladesItem of type '${this.type}' ("${this.name}") cannot be RollOpposition.`);
    }
    return this.type;
  }
  get rollOppModsSchemaSet() {
    return [];
  }
  // #endregion
  // #region BladesRoll.ParticipantDoc Implementation
  get rollParticipantID() {
    return this.id;
  }
  get rollParticipantDoc() {
    return this;
  }
  get rollParticipantIcon() {
    return this.img;
  }
  get rollParticipantName() {
    return this.name;
  }
  get rollParticipantType() {
    if (![
      BladesItemType.cohort_gang,
      BladesItemType.cohort_expert,
      BladesItemType.gm_tracker
    ].includes(this.type)) {
      throw new Error(`BladesItem of type '${this.type}' ("${this.name}") cannot be RollParticipant.`);
    }
    return this.type;
  }
  get rollParticipantModsSchemaSet() {
    return [];
  }
  // #endregion
  // #endregion
  // #region PREPARING DERIVED DATA
  prepareDerivedData() {
    super.prepareDerivedData();
    if (BladesItem.IsType(this, BladesItemType.cohort_gang, BladesItemType.cohort_expert)) {
      this._prepareCohortData(this.system);
    }
    if (BladesItem.IsType(this, BladesItemType.crew_playbook)) {
      this._preparePlaybookData(this.system);
    }
    if (BladesItem.IsType(this, BladesItemType.gear)) {
      this._prepareGearData(this.system);
    }
    if (BladesItem.IsType(this, BladesItemType.playbook)) {
      this._preparePlaybookData(this.system);
    }
  }
  _prepareCohortData(system) {
    if (!BladesItem.IsType(this, BladesItemType.cohort_gang, BladesItemType.cohort_expert)) {
      return;
    }
    system.tier.name = "Quality";
    const subtypes = U.unique(Object.values(system.subtypes).map((subtype) => subtype.trim()).filter((subtype) => /[A-Za-z]/.test(subtype)));
    const eliteSubtypes = [
      ...Object.values(system.elite_subtypes)
    ];
    if (BladesCrew$1.IsType(this.parent)) {
      eliteSubtypes.push(
        ...this.parent.upgrades.filter((upgrade) => (upgrade.name ?? "").startsWith("Elite")).map((upgrade) => (upgrade.name ?? "").trim().replace(/^Elite /, ""))
      );
    }
    system.subtypes = Object.fromEntries(subtypes.map((subtype, i) => [`${i + 1}`, subtype]));
    system.elite_subtypes = Object.fromEntries(
      U.unique(
        eliteSubtypes.map((subtype) => subtype.trim()).filter((subtype) => /[A-Za-z]/.test(subtype) && subtypes.includes(subtype))
      ).map((subtype, i) => [`${i + 1}`, subtype])
    );
    system.edges = Object.fromEntries(Object.values(system.edges ?? []).filter((edge) => /[A-Za-z]/.test(edge)).map((edge, i) => [`${i + 1}`, edge.trim()]));
    system.flaws = Object.fromEntries(Object.values(system.flaws ?? []).filter((flaw) => /[A-Za-z]/.test(flaw)).map((flaw, i) => [`${i + 1}`, flaw.trim()]));
    system.quality = this.getFactorTotal(Factor.quality);
    if (BladesItem.IsType(this, BladesItemType.cohort_gang)) {
      if ([...subtypes, ...eliteSubtypes].includes(Tag.GangType.Vehicle)) {
        system.scale = this.getFactorTotal(Factor.scale);
        system.scaleExample = "(1 vehicle)";
      } else {
        system.scale = this.getFactorTotal(Factor.scale);
        const scaleIndex = Math.min(6, system.scale);
        system.scaleExample = C.ScaleExamples[scaleIndex];
        system.subtitle = C.ScaleSizes[scaleIndex];
      }
      if (subtypes.length + eliteSubtypes.length === 0) {
        system.subtitle = system.subtitle.replace(/\s+of\b/g, "").trim();
      }
    } else {
      system.scale = 0;
      system.scaleExample = [...subtypes, ...eliteSubtypes].includes("Pet") ? "(1 animal)" : "(1 person)";
      system.subtitle = "An Expert";
    }
    if (subtypes.length + eliteSubtypes.length > 0) {
      if ([...subtypes, ...eliteSubtypes].includes(Tag.GangType.Vehicle)) {
        system.subtitle = C.VehicleDescriptors[Math.min(6, this.getFactorTotal(Factor.tier))];
      } else {
        system.subtitle += ` ${U.oxfordize([
          ...subtypes.filter((subtype) => !eliteSubtypes.includes(subtype)),
          ...eliteSubtypes.map((subtype) => `Elite ${subtype}`)
        ], false, "&")}`;
      }
    }
  }
  _prepareGearData(system) {
    if (!BladesItem.IsType(this, BladesItemType.gear)) {
      return;
    }
    system.tier.name = "Quality";
  }
  _preparePlaybookData(system) {
    if (!BladesItem.IsType(this, BladesItemType.playbook, BladesItemType.crew_playbook)) {
      return;
    }
    const expClueData = {};
    [...Object.values(system.experience_clues).filter((clue) => /[A-Za-z]/.test(clue)), " "].forEach((clue, i) => {
      expClueData[(i + 1).toString()] = clue;
    });
    system.experience_clues = expClueData;
    if (BladesItem.IsType(this, BladesItemType.playbook)) {
      const gatherInfoData = {};
      [...Object.values(system.gather_info_questions).filter((question) => /[A-Za-z]/.test(question)), " "].forEach((question, i) => {
        gatherInfoData[(i + 1).toString()] = question;
      });
      system.gather_info_questions = gatherInfoData;
    }
  }
  // #endregion
  // Unlock lower-level update method for subclasses
  async callOnUpdate(...args) {
    await this._onUpdate(...args);
  }
}
const BladesItem$1 = BladesItem;
const FUNCQUEUE = {};
const CUSTOMFUNCS = {
  addItem: async (actor, funcData, _, isReversing = false) => {
    eLog.checkLog("activeEffects", "addItem", { actor, funcData, isReversing });
    if (actor.hasActiveSubItemOf(funcData)) {
      if (isReversing) {
        return actor.remSubItem(funcData);
      }
    } else if (!isReversing) {
      return actor.addSubItem(funcData);
    }
    return void 0;
  },
  addIfChargen: async (actor, funcData, _, isReversing = false) => {
    var _a2;
    eLog.checkLog("activeEffects", "addIfChargen", { actor, funcData, isReversing });
    if (!isReversing && ((_a2 = game.eunoblades.Tracker) == null ? void 0 : _a2.system.phase) !== BladesPhase.CharGen) {
      return;
    }
    const [target, qty] = funcData.split(/:/);
    if (isReversing) {
      await actor.update({ [target]: U.pInt(getProperty(actor, target)) - U.pInt(qty) });
      return;
    }
    await actor.update({ [target]: U.pInt(getProperty(actor, target)) + U.pInt(qty) });
  },
  upgradeIfChargen: async (actor, funcData, _, isReversing = false) => {
    var _a2;
    eLog.checkLog("activeEffects", "upgradeIfChargen", { actor, funcData, isReversing });
    if (!isReversing && ((_a2 = game.eunoblades.Tracker) == null ? void 0 : _a2.system.phase) !== BladesPhase.CharGen) {
      return;
    }
    const [target, qty] = funcData.split(/:/);
    if (getProperty(actor, target) < U.pInt(qty)) {
      await actor.update({ [target]: U.pInt(qty) });
    }
  },
  APPLYTOMEMBERS: async () => void 0,
  APPLYTOCOHORTS: async () => void 0,
  remItem: async (actor, funcData, _, isReversing = false) => {
    function testString(targetString, testDef) {
      if (testDef.startsWith("rX")) {
        const pat = new RegExp(testDef.replace(/^rX:\/(.*?)\//, "$1"));
        return pat.test(targetString);
      }
      return targetString === testDef;
    }
    if (funcData.startsWith("{")) {
      if (isReversing) {
        console.error("Cannot reverse a 'remItem' custom effect that was defined with a JSON object.");
        return void 0;
      }
      const { type, tags, name } = JSON.parse(funcData);
      let activeSubItems = actor.activeSubItems;
      if (activeSubItems.length === 0) {
        return void 0;
      }
      if (name) {
        activeSubItems = activeSubItems.filter((item) => testString(item.name, name));
      }
      if (activeSubItems.length === 0) {
        return void 0;
      }
      if (type) {
        activeSubItems = activeSubItems.filter((item) => testString(item.type, type));
      }
      if (activeSubItems.length === 0) {
        return void 0;
      }
      if (tags) {
        activeSubItems = activeSubItems.filter((item) => item.hasTag(...tags));
      }
      if (activeSubItems.length === 0) {
        return void 0;
      }
      eLog.checkLog("activeEffects", "remItem - JSON OBJECT", { actor, funcData: JSON.parse(funcData), isReversing, activeSubItems });
      activeSubItems.forEach((item) => actor.remSubItem(item));
    }
    eLog.checkLog("activeEffects", "remItem", { actor, funcData, isReversing });
    if (actor.hasActiveSubItemOf(funcData)) {
      return actor.remSubItem(funcData);
    }
    if (isReversing) {
      return actor.addSubItem(funcData);
    }
    return void 0;
  }
};
class BladesActiveEffect extends ActiveEffect {
  static Initialize() {
    CONFIG.ActiveEffect.documentClass = BladesActiveEffect;
    Hooks.on("preCreateActiveEffect", async (effect) => {
      var _a2;
      eLog.checkLog3("effect", "PRECREATE ActiveEffect", { effect, parent: (_a2 = effect.parent) == null ? void 0 : _a2.name });
      if (!(effect.parent instanceof BladesActor$1)) {
        return;
      }
      if (effect.changes.some((change) => change.key === "APPLYTOMEMBERS")) {
        if (BladesActor$1.IsType(effect.parent, BladesActorType.pc) && BladesActor$1.IsType(effect.parent.crew, BladesActorType.crew)) {
          const otherMembers = effect.parent.crew.members.filter((member) => {
            var _a3;
            return member.id !== ((_a3 = effect.parent) == null ? void 0 : _a3.id);
          });
          if (otherMembers.length > 0) {
            effect.changes = effect.changes.filter((change) => change.key !== "APPLYTOMEMBERS");
            await Promise.all(otherMembers.map(async (member) => member.createEmbeddedDocuments("ActiveEffect", [effect.toJSON()])));
            await effect.parent.setFlag("eunos-blades", `memberEffects.${effect.id}`, {
              appliedTo: otherMembers.map((member) => member.id),
              effect: effect.toJSON()
            });
          }
        } else if (BladesActor$1.IsType(effect.parent, BladesActorType.crew)) {
          const changeKey = U.pullElement(effect.changes, (change) => change.key === "APPLYTOMEMBERS");
          if (!changeKey) {
            return;
          }
          if (effect.parent.members.length > 0) {
            await Promise.all(effect.parent.members.map(async (member) => member.createEmbeddedDocuments("ActiveEffect", [effect.toJSON()])));
          }
          await effect.parent.setFlag("eunos-blades", `memberEffects.${effect.id}`, {
            appliedTo: effect.parent.members.map((member) => member.id),
            effect
          });
          await effect.updateSource({ changes: [changeKey] });
        }
      } else if (effect.changes.some((change) => change.key === "APPLYTOCOHORTS") && (BladesActor$1.IsType(effect.parent, BladesActorType.pc) || BladesActor$1.IsType(effect.parent, BladesActorType.crew))) {
        if (effect.parent.cohorts.length > 0) {
          await Promise.all(effect.parent.cohorts.map(async (cohort) => cohort.createEmbeddedDocuments("ActiveEffect", [effect.toJSON()])));
        }
        await effect.parent.setFlag("eunos-blades", `cohortEffects.${effect.id}`, {
          appliedTo: effect.parent.cohorts.map((cohort) => cohort.id),
          effect
        });
        await effect.updateSource({ changes: effect.changes.filter((change) => change.key === "APPLYTOCOHORTS") });
      }
      const [permChanges, changes] = U.partition(effect.changes, (change) => change.key.startsWith("perm"));
      await effect.updateSource({ changes });
      for (const permChange of permChanges) {
        const { key, value } = permChange;
        const permFuncName = key.replace(/^perm/, "");
        if (permFuncName in CUSTOMFUNCS) {
          const funcData = {
            funcName: permFuncName,
            funcData: value,
            isReversing: false,
            effect
          };
          BladesActiveEffect.ThrottleCustomFunc(effect.parent, funcData);
        } else if (permFuncName === "Add") {
          const [target, qty] = value.split(/:/);
          effect.parent.update({ [target]: U.pInt(getProperty(effect.parent, target)) + U.pInt(qty) });
        }
      }
    });
    Hooks.on("applyActiveEffect", (actor, changeData) => {
      if (!(actor instanceof BladesActor$1)) {
        return;
      }
      if (changeData.key in CUSTOMFUNCS) {
        const funcData = {
          funcName: changeData.key,
          funcData: changeData.value,
          isReversing: false,
          effect: changeData.effect
        };
        BladesActiveEffect.ThrottleCustomFunc(actor, funcData);
      }
    });
    Hooks.on("updateActiveEffect", (effect, { disabled }) => {
      if (!(effect.parent instanceof BladesActor$1)) {
        return;
      }
      const customEffects = effect.changes.filter((changes) => changes.mode === 0);
      customEffects.forEach(({ key, value }) => {
        const funcData = {
          funcName: key,
          funcData: value,
          isReversing: disabled,
          effect
        };
        BladesActiveEffect.ThrottleCustomFunc(effect.parent, funcData);
      });
    });
    Hooks.on("deleteActiveEffect", async (effect) => {
      if (!(effect.parent instanceof BladesActor$1)) {
        return;
      }
      if (effect.changes.some((change) => change.key === "APPLYTOMEMBERS")) {
        if (BladesActor$1.IsType(effect.parent, BladesActorType.pc) && BladesActor$1.IsType(effect.parent.crew, BladesActorType.crew)) {
          const otherMembers = effect.parent.crew.members.filter((member) => {
            var _a2;
            return member.id !== ((_a2 = effect.parent) == null ? void 0 : _a2.id);
          });
          if (otherMembers.length > 0) {
            await Promise.all(otherMembers.map(async (member) => Promise.all(member.effects.filter((e) => e.name === effect.name).map(async (e) => e.delete()))));
          }
          await effect.parent.unsetFlag("eunos-blades", `memberEffects.${effect.id}`);
        } else if (BladesActor$1.IsType(effect.parent, BladesActorType.crew)) {
          if (effect.parent.members.length > 0) {
            await Promise.all(effect.parent.members.map(async (member) => Promise.all(member.effects.filter((e) => e.name === effect.name).map(async (e) => e.delete()))));
          }
          await effect.parent.unsetFlag("eunos-blades", `memberEffects.${effect.id}`);
        }
      } else if (effect.changes.some((change) => change.key === "APPLYTOCOHORTS") && BladesActor$1.IsType(effect.parent, BladesActorType.pc, BladesActorType.crew)) {
        if (effect.parent.cohorts.length > 0) {
          await Promise.all(effect.parent.cohorts.map(async (cohort) => Promise.all(cohort.effects.filter((e) => e.name === effect.name).map(async (e) => e.delete()))));
        }
        await effect.parent.unsetFlag("eunos-blades", `cohortEffects.${effect.id}`);
      }
      const customEffects = effect.changes.filter((changes) => changes.mode === 0);
      customEffects.forEach(({ key, value }) => {
        const funcData = {
          funcName: key,
          funcData: value,
          isReversing: true,
          effect
        };
        BladesActiveEffect.ThrottleCustomFunc(effect.parent, funcData);
      });
    });
  }
  static async AddActiveEffect(doc, name, eChanges, icon = "systems/eunos-blades/assets/icons/effect-icons/default.png") {
    const changes = [eChanges].flat();
    await doc.createEmbeddedDocuments("ActiveEffect", [{ name, icon, changes }]);
  }
  static ThrottleCustomFunc(actor, data) {
    const { funcName, funcData, isReversing, effect } = data;
    if (!actor.id) {
      return;
    }
    eLog.checkLog3("activeEffect", `Throttling Func: ${funcName}(${funcData}, ${isReversing})`);
    if (actor.id && actor.id in FUNCQUEUE) {
      const matchingQueue = FUNCQUEUE[actor.id].queue.find((fData) => JSON.stringify(fData) === JSON.stringify(data));
      eLog.checkLog("activeEffects", "... Checking Queue", { data, FUNCQUEUE: FUNCQUEUE[actor.id], matchingQueue });
      if (matchingQueue) {
        eLog.error("... Function ALREADY QUEUED, SKIPPING");
        return;
      }
      FUNCQUEUE[actor.id].queue.push(data);
      return;
    }
    eLog.checkLog3("activeEffect", "... Creating New FUNCQUEUE, RUNNING:");
    FUNCQUEUE[actor.id] = {
      curFunc: BladesActiveEffect.RunCustomFunc(actor, CUSTOMFUNCS[funcName](actor, funcData, effect, isReversing)),
      queue: []
    };
  }
  static async RunCustomFunc(actor, funcPromise) {
    if (!actor.id) {
      return;
    }
    eLog.checkLog("activeEffects", "... Running Func ...");
    await funcPromise;
    eLog.checkLog("activeEffects", "... Function Complete!");
    if (FUNCQUEUE[actor.id].queue.length) {
      const { funcName, funcData, isReversing, effect } = FUNCQUEUE[actor.id].queue.shift() ?? {};
      if (!funcName || !(funcName in CUSTOMFUNCS)) {
        return;
      }
      if (!funcData) {
        return;
      }
      eLog.checkLog3("activeEffect", `Progressing Queue: ${funcName}(${funcData}, ${isReversing}) -- ${FUNCQUEUE[actor.id].queue.length} remaining funcs.`);
      FUNCQUEUE[actor.id].curFunc = BladesActiveEffect.RunCustomFunc(
        actor,
        CUSTOMFUNCS[funcName](actor, funcData, effect, isReversing)
      );
    } else {
      eLog.checkLog3("activeEffect", "Function Queue Complete! Deleting.");
      delete FUNCQUEUE[actor.id];
    }
  }
  /**
   * Manage Active Effect instances through the Actor Sheet via effect control buttons.
   * @param {MouseEvent} event      The left-click event on the effect control
   * @param {Actor|Item} owner      The owning entity which manages this effect
   */
  static onManageActiveEffect(event, owner) {
    var _a2;
    event.preventDefault();
    const a = event.currentTarget;
    if (a.dataset.action === "create") {
      return owner.createEmbeddedDocuments("ActiveEffect", [{
        name: owner.name,
        icon: owner.img,
        origin: owner.uuid
      }]);
    }
    const selector3 = a.closest("tr");
    if (selector3 === null) {
      return null;
    }
    const effect = selector3.dataset.effectId ? owner.effects.get(selector3.dataset.effectId) : null;
    if (!effect) {
      return null;
    }
    switch (a.dataset.action) {
      case "edit":
        return (_a2 = effect.sheet) == null ? void 0 : _a2.render(true);
      case "delete":
        eLog.checkLog("activeEffects", "delete effect");
        return effect.delete();
      case "toggle":
        return effect.update({ disabled: !effect.disabled });
      default:
        return null;
    }
  }
  async _preCreate(data, options, user) {
    eLog.checkLog3("effect", "ActiveEffect._preCreate()", { data, options, user });
    await super._preCreate(data, options, user);
  }
  _onDelete(options, userID) {
    eLog.checkLog3("effect", "ActiveEffect._onDelete()", { options, userID });
    super._onDelete(options, userID);
  }
  get isSuppressed() {
    if (!/Actor.*Item/.test(this.origin)) {
      return super.isSuppressed;
    }
    const [actorID, itemID] = this.origin.replace(/Actor\.|Item\./g, "").split(".");
    const actor = game.actors.get(actorID);
    const item = actor.items.get(itemID);
    return super.isSuppressed || (item == null ? void 0 : item.hasTag(Tag.System.Archived));
  }
}
const _onTagifyChange = (event, doc, targetKey) => {
  const tagString = event.target.value;
  if (tagString) {
    const tags = JSON.parse(tagString).map(({ value }) => value);
    doc.update({ [targetKey]: tags });
  } else {
    doc.update({ [targetKey]: [] });
  }
};
const Tags = {
  InitListeners: (html, doc) => {
    function makeTagInput(elem, tags) {
      const tagify = new Tagify(elem, {
        enforceWhitelist: true,
        editTags: false,
        whitelist: Object.entries(tags).map(([dataGroup, tagList]) => tagList.map((tag) => ({
          "value": new Handlebars.SafeString(tag).toString(),
          "data-group": dataGroup
        }))).flat(),
        dropdown: {
          enabled: 0,
          maxItems: 1e4,
          placeAbove: false,
          appendTarget: html[0]
        }
      });
      tagify.dropdown.createListHTML = (optionsArr) => {
        const map = {};
        return structuredClone(optionsArr).map((suggestion) => {
          const value = tagify.dropdown.getMappedValue.call(
            tagify,
            suggestion
          );
          let tagHTMLString = "";
          if (!map[suggestion["data-group"]]) {
            map[suggestion["data-group"]] = true;
            if (Object.keys(map).length) {
              tagHTMLString += "</div>";
            }
            tagHTMLString += `
                <div class="tagify__dropdown__itemsGroup">
                <h3>${suggestion["data-group"]}</h3>
              `;
          }
          suggestion.value = value && typeof value === "string" ? U.escapeHTML(value) : value;
          tagHTMLString += tagify.settings.templates.dropdownItem.apply(
            tagify,
            [suggestion]
          );
          return tagHTMLString;
        }).join("");
      };
      function findDataGroup(tag) {
        for (const [group2, tagList] of Object.entries(tags)) {
          if (tagList.includes(tag)) {
            return group2;
          }
        }
        return false;
      }
      const targetKey = $(elem).data("tagTarget") ?? "system.tags";
      const curTags = [getProperty(doc, targetKey) ?? []].flat().filter(Boolean);
      tagify.addTags(
        curTags.filter(findDataGroup).map((tag) => ({
          "value": new Handlebars.SafeString(tag).toString(),
          "data-group": findDataGroup(tag)
        })),
        true,
        true
      );
      setTimeout(() => elem.addEventListener("change", (event) => {
        _onTagifyChange(event, doc, targetKey);
      }), 1e3);
    }
    const systemTags = {
      "System Tags": Object.values(Tag.System),
      "Gear Tags": [
        ...Object.values(Tag.Gear),
        ...Object.values(Tag.GearCategory)
      ],
      "Actor Tags": [
        ...Object.values(Tag.PC),
        ...Object.values(Tag.NPC)
      ],
      "Vices": Object.values(Vice),
      "Playbooks": Object.values(Playbook),
      "Inventions": Object.values(Tag.Invention),
      "Gang Types": Object.values(Tag.GangType)
    };
    const districtTags = {
      "City Districts": Object.values(MainDistrict),
      "Other Districts": Object.values(OtherDistrict)
    };
    const factionTags = { Factions: game.actors.filter((actor) => actor.type === BladesActorType.faction && actor.name !== null).map((faction) => faction.name) };
    $(html).find(".tags-gm").each((_, e) => makeTagInput(e, systemTags));
    $(html).find(".tags-district").each((_, e) => makeTagInput(e, districtTags));
    $(html).find(".tags-faction").each((_, e) => makeTagInput(e, factionTags));
  }
};
class BladesItemSheet extends ItemSheet {
  constructor() {
    super(...arguments);
    __publicField(this, "_getTypedItemData", {
      [BladesItemType.ability]: (context3) => {
        if (!BladesItem$1.IsType(this.item, BladesItemType.ability)) {
          return void 0;
        }
        const sheetData = {};
        return {
          ...context3,
          ...sheetData
        };
      },
      [BladesItemType.background]: (context3) => {
        if (!BladesItem$1.IsType(this.item, BladesItemType.background)) {
          return void 0;
        }
        const sheetData = {};
        return {
          ...context3,
          ...sheetData
        };
      },
      [BladesItemType.clock_keeper]: (context3) => {
        if (!BladesItem$1.IsType(this.item, BladesItemType.clock_keeper)) {
          return void 0;
        }
        const sheetData = {
          phases: Object.values(BladesPhase)
        };
        return {
          ...context3,
          ...sheetData
        };
      },
      [BladesItemType.cohort_gang]: (context3) => {
        var _a2, _b;
        if (!BladesItem$1.IsType(this.item, BladesItemType.cohort_gang, BladesItemType.cohort_expert)) {
          return void 0;
        }
        context3.tierTotal = this.item.system.quality > 0 ? U.romanizeNum(this.item.system.quality) : "0";
        (_a2 = context3.system).subtypes ?? (_a2.subtypes = {});
        (_b = context3.system).elite_subtypes ?? (_b.elite_subtypes = {});
        const sheetData = {
          tierData: {
            class: "comp-tier comp-vertical comp-teeth",
            dotline: {
              data: this.item.system.tier,
              target: "system.tier.value",
              iconEmpty: "dot-empty.svg",
              iconEmptyHover: "dot-empty-hover.svg",
              iconFull: "dot-full.svg",
              iconFullHover: "dot-full-hover.svg"
            }
          }
        };
        sheetData.edgeData = Object.fromEntries(Object.values(context3.system.edges ?? []).filter((edge) => /[A-Za-z]/.test(edge)).map((edge) => [edge.trim(), C.EdgeTooltips[edge]]));
        sheetData.flawData = Object.fromEntries(Object.values(context3.system.flaws ?? []).filter((flaw) => /[A-Za-z]/.test(flaw)).map((flaw) => [flaw.trim(), C.FlawTooltips[flaw]]));
        return {
          ...context3,
          ...sheetData
        };
      },
      [BladesItemType.cohort_expert]: (context3) => {
        const typedItemData = this._getTypedItemData[BladesItemType.cohort_gang];
        if (!typedItemData) {
          throw new Error(`No data for type ${this.item.type}`);
        }
        return typedItemData(context3);
      },
      [BladesItemType.crew_ability]: (context3) => {
        if (!BladesItem$1.IsType(this.item, BladesItemType.crew_ability)) {
          return void 0;
        }
        const sheetData = {};
        return {
          ...context3,
          ...sheetData
        };
      },
      [BladesItemType.crew_reputation]: (context3) => {
        if (!BladesItem$1.IsType(this.item, BladesItemType.crew_reputation)) {
          return void 0;
        }
        const sheetData = {};
        return {
          ...context3,
          ...sheetData
        };
      },
      [BladesItemType.crew_playbook]: (context3) => {
        if (!BladesItem$1.IsType(this.item, BladesItemType.crew_playbook)) {
          return void 0;
        }
        if (context3.isGM) {
          const expClueData = {};
          [...Object.values(context3.system.experience_clues ?? []).filter((clue) => /[A-Za-z]/.test(clue)), " "].forEach((clue, i) => {
            expClueData[(i + 1).toString()] = clue;
          });
          context3.system.experience_clues = expClueData;
        }
        const sheetData = {};
        return {
          ...context3,
          ...sheetData
        };
      },
      [BladesItemType.crew_upgrade]: (context3) => {
        if (!BladesItem$1.IsType(this.item, BladesItemType.crew_upgrade)) {
          return void 0;
        }
        const sheetData = {};
        return {
          ...context3,
          ...sheetData
        };
      },
      [BladesItemType.feature]: (context3) => {
        if (!BladesItem$1.IsType(this.item, BladesItemType.feature)) {
          return void 0;
        }
        const sheetData = {};
        return {
          ...context3,
          ...sheetData
        };
      },
      [BladesItemType.gm_tracker]: (context3) => {
        if (!BladesItem$1.IsType(this.item, BladesItemType.gm_tracker)) {
          return void 0;
        }
        const sheetData = {
          phase: this.item.system.phase,
          phases: Object.values(BladesPhase)
        };
        return {
          ...context3,
          ...sheetData
        };
      },
      [BladesItemType.heritage]: (context3) => {
        if (!BladesItem$1.IsType(this.item, BladesItemType.heritage)) {
          return void 0;
        }
        const sheetData = {};
        return {
          ...context3,
          ...sheetData
        };
      },
      [BladesItemType.gear]: (context3) => {
        if (!BladesItem$1.IsType(this.item, BladesItemType.gear)) {
          return void 0;
        }
        const sheetData = {
          tierData: {
            class: "comp-tier comp-vertical comp-teeth",
            label: "Quality",
            labelClass: "filled-label full-width",
            dotline: {
              data: this.item.system.tier,
              target: "system.tier.value",
              iconEmpty: "dot-empty.svg",
              iconEmptyHover: "dot-empty-hover.svg",
              iconFull: "dot-full.svg",
              iconFullHover: "dot-full-hover.svg"
            }
          }
        };
        return {
          ...context3,
          ...sheetData
        };
      },
      [BladesItemType.playbook]: (context3) => {
        if (!BladesItem$1.IsType(this.item, BladesItemType.playbook)) {
          return void 0;
        }
        if (context3.isGM) {
          const expClueData = {};
          [...Object.values(context3.system.experience_clues ?? []).filter((clue) => /[A-Za-z]/.test(clue)), " "].forEach((clue, i) => {
            expClueData[(i + 1).toString()] = clue;
          });
          context3.system.experience_clues = expClueData;
          const gatherInfoData = {};
          [...Object.values(context3.system.gather_info_questions ?? []).filter((question) => /[A-Za-z]/.test(question)), " "].forEach((question, i) => {
            gatherInfoData[(i + 1).toString()] = question;
          });
          context3.system.gather_info_questions = gatherInfoData;
        }
        const sheetData = {};
        return {
          ...context3,
          ...sheetData
        };
      },
      [BladesItemType.preferred_op]: (context3) => {
        if (!BladesItem$1.IsType(this.item, BladesItemType.preferred_op)) {
          return void 0;
        }
        const sheetData = {};
        return {
          ...context3,
          ...sheetData
        };
      },
      [BladesItemType.stricture]: (context3) => {
        if (!BladesItem$1.IsType(this.item, BladesItemType.stricture)) {
          return void 0;
        }
        const sheetData = {};
        return {
          ...context3,
          ...sheetData
        };
      },
      [BladesItemType.vice]: (context3) => {
        if (!BladesItem$1.IsType(this.item, BladesItemType.vice)) {
          return void 0;
        }
        const sheetData = {};
        return {
          ...context3,
          ...sheetData
        };
      },
      [BladesItemType.ritual]: (context3) => {
        if (!BladesItem$1.IsType(this.item, BladesItemType.ritual)) {
          return void 0;
        }
        const sheetData = {};
        return {
          ...context3,
          ...sheetData
        };
      },
      [BladesItemType.design]: (context3) => {
        if (!BladesItem$1.IsType(this.item, BladesItemType.design)) {
          return void 0;
        }
        const sheetData = {};
        return {
          ...context3,
          ...sheetData
        };
      },
      [BladesItemType.location]: (context3) => {
        if (!BladesItem$1.IsType(this.item, BladesItemType.location)) {
          return void 0;
        }
        const sheetData = {};
        return {
          ...context3,
          ...sheetData
        };
      },
      [BladesItemType.score]: (context3) => {
        if (!BladesItem$1.IsType(this.item, BladesItemType.score)) {
          return void 0;
        }
        return context3;
      }
    });
  }
  static get defaultOptions() {
    return foundry.utils.mergeObject(super.defaultOptions, {
      classes: ["eunos-blades", "sheet", "item"],
      width: 560,
      height: 500,
      tabs: [{ navSelector: ".sheet-tabs", contentSelector: ".sheet-body", initial: "description" }]
    });
  }
  /* -------------------------------------------- */
  // constructor(item: BladesItem, options: Partial<ItemSheet.Options> = {}) {
  //   options.classes = [...options.classes ?? [], "eunos-blades", "sheet", "item", item.type];
  //   super(item, options);
  // }
  // override async getData() {
  getData() {
    var _a2;
    const context3 = super.getData();
    const sheetData = {
      cssClass: this.item.type,
      editable: this.options.editable,
      isGM: ((_a2 = game.eunoblades.Tracker) == null ? void 0 : _a2.system.is_spoofing_player) ? false : Boolean(game.user.isGM),
      isEmbeddedItem: Boolean(this.item.parent),
      item: this.item,
      system: this.item.system,
      tierTotal: this.item.getFactorTotal(Factor.tier) > 0 ? U.romanizeNum(this.item.getFactorTotal(Factor.tier)) : "0",
      activeEffects: Array.from(this.item.effects)
    };
    const typedItemData = this._getTypedItemData[this.item.type];
    if (typedItemData) {
      return typedItemData({ ...context3, ...sheetData });
    }
    return {
      ...context3,
      ...sheetData
    };
  }
  get template() {
    const pathComps = [
      "systems/eunos-blades/templates/items"
    ];
    if (C.SimpleItemTypes.includes(this.item.type)) {
      pathComps.push("simple-sheet.hbs");
    } else {
      pathComps.push(`${this.item.type}-sheet.hbs`);
    }
    return pathComps.join("/");
  }
  /* -------------------------------------------- */
  addDotlineListeners(html) {
    html.find(".dotline").each((__, elem) => {
      if ($(elem).hasClass("locked")) {
        return;
      }
      const targetDoc = this.item;
      const targetField = $(elem).data("target");
      const comp$ = $(elem).closest("comp");
      const curValue = U.pInt($(elem).data("value"));
      $(elem).find(".dot").each((_, dot) => {
        $(dot).on("click", (event) => {
          event.preventDefault();
          const thisValue = U.pInt($(dot).data("value"));
          if (thisValue !== curValue) {
            if (comp$.hasClass("comp-coins") || comp$.hasClass("comp-stash")) {
              G.effects.fillCoins($(dot).prevAll(".dot")).then(() => targetDoc.update({ [targetField]: thisValue }));
            } else {
              targetDoc.update({ [targetField]: thisValue });
            }
          }
        });
        $(dot).on("contextmenu", (event) => {
          event.preventDefault();
          const thisValue = U.pInt($(dot).data("value")) - 1;
          if (thisValue !== curValue) {
            targetDoc.update({ [targetField]: thisValue });
          }
        });
      });
    });
  }
  async activateListeners(html) {
    await super.activateListeners(html);
    const self2 = this;
    Tags.InitListeners(html, this.item);
    ApplyTooltipAnimations(html);
    if (!this.options.editable) {
      return;
    }
    this.addDotlineListeners(html);
    if (BladesItem$1.IsType(this.item, BladesItemType.cohort_expert, BladesItemType.cohort_gang)) {
      html.find("[data-harm-click]").on({
        click: (event) => {
          var _a2;
          event.preventDefault();
          const harmLevel = U.pInt($(event.currentTarget).data("harmClick"));
          if (((_a2 = this.item.system.harm) == null ? void 0 : _a2.value) !== harmLevel) {
            this.item.update({ "system.harm.value": harmLevel });
          }
        },
        contextmenu: (event) => {
          var _a2;
          event.preventDefault();
          const harmLevel = Math.max(0, U.pInt($(event.currentTarget).data("harmClick")) - 1);
          if (((_a2 = this.item.system.harm) == null ? void 0 : _a2.value) !== harmLevel) {
            this.item.update({ "system.harm.value": harmLevel });
          }
        }
      });
    }
    if (this.options.submitOnChange) {
      html.on("change", "textarea", this._onChangeInput.bind(this));
    }
    html.find(".effect-control").on("click", (ev) => {
      var _a2;
      if (self2.item.isOwned) {
        (_a2 = ui.notifications) == null ? void 0 : _a2.warn(game.i18n.localize("BITD.EffectWarning"));
        return;
      }
      BladesActiveEffect.onManageActiveEffect(ev, self2.item);
    });
    html.find('[data-action="toggle-turf-connection"').on("click", this.toggleTurfConnection.bind(this));
  }
  toggleTurfConnection(event) {
    const button$ = $(event.currentTarget);
    const connector$ = button$.parent();
    const turfNum = parseInt(connector$.data("index") ?? 0, 10);
    const turfDir = connector$.data("dir");
    if (!turfNum || !turfDir) {
      return;
    }
    const toggleState = connector$.hasClass("no-connect");
    const updateData = {
      [`system.turfs.${turfNum}.connects.${turfDir}`]: toggleState
    };
    const partner = connector$.data("partner");
    if (typeof partner === "string" && /-/.test(partner)) {
      const [partnerNum, partnerDir] = partner.split("-");
      updateData[`system.turfs.${partnerNum}.connects.${partnerDir}`] = toggleState;
    }
    this.item.update(updateData);
  }
}
class BladesProjectSheet extends BladesItemSheet {
  constructor() {
    super(...arguments);
    __publicField(this, "_htmlContext");
  }
  static get defaultOptions() {
    return foundry.utils.mergeObject(super.defaultOptions, {
      classes: ["eunos-blades", "sheet", "item", "project-sheet"],
      template: "systems/eunos-blades/templates/items/project-sheet.hbs"
    });
  }
  getData() {
    const context3 = super.getData();
    const sheetData = {};
    sheetData.presentingClock = this.presentedClock;
    return {
      ...context3,
      ...sheetData
    };
  }
  get presentedClock() {
    const { clockKey } = this.document;
    if (!clockKey) {
      throw new Error(`ClockKey not initialized for Project ${this.document.name}`);
    }
    let focusedClockIndex;
    if (U.isInt(clockKey.displayMode)) {
      focusedClockIndex = clockKey.displayMode;
    } else if (clockKey.displayMode === ClockKeyDisplayMode.presentCurrentClock) {
      focusedClockIndex = this.document.currentClock.index;
    } else if (clockKey.displayMode.startsWith("present")) {
      focusedClockIndex = U.pInt(clockKey.displayMode.slice(7));
    } else {
      return false;
    }
    return this.document.clockKey.getClockByIndex(focusedClockIndex) ?? false;
  }
  getClockKeyComponents(html) {
    const { clockKey } = this.document;
    if (!clockKey) {
      throw new Error(`ClockKey not initialized for Project ${this.document.name}`);
    }
    return {
      clockKey,
      keyElems$: clockKey.getElements$(html.find(".clock-key-panel"))
    };
  }
  switchToPresentAllClocks(clockKey, keyElems$) {
    const { clocks } = keyElems$;
    const timeline2 = clockKey.switchToMode(keyElems$, ClockKeyDisplayMode.clocks);
    if (clockKey.size > 1) {
      clockKey.visibleClocks.forEach((clock, i) => {
        const { clockLabel$ } = clocks[clock.id];
        timeline2.blurReveal(clockLabel$, i === 0 ? ">" : "<+0.05");
      });
    }
    timeline2.play().then(() => {
      if (this._htmlContext && this.document.currentClock) {
        this._htmlContext.find(".sheet-subtitle").attr("data-action", "current-clock-name").val(this.document.currentClock.name);
      }
    });
  }
  switchToPresentClock(clockRef, clockKey, keyElems$) {
    const timeline2 = clockKey.switchToMode(
      keyElems$,
      clockRef === ClockKeyDisplayMode.presentCurrentClock ? clockRef : `present${clockRef}`,
      void 0,
      void 0,
      true,
      () => {
        eLog.checkLog3("BladesProject", "Clock Switch", { clockRef, clockKey, keyElems$, htmlContext: this._htmlContext, presentedClock: this.presentedClock });
        if (this._htmlContext && this.presentedClock) {
          this._htmlContext.find(".sheet-subtitle").attr("data-action", "presented-clock-name").val(this.presentedClock.name);
        }
      }
    );
    timeline2.to(keyElems$.container$.find(".clock-label, .clock-key-label"), { autoAlpha: 0, duration: 0.5, ease: "sine" }, 0);
    timeline2.play().then();
  }
  activateClockKeyListeners(clockKey, keyElems$) {
    eLog.checkLog2("BladesProject", "Clock Key Data", { clockKey, keyElems$ });
    const { container$ } = keyElems$;
    container$.css("pointer-events", "auto");
    container$.on("contextmenu", () => {
      this.switchToPresentAllClocks(clockKey, keyElems$);
    });
    Object.entries(keyElems$.clocks).forEach(([clockId, clockElems$]) => {
      clockElems$.clockContainer$.css("pointer-events", "auto");
      clockElems$.clockContainer$.on("click", () => {
        var _a2;
        this.switchToPresentClock(
          ((_a2 = clockKey.clocks.get(clockId)) == null ? void 0 : _a2.index) ?? ClockKeyDisplayMode.presentCurrentClock,
          clockKey,
          keyElems$
        );
      });
    });
  }
  async activateListeners(html) {
    this._htmlContext = html;
    await super.activateListeners(html);
    const { clockKey, keyElems$ } = this.getClockKeyComponents(html);
    html.find("input.sheet-subtitle").on({
      change: (event) => {
        event.preventDefault();
        const action = $(event.currentTarget).data("action");
        eLog.checkLog3("BladesProject", "Clock Name Change", { action, value: $(event.currentTarget).val() });
        if (action === "presented-clock-name" && this.presentedClock) {
          this.presentedClock.updateTarget("name", $(event.currentTarget).val());
          keyElems$.clocks[this.presentedClock.id].clockLabel$.text($(event.currentTarget).val());
        } else if (action === "current-clock-name") {
          this.document.clockKey.currentClock.updateTarget("name", $(event.currentTarget).val());
          keyElems$.clocks[this.document.clockKey.currentClock.id].clockLabel$.text($(event.currentTarget).val());
        }
        clockKey.formatLabels(keyElems$);
      }
    });
    clockKey.initElementsInContext(html);
    this.activateClockKeyListeners(clockKey, keyElems$);
    await Promise.all([
      ...clockKey.visibleClocks.map((clock) => new Promise((resolve) => {
        const clockElems$ = keyElems$.clocks[clock.id];
        clock.reveal_Animation(clockElems$, () => {
          resolve();
        });
      })),
      ...clockKey.activeClocks.map((clock) => new Promise((resolve) => {
        const clockElems$ = keyElems$.clocks[clock.id];
        clock.activate_Animation(clockElems$, () => {
          resolve();
        });
      }))
    ]);
  }
}
class BladesProject extends BladesItem$1 {
  constructor() {
    super(...arguments);
    __publicField(this, "_clockKey");
  }
  // #region INITIALIZATION ~
  static async Initialize() {
    Object.assign(globalThis, { BladesProject, BladesProjectSheet });
    Items.registerSheet("blades", BladesProjectSheet, { types: ["project"], makeDefault: true });
    return loadTemplates(["systems/eunos-blades/templates/items/project-sheet.hbs"]);
  }
  // #endregion
  static IsType(doc) {
    return super.IsType(doc, BladesItemType.project);
  }
  static async create(data, options = {}) {
    const project = await super.create(data, { ...options, renderSheet: false });
    if (!project._clockKey) {
      project._clockKey = await BladesClockKey.Create({
        name: project.name,
        target: project,
        targetKey: "system.clocksData",
        isNameVisible: false,
        isSpotlit: false,
        isVisible: true,
        displayMode: ClockKeyDisplayMode.clocks
        // oneKeyIndex: U.gsap.utils.random(0, 4, 1) as OneKeyImgIndex
      }, void 0, [{
        name: "",
        index: 0,
        color: ClockColor.yellow,
        value: 0,
        max: 8,
        isVisible: true,
        isActive: true,
        isNameVisible: false,
        isHighlighted: false
      }]);
    }
    return project;
  }
  get clockKey() {
    var _a2, _b, _c;
    if (this._clockKey) {
      return this._clockKey;
    }
    const keysData = Object.values(this.system.clocksData);
    if (keysData.length === 0) {
      throw new Error(`ClockKey not initialized for Project ${this.name}`);
    }
    let keyID;
    if (keysData.length === 1) {
      keyID = keysData[0].id;
    } else if (this.isEmbedded) {
      keyID = (_a2 = keysData.find((keyData) => {
        var _a3;
        return keyData.targetID.includes((_a3 = this.parent) == null ? void 0 : _a3.id);
      })) == null ? void 0 : _a2.id;
      if (!keyID) {
        throw new Error(`ClockKey not initialized for Project ${this.name} embedded in document '${(_b = this.parent) == null ? void 0 : _b.name}'.`);
      }
    } else {
      keyID = (_c = keysData.find((keyData) => /^Item\.[^.]{16}$/.exec(keyData.targetID))) == null ? void 0 : _c.id;
      if (!keyID) {
        throw new Error(`ClockKey not initialized for Project ${this.name}.`);
      }
    }
    this._clockKey = game.eunoblades.ClockKeys.get(keyID) ?? new BladesClockKey(this.system.clocksData[keyID]);
    if (!this._clockKey) {
      throw new Error(`ClockKey not initialized for Project ${this.name}`);
    }
    return this._clockKey;
  }
  get ownerName() {
    if (this.parent) {
      return this.parent.name;
    }
    return void 0;
  }
  get currentClock() {
    return this.clockKey.currentClock;
  }
  get isComplete() {
    return this.clockKey.isComplete;
  }
  get rollOppClock() {
    var _a2;
    return (_a2 = this.currentClock) == null ? void 0 : _a2.data;
  }
  async advanceClock(segments = 1) {
    if (!this.currentClock) {
      return void 0;
    }
    return this.currentClock.fillSegments(segments);
  }
  get rollFactors() {
    const factorData = {};
    [
      Factor.tier,
      Factor.quality
    ].forEach((factor, i) => {
      const factorTotal = this.getFactorTotal(factor);
      factorData[factor] = {
        name: factor,
        value: factorTotal,
        max: factorTotal,
        baseVal: factorTotal,
        display: factor === Factor.tier ? U.romanizeNum(factorTotal) : `${factorTotal}`,
        isActive: i === 0,
        isPrimary: i === 0,
        isDominant: false,
        highFavorsPC: true,
        cssClasses: `factor-gold${i === 0 ? " factor-main" : ""}`
      };
    });
    return factorData;
  }
  getFactorTotal(factor) {
    switch (factor) {
      case Factor.tier:
        return this.system.tier.value;
      case Factor.quality:
        return this.getFactorTotal(Factor.tier);
    }
    return 0;
  }
  get rollOppImg() {
    return "";
  }
  get keyElem() {
    if (!this.clockKey) {
      return void 0;
    }
    return $(`#${this.clockKey.id}`)[0];
  }
  get currentClockElem() {
    if (!this.keyElem) {
      return void 0;
    }
    if (!this.currentClock) {
      return void 0;
    }
    return $(this.keyElem).find(`.clock[data-id="${this.currentClock.id}"]`)[0];
  }
}
const BladesProject$1 = BladesProject;
class BladesLocation extends BladesItem$1 {
  get rollFactors() {
    const factorData = {};
    [
      Factor.tier,
      Factor.quality,
      Factor.scale
    ].forEach((factor, i) => {
      const factorTotal = this.getFactorTotal(factor);
      factorData[factor] = {
        name: factor,
        value: factorTotal,
        max: factorTotal,
        baseVal: factorTotal,
        display: factor === Factor.tier ? U.romanizeNum(factorTotal) : `${factorTotal}`,
        isActive: i === 0,
        isPrimary: i === 0,
        isDominant: false,
        highFavorsPC: true,
        cssClasses: `factor-gold${i === 0 ? " factor-main" : ""}`
      };
    });
    return factorData;
  }
  getFactorTotal(factor) {
    switch (factor) {
      case Factor.tier:
        return this.system.tier.value;
      case Factor.quality:
        return this.getFactorTotal(Factor.tier);
      case Factor.scale:
        return this.system.scale;
    }
    return 0;
  }
  get rollOppImg() {
    return this.img ?? "";
  }
  // #region OVERRIDES: _onUpdate
  // override async _onUpdate(changed: any, options: any, userId: string) {
  //   await super._onUpdate(changed, options, userId);
  //   BladesActor.GetTypeWithTags(BladesActorType.pc).forEach((actor) => actor.render());
  // }
  // #endregion
}
class BladesClockKeeper extends BladesItem$1 {
  static async Initialize() {
    const clockKeeper = game.items.find((item) => item.type === "clock_keeper");
    if (!clockKeeper) {
      game.eunoblades.ClockKeeper = await BladesClockKeeper.create({
        name: "Clock Keeper",
        type: "clock_keeper",
        img: "systems/eunos-blades/assets/icons/misc-icons/clock-keeper.svg"
      });
    } else {
      game.eunoblades.ClockKeeper = clockKeeper;
    }
    return loadTemplates([
      "systems/eunos-blades/templates/parts/clock-sheet-key-controls.hbs",
      "systems/eunos-blades/templates/parts/clock-sheet-clock-controls.hbs"
    ]);
  }
  showClockKeyControls(keyID) {
    var _a2;
    if ((_a2 = this.sheet) == null ? void 0 : _a2.element)
      ;
  }
  hideClockKeyControls(keyID) {
    var _a2;
    if ((_a2 = this.sheet) == null ? void 0 : _a2.element)
      ;
  }
  // #region CLOCKS OVERLAY
  get clockKeys() {
    return this.getSceneKeys();
  }
  get currentScene() {
    var _a2, _b;
    return (_b = (_a2 = game.scenes) == null ? void 0 : _a2.current) == null ? void 0 : _b.id;
  }
  get currentSceneID() {
    var _a2;
    if (!((_a2 = game.scenes) == null ? void 0 : _a2.current)) {
      throw new Error("[BladesClockKeeper.currentScene] Error retrieving 'game.scenes.current'.");
    }
    return game.scenes.current.id;
  }
  get targetSceneID() {
    return this.system.targetScene ?? this.currentSceneID;
  }
  get keys() {
    return new Collection(
      Object.entries(this.system.clocksData ?? {}).map(([id, data]) => [
        id,
        game.eunoblades.ClockKeys.get(id) ?? new BladesClockKey(data)
      ])
    );
  }
  getSceneKeys(sceneID) {
    sceneID ?? (sceneID = this.targetSceneID);
    return new Collection(Array.from(game.eunoblades.ClockKeys).filter((clockKey) => clockKey.sceneIDs.includes(sceneID)).map((clockKey) => [clockKey.id, clockKey]));
  }
  async addClockKey(clockKeyConfig = {}) {
    var _a2;
    if (!((_a2 = clockKeyConfig.sceneIDs) == null ? void 0 : _a2.length)) {
      clockKeyConfig.sceneIDs = [this.targetSceneID];
    }
    const key = await BladesClockKey.Create({
      target: this,
      targetKey: "system.clocksData",
      ...clockKeyConfig
    });
    return key;
  }
  async deleteClockKey(keyID) {
    var _a2;
    await ((_a2 = game.eunoblades.ClockKeys.get(keyID)) == null ? void 0 : _a2.delete(game.eunoblades.ClockKeys));
  }
  async addClockToKey(keyID, clockData) {
    const key = await game.eunoblades.ClockKeys.get(keyID);
    if (!key) {
      return;
    }
    await key.addClock(clockData);
  }
  async deleteClockFromKey(keyID, clockID) {
    const key = await game.eunoblades.ClockKeys.get(keyID);
    if (!key) {
      return;
    }
    await key.deleteClock(clockID);
  }
  // #endregion
  // #region OVERRIDES: prepareDerivedData, _onUpdate
  prepareDerivedData() {
    var _a2, _b;
    super.prepareDerivedData();
    (_b = this.system).targetScene ?? (_b.targetScene = ((_a2 = game.scenes.current) == null ? void 0 : _a2.id) || null);
  }
  // #endregion
}
const BladesClockKeeper$1 = BladesClockKeeper;
class BladesGMTracker extends BladesItem$1 {
  static async Initialize() {
    const tracker = game.items.find((item) => BladesItem$1.IsType(item, BladesItemType.gm_tracker));
    if (tracker) {
      game.eunoblades.Tracker = tracker;
    } else {
      game.eunoblades.Tracker = await BladesGMTracker.create({
        name: "GM Tracker",
        type: "gm_tracker",
        img: "systems/eunos-blades/assets/icons/misc-icons/gm-tracker.svg"
      });
    }
  }
  get phase() {
    return this.system.phase ?? BladesPhase.Freeplay;
  }
  set phase(phase) {
    this.update({ "system.phase": phase });
  }
  prepareDerivedData() {
    this.system.phases = Object.values(BladesPhase);
  }
  // #region OVERRIDES: prepareDerivedData, _onUpdate
  async _onUpdate(...args) {
    await super.callOnUpdate(...args);
    BladesActor$1.GetTypeWithTags(BladesActorType.pc).forEach((actor) => actor.render());
  }
  // #endregion
}
const BladesGMTracker$1 = BladesGMTracker;
class BladesScoreSheet extends BladesItemSheet {
  static get defaultOptions() {
    return foundry.utils.mergeObject(super.defaultOptions, {
      classes: ["eunos-blades", "sheet", "item", "score-sheet"],
      template: "systems/eunos-blades/templates/items/score-sheet.hbs",
      width: 900,
      submitOnChange: false,
      height: 970
    });
  }
  async generateRandomizerData(category) {
    const randomData = {
      Bargains: Object.fromEntries(Object.entries(U.sample(Randomizers.GM.Bargains.filter((bData) => !Object.values(this.document.system.randomizers.Bargains).some((_bData) => _bData.name === bData.name || _bData.effect === bData.effect)), 3, true, (e, a) => a.filter((_e) => e.category === _e.category).length === 0)).map(([k, v]) => {
        k = `${k}`;
        Object.assign(v, { notes: "" });
        return [k, v];
      })),
      Obstacles: Object.fromEntries(Object.entries(U.sample(Randomizers.GM.Obstacles.filter((bData) => !Object.values(this.document.system.randomizers.Obstacles).some((_bData) => _bData.name === bData.name || _bData.desc === bData.desc)), 3, true, (e, a) => a.filter((_e) => e.category === _e.category).length === 0)).map(([k, v]) => {
        k = `${k}`;
        Object.assign(v, { notes: "" });
        return [k, v];
      })),
      NPCs: Object.fromEntries(Object.entries(U.sample(
        Randomizers.GM.NPCs.filter(
          (bData) => !Object.values(this.document.system.randomizers.NPCs).some((_bData) => _bData.name === bData.name || _bData.description === bData.description)
        ),
        3,
        true,
        (e, a) => a.filter((_e) => e.arena === _e.arena).length === 0
      )).map(([k, v]) => {
        k = `${k}`;
        Object.assign(v, { notes: "" });
        return [k, v];
      })),
      Scores: Object.fromEntries(Object.entries(U.sample(Randomizers.GM.Scores.filter((bData) => !Object.values(this.document.system.randomizers.Scores).some((_bData) => _bData.name === bData.name || _bData.desc === bData.desc)), 3, true, (e, a) => a.filter((_e) => e.category === _e.category).length === 0)).map(([k, v]) => {
        k = `${k}`;
        Object.assign(v, { notes: "" });
        return [k, v];
      }))
    };
    if (category) {
      Object.keys(randomData).filter((cat) => cat !== category).forEach((cat) => {
        const _cat = cat;
        randomData[_cat] = this.document.system.randomizers[_cat];
      });
    }
    const finalRandomData = {
      Bargains: {},
      Obstacles: {},
      NPCs: {},
      Scores: {}
    };
    Object.keys(randomData).forEach((cat) => {
      const _cat = cat;
      Object.keys(randomData[_cat]).forEach((index) => {
        var _a2;
        if ((_a2 = this.document.system.randomizers) == null ? void 0 : _a2[_cat][index].isLocked) {
          finalRandomData[_cat][index] = this.document.system.randomizers[_cat][index];
        } else {
          finalRandomData[_cat][index] = randomData[_cat][index];
        }
      });
    });
    await this.document.update({ "system.randomizers": finalRandomData });
  }
  getData() {
    const context3 = super.getData();
    const sheetData = {};
    sheetData.playerCharacters = BladesActor$1.GetTypeWithTags(BladesActorType.pc, Tag.PC.ActivePC).map((pc) => {
      return Object.assign(
        pc,
        {
          actionData: Object.fromEntries(Object.entries(pc.system.attributes).map(([attrName, attrData]) => {
            return [
              attrName,
              Object.fromEntries(Object.entries(attrData).map(([actionName, actionData]) => {
                return [
                  U.uCase(actionName).slice(0, 3),
                  actionData
                ];
              }))
            ];
          }))
        }
      );
    });
    const validOppositions = {};
    for (const [id, data] of Object.entries(context3.system.oppositions)) {
      if (!data.rollOppName && !data.rollOppSubName) {
        continue;
      }
      validOppositions[id] = data;
    }
    context3.system.oppositions = validOppositions;
    return {
      ...context3,
      ...sheetData
    };
  }
  _toggleRandomizerLock(event) {
    const elem$ = $(event.currentTarget);
    const elemCat = elem$.data("category");
    const elemIndex = `${elem$.data("index")}`;
    const elemValue = elem$.data("value");
    if (`${elemValue}` === "true") {
      this.document.update({ [`system.randomizers.${elemCat}.${elemIndex}.isLocked`]: false });
    } else {
      this.document.update({ [`system.randomizers.${elemCat}.${elemIndex}.isLocked`]: true });
    }
  }
  _selectImage(event) {
    const elem$ = $(event.currentTarget);
    const imageNum = elem$.data("imgNum");
    this.document.update({ "system.imageSelected": imageNum });
  }
  _deselectOrDeleteImage(event) {
    const elem$ = $(event.currentTarget);
    const imageNum = elem$.data("imgNum");
    if (this.document.system.imageSelected === imageNum) {
      this.document.update({ "system.-=imageSelected": null });
      return;
    }
    const images = { ...this.document.system.images };
    this.document.update({ "system.-=images": null }).then(() => this.document.update({
      "system.images": Object.fromEntries(Object.entries(Object.values(images).filter((_, i) => U.pInt(imageNum) !== i)))
    }));
  }
  _addImage() {
    U.displayImageSelector(
      (path) => {
        const imgIndex = U.objSize(this.document.system.images);
        return this.document.update({ [`system.images.${imgIndex}`]: path });
      },
      "systems/eunos-blades/assets",
      this.position
    );
  }
  _selectRollOpposition(event) {
    var _a2;
    eLog.checkLog3("Select Roll Opposition", { event });
    const elem$ = $(event.currentTarget);
    const oppId = elem$.data("oppId");
    this.document.update({ "system.oppositionSelected": oppId });
    if (((_a2 = BladesScore$1.Active) == null ? void 0 : _a2.id) === this.document.id && BladesRoll$1.Active) {
      BladesRoll$1.Active.rollOpposition = new BladesRollOpposition(
        BladesRoll$1.Active,
        this.document.system.oppositions[oppId]
      );
    }
  }
  _triggerRandomize(event) {
    const elem$ = $(event.currentTarget);
    const category = elem$.data("category");
    if (category && category in Randomizers.GM) {
      this.generateRandomizerData(category);
    } else {
      this.generateRandomizerData();
    }
  }
  async _updateGMNotesOnPC(event) {
    const elem$ = $(event.currentTarget);
    const actor = BladesActor$1.Get(elem$.data("id"));
    if (!actor) {
      throw new Error(`Unable to retrieve actor with id '${elem$.data("id")}'`);
    }
    const updateText = event.currentTarget.innerHTML;
    eLog.checkLog3("scoreSheet", "Retrieved Text, Updating ...", { updateText });
    await actor.update({ "system.gm_notes": updateText });
    eLog.checkLog3("scoreSheet", "Updated!", { gm_notes: actor.system.gm_notes });
  }
  async activateListeners(html) {
    super.activateListeners(html);
    html.find("[data-action='select-image']").on({
      click: this._selectImage.bind(this),
      contextmenu: this._deselectOrDeleteImage.bind(this)
    });
    html.find("[data-action='add-image']").on({
      click: this._addImage.bind(this)
    });
    html.find(".roll-opposition-name").on({
      dblclick: this._selectRollOpposition.bind(this)
    });
    html.find(".toggle-lock").on({
      click: this._toggleRandomizerLock.bind(this)
    });
    html.find("[data-action='randomize'").on({
      click: this._triggerRandomize.bind(this)
    });
    html.find("textarea.pc-summary-notes-body").on({
      change: this._updateGMNotesOnPC.bind(this)
    });
  }
  async _onSubmit(event, params = {}) {
    let isForcingRender = true;
    const prevPhase = this.item.system.phase;
    const submitData = await super._onSubmit(event, params);
    const newPhase = this.item.system.phase;
    if (prevPhase !== newPhase) {
      switch (prevPhase) {
        case BladesPhase.CharGen: {
          break;
        }
        case BladesPhase.Freeplay: {
          break;
        }
        case BladesPhase.Score: {
          isForcingRender = false;
          game.actors.filter((actor) => BladesActor$1.IsType(actor, BladesActorType.pc)).forEach((actor) => actor.clearLoadout());
          break;
        }
        case BladesPhase.Downtime: {
          break;
        }
      }
      switch (newPhase) {
        case BladesPhase.CharGen: {
          break;
        }
        case BladesPhase.Freeplay: {
          break;
        }
        case BladesPhase.Score: {
          break;
        }
        case BladesPhase.Downtime: {
          break;
        }
      }
    }
    if (isForcingRender) {
      game.actors.filter((actor) => actor.type === BladesActorType.pc).forEach((actor) => {
        var _a2;
        return (_a2 = actor.sheet) == null ? void 0 : _a2.render();
      });
    }
    return submitData;
  }
}
class BladesScore extends BladesItem$1 {
  // #region INITIALIZATION ~
  static async Initialize() {
    Object.assign(globalThis, { BladesScore, BladesScoreSheet });
    Items.registerSheet("blades", BladesScoreSheet, { types: ["score"], makeDefault: true });
    return loadTemplates(["systems/eunos-blades/templates/items/score-sheet.hbs"]);
  }
  // #endregion
  static get Active() {
    return BladesItem$1.GetTypeWithTags(BladesItemType.score).find((score) => score.system.isActive);
  }
  static set Active(val) {
    var _a2;
    (_a2 = BladesItem$1.GetTypeWithTags(BladesItemType.score).find((score) => score.system.isActive)) == null ? void 0 : _a2.update({ "system.isActive": false }).then(() => {
      if (val) {
        val.update({ "system.isActive": true });
      }
    });
  }
  // #region BladesRoll.OppositionData Implementation
  get rollFactors() {
    const tierTotal = this.getFactorTotal(Factor.tier);
    return {
      [Factor.tier]: {
        name: "Tier",
        value: tierTotal,
        max: tierTotal,
        baseVal: tierTotal,
        display: U.romanizeNum(tierTotal),
        isActive: true,
        isPrimary: true,
        isDominant: false,
        highFavorsPC: true,
        cssClasses: "factor-gold factor-main"
      }
    };
  }
  get rollOppImg() {
    return this.img ?? "";
  }
  getFactorTotal(factor) {
    switch (factor) {
      case Factor.tier:
        return this.system.tier.value;
      case Factor.quality:
        return this.getFactorTotal(Factor.tier);
      case Factor.scale:
        return 0;
      case Factor.magnitude:
        return 0;
      default:
        return 0;
    }
  }
  // #endregion
  // #region OVERRIDES: _onUpdate
  async _onUpdate(changed, options, userId) {
    super._onUpdate(changed, options, userId);
    BladesActor$1.GetTypeWithTags(BladesActorType.pc).forEach((actor) => actor.render());
  }
  // #endregion
}
const BladesScore$1 = BladesScore;
const ItemsMap = {
  [BladesItemType.ability]: BladesItem$1,
  [BladesItemType.background]: BladesItem$1,
  [BladesItemType.clock_keeper]: BladesClockKeeper$1,
  [BladesItemType.cohort_gang]: BladesItem$1,
  [BladesItemType.cohort_expert]: BladesItem$1,
  [BladesItemType.crew_ability]: BladesItem$1,
  [BladesItemType.crew_reputation]: BladesItem$1,
  [BladesItemType.crew_playbook]: BladesItem$1,
  [BladesItemType.crew_upgrade]: BladesItem$1,
  [BladesItemType.feature]: BladesItem$1,
  [BladesItemType.gm_tracker]: BladesGMTracker$1,
  [BladesItemType.heritage]: BladesItem$1,
  [BladesItemType.gear]: BladesItem$1,
  [BladesItemType.playbook]: BladesItem$1,
  [BladesItemType.preferred_op]: BladesItem$1,
  [BladesItemType.stricture]: BladesItem$1,
  [BladesItemType.vice]: BladesItem$1,
  [BladesItemType.project]: BladesProject$1,
  [BladesItemType.ritual]: BladesItem$1,
  [BladesItemType.design]: BladesItem$1,
  [BladesItemType.location]: BladesLocation,
  [BladesItemType.score]: BladesScore$1
};
const BladesItemProxy = new Proxy(function() {
}, {
  construct(_, args) {
    const [{ type }] = args;
    if (!type) {
      throw new Error(`Invalid Item Type: ${String(type)}`);
    }
    const MappedConstructor = ItemsMap[type];
    if (!MappedConstructor) {
      return new BladesItem$1(...args);
    }
    return new MappedConstructor(...args);
  },
  get(_, prop) {
    switch (prop) {
      case "create":
      case "createDocuments":
        return function(data, options = {}) {
          if (U.isArray(data)) {
            return data.map((i) => CONFIG.Item.documentClass.create(i, options));
          }
          const MappedConstructor = ItemsMap[data.type];
          if (!MappedConstructor) {
            return BladesItem$1.create(data, options);
          }
          return MappedConstructor.create(data, options);
        };
      case Symbol.hasInstance:
        return function(instance) {
          return Object.values(ItemsMap).some((i) => instance instanceof i);
        };
      default:
        return BladesItem$1[prop];
    }
  }
});
var BladesActorUniqueTags = ((BladesActorUniqueTags2) => {
  BladesActorUniqueTags2[BladesActorUniqueTags2["CharacterCrew"] = Tag.PC.CharacterCrew] = "CharacterCrew";
  BladesActorUniqueTags2[BladesActorUniqueTags2["VicePurveyor"] = Tag.NPC.VicePurveyor] = "VicePurveyor";
  return BladesActorUniqueTags2;
})(BladesActorUniqueTags || {});
var BladesItemUniqueTypes = ((BladesItemUniqueTypes2) => {
  BladesItemUniqueTypes2[BladesItemUniqueTypes2["background"] = BladesItemType.background] = "background";
  BladesItemUniqueTypes2[BladesItemUniqueTypes2["vice"] = BladesItemType.vice] = "vice";
  BladesItemUniqueTypes2[BladesItemUniqueTypes2["crew_playbook"] = BladesItemType.crew_playbook] = "crew_playbook";
  BladesItemUniqueTypes2[BladesItemUniqueTypes2["crew_reputation"] = BladesItemType.crew_reputation] = "crew_reputation";
  BladesItemUniqueTypes2[BladesItemUniqueTypes2["heritage"] = BladesItemType.heritage] = "heritage";
  BladesItemUniqueTypes2[BladesItemUniqueTypes2["playbook"] = BladesItemType.playbook] = "playbook";
  BladesItemUniqueTypes2[BladesItemUniqueTypes2["preferred_op"] = BladesItemType.preferred_op] = "preferred_op";
  return BladesItemUniqueTypes2;
})(BladesItemUniqueTypes || {});
class BladesActor extends Actor {
  constructor() {
    super(...arguments);
    // #endregion
    // #region BladesSubActor Implementation ~
    __publicField(this, "parentActor");
  }
  // #region Static Overrides: Create ~
  static async create(data, options = {}) {
    data.token = data.token || {};
    data.system = data.system ?? {};
    data.system.world_name = data.system.world_name ?? data.name.replace(/[^A-Za-z_0-9 ]/g, "").trim().replace(/ /g, "_");
    return await super.create(data, options);
  }
  // #endregion
  // #region BladesDocument Implementation ~
  static get All() {
    return game.actors;
  }
  static Get(actorRef) {
    if (actorRef instanceof BladesActor) {
      return actorRef;
    }
    if (U.isDocID(actorRef)) {
      return BladesActor.All.get(actorRef);
    }
    return BladesActor.All.find((a) => a.system.world_name === actorRef) || BladesActor.All.find((a) => a.name === actorRef);
  }
  static GetTypeWithTags(docType, ...tags) {
    return BladesActor.All.filter((actor) => actor.type === docType).filter((actor) => actor.hasTag(...tags));
  }
  static IsType(doc, ...types) {
    const typeSet = new Set(types);
    return doc instanceof BladesActor && typeSet.has(doc.type);
  }
  get tags() {
    return this.system.tags ?? [];
  }
  hasTag(...tags) {
    return tags.every((tag) => this.tags.includes(tag));
  }
  async addTag(...tags) {
    const curTags = this.tags;
    tags.forEach((tag) => {
      if (curTags.includes(tag)) {
        return;
      }
      curTags.push(tag);
    });
    eLog.checkLog2("actor", "BladesActor.addTag(...tags)", { tags, curTags });
    await this.update({ "system.tags": curTags });
  }
  async remTag(...tags) {
    const curTags = this.tags.filter((tag) => !tags.includes(tag));
    eLog.checkLog2("actor", "BladesActor.remTag(...tags)", { tags, curTags });
    await this.update({ "system.tags": curTags });
  }
  get tooltip() {
    const tooltipText = [this.system.concept, this.system.subtitle].filter(Boolean).join("<br><br>");
    return tooltipText ? new Handlebars.SafeString(tooltipText).toString() : void 0;
  }
  get dialogCSSClasses() {
    return "";
  }
  getFactorTotal(factor) {
    var _a2;
    switch (factor) {
      case Factor.tier: {
        if (BladesActor.IsType(this, BladesActorType.pc)) {
          return this.system.tier.value + (((_a2 = this.crew) == null ? void 0 : _a2.getFactorTotal(Factor.tier)) ?? 0);
        }
        return this.system.tier.value;
      }
      case Factor.quality:
        return this.getFactorTotal(Factor.tier);
      case Factor.scale: {
        if (BladesActor.IsType(this, BladesActorType.npc)) {
          return this.system.scale;
        }
        return 0;
      }
      case Factor.magnitude: {
        if (BladesActor.IsType(this, BladesActorType.npc)) {
          return this.system.magnitude;
        }
        return 0;
      }
      default:
        return 0;
    }
  }
  // #endregion
  // #region SubActorControl Implementation ~
  get subActors() {
    return Object.keys(this.system.subactors).map((id) => this.getSubActor(id)).filter((subActor) => Boolean(subActor));
  }
  get activeSubActors() {
    return this.subActors.filter((subActor) => !subActor.hasTag(Tag.System.Archived));
  }
  get archivedSubActors() {
    return this.subActors.filter((subActor) => subActor.hasTag(Tag.System.Archived));
  }
  checkActorPrereqs(actor) {
    return Boolean(actor);
  }
  processEmbeddedActorMatches(globalActors) {
    return globalActors.filter(this.checkActorPrereqs).filter((gActor) => !this.activeSubActors.some((aActor) => aActor.id === gActor.id)).map((gActor) => this.getSubActor(gActor) || gActor).sort((a, b) => {
      if (a.name === b.name) {
        return 0;
      }
      if (a.name === null) {
        return 1;
      }
      if (b.name === null) {
        return -1;
      }
      if (a.name > b.name) {
        return 1;
      }
      if (a.name < b.name) {
        return -1;
      }
      return 0;
    });
  }
  getDialogActors(category) {
    var _a2;
    const dialogData = {};
    switch (category) {
      case SelectionCategory.Contact:
      case SelectionCategory.Rival:
      case SelectionCategory.Friend:
      case SelectionCategory.Acquaintance: {
        if (!BladesActor.IsType(this, BladesActorType.pc, BladesActorType.crew) || this.playbookName === null) {
          return false;
        }
        dialogData.Main = this.processEmbeddedActorMatches(
          BladesActor.GetTypeWithTags(BladesActorType.npc, this.playbookName)
        );
        return dialogData;
      }
      case SelectionCategory.VicePurveyor: {
        if (!BladesActor.IsType(this, BladesActorType.pc) || !((_a2 = this.vice) == null ? void 0 : _a2.name)) {
          return false;
        }
        dialogData.Main = this.processEmbeddedActorMatches(
          BladesActor.GetTypeWithTags(BladesActorType.npc, this.vice.name)
        );
        return dialogData;
      }
      case SelectionCategory.Crew: {
        dialogData.Main = BladesActor.GetTypeWithTags(BladesActorType.crew);
        return dialogData;
      }
      default:
        return false;
    }
  }
  async addSubActor(actorRef, tags) {
    let focusSubActor;
    if (this.hasSubActorOf(actorRef)) {
      const subActor = this.getSubActor(actorRef);
      if (!subActor) {
        return;
      }
      if (subActor.hasTag(Tag.System.Archived)) {
        await subActor.remTag(Tag.System.Archived);
      }
      focusSubActor = subActor;
    } else {
      const actor = BladesActor.Get(actorRef);
      if (!actor) {
        return;
      }
      const subActorData = {};
      if (tags) {
        subActorData.tags = U.unique([
          ...actor.tags,
          ...tags
        ]);
      }
      await this.update({ [`system.subactors.${actor.id}`]: subActorData });
      focusSubActor = this.getSubActor(actor.id);
    }
    if (!focusSubActor) {
      return;
    }
    const uniqueTags = focusSubActor.tags.filter((tag) => tag in BladesActorUniqueTags);
    if (uniqueTags.length > 0) {
      uniqueTags.forEach((uTag) => this.activeSubActors.filter(
        (subActor) => Boolean((focusSubActor == null ? void 0 : focusSubActor.id) && subActor.id !== focusSubActor.id && subActor.hasTag(uTag))
      ).map((subActor) => this.remSubActor(subActor.id)));
    }
  }
  getSubActor(actorRef) {
    const actor = BladesActor.Get(actorRef);
    if (!(actor == null ? void 0 : actor.id)) {
      return void 0;
    }
    if (!BladesActor.IsType(actor, BladesActorType.npc, BladesActorType.faction)) {
      return actor;
    }
    const subActorData = this.system.subactors[actor.id] ?? {};
    Object.assign(
      actor.system,
      subActorData
    );
    actor.parentActor = this;
    return actor;
  }
  hasSubActorOf(actorRef) {
    const actor = BladesActor.Get(actorRef);
    if (!actor) {
      return false;
    }
    return (actor == null ? void 0 : actor.id) ? actor.id in this.system.subactors : false;
  }
  async updateSubActor(actorRef, upData) {
    const updateData = U.objExpand(upData);
    if (!updateData.system) {
      return void 0;
    }
    const actor = BladesActor.Get(actorRef);
    if (!actor) {
      return void 0;
    }
    const diffUpdateSystem = U.objDiff(actor.system, updateData.system);
    const mergedSubActorSystem = U.objMerge(
      this.system.subactors[actor.id] ?? {},
      diffUpdateSystem,
      { isReplacingArrays: true, isConcatenatingArrays: false }
    );
    if (JSON.stringify(this.system.subactors[actor.id]) === JSON.stringify(mergedSubActorSystem)) {
      return void 0;
    }
    return this.update({ [`system.subactors.${actor.id}`]: null }, void 0, true).then(() => this.update({ [`system.subactors.${actor.id}`]: mergedSubActorSystem }, void 0, true)).then(() => {
      var _a2;
      return (_a2 = actor.sheet) == null ? void 0 : _a2.render();
    });
  }
  async remSubActor(actorRef) {
    const subActor = this.getSubActor(actorRef);
    if (!subActor) {
      return;
    }
    await this.update({ "system.subactors": mergeObject(this.system.subactors, { [`-=${subActor.id}`]: null }) }, void 0, true);
  }
  async clearSubActors(isReRendering = true) {
    var _a2;
    this.subActors.forEach((subActor) => {
      var _a3;
      if (((_a3 = subActor.parentActor) == null ? void 0 : _a3.id) === this.id) {
        subActor.clearParentActor(isReRendering);
      }
    });
    await ((_a2 = this.sheet) == null ? void 0 : _a2.render());
  }
  async clearParentActor(isReRendering = true) {
    var _a2;
    const { parentActor } = this;
    if (!parentActor) {
      return;
    }
    this.parentActor = void 0;
    this.system = this._source.system;
    this.ownership = this._source.ownership;
    this.prepareData();
    if (isReRendering) {
      await ((_a2 = this.sheet) == null ? void 0 : _a2.render());
    }
  }
  // #endregion
  // #region SubItemControl Implementation ~
  get subItems() {
    return Array.from(this.items);
  }
  getSubItemsOfType(itemType) {
    return this.items.filter((item) => item.type === itemType);
  }
  get activeSubItems() {
    return this.items.filter((item) => !item.hasTag(Tag.System.Archived));
  }
  get archivedSubItems() {
    return this.items.filter((item) => item.hasTag(Tag.System.Archived));
  }
  _checkItemPrereqs(item) {
    if (!item.system.prereqs) {
      return true;
    }
    for (const [pType, pReqs] of Object.entries(
      item.system.prereqs
    )) {
      const pReqArray = Array.isArray(pReqs) ? pReqs : [pReqs.toString()];
      const hitRecord = {};
      if (!this._processPrereqArray(pReqArray, pType, hitRecord)) {
        return false;
      }
    }
    return true;
  }
  _processPrereqArray(pReqArray, pType, hitRecord) {
    while (pReqArray.length) {
      const pString = pReqArray.pop();
      hitRecord[pType] ?? (hitRecord[pType] = []);
      if (!this._processPrereqType(pType, pString, hitRecord)) {
        return false;
      }
    }
    return true;
  }
  _processPrereqType(pType, pString, hitRecord) {
    switch (pType) {
      case PrereqType.HasActiveItem: {
        return this._processActiveItemPrereq(pString, hitRecord, pType);
      }
      case PrereqType.HasActiveItemsByTag: {
        return this._processActiveItemsByTagPrereq(pString, hitRecord, pType);
      }
      case PrereqType.AdvancedPlaybook: {
        return this._processAdvancedPlaybookPrereq();
      }
      default:
        return true;
    }
  }
  _processActiveItemPrereq(pString, hitRecord, pType) {
    var _a2;
    const thisItem = this.activeSubItems.filter((i) => {
      var _a3;
      return !((_a3 = hitRecord[pType]) == null ? void 0 : _a3.includes(i.id));
    }).find((i) => i.system.world_name === pString);
    if (thisItem) {
      (_a2 = hitRecord[pType]) == null ? void 0 : _a2.push(thisItem.id);
      return true;
    } else {
      return false;
    }
  }
  _processActiveItemsByTagPrereq(pString, hitRecord, pType) {
    var _a2;
    const thisItem = this.activeSubItems.filter((i) => {
      var _a3;
      return !((_a3 = hitRecord[pType]) == null ? void 0 : _a3.includes(i.id));
    }).find((i) => i.hasTag(pString));
    if (thisItem) {
      (_a2 = hitRecord[pType]) == null ? void 0 : _a2.push(thisItem.id);
      return true;
    } else {
      return false;
    }
  }
  _processAdvancedPlaybookPrereq() {
    if (!BladesActor.IsType(this, BladesActorType.pc)) {
      return false;
    }
    if (!this.playbookName || ![Playbook.Ghost, Playbook.Hull, Playbook.Vampire].includes(this.playbookName)) {
      return false;
    }
    return true;
  }
  _processEmbeddedItemMatches(globalItems) {
    return globalItems.filter((item) => this._checkItemPrereqs(item)).filter((gItem) => gItem.hasTag(Tag.System.MultiplesOK) || (gItem.system.max_per_score ?? 1) > this.activeSubItems.filter((sItem) => sItem.system.world_name === gItem.system.world_name).length).map((gItem) => {
      const matchingSubItems = this.archivedSubItems.filter((sItem) => sItem.system.world_name === gItem.system.world_name);
      if (matchingSubItems.length > 0) {
        return matchingSubItems;
      } else {
        return gItem;
      }
    }).flat().map((sItem) => {
      sItem.dialogCSSClasses = "";
      const cssClasses = [];
      if (sItem.isEmbedded) {
        cssClasses.push("embedded");
      }
      if (sItem.hasTag(Tag.Gear.Fine)) {
        cssClasses.push("fine-quality");
      }
      if (sItem.hasTag(Tag.System.Featured)) {
        cssClasses.push("featured-item");
      }
      if ([BladesItemType.ability, BladesItemType.crew_ability].includes(sItem.type)) {
        if (this.getAvailableAdvancements("Ability") === 0) {
          cssClasses.push("locked");
        } else if ((sItem.system.price ?? 1) > this.getAvailableAdvancements("Ability")) {
          cssClasses.push("locked", "unaffordable");
        } else if ((sItem.system.price ?? 1) > 1) {
          cssClasses.push("expensive");
        }
      }
      if ([BladesItemType.crew_upgrade].includes(sItem.type)) {
        if (this.getAvailableAdvancements("Upgrade") === 0) {
          cssClasses.push("locked");
        } else if ((sItem.system.price ?? 1) > this.getAvailableAdvancements("Upgrade")) {
          cssClasses.push("locked", "unaffordable");
        } else if ((sItem.system.price ?? 1) > 1) {
          cssClasses.push("expensive");
        }
      }
      if (cssClasses.length > 0) {
        sItem.dialogCSSClasses = cssClasses.join(" ");
      }
      return sItem;
    }).sort((a, b) => {
      if (a.hasTag(Tag.System.Featured) && !b.hasTag(Tag.System.Featured)) {
        return -1;
      }
      if (!a.hasTag(Tag.System.Featured) && b.hasTag(Tag.System.Featured)) {
        return 1;
      }
      if (a.hasTag(Tag.Gear.Fine) && !b.hasTag(Tag.Gear.Fine)) {
        return -1;
      }
      if (!a.hasTag(Tag.Gear.Fine) && b.hasTag(Tag.Gear.Fine)) {
        return 1;
      }
      if (a.system.world_name > b.system.world_name) {
        return 1;
      }
      if (a.system.world_name < b.system.world_name) {
        return -1;
      }
      if (a.isEmbedded && !b.isEmbedded) {
        return -1;
      }
      if (!a.isEmbedded && b.isEmbedded) {
        return 1;
      }
      if (a.name === b.name) {
        return 0;
      }
      if (a.name === null) {
        return 1;
      }
      if (b.name === null) {
        return -1;
      }
      if (a.name > b.name) {
        return 1;
      }
      if (a.name < b.name) {
        return -1;
      }
      return 0;
    });
  }
  getSubItem(itemRef, activeOnly = false) {
    const activeCheck = (i) => !activeOnly || !i.hasTag(Tag.System.Archived);
    if (typeof itemRef === "string" && this.items.get(itemRef)) {
      const returnItem = this.items.get(itemRef);
      if (returnItem && activeCheck(returnItem)) {
        return returnItem;
      } else {
        return void 0;
      }
    } else {
      const globalItem = BladesItem$1.Get(itemRef);
      if (!globalItem) {
        return void 0;
      }
      return this.items.find((item) => item.name === globalItem.name && activeCheck(item)) ?? this.items.find((item) => item.system.world_name === globalItem.system.world_name && activeCheck(item));
    }
  }
  hasSubItemOf(itemRef) {
    const item = BladesItem$1.Get(itemRef);
    if (!item) {
      return false;
    }
    return Boolean(this.items.find((i) => i.system.world_name === item.system.world_name));
  }
  hasActiveSubItemOf(itemRef) {
    const item = BladesItem$1.Get(itemRef);
    if (!item) {
      return false;
    }
    return Boolean(this.items.find((i) => !i.hasTag(Tag.System.Archived) && i.system.world_name === item.system.world_name));
  }
  async addSubItem(itemRef) {
    function isBladesItemUniqueTypes(type) {
      return Object.values(BladesItemUniqueTypes).includes(type);
    }
    eLog.checkLog3("subitems", "[addSubItem] itemRef", itemRef);
    let focusItem;
    const embeddedItem = this.getSubItem(itemRef);
    if (embeddedItem) {
      if (embeddedItem.hasTag(Tag.System.Archived)) {
        await embeddedItem.remTag(Tag.System.Archived);
        focusItem = embeddedItem;
        eLog.checkLog3("subitems", `[addSubItem] IS ARCHIVED EMBEDDED > Removing 'Archived' Tag, '${focusItem.id}':`, focusItem);
      } else {
        focusItem = await BladesItem$1.create(
          [embeddedItem],
          { parent: this }
        );
        eLog.checkLog3("subitems", `[addSubItem] IS ACTIVE EMBEDDED > Duplicating, focusItem '${focusItem.id}':`, focusItem);
      }
    } else {
      const globalItem = BladesItem$1.Get(itemRef);
      eLog.checkLog3("subitems", `[addSubItem] IS NOT EMBEDDED > Fetching Global, globalItem '${globalItem == null ? void 0 : globalItem.id}':`, globalItem);
      if (!globalItem) {
        return;
      }
      focusItem = await BladesItem$1.create(
        [globalItem],
        { parent: this }
      );
      focusItem = this.items.getName(globalItem.name);
    }
    if (focusItem && isBladesItemUniqueTypes(focusItem.type)) {
      await Promise.all(this.activeSubItems.filter((subItem) => subItem.type === (focusItem == null ? void 0 : focusItem.type) && subItem.system.world_name !== (focusItem == null ? void 0 : focusItem.system.world_name) && !subItem.hasTag(Tag.System.Archived)).map(this.remSubItem.bind(this)));
    }
  }
  async remSubItem(itemRef) {
    const subItem = this.getSubItem(itemRef);
    if (!subItem) {
      return;
    }
    if (subItem.type !== BladesItemType.gear) {
      this.purgeSubItem(itemRef);
      return;
    }
    eLog.checkLog("actorTrigger", `Removing SubItem ${subItem.name}`, subItem);
    if (subItem.hasTag(Tag.System.Archived)) {
      return;
    }
    await subItem.addTag(Tag.System.Archived);
  }
  async purgeSubItem(itemRef) {
    const subItem = this.getSubItem(itemRef);
    if (!subItem || subItem.hasTag(Tag.System.Archived)) {
      return;
    }
    await subItem.delete();
  }
  // #endregion
  // #region Advancement Implementation ~
  // get totalAbilityPoints(): number {
  //   if (!BladesActor.IsType(this, BladesActorType.pc, BladesActorType.crew)) { return 0 }
  //   if (!this.playbook) { return 0 }
  //   switch (this.type) {
  //     case BladesActorType.pc: return this.system.advancement.ability ?? 0;
  //     case BladesActorType.crew: return Math.floor(0.5 * (this.system.advancement.general ?? 0))
  //      + (this.system.advancement.ability ?? 0);
  //     default: return 0;
  //   }
  // }
  // get spentAbilityPoints(): number {
  //   if (!BladesActor.IsType(this, BladesActorType.pc, BladesActorType.crew)) { return 0 }
  //   if (!this.playbook) { return 0 }
  //   return this.abilities.reduce((total, ability) => total + (ability.system.price ?? 1), 0);
  // }
  // get getAvailableAdvancements("Ability")(): number {
  //   if (!BladesActor.IsType(this, BladesActorType.pc, BladesActorType.crew)) { return 0 }
  //   if (!this.playbook) { return 0 }
  //   return this.totalAbilityPoints - this.spentAbilityPoints;
  // }
  /* Need simple getters for total ability & upgrade points that check for PRICES of items
        (upgrade.system.price ?? 1) */
  async grantAdvancementPoints(allowedTypes, amount = 1) {
    var _a2;
    const aPtKey = Array.isArray(allowedTypes) ? [...allowedTypes].sort((a, b) => a.localeCompare(b)).join("_") : allowedTypes;
    await this.update({ [`system.advancement_points.${aPtKey}`]: (((_a2 = this.system.advancement_points) == null ? void 0 : _a2[aPtKey]) ?? 0) + amount });
  }
  async removeAdvancementPoints(allowedTypes, amount = 1) {
    var _a2;
    const aPtKey = Array.isArray(allowedTypes) ? [...allowedTypes].sort((a, b) => a.localeCompare(b)).join("_") : allowedTypes;
    const newCount = ((_a2 = this.system.advancement_points) == null ? void 0 : _a2[aPtKey]) ?? 0 - amount;
    if (newCount <= 0 && aPtKey in (this.system.advancement_points ?? [])) {
      await this.update({ [`system.advancement_points.-=${aPtKey}`]: null });
    } else {
      await this.update({ [`system.advancement_points.${aPtKey}`]: newCount });
    }
  }
  getAvailableAdvancements(trait) {
    var _a2, _b, _c, _d, _e;
    if (!BladesActor.IsType(this, BladesActorType.pc, BladesActorType.crew)) {
      return 0;
    }
    if (trait in ActionTrait) {
      return 1;
    }
    if (trait === "Cohort") {
      const pointsCohort = ((_a2 = this.system.advancement_points) == null ? void 0 : _a2[AdvancementPoint.Cohort]) ?? 0;
      const spentCohort = this.cohorts.length;
      return Math.max(0, pointsCohort - spentCohort);
    }
    const pointsAbility = ((_b = this.system.advancement_points) == null ? void 0 : _b[AdvancementPoint.Ability]) ?? 0;
    const pointsCohortType = ((_c = this.system.advancement_points) == null ? void 0 : _c[AdvancementPoint.CohortType]) ?? 0;
    const pointsUpgrade = ((_d = this.system.advancement_points) == null ? void 0 : _d[AdvancementPoint.Upgrade]) ?? 0;
    const pointsUpgradeOrAbility = ((_e = this.system.advancement_points) == null ? void 0 : _e[AdvancementPoint.UpgradeOrAbility]) ?? 0;
    const spentAbility = U.sum(this.items.filter((item) => BladesItem$1.IsType(item, BladesItemType.ability, BladesItemType.crew_ability)).map((abil) => abil.system.price ?? 1));
    const spentCohortType = U.sum(
      this.cohorts.map((cohort) => Math.max(0, U.unique(Object.values(cohort.system.subtypes)).length - 1))
    );
    const spentUpgrade = U.sum(this.items.filter((item) => BladesItem$1.IsType(item, BladesItemType.crew_upgrade)).map((upgrade) => upgrade.system.price ?? 1));
    const excessUpgrade = Math.max(0, spentUpgrade - pointsUpgrade);
    const excessCohortType = Math.max(0, spentCohortType - pointsCohortType);
    const excessAbility = Math.max(0, spentAbility - pointsAbility);
    const remainingAbility = Math.max(0, pointsAbility - spentAbility);
    const remainingCohortType = Math.max(0, pointsCohortType - spentCohortType);
    const remainingUpgrade = Math.max(0, pointsUpgrade - spentUpgrade);
    const remainingUpgradeOrAbility = Math.max(
      0,
      pointsUpgradeOrAbility - excessUpgrade - 2 * excessAbility - 2 * excessCohortType
    );
    if (trait === "Ability") {
      return remainingAbility + Math.floor(0.5 * remainingUpgradeOrAbility);
    }
    if (trait === "Upgrade") {
      return remainingUpgrade + remainingUpgradeOrAbility;
    }
    if (trait === "CohortType") {
      return remainingCohortType + remainingUpgradeOrAbility;
    }
    return 0;
  }
  get availableAbilityPoints() {
    return this.getAvailableAdvancements("Ability");
  }
  get availableUpgradePoints() {
    return this.getAvailableAdvancements("Upgrade");
  }
  get availableCohortPoints() {
    return this.getAvailableAdvancements("Cohort");
  }
  get availableCohortTypePoints() {
    return this.getAvailableAdvancements("CohortType");
  }
  get canPurchaseAbility() {
    return this.availableAbilityPoints > 0;
  }
  get canPurchaseUpgrade() {
    return this.availableUpgradePoints > 0;
  }
  get canPurchaseCohort() {
    return this.availableCohortPoints > 0;
  }
  get canPurchaseCohortType() {
    return this.availableCohortTypePoints > 0;
  }
  async advancePlaybook() {
    if (!BladesActor.IsType(this, BladesActorType.pc, BladesActorType.crew) || !this.playbook) {
      return;
    }
    await this.update({ "system.experience.playbook.value": 0 });
    if (this instanceof BladesPC$1) {
      BladesDirector.getInstance().pushNotice_SocketCall(
        "ALL",
        {
          title: `${this.name} Advances their Playbook!`,
          body: `${this.name}, select a new Ability on your Character Sheet.`,
          type: BladesNoticeType.push,
          cssClasses: "advancement-alert"
        }
      );
      this.grantAdvancementPoints(AdvancementPoint.Ability);
      return;
    }
    if (this instanceof BladesCrew$1) {
      BladesDirector.getInstance().pushNotice_SocketCall(
        "ALL",
        {
          title: "You Advance your Crew Playbook!",
          body: "Select new Upgrades and/or Abilities on your Crew Sheet.",
          type: BladesNoticeType.push,
          cssClasses: "advancement-alert crew-advancement-alert"
        }
      );
      const coinGained = this.system.tier.value + 2;
      this.members.forEach((member) => {
        var _a2, _b;
        if ((_a2 = member.primaryUser) == null ? void 0 : _a2.id) {
          BladesDirector.getInstance().pushNotice_SocketCall(
            (_b = member.primaryUser) == null ? void 0 : _b.id,
            {
              title: "Your Stash Increases! <em>(Crew Advancement)</em>",
              type: BladesNoticeType.push,
              body: `You gain ${coinGained} Stash from Crew Advancement.`,
              cssClasses: "stash-alert"
            }
          );
          member.addStash(coinGained);
        }
      });
      this.grantAdvancementPoints(AdvancementPoint.UpgradeOrAbility, 2);
    }
  }
  async advanceAttribute(attribute) {
    var _a2;
    if (!(this instanceof BladesPC$1)) {
      return;
    }
    if (!((_a2 = this.primaryUser) == null ? void 0 : _a2.id)) {
      return;
    }
    await this.update({ [`system.experience.${attribute}.value`]: 0 });
    const actions = C.Action[attribute].map((action) => `<strong>${U.tCase(action)}</strong>`);
    BladesDirector.getInstance().pushNotice_SocketCall(
      this.primaryUser.id,
      {
        title: `${this.name} Advances their ${U.uCase(attribute)}!`,
        body: `${this.name}, add a dot to one of ${U.oxfordize(actions, true, "or")}.`,
        type: BladesNoticeType.push,
        cssClasses: "advancement-alert"
      }
    );
  }
  get isAtWar() {
    var _a2;
    if (BladesNPC$1.IsType(this)) {
      return false;
    }
    if (BladesPC$1.IsType(this)) {
      return ((_a2 = this.crew) == null ? void 0 : _a2.isAtWar) ?? false;
    }
    return Object.values(this.system.at_war_with ?? {}).filter((val) => val === true).length > 0;
  }
  get isSubActor() {
    return this.parentActor !== void 0;
  }
  // #endregion
  // #region BladesRoll Implementation ~
  get rollPrimaryModsSchemaSet() {
    return BladesRollMod.ParseDocModsToSchemaSet(this);
  }
  get rollFactors() {
    const factorData = {
      [Factor.tier]: {
        name: Factor.tier,
        display: "Tier",
        value: this.getFactorTotal(Factor.tier),
        max: this.getFactorTotal(Factor.tier),
        baseVal: this.getFactorTotal(Factor.tier),
        isActive: true,
        isPrimary: true,
        isDominant: false,
        highFavorsPC: true
      },
      [Factor.quality]: {
        name: Factor.quality,
        display: "Quality",
        value: this.getFactorTotal(Factor.quality),
        max: this.getFactorTotal(Factor.quality),
        baseVal: this.getFactorTotal(Factor.quality),
        isActive: false,
        isPrimary: false,
        isDominant: false,
        highFavorsPC: true
      }
    };
    return factorData;
  }
  // #region BladesRoll.PrimaryDoc Implementation
  get rollPrimaryID() {
    return this.id;
  }
  get rollPrimaryDoc() {
    return this;
  }
  get rollPrimaryName() {
    return this.name;
  }
  get rollPrimaryType() {
    if (![BladesActorType.pc, BladesActorType.crew].includes(this.type)) {
      throw new Error(`BladesActor of type '${this.type}' ("${this.name}") cannot be RollPrimary.`);
    }
    return this.type;
  }
  get rollPrimaryImg() {
    return this.img;
  }
  // #endregion
  // #endregion
  // #region BladesCrew Implementation ~
  // #endregion
  // #region PREPARING DERIVED DATA ~
  prepareDerivedData() {
    if (BladesActor.IsType(this, BladesActorType.pc)) {
      this._preparePCData(this.system);
    }
    if (BladesActor.IsType(this, BladesActorType.crew)) {
      this._prepareCrewData(this.system);
    }
  }
  _preparePCData(system) {
    if (!BladesActor.IsType(this, BladesActorType.pc)) {
      return;
    }
    if (this.playbook) {
      system.experience.clues = [
        ...system.experience.clues,
        ...Object.values(this.playbook.system.experience_clues).filter((clue) => Boolean(clue.trim()))
      ];
    }
    if (this.playbook) {
      system.gather_info = [
        ...system.gather_info,
        ...Object.values(this.playbook.system.gather_info_questions).filter((question) => Boolean(question.trim()))
      ];
    }
  }
  _prepareCrewData(system) {
    if (!BladesActor.IsType(this, BladesActorType.crew)) {
      return;
    }
    if (this.playbook) {
      system.experience.clues = [
        ...system.experience.clues,
        ...Object.values(this.playbook.system.experience_clues).filter((clue) => Boolean(clue.trim()))
      ];
      system.turfs = this.playbook.system.turfs;
    }
  }
  // #endregion
  // #region OVERRIDES: _onCreateDescendantDocuments, update ~
  // @ts-expect-error New method not defined in @league VTT types.
  async _onCreateDescendantDocuments(parent, collection, docs, data, options, userId) {
    await Promise.all(docs.map(async (doc) => {
      if (BladesItem$1.IsType(doc, BladesItemType.playbook, BladesItemType.crew_playbook)) {
        await Promise.all(this.activeSubItems.filter((aItem) => aItem.type === doc.type && aItem.system.world_name !== doc.system.world_name).map((aItem) => this.remSubItem(aItem)));
      }
    }));
    await super._onCreateDescendantDocuments(parent, collection, docs, data, options, userId);
    eLog.checkLog("actorTrigger", "_onCreateDescendantDocuments", { parent, collection, docs, data, options, userId });
    docs.forEach((doc) => {
      if (BladesItem$1.IsType(doc, BladesItemType.vice) && BladesActor.IsType(this, BladesActorType.pc)) {
        this.activeSubActors.filter((subActor) => subActor.hasTag(Tag.NPC.VicePurveyor) && !subActor.hasTag(doc.name)).forEach((subActor) => {
          this.remSubActor(subActor);
        });
      }
    });
  }
  async update(updateData, context3, isSkippingSubActorCheck = false) {
    if (!updateData) {
      return super.update(updateData);
    }
    if (BladesActor.IsType(this, BladesActorType.crew)) {
      if (!this.playbook) {
        return void 0;
      }
      eLog.checkLog("actorTrigger", "Updating Crew", { updateData });
      const playbookUpdateData = Object.fromEntries(
        Object.entries(flattenObject(updateData)).filter(([key, _]) => key.startsWith("system.turfs."))
      );
      updateData = Object.fromEntries(Object.entries(flattenObject(updateData)).filter(([key, _]) => !key.startsWith("system.turfs.")));
      eLog.checkLog("actorTrigger", "Updating Crew", { crewUpdateData: updateData, playbookUpdateData });
      const diffPlaybookData = diffObject(
        flattenObject(this.playbook),
        playbookUpdateData
      );
      delete diffPlaybookData._id;
      if (!U.isEmpty(diffPlaybookData)) {
        await this.playbook.update(playbookUpdateData, context3).then(() => {
          var _a2;
          return (_a2 = this.sheet) == null ? void 0 : _a2.render(false);
        });
      }
    } else if ((BladesActor.IsType(this, BladesActorType.npc) || BladesActor.IsType(this, BladesActorType.faction)) && this.parentActor && !isSkippingSubActorCheck) {
      return this.parentActor.updateSubActor(this.id, updateData).then(() => this);
    }
    return super.update(updateData, context3);
  }
  // #endregion
  // #region Rolling Dice ~
  /**
   * Creates <options> modifiers for dice roll.
   *
   * @param {int} rs
   *  Min die modifier
   * @param {int} re
   *  Max die modifier
   * @param {int} s
   *  Selected die
   */
  createListOfDiceMods(rs, re, s) {
    let text = "";
    if (s === "") {
      s = 0;
    }
    for (let i = rs; i <= re; i++) {
      let plus = "";
      if (i >= 0) {
        plus = "+";
      }
      text += `<option value="${i}"`;
      if (i === s) {
        text += " selected";
      }
      text += `>${plus}${i}d</option>`;
    }
    return text;
  }
  // #endregion Rolling Dice
  // #region NPC Randomizers ~
  updateRandomizers() {
    if (!BladesActor.IsType(this, BladesActorType.npc)) {
      return;
    }
    const titleChance = 0.05;
    const suffixChance = 0.01;
    const { persona, secret, random: random3 } = this.system;
    function sampleArray(arr, ...curVals) {
      arr = arr.filter((elem) => !curVals.includes(elem));
      if (!arr.length) {
        return "";
      }
      return arr[Math.floor(Math.random() * arr.length)];
    }
    const randomGen = {
      name: (gen) => {
        return [
          Math.random() <= titleChance ? sampleArray(Randomizers.NPC.name_title) : "",
          sampleArray([
            ...(gen ?? "").charAt(0).toLowerCase() !== "m" ? Randomizers.NPC.name_first.female : [],
            ...(gen ?? "").charAt(0).toLowerCase() !== "f" ? Randomizers.NPC.name_first.male : []
          ]),
          `"${sampleArray(Randomizers.NPC.name_alias)}"`,
          sampleArray(Randomizers.NPC.name_surname),
          Math.random() <= suffixChance ? sampleArray(Randomizers.NPC.name_suffix) : ""
        ].filter((val) => Boolean(val)).join(" ");
      },
      background: () => sampleArray(Randomizers.NPC.background, random3.background.value),
      heritage: () => sampleArray(Randomizers.NPC.heritage, random3.heritage.value),
      profession: () => sampleArray(Randomizers.NPC.profession, random3.profession.value),
      gender: () => sampleArray(Randomizers.NPC.gender, persona.gender.value),
      appearance: () => sampleArray(Randomizers.NPC.appearance, persona.appearance.value),
      goal: () => sampleArray(Randomizers.NPC.goal, persona.goal.value, secret.goal.value),
      method: () => sampleArray(Randomizers.NPC.method, persona.method.value, secret.method.value),
      trait: () => sampleArray(
        Randomizers.NPC.trait,
        persona.trait1.value,
        persona.trait2.value,
        persona.trait3.value,
        secret.trait.value
      ),
      interests: () => sampleArray(Randomizers.NPC.interests, persona.interests.value, secret.interests.value),
      quirk: () => sampleArray(Randomizers.NPC.quirk, persona.quirk.value),
      style: (gen = "") => sampleArray([
        ...gen.charAt(0).toLowerCase() !== "m" ? Randomizers.NPC.style.female : [],
        ...gen.charAt(0).toLowerCase() !== "f" ? Randomizers.NPC.style.male : []
      ], persona.style.value)
    };
    const gender = persona.gender.isLocked ? persona.gender.value : randomGen.gender();
    const updateKeys = [
      ...Object.keys(persona).filter((key) => {
        var _a2;
        return !((_a2 = persona[key]) == null ? void 0 : _a2.isLocked);
      }),
      ...Object.keys(random3).filter((key) => {
        var _a2;
        return !((_a2 = random3[key]) == null ? void 0 : _a2.isLocked);
      }),
      ...Object.keys(secret).filter((key) => {
        var _a2;
        return !((_a2 = secret[key]) == null ? void 0 : _a2.isLocked);
      }).map((secretKey) => `secret-${secretKey}`)
    ];
    eLog.checkLog("Update Keys", { updateKeys });
    const updateData = {};
    updateKeys.forEach((key) => {
      switch (key) {
        case "name":
        case "heritage":
        case "background":
        case "profession": {
          const randomVal = randomGen[key]();
          updateData[`system.random.${key}`] = {
            isLocked: false,
            value: randomVal || random3[key].value
          };
          break;
        }
        case "secret-goal":
        case "secret-interests":
        case "secret-method": {
          key = key.replace(/^secret-/, "");
          const randomVal = randomGen[key]();
          updateData[`system.secret.${key}`] = {
            isLocked: false,
            value: randomVal || secret[key].value
          };
          break;
        }
        case "gender": {
          updateData[`system.persona.${key}`] = {
            isLocked: persona.gender.isLocked,
            value: gender
          };
          break;
        }
        case "trait1":
        case "trait2":
        case "trait3":
        case "secret-trait": {
          const trait1 = persona.trait1.isLocked ? persona.trait1.value : sampleArray(
            Randomizers.NPC.trait,
            persona.trait1.value,
            persona.trait2.value,
            persona.trait3.value,
            secret.trait.value
          );
          const trait2 = persona.trait2.isLocked ? persona.trait2.value : sampleArray(
            Randomizers.NPC.trait,
            trait1,
            persona.trait1.value,
            persona.trait2.value,
            persona.trait3.value,
            secret.trait.value
          );
          const trait3 = persona.trait3.isLocked ? persona.trait3.value : sampleArray(
            Randomizers.NPC.trait,
            trait1,
            trait2,
            persona.trait1.value,
            persona.trait2.value,
            persona.trait3.value,
            secret.trait.value
          );
          const secretTrait = secret.trait.isLocked ? secret.trait.value : sampleArray(
            Randomizers.NPC.trait,
            trait1,
            trait2,
            trait3,
            persona.trait1.value,
            persona.trait2.value,
            persona.trait3.value,
            secret.trait.value
          );
          if (!persona.trait1.isLocked) {
            updateData["system.persona.trait1"] = {
              isLocked: false,
              value: trait1
            };
          }
          if (!persona.trait2.isLocked) {
            updateData["system.persona.trait2"] = {
              isLocked: false,
              value: trait2
            };
          }
          if (!persona.trait3.isLocked) {
            updateData["system.persona.trait3"] = {
              isLocked: false,
              value: trait3
            };
          }
          if (!secret.trait.isLocked) {
            updateData["system.secret.trait"] = {
              isLocked: false,
              value: secretTrait
            };
          }
          break;
        }
        default: {
          const randomVal = randomGen[key]();
          updateData[`system.persona.${key}`] = {
            isLocked: false,
            value: randomVal || persona[key].value
          };
          break;
        }
      }
    });
    this.update(updateData);
  }
  // #endregion NPC Randomizers
  // Unlock lower-level update method for subclasses
  async callOnUpdate(...args) {
    await this._onUpdate(...args);
  }
}
const BladesActor$1 = BladesActor;
class BladesActorSheet extends ActorSheet {
  /**
   * Override the default getData method to provide additional data for the actor sheet.
   * This includes: cssClass, editable, isGM, actor, system, tierTotal, rollData, activeEffects,
   *                 hasFullVision, hasLimitedVision, hasControl, preparedItems.
   * @returns {BladesActorSheetData} The data object for the actor sheet.
   */
  getData() {
    var _a2, _b;
    const context3 = super.getData();
    const sheetData = {
      // Basic actor data.
      cssClass: this.actor.type,
      editable: this.options.editable,
      isGM: ((_a2 = game.eunoblades.Tracker) == null ? void 0 : _a2.system.is_spoofing_player) ? false : game.user.isGM,
      actor: this.actor,
      system: this.actor.system,
      gamePhase: ((_b = game.eunoblades.Tracker) == null ? void 0 : _b.phase) || BladesPhase.Freeplay,
      tierTotal: this.actor.getFactorTotal(Factor.tier) > 0 ? U.romanizeNum(this.actor.getFactorTotal(Factor.tier)) : "0",
      rollData: this.actor.getRollData(),
      activeEffects: Array.from(this.actor.effects),
      hasFullVision: game.user.isGM || this.actor.testUserPermission(game.user, CONST.DOCUMENT_PERMISSION_LEVELS.OBSERVER),
      hasLimitedVision: game.user.isGM || this.actor.testUserPermission(game.user, CONST.DOCUMENT_PERMISSION_LEVELS.LIMITED),
      hasControl: game.user.isGM || this.actor.testUserPermission(game.user, CONST.DOCUMENT_PERMISSION_LEVELS.OWNER)
    };
    if (BladesPC$1.IsType(this.actor) || BladesCrew$1.IsType(this.actor)) {
      sheetData.preparedItems = {
        abilities: [],
        loadout: [],
        cohorts: {
          gang: this.actor.cohorts.filter((item) => item.type === BladesItemType.cohort_gang).map((item) => {
            const subtypes = U.unique(Object.values(item.system.subtypes).map((subtype) => subtype.trim()).filter((subtype) => /[A-Za-z]/.test(subtype)));
            const eliteSubtypes = [
              ...Object.values(item.system.elite_subtypes)
            ];
            if (BladesCrew$1.IsType(item.parent)) {
              eliteSubtypes.push(...(item.parent.upgrades ?? []).map((upgrade) => (upgrade.name ?? "").trim().replace(/^Elite /, "")));
            }
            const imgTypes = [...U.unique(
              eliteSubtypes.map((subtype) => subtype.trim()).filter(
                (subtype) => /[A-Za-z]/.test(subtype) && subtypes.includes(subtype)
              )
            )];
            if (imgTypes.length < 2) {
              imgTypes.push(...subtypes.filter((subtype) => !imgTypes.includes(subtype)));
            }
            if (U.unique(imgTypes).length === 1) {
              item.system.image = Object.values(item.system.elite_subtypes).includes(imgTypes[0]) ? `elite-${U.lCase(imgTypes[0])}.svg` : `${U.lCase(imgTypes[0])}.svg`;
            } else if (U.unique(imgTypes).length > 1) {
              const [rightType, leftType] = imgTypes;
              item.system.imageLeft = Object.values(item.system.elite_subtypes).includes(leftType) ? `elite-${U.lCase(leftType)}.svg` : `${U.lCase(leftType)}.svg`;
              item.system.imageRight = Object.values(item.system.elite_subtypes).includes(rightType) ? `elite-${U.lCase(rightType)}.svg` : `${U.lCase(rightType)}.svg`;
            }
            Object.assign(
              item.system,
              {
                tierTotal: item.getFactorTotal(Factor.tier) > 0 ? U.romanizeNum(item.getFactorTotal(Factor.tier)) : "0",
                cohortRollData: [
                  { mode: "untrained", label: "Untrained", color: "transparent", tooltip: "<p>Roll Untrained</p>" }
                ],
                edgeData: Object.fromEntries(Object.values(item.system.edges ?? []).filter((edge) => /[A-Za-z]/.test(edge)).map((edge) => [edge.trim(), C.EdgeTooltips[edge]])),
                flawData: Object.fromEntries(Object.values(item.system.flaws ?? []).filter((flaw) => /[A-Za-z]/.test(flaw)).map((flaw) => [flaw.trim(), C.FlawTooltips[flaw]]))
              }
            );
            return item;
          }),
          expert: this.actor.activeSubItems.filter((item) => item.type === BladesItemType.cohort_expert).map((item) => {
            Object.assign(
              item.system,
              {
                tierTotal: item.getFactorTotal(Factor.tier) > 0 ? U.romanizeNum(item.getFactorTotal(Factor.tier)) : "0",
                cohortRollData: [
                  { mode: "untrained", label: "Untrained", tooltip: "<h2>Roll Untrained</h2>" }
                ],
                edgeData: Object.fromEntries(Object.values(item.system.edges ?? []).filter((edge) => /[A-Za-z]/.test(edge)).map((edge) => [edge.trim(), C.EdgeTooltips[edge]])),
                flawData: Object.fromEntries(Object.values(item.system.flaws ?? []).filter((flaw) => /[A-Za-z]/.test(flaw)).map((flaw) => [flaw.trim(), C.FlawTooltips[flaw]]))
              }
            );
            return item;
          })
        },
        projects: []
      };
    }
    if (BladesActor$1.IsType(this.actor, BladesActorType.pc) || BladesActor$1.IsType(this.actor, BladesActorType.crew)) {
      sheetData.playbookData = {
        dotline: {
          data: this.actor.system.experience.playbook,
          dotlineClass: "xp-playbook",
          target: "system.experience.playbook.value",
          svgKey: "teeth.tall",
          svgFull: "full|frame",
          svgEmpty: "full|half|frame",
          advanceButton: "advance-playbook"
        }
      };
      if (this.actor.system.experience.playbook.value !== this.actor.system.experience.playbook.max) {
        sheetData.playbookData.tooltip = new Handlebars.SafeString([
          "<h2>At the End of the Session, Gain XP If ...</h2>",
          "<ul>",
          ...Object.values(this.actor.system.experience.clues ?? []).map((line) => `<li>${line.replace(/^Y/, "... y")}</li>`) ?? [],
          "</ul>"
        ].join("")).toString();
      }
      sheetData.coinsData = {
        dotline: {
          data: this.actor.system.coins,
          target: "system.coins.value",
          iconEmpty: "coin-full.svg",
          iconFull: "coin-full.svg"
        }
      };
    }
    return {
      ...context3,
      ...sheetData
    };
  }
  // #region LISTENERS & EVENT HANDLERS
  activateListeners(html) {
    super.activateListeners(html);
    if (game.user.isGM) {
      html.attr("style", "--secret-text-display: initial");
    } else {
      html.find('.editor:not(.tinymce) [data-is-secret="true"]').remove();
    }
    ApplyTooltipAnimations(html);
    Tags.InitListeners(html, this.actor);
    if (!this.options.editable) {
      return;
    }
    html.find(".dotline").each((__, elem) => {
      if ($(elem).hasClass("locked")) {
        return;
      }
      let targetDoc = this.actor;
      let targetField = $(elem).data("target");
      const comp$ = $(elem).closest("comp");
      if (targetField.startsWith("item")) {
        targetField = targetField.replace(/^item\./, "");
        const itemId = $(elem).closest("[data-comp-id]").data("compId");
        if (!itemId) {
          return;
        }
        const item = this.actor.items.get(itemId);
        if (!item) {
          return;
        }
        targetDoc = item;
      }
      const curValue = U.pInt($(elem).data("value"));
      $(elem).find(".dot").each((_, dot) => {
        $(dot).on("click", (event) => {
          event.preventDefault();
          const thisValue = U.pInt($(dot).data("value"));
          if (thisValue !== curValue) {
            if (comp$.hasClass("comp-coins") || comp$.hasClass("comp-stash")) {
              G.effects.fillCoins($(dot).prevAll(".dot")).then(() => targetDoc.update({ [targetField]: thisValue }));
            } else {
              targetDoc.update({ [targetField]: thisValue });
            }
          }
        });
        $(dot).on("contextmenu", (event) => {
          event.preventDefault();
          const thisValue = U.pInt($(dot).data("value")) - 1;
          if (thisValue !== curValue) {
            targetDoc.update({ [targetField]: thisValue });
          }
        });
      });
    });
    html.find("[data-comp-id]").find(".comp-title").on({ click: this._onItemOpenClick.bind(this) });
    html.find(".comp-control.comp-add").on({ click: this._onItemAddClick.bind(this) });
    html.find(".comp-control.comp-delete").on({ click: this._onItemRemoveClick.bind(this) });
    html.find(".comp-control.comp-delete-full").on({ click: this._onItemFullRemoveClick.bind(this) });
    html.find(".comp-control.comp-toggle").on({ click: this._onItemToggleClick.bind(this) });
    html.find(`
        select[data-action='player-select'],
        select[data-action='gm-select']
      `).on({ change: this._onSelectChange.bind(this) });
    html.find("[data-action='toggle-value'").on({ click: this._onToggleValueClick.bind(this) });
    html.find(".advance-button").on({ click: this._onAdvanceClick.bind(this) });
    html.find(".effect-control").on({ click: this._onActiveEffectControlClick.bind(this) });
    html.find("[data-roll-trait]").on({ click: this._onRollTraitClick.bind(this) });
    html.find("[data-action*='downtime-action-']").on({ click: this._onDowntimeActionClick.bind(this) });
    if (this.options.submitOnChange) {
      html.on("change", "textarea", this._onChangeInput.bind(this));
    }
  }
  async _onSubmit(event, params = {}) {
    if (!game.user.isGM && !this.actor.testUserPermission(game.user, CONST.DOCUMENT_PERMISSION_LEVELS.OWNER)) {
      eLog.checkLog("actorSheetTrigger", "User does not have permission to edit this actor", { user: game.user, actor: this.actor });
      return {};
    }
    return super._onSubmit(event, params);
  }
  async close(options) {
    if (this.actor.type === BladesActorType.pc) {
      return super.close(options).then(() => this.actor.clearSubActors());
    } else if (this.actor.type === BladesActorType.npc && this.actor.parentActor) {
      return super.close(options).then(() => this.actor.clearParentActor(false));
    }
    return super.close(options);
  }
  // #region Component Handlers
  _getCompData(event) {
    const elem$ = $(event.currentTarget).closest(".comp");
    const compData = {
      elem$,
      docID: elem$.data("compId"),
      docCat: elem$.data("compCat"),
      docType: elem$.data("compType"),
      docTags: (elem$.data("compTags") ?? "").split(/\s+/g)
    };
    eLog.checkLog2("dialog", "Component Data", { elem: elem$, ...compData });
    if (compData.docID && compData.docType) {
      compData.doc = {
        Actor: this.actor.getSubActor(compData.docID),
        Item: this.actor.getSubItem(compData.docID)
      }[compData.docType];
    }
    if (compData.docCat && compData.docType && (BladesPC$1.IsType(this.actor) || BladesCrew$1.IsType(this.actor))) {
      compData.dialogDocs = {
        Actor: this.actor.getDialogActors(compData.docCat),
        Item: this.actor.getDialogItems(compData.docCat)
      }[compData.docType];
    }
    return compData;
  }
  _onItemOpenClick(event) {
    var _a2;
    event.preventDefault();
    const { doc } = this._getCompData(event);
    if (!doc) {
      return;
    }
    (_a2 = doc.sheet) == null ? void 0 : _a2.render(true);
  }
  async _onItemAddClick(event) {
    event.preventDefault();
    const addType = $(event.currentTarget).closest(".comp").data("addType");
    if (addType && addType in BladesItemType) {
      await this.actor.createEmbeddedDocuments("Item", [
        {
          name: {
            [BladesItemType.cohort_gang]: "A Gang",
            [BladesItemType.cohort_expert]: "An Expert"
          }[addType] ?? randomID(),
          type: addType
        }
      ]);
      return;
    }
    const { docCat, docType, dialogDocs, docTags } = this._getCompData(event);
    if (!dialogDocs || !docCat || !docType) {
      return;
    }
    await BladesDialog.DisplaySelectionDialog(
      this.actor,
      U.tCase(`Add ${docCat.replace(/_/g, " ")}`),
      docType,
      dialogDocs,
      docTags
    );
  }
  async _onItemRemoveClick(event) {
    event.preventDefault();
    const { elem$, doc } = this._getCompData(event);
    if (!doc) {
      return;
    }
    await G.effects.blurRemove(elem$).then(async () => {
      if (doc instanceof BladesItem$1) {
        await this.actor.remSubItem(doc);
      } else {
        await this.actor.remSubActor(doc);
      }
    });
  }
  async _onItemFullRemoveClick(event) {
    event.preventDefault();
    const { elem$, doc } = this._getCompData(event);
    if (!doc) {
      return;
    }
    await G.effects.blurRemove(elem$).then(async () => await doc.delete());
  }
  async _onItemToggleClick(event) {
    event.preventDefault();
    const target = $(event.currentTarget).data("target");
    await this.actor.update({
      [target]: !getProperty(this.actor, target)
    });
  }
  async _onSelectChange(event) {
    event.preventDefault();
    await U.EventHandlers.onSelectChange(this, event);
  }
  async _onToggleValueClick(event) {
    event.preventDefault();
    const elem$ = $(event.currentTarget);
    const targetKey = elem$.data("target");
    const toggleOnVal = elem$.data("toggleOnVal") || "";
    const toggleOffVal = elem$.data("toggleOffVal") || "";
    if (getProperty(this.actor, targetKey) === toggleOnVal) {
      await this.actor.update({ [targetKey]: toggleOffVal });
    } else {
      await this.actor.update({ [targetKey]: toggleOnVal });
    }
  }
  async _onAdvanceClick(event) {
    event.preventDefault();
    if ($(event.currentTarget).data("action") === "advance-playbook") {
      await this.actor.advancePlaybook();
    }
  }
  // #endregion
  // #region Roll Handlers
  async _onRollTraitClick(event) {
    const traitName = $(event.currentTarget).data("rollTrait");
    const rollType = $(event.currentTarget).data("rollType");
    const rollData = {
      target: this.actor,
      targetFlagKey: "rollCollab"
    };
    if (U.lCase(traitName) in { ...ActionTrait, ...AttributeTrait, ...Factor }) {
      rollData.rollTrait = U.lCase(traitName);
    } else if (U.isInt(traitName)) {
      rollData.rollTrait = U.pInt(traitName);
    }
    if (U.tCase(rollType) in RollType) {
      rollData.rollType = U.tCase(rollType);
    } else if (typeof rollData.rollTrait === "string") {
      if (rollData.rollTrait in AttributeTrait) {
        rollData.rollType = RollType.Resistance;
      } else if (rollData.rollTrait in ActionTrait) {
        rollData.rollType = RollType.Action;
      }
    }
    if (game.user.isGM) {
      if (BladesRollPrimary.IsDoc(this.actor)) {
        rollData.rollPrimaryData = this.actor;
      } else if (BladesRollOpposition.IsDoc(this.actor)) {
        rollData.rollOppData = this.actor;
      }
    }
    await BladesActionRoll.New(rollData);
  }
  // Returns TRUE if can proceed, FALSE if action should stop (i.e. panel revealed for another user click)
  async _validateOrRevealSubData(downtimeAction, actionSubData) {
    switch (downtimeAction) {
      case DowntimeAction.LongTermProject: {
        if (actionSubData === "NewProject") {
          return false;
        }
        const projectItem = game.items.get(actionSubData ?? "");
        if (BladesProject$1.IsType(projectItem)) {
          return true;
        }
        return false;
      }
      case DowntimeAction.Recover: {
        const healerActor = game.actors.get(actionSubData ?? "");
        if (healerActor instanceof BladesActor$1 && healerActor.hasTag(Tag.NPC.CanHeal)) {
          return true;
        }
        return false;
      }
      case DowntimeAction.Train: {
        return Boolean(/^[a-z]+:\d$/.exec(actionSubData ?? ""));
      }
      default:
        return true;
    }
  }
  async _onDowntimeActionClick(event) {
    var _a2, _b, _c;
    const elem$ = $(event.currentTarget);
    const downtimeAction = elem$.data("action").substring(elem$.data("action").lastIndexOf("-") + 1);
    const actionSubData = elem$.data("actionSubData");
    if (!await this._validateOrRevealSubData(downtimeAction, actionSubData)) {
      $("#eunos-blades-tooltips").children(".tooltip").remove();
      await this.actor.update({ "system.downtime_actions_open_submenu": downtimeAction });
      $("#eunos-blades-tooltips").children(".tooltip").remove();
      return;
    }
    const config3 = {
      target: this.actor,
      targetFlagKey: "rollCollab",
      rollDowntimeAction: downtimeAction
    };
    switch (downtimeAction) {
      case DowntimeAction.AcquireAsset:
      case DowntimeAction.LongTermProject:
      case DowntimeAction.ReduceHeat: {
        config3.rollType = RollType.Action;
        break;
      }
      case DowntimeAction.Recover: {
        config3.rollType = RollType.Action;
        if (BladesPC$1.IsType(this.actor) && this.actor.healingClock) {
          config3.rollClockKey = this.actor.healingClock.id;
        }
        break;
      }
      case DowntimeAction.IndulgeVice: {
        config3.rollType = RollType.IndulgeVice;
        break;
      }
      case DowntimeAction.Train: {
        const [attr, value] = actionSubData.split(/:/);
        if (attr === "playbook") {
          this.actor.update({ [`system.experience.${attr}.value`]: U.pInt(((_b = (_a2 = this.actor.system.experience) == null ? void 0 : _a2.playbook) == null ? void 0 : _b.value) ?? 0) + U.pInt(value) });
        } else if (BladesPC$1.IsType(this.actor)) {
          this.actor.update({ [`system.experience.${attr}.value`]: U.pInt(this.actor.system.experience[attr].value) + U.pInt(value) });
        }
        break;
      }
    }
    await this.actor.update({
      "system.downtime_actions_open_submenu": "",
      "system.downtime_actions.value": (((_c = this.actor.system.downtime_actions) == null ? void 0 : _c.value) ?? 0) + 1
    });
    if ("rollType" in config3) {
      if (downtimeAction === DowntimeAction.IndulgeVice) {
        BladesIndulgeViceRoll.New(config3);
      } else {
        BladesActionRoll.New(config3);
      }
    }
  }
  async _onGatherInfoClick(event) {
    const elem$ = $(event.currentTarget);
    if (elem$.data("isFortuneRoll")) {
      BladesFortuneRoll.New({
        target: this.actor,
        targetFlagKey: "rollCollab",
        rollType: RollType.Fortune
      });
    } else {
      BladesActionRoll.New({
        target: this.actor,
        targetFlagKey: "rollCollab",
        rollType: RollType.Action,
        rollTrait: ""
      });
    }
  }
  // #endregion
  // #region Active Effect Handlers
  _onActiveEffectControlClick(event) {
    BladesActiveEffect.onManageActiveEffect(event, this.actor);
  }
  // #endregion
  // #endregion
}
class BladesPCSheet extends BladesActorSheet {
  static get defaultOptions() {
    return foundry.utils.mergeObject(super.defaultOptions, {
      classes: ["eunos-blades", "sheet", "actor", "pc"],
      template: "systems/eunos-blades/templates/actor-sheet.hbs",
      width: 775,
      height: 775,
      tabs: [{ navSelector: ".nav-tabs", contentSelector: ".tab-content", initial: "abilities" }]
    });
  }
  getData() {
    var _a2, _b, _c, _d;
    const context3 = super.getData();
    const { activeSubItems, activeSubActors } = this.actor;
    const sheetData = {};
    sheetData.preparedItems = Object.assign(
      context3.preparedItems ?? {},
      {
        abilities: activeSubItems.filter((item) => item.type === BladesItemType.ability).map((item) => {
          if (item.system.uses_per_score.max) {
            Object.assign(item, {
              inRuleDotline: {
                data: item.system.uses_per_score,
                dotlineLabel: "Uses",
                target: "item.system.uses_per_score.value",
                iconEmpty: "dot-empty.svg",
                iconEmptyHover: "dot-empty-hover.svg",
                iconFull: "dot-full.svg",
                iconFullHover: "dot-full-hover.svg"
              }
            });
          }
          return item;
        }),
        background: activeSubItems.find((item) => item.type === BladesItemType.background),
        heritage: activeSubItems.find((item) => item.type === BladesItemType.heritage),
        vice: activeSubItems.find((item) => item.type === BladesItemType.vice),
        loadout: activeSubItems.filter((item) => item.type === BladesItemType.gear).map((item) => {
          if (item.system.load) {
            Object.assign(item, {
              numberCircle: item.system.load,
              numberCircleClass: "item-load"
            });
          }
          if (item.system.uses_per_score.max) {
            Object.assign(item, {
              inRuleDotline: {
                data: item.system.uses_per_score,
                dotlineLabel: "Uses",
                target: "item.system.uses_per_score.value",
                iconEmpty: "dot-empty.svg",
                iconEmptyHover: "dot-empty-hover.svg",
                iconFull: "dot-full.svg",
                iconFullHover: "dot-full-hover.svg"
              }
            });
          }
          return item;
        }),
        playbook: this.actor.playbook,
        projects: activeSubItems.filter((item) => item.type === BladesItemType.project),
        cohorts: (_a2 = context3.preparedItems) == null ? void 0 : _a2.cohorts
      }
    );
    sheetData.preparedActors = {
      crew: activeSubActors.find((actor) => actor.type === BladesActorType.crew),
      vice_purveyor: activeSubActors.find((actor) => actor.hasTag(Tag.NPC.VicePurveyor)),
      acquaintances: activeSubActors.filter((actor) => actor.hasTag(Tag.NPC.Acquaintance))
    };
    sheetData.hasVicePurveyor = Boolean(((_b = this.actor.playbook) == null ? void 0 : _b.hasTag(Tag.Gear.Advanced)) === false && activeSubItems.find((item) => item.type === BladesItemType.vice));
    sheetData.healing_clock = this.actor.healingClock;
    sheetData.stashData = {
      label: "Stash:",
      dotline: {
        data: this.actor.system.stash,
        target: "system.stash.value",
        iconEmpty: "coin-empty.svg",
        iconEmptyHover: "coin-empty-hover.svg",
        iconFull: "coin-full.svg",
        iconFullHover: "coin-full-hover.svg",
        altIconFull: "coin-ten.svg",
        altIconFullHover: "coin-ten-hover.svg",
        altIconStep: 10
      }
    };
    sheetData.stressData = {
      label: this.actor.system.stress.name,
      dotline: {
        data: this.actor.system.stress,
        dotlineClass: this.actor.system.stress.max >= 13 ? "narrow-stress" : "",
        target: "system.stress.value",
        svgKey: "teeth.tall",
        svgFull: "full|half|frame",
        svgEmpty: "full|half|frame"
      }
    };
    if (BladesActor$1.IsType(this.actor, BladesActorType.pc)) {
      sheetData.traumaData = {
        label: this.actor.system.trauma.name,
        dotline: {
          data: { value: this.actor.trauma, max: this.actor.system.trauma.max },
          svgKey: "teeth.short",
          svgFull: "full|frame",
          svgEmpty: "frame",
          isLocked: true
        },
        compContainer: {
          class: "comp-trauma-conditions comp-vertical full-width",
          blocks: [
            this.actor.traumaList.slice(0, Math.ceil(this.actor.traumaList.length / 2)).map((tName) => ({
              checkLabel: tName,
              checkClasses: {
                active: "comp-toggle-red",
                inactive: "comp-toggle-grey"
              },
              checkTarget: `system.trauma.checked.${tName}`,
              checkValue: this.actor.system.trauma.checked[tName] ?? false,
              tooltip: C.TraumaTooltips[tName],
              tooltipClass: "tooltip-trauma"
            })),
            this.actor.traumaList.slice(Math.ceil(this.actor.traumaList.length / 2)).map((tName) => ({
              checkLabel: tName,
              checkClasses: {
                active: "comp-toggle-red",
                inactive: "comp-toggle-grey"
              },
              checkTarget: `system.trauma.checked.${tName}`,
              checkValue: this.actor.system.trauma.checked[tName] ?? false,
              tooltip: C.TraumaTooltips[tName],
              tooltipClass: "tooltip-trauma"
            }))
          ]
        }
      };
    }
    sheetData.abilityData = {
      dotline: {
        dotlineClass: "dotline-right dotline-glow",
        data: {
          value: this.actor.getAvailableAdvancements("Ability"),
          max: this.actor.getAvailableAdvancements("Ability")
        },
        dotlineLabel: "Available Abilities",
        isLocked: true,
        iconFull: "dot-full.svg"
      }
    };
    sheetData.loadData = {
      curLoad: this.actor.currentLoad,
      selLoadCount: this.actor.system.loadout.levels[U.lCase(this.actor.system.loadout.selected)],
      options: C.Loadout.selections,
      selected: this.actor.system.loadout.selected ?? ""
    };
    sheetData.armor = Object.fromEntries(Object.entries(this.actor.system.armor.active).filter(([, isActive]) => isActive).map(([armor]) => [
      armor,
      this.actor.system.armor.checked[armor]
    ]));
    sheetData.attributeData = {};
    const attrEntries = Object.entries(this.actor.system.attributes);
    for (const [attribute, attrData] of attrEntries) {
      sheetData.attributeData[attribute] = {
        tooltip: C.AttributeTooltips[attribute],
        actions: {}
      };
      const actionEntries = Object.entries(attrData);
      for (const [action, actionData] of actionEntries) {
        sheetData.attributeData[attribute].actions[action] = {
          tooltip: C.ActionTooltips[action],
          value: actionData.value,
          max: game.eunoblades.Tracker.phase === BladesPhase.CharGen ? 2 : this.actor.system.attributes[attribute][action].max
        };
      }
    }
    if (((_c = game.eunoblades.Tracker) == null ? void 0 : _c.phase) === BladesPhase.Downtime) {
      const actionsList = {
        [DowntimeAction.AcquireAsset]: "Acquire Asset",
        [DowntimeAction.IndulgeVice]: "Indulge Vice",
        [DowntimeAction.LongTermProject]: "Project",
        [DowntimeAction.Recover]: "Recover",
        [DowntimeAction.ReduceHeat]: "Reduce Heat",
        [DowntimeAction.Train]: "Train"
      };
      const healCapableDocs = [
        ...BladesActor$1.GetTypeWithTags(BladesActorType.pc, Tag.PC.CanHeal),
        ...BladesActor$1.GetTypeWithTags(BladesActorType.npc, Tag.NPC.CanHeal)
        /* ALSO NEED TO INCLUDE EXPERT COHORTS WITH CANHEAL TAG */
      ];
      if (this.actor.stress === 0) {
        delete actionsList[DowntimeAction.IndulgeVice];
      }
      if (this.actor.harmLevel === 0 || healCapableDocs.length === 0) {
        delete actionsList[DowntimeAction.Recover];
      }
      if (!this.actor.crew || this.actor.crew.system.heat.value === 0) {
        delete actionsList[DowntimeAction.ReduceHeat];
      }
      let actionsSubmenuData = void 0;
      switch (this.actor.system.downtime_actions_open_submenu) {
        case DowntimeAction.LongTermProject: {
          actionsSubmenuData = [
            {
              actionSubData: "NewProject",
              display: "New Project"
            }
          ];
          break;
        }
        case DowntimeAction.Recover: {
          actionsSubmenuData = [];
          healCapableDocs.forEach((hDoc) => {
            if (hDoc.id === this.actor.id) {
              actionsSubmenuData == null ? void 0 : actionsSubmenuData.unshift({
                actionSubData: this.actor.id,
                display: "Heal Self"
              });
            } else if (BladesPC$1.IsType(hDoc)) {
              actionsSubmenuData == null ? void 0 : actionsSubmenuData.push({
                actionSubData: hDoc.id,
                display: U.uCase(hDoc.name)
              });
            } else if (BladesNPC$1.IsType(hDoc)) {
              actionsSubmenuData == null ? void 0 : actionsSubmenuData.push({
                actionSubData: hDoc.id,
                display: hDoc.name
              });
            }
          });
          break;
        }
        case DowntimeAction.Train: {
          const crewTrainingUpgrades = ((_d = this.actor.crew) == null ? void 0 : _d.upgrades.filter((upgrade) => /^Training_/.exec(upgrade.system.world_name)).map((upgrade) => U.lCase(upgrade.system.world_name.split(/_/)[1]))) ?? [];
          actionsSubmenuData = [
            {
              actionSubData: `playbook:${crewTrainingUpgrades.includes("playbook") ? 2 : 1}`,
              display: `${crewTrainingUpgrades.includes("playbook") ? 2 : 1} Playbook XP`
            },
            {
              actionSubData: `insight:${crewTrainingUpgrades.includes(AttributeTrait.insight) ? 2 : 1}`,
              display: `${crewTrainingUpgrades.includes(AttributeTrait.insight) ? 2 : 1} Insight XP`
            },
            {
              actionSubData: `prowess:${crewTrainingUpgrades.includes(AttributeTrait.prowess) ? 2 : 1}`,
              display: `${crewTrainingUpgrades.includes(AttributeTrait.prowess) ? 2 : 1} Prowess XP`
            },
            {
              actionSubData: `resolve:${crewTrainingUpgrades.includes(AttributeTrait.resolve) ? 2 : 1}`,
              display: `${crewTrainingUpgrades.includes(AttributeTrait.resolve) ? 2 : 1} Resolve XP`
            }
          ];
          break;
        }
      }
      const actionsTooltips = {
        [DowntimeAction.AcquireAsset]: `<h1>Acquire an Asset</h1>
        <p>Roll your <strong class='gold-bright'>Tier</strong> to acquire temporary use of an asset or service.</p>
        <p>The <strong>Quality</strong> of the acquired asset depends on the result of your roll:</p>
        <ul>
        <li><strong class='gold-bright'>Critical Success</strong> &mdash; <strong class='gold-bright'>Tier</strong> <strong>+ 2</strong></li>
        <li><strong>Success</strong> &mdash; <strong class='gold-bright'>Tier</strong> <strong>+ 2</strong></li>
        <li><b>Partial Success</b> &mdash; <strong class='gold-bright'>Tier</strong></li>
        <li><strong class='red-bright'>Fail</strong> &mdash; <strong class='gold-bright'>Tier</strong> <strong>− 1</strong></li>
        </ul>`,
        [DowntimeAction.IndulgeVice]: `<h1>Indulge Your Vice</h1>
        <p>Roll your <strong class='red-bright'>lowest</strong> <strong>Attribute</strong>. Clear <strong>Stress</strong> equal to the <strong>highest</strong> die result.</p>
        <p><strong class="red-bright">Warning:</strong> If you clear more <strong>Stress</strong> than you have, you will <strong class="red-bright">overindulge</strong>.</p>`,
        [DowntimeAction.LongTermProject]: `<h1>Work on a Long-Term Project</h1>
        <p>Work to <strong>advance the clock</strong> of one of your existing <strong>Long-Term Projects</strong>, or begin a new one.</p>
        <p>Roll the <strong>Action</strong> most appropriate to the work you are doing. The results of your roll determine how far you will <strong>advance the clock</strong>:</p>
        <ul>
        <li><strong class='gold-bright'>Critical Success</strong> &mdash; <strong class='gold-bright'>Five</strong> Segments</li>
        <li><strong>Success</strong> &mdash;  <strong>Three</strong> Segments</li>
        <li><b>Partial Success</b> &mdash; <b>Two</b> Segments</li>
        <li><strong class='red-bright'>Fail</strong> &mdash; <strong class='red-bright'>One</strong> Segment</li>
        </ul>`,
        [DowntimeAction.Recover]: `<h1>Recover from Harm</h1>
        <p>Make a <strong>healing treatment roll</strong> using the appropriate trait of the character healing you:</p>
        <ul>
        <li><strong>A PC with 'Physicker'</strong> &mdash; <strong>Tinker</strong>. <em>(You can heal yourself this way, but suffer <strong class="red-bright">2 Stress</strong> for doing so.)</em></li>
        <li><strong>An NPC</strong> &mdash; <strong>Quality</strong></li>
        </ul>
        <p>The results of your roll determine how far you will <strong>Advance your healing clock</strong>:</p>
        <ul>
        <li><strong class='gold-bright'>Critical Success</strong> &mdash; <strong class='gold-bright'>Five</strong> Segments</li>
        <li><strong>Success</strong> &mdash;  <strong>Three</strong> Segments</li>
        <li><b>Partial Success</b> &mdash; <b>Two</b> Segments</li>
        <li><strong class='red-bright'>Fail</strong> &mdash; <strong class='red-bright'>One</strong> Segment</li>
        </ul>
        <p>When your <strong>healing clock</strong> is filled, reduce each Harm by one level of severity.</p>`,
        [DowntimeAction.ReduceHeat]: `<h1>Reduce Heat</h1>
        <p>Work to <strong>reduce the Heat</strong> on your Crew.</p>
        <p>Roll the <strong>Action</strong> most appropriate to the measures you are taking. The results of your roll determine how much <strong class="red-bright">Heat</strong> you clear:</p>
        <ul>
        <li><strong class='gold-bright'>Critical Success</strong> &mdash; <strong class='gold-bright'>Five</strong> Heat</li>
        <li><strong>Success</strong> &mdash;  <strong>Three</strong> Heat</li>
        <li><b>Partial Success</b> &mdash; <b>Two</b> Heat</li>
        <li><strong class='red-bright'>Fail</strong> &mdash; <strong class='red-bright'>One</strong> Heat</li>
        </ul>`,
        [DowntimeAction.Train]: `<h1>Train</h1>
        <p>Select an <strong>Experience Track</strong> <em>(i.e. Insight, Prowess, Resolve, or your Playbook)</em>. Gain <strong>1 XP</strong> in that track, or <strong>2 XP</strong> if your Crew has the corresponding <strong>Training Upgrade</strong>.</p>`
      };
      const actionsRemaining = this.actor.system.downtime_actions.max + this.actor.system.downtime_action_bonus - this.actor.system.downtime_actions.value - (this.actor.isAtWar ? 1 : 0);
      const canPayCoin = Boolean(
        this.actor.system.coins.value >= 1 || this.actor.system.stash.value >= 2
      );
      const canPayRep = Boolean(
        this.actor.crew && this.actor.crew.system.rep.value >= 1
      );
      const isDisplayingCosts = actionsRemaining <= 0;
      const isDisplayingActions = actionsRemaining > 0 || canPayCoin && this.actor.system.downtime_action_selected_cost === "Coin" || canPayRep && this.actor.system.downtime_action_selected_cost === "Rep";
      sheetData.downtimeData = {
        actionsList,
        actionsTooltips,
        actionsRemaining,
        actionsSubmenuData,
        canPayCoin,
        canPayRep,
        isDisplayingCosts,
        isDisplayingActions,
        dotline: {
          dotlineClass: "dotline-right dotline-glow",
          data: {
            value: actionsRemaining,
            max: actionsRemaining
          },
          dotlineLabel: "Actions Remaining",
          isLocked: true,
          iconFull: "dot-full.svg"
        }
      };
    }
    sheetData.gatherInfoTooltip = new Handlebars.SafeString([
      "<h1>Gathering Information</h1>",
      "<h2>Questions to Consider</h2>",
      "<ul>",
      ...Object.values(this.actor.system.gather_info ?? []).map((line) => `<li>${line}</li>`) ?? [],
      "</ul>"
    ].join("")).toString();
    eLog.checkLog("Attribute", "[BladesPCSheet] attributeData", { attributeData: sheetData.attributeData });
    eLog.checkLog("actor", "[BladesPCSheet] getData()", { ...context3, ...sheetData });
    return { ...context3, ...sheetData };
  }
  get activeArmor() {
    return Object.keys(U.objFilter(
      this.actor.system.armor.active,
      (val) => val === true
    ));
  }
  get checkedArmor() {
    return Object.keys(U.objFilter(
      this.actor.system.armor.checked,
      (val, key) => val === true && this.actor.system.armor.active[key] === true
    ));
  }
  get uncheckedArmor() {
    return Object.keys(U.objFilter(
      this.actor.system.armor.active,
      (val, key) => val === true && this.actor.system.armor.checked[key] === false
    ));
  }
  _getHoverArmor() {
    if (!this.activeArmor.length) {
      return false;
    }
    if (this.activeArmor.includes("heavy")) {
      return this.checkedArmor.includes("heavy") ? "light" : "heavy";
    } else if (this.activeArmor.includes("light")) {
      return "light";
    }
    return "special";
  }
  _getClickArmor() {
    if (!this.uncheckedArmor.length) {
      return false;
    }
    if (this.uncheckedArmor.includes("heavy")) {
      return "heavy";
    }
    if (this.uncheckedArmor.includes("light")) {
      return "light";
    }
    return "special";
  }
  _getContextMenuArmor() {
    if (!this.checkedArmor.length) {
      return false;
    }
    if (this.checkedArmor.includes("light")) {
      return "light";
    }
    if (this.checkedArmor.includes("heavy")) {
      return "heavy";
    }
    return "special";
  }
  async _onAdvanceClick(event) {
    event.preventDefault();
    super._onAdvanceClick(event);
    const action = $(event.currentTarget).data("action").replace(/^advance-/, "");
    if (action in AttributeTrait) {
      await this.actor.advanceAttribute(action);
    }
  }
  activateListeners(html) {
    super.activateListeners(html);
    if (!this.options.editable) {
      return;
    }
    const self2 = this;
    html.find(".main-armor-control").on({
      click() {
        const targetArmor = self2._getClickArmor();
        if (!targetArmor) {
          return;
        }
        self2.actor.update({ [`system.armor.checked.${targetArmor}`]: true });
      },
      contextmenu() {
        const targetArmor = self2._getContextMenuArmor();
        if (!targetArmor) {
          return;
        }
        self2.actor.update({ [`system.armor.checked.${targetArmor}`]: false });
      },
      mouseenter() {
        const targetArmor = self2._getHoverArmor();
        eLog.log4("Mouse Enter", targetArmor, this, $(this), $(this).next());
        if (!targetArmor) {
          return;
        }
        $(this).siblings(`.svg-armor.armor-${targetArmor}`).addClass("hover-over");
      },
      mouseleave() {
        const targetArmor = self2._getHoverArmor();
        if (!targetArmor) {
          return;
        }
        $(this).siblings(`.svg-armor.armor-${targetArmor}`).removeClass("hover-over");
      }
    });
    html.find(".special-control").on({
      click() {
        if (!self2.activeArmor.includes("special")) {
          return;
        }
        self2.actor.update({ "system.armor.checked.special": self2.uncheckedArmor.includes("special") });
      },
      contextmenu() {
        if (!self2.activeArmor.includes("special")) {
          return;
        }
        self2.actor.update({ "system.armor.checked.special": self2.uncheckedArmor.includes("special") });
      },
      mouseenter() {
        if (!self2.activeArmor.includes("special") || self2.activeArmor.length === 1) {
          return;
        }
        $(this).siblings(".svg-armor.armor-special").addClass("hover-over");
      },
      mouseleave() {
        if (!self2.activeArmor.includes("special") || self2.activeArmor.length === 1) {
          return;
        }
        $(this).siblings(".svg-armor.armor-special").removeClass("hover-over");
      }
    });
  }
}
class BladesPC extends BladesActor$1 {
  // #region INITIALIZATION ~
  static async Initialize() {
    Object.assign(globalThis, { BladesPC, BladesPCSheet });
    Actors.registerSheet("blades", BladesPCSheet, { types: ["pc"], makeDefault: true });
    Hooks.on("dropActorSheetData", async (parentActor, _, { uuid }) => {
      const doc = fromUuidSync(uuid);
      if (doc instanceof BladesActor$1) {
        if (parentActor.type === BladesActorType.crew && doc.type === BladesActorType.pc) {
          doc.addSubActor(parentActor);
        } else if (parentActor.type === BladesActorType.pc && doc.type === BladesActorType.crew) {
          parentActor.addSubActor(doc);
        }
      }
    });
    return loadTemplates(["systems/eunos-blades/templates/actor-sheet.hbs"]);
  }
  // #endregion
  // #region Static Overrides: Create, get All ~
  // static override IsType<T extends BladesActorType = BladesActorType.pc>(doc: unknown): doc is BladesActorOfType<T> {
  //   return super.IsType(doc, BladesActorType.pc);
  // }
  static IsType(doc) {
    return super.IsType(doc, BladesActorType.pc);
  }
  static GetUser(userRef) {
    let user;
    if (typeof userRef === "string") {
      user = game.users.get(userRef) ?? game.users.getName(userRef);
    } else if (userRef instanceof User) {
      user = userRef;
    }
    return user;
  }
  static GetFromUser(userRef) {
    var _a2;
    const user = BladesPC.GetUser(userRef);
    if (!user) {
      throw new Error(`Unable to find user '${userRef}'`);
    }
    const actor = game.actors.get(((_a2 = user.character) == null ? void 0 : _a2.id) ?? "");
    if (BladesPC.IsType(actor)) {
      return actor;
    }
    return void 0;
  }
  static async create(data, options = {}) {
    data.token = data.token || {};
    data.system = data.system ?? {};
    eLog.checkLog2("actor", "BladesPC.create(data,options)", { data, options });
    data.token.actorLink = true;
    data.system.experience = {
      playbook: { value: 0, max: 8 },
      insight: { value: 0, max: 6 },
      prowess: { value: 0, max: 6 },
      resolve: { value: 0, max: 6 },
      clues: [],
      ...data.system.experience ?? {}
    };
    const pc = await super.create(data, options);
    await BladesClockKey.Create({
      name: "",
      target: pc,
      targetKey: "system.clocksData",
      isVisible: true,
      isNameVisible: false,
      isSpotlit: false
    }, void 0, [
      {
        color: ClockColor.white,
        value: 0,
        max: 4,
        index: 0,
        isVisible: true,
        isActive: true,
        isNameVisible: false,
        isHighlighted: false
      }
    ]);
    return pc;
  }
  static get All() {
    return new Collection(
      super.GetTypeWithTags(BladesActorType.pc).map((pc) => [pc.id, pc])
    );
  }
  // #endregion
  constructor(data) {
    super(data);
    eLog.checkLog3("pcConstructor", "new BladesPC()", { data });
  }
  // #region BladesPrimaryActor Implementation ~
  get primaryUser() {
    var _a2;
    return ((_a2 = game.users) == null ? void 0 : _a2.find((user) => {
      var _a3;
      return ((_a3 = user.character) == null ? void 0 : _a3.id) === (this == null ? void 0 : this.id);
    })) || null;
  }
  async clearLoadout() {
    await this.update({ "system.loadout.selected": "" });
    this.updateEmbeddedDocuments(
      "Item",
      [
        ...this.activeSubItems.filter((item) => BladesItem$1.IsType(item, BladesItemType.gear) && !item.hasTag(Tag.System.Archived)).map((item) => ({
          "_id": item.id,
          "system.tags": [...item.tags, Tag.System.Archived],
          "system.uses_per_score.value": 0
        })),
        ...this.activeSubItems.filter((item) => BladesItem$1.IsType(item, BladesItemType.ability) && item.system.uses_per_score.max).map((item) => ({
          "_id": item.id,
          "system.uses_per_score.value": 0
        }))
      ]
    );
  }
  // #endregion
  getSubActor(actorRef) {
    var _a2;
    const actor = super.getSubActor(actorRef);
    if (!actor) {
      return void 0;
    }
    if ((_a2 = this.primaryUser) == null ? void 0 : _a2.id) {
      actor.ownership[this.primaryUser.id] = CONST.DOCUMENT_PERMISSION_LEVELS.OWNER;
    }
    return actor;
  }
  get isLightArmorEquipped() {
    return this.system.armor.active.light;
  }
  get isLightArmorEquippable() {
    return !this.isLightArmorEquipped && this.remainingLoad >= 2;
  }
  get isLightArmorUsed() {
    return this.system.armor.checked.light;
  }
  get isLightArmorAvailable() {
    return (this.isLightArmorEquipped || this.isLightArmorEquippable) && !this.isLightArmorUsed;
  }
  get isHeavyArmorEquipped() {
    return this.system.armor.active.heavy;
  }
  get isHeavyArmorEquippable() {
    if (this.isHeavyArmorEquipped) {
      return false;
    }
    if (this.isLightArmorEquipped) {
      return this.remainingLoad >= 3;
    }
    return this.remainingLoad >= 5;
  }
  get isHeavyArmorUsed() {
    return this.system.armor.checked.heavy;
  }
  get isHeavyArmorAvailable() {
    return (this.isHeavyArmorEquipped || this.isHeavyArmorEquippable) && !this.isHeavyArmorUsed;
  }
  get availableArmor() {
    const armor = [];
    if (this.isLightArmorAvailable) {
      armor.push("Light Armor");
    }
    if (this.isHeavyArmorAvailable) {
      armor.push("Heavy Armor");
    }
    return armor;
  }
  get isSpecialArmorAvailable() {
    return this.system.armor.active.special && !this.system.armor.checked.special;
  }
  // #region BladesScoundrel Implementation ~
  isMember(crew) {
    var _a2;
    return ((_a2 = this.crew) == null ? void 0 : _a2.id) === crew.id;
  }
  get vice() {
    if (this.type !== BladesActorType.pc) {
      return void 0;
    }
    return this.activeSubItems.find((item) => item.type === BladesItemType.vice);
  }
  get crew() {
    return this.activeSubActors.find((subActor) => BladesActor$1.IsType(subActor, BladesActorType.crew));
  }
  get abilities() {
    if (!this.playbook) {
      return [];
    }
    return this.activeSubItems.filter((item) => [BladesItemType.ability, BladesItemType.crew_ability].includes(item.type));
  }
  get cohorts() {
    return this.activeSubItems.filter(
      (item) => BladesItem$1.IsType(item, BladesItemType.cohort_gang, BladesItemType.cohort_expert)
    );
  }
  get playbookName() {
    var _a2;
    return (_a2 = this.playbook) == null ? void 0 : _a2.name;
  }
  get playbook() {
    return this.activeSubItems.find((item) => item.type === BladesItemType.playbook);
  }
  get attributes() {
    if (!BladesActor$1.IsType(this, BladesActorType.pc)) {
      return void 0;
    }
    return {
      insight: Object.values(this.system.attributes.insight).filter(({ value }) => value > 0).length + this.system.resistance_bonus.insight,
      prowess: Object.values(this.system.attributes.prowess).filter(({ value }) => value > 0).length + this.system.resistance_bonus.prowess,
      resolve: Object.values(this.system.attributes.resolve).filter(({ value }) => value > 0).length + this.system.resistance_bonus.resolve
    };
  }
  get actions() {
    if (!BladesActor$1.IsType(this, BladesActorType.pc)) {
      return void 0;
    }
    return U.objMap(
      {
        ...this.system.attributes.insight,
        ...this.system.attributes.prowess,
        ...this.system.attributes.resolve
      },
      ({ value, max }) => U.gsap.utils.clamp(0, max, value)
    );
  }
  get rollable() {
    if (!BladesActor$1.IsType(this, BladesActorType.pc)) {
      return void 0;
    }
    return {
      ...this.attributes,
      ...this.actions
    };
  }
  get stress() {
    return this.system.stress.value;
  }
  get stressMax() {
    return this.system.stress.max;
  }
  get isHealingClockReady() {
    const [clockKeyID] = Object.keys(this.system.clocksData);
    return game.eunoblades.ClockKeys.has(clockKeyID ?? "");
  }
  get healingClock() {
    if (!this.isHealingClockReady) {
      return void 0;
    }
    const [clockKeyID] = Object.keys(this.system.clocksData);
    const clockKey = game.eunoblades.ClockKeys.get(clockKeyID ?? "");
    return clockKey;
  }
  get harmLevel() {
    if (this.system.harm.severe.one.length > 1) {
      return 3;
    }
    if (this.system.harm.moderate.one.length + this.system.harm.moderate.two.length > 0) {
      return 2;
    }
    if (this.system.harm.lesser.one.length + this.system.harm.lesser.two.length > 0) {
      return 1;
    }
    return 0;
  }
  get trauma() {
    if (!BladesActor$1.IsType(this, BladesActorType.pc)) {
      return 0;
    }
    return Object.keys(this.system.trauma.checked).filter((traumaName) => (
      // @ts-ignore Compiler linter mismatch.
      this.system.trauma.active[traumaName] && this.system.trauma.checked[traumaName]
    )).length;
  }
  get traumaList() {
    return BladesActor$1.IsType(this, BladesActorType.pc) ? Object.keys(this.system.trauma.active).filter((key) => this.system.trauma.active[key]) : [];
  }
  get activeTraumaConditions() {
    if (!BladesActor$1.IsType(this, BladesActorType.pc)) {
      return {};
    }
    return U.objFilter(
      this.system.trauma.checked,
      // @ts-ignore Compiler linter mismatch.
      (_v, traumaName) => Boolean(
        traumaName in this.system.trauma.active && this.system.trauma.active[traumaName]
      )
    );
  }
  get currentLoad() {
    if (!BladesActor$1.IsType(this, BladesActorType.pc)) {
      return 0;
    }
    const activeLoadItems = this.activeSubItems.filter((item) => item.type === BladesItemType.gear);
    return U.gsap.utils.clamp(0, 10, activeLoadItems.reduce((tot, i) => tot + U.pInt(i.system.load), 0));
  }
  get remainingLoad() {
    if (!BladesActor$1.IsType(this, BladesActorType.pc)) {
      return 0;
    }
    if (!this.system.loadout.selected) {
      return 0;
    }
    const maxLoad = this.system.loadout.levels[game.i18n.localize(this.system.loadout.selected.toString()).toLowerCase()];
    return Math.max(0, maxLoad - this.currentLoad);
  }
  async addStash(amount) {
    if (!BladesActor$1.IsType(this, BladesActorType.pc)) {
      return;
    }
    await this.update({ "system.stash.value": Math.min(this.system.stash.value + amount, this.system.stash.max) });
  }
  get projects() {
    return this.getSubItemsOfType(BladesItemType.project);
  }
  get remainingDowntimeActions() {
    if (!BladesActor$1.IsType(this, BladesActorType.pc)) {
      return 0;
    }
    return this.system.downtime_actions.max + this.system.downtime_action_bonus - this.system.downtime_actions.value;
  }
  _processAbilityDialogItems(dialogData) {
    if (!this.playbookName) {
      return;
    }
    dialogData[this.playbookName] = this._processEmbeddedItemMatches(
      BladesItem$1.GetTypeWithTags(BladesItemType.ability, this.playbookName)
    );
    dialogData.Veteran = this._processEmbeddedItemMatches(BladesItem$1.GetTypeWithTags(BladesItemType.ability)).filter((item) => !item.hasTag(this.playbookName)).map((item) => {
      if (item.dialogCSSClasses) {
        item.dialogCSSClasses = item.dialogCSSClasses.replace(/featured-item\s?/g, "");
      }
      return item;
    }).sort((a, b) => {
      if (a.system.world_name > b.system.world_name) {
        return 1;
      }
      if (a.system.world_name < b.system.world_name) {
        return -1;
      }
      return 0;
    });
  }
  processGearDialogItems(dialogData) {
    if (this.playbookName === null) {
      return;
    }
    const gearItems = this._processEmbeddedItemMatches([
      ...BladesItem$1.GetTypeWithTags(BladesItemType.gear, this.playbookName),
      ...BladesItem$1.GetTypeWithTags(BladesItemType.gear, Tag.Gear.General)
    ]).filter((item) => this.remainingLoad >= item.system.load);
    dialogData[this.playbookName] = gearItems.filter((item) => item.hasTag(this.playbookName));
    dialogData.General = gearItems.filter((item) => item.hasTag(Tag.Gear.General)).map((item) => {
      if (item.dialogCSSClasses) {
        item.dialogCSSClasses = item.dialogCSSClasses.replace(/featured-item\s?/g, "");
      }
      return item;
    }).sort((a, b) => {
      if (a.system.world_name > b.system.world_name) {
        return 1;
      }
      if (a.system.world_name < b.system.world_name) {
        return -1;
      }
      return 0;
    });
  }
  getDialogItems(category) {
    const dialogData = {};
    const { playbookName } = this;
    if (category === SelectionCategory.Heritage) {
      dialogData.Main = this._processEmbeddedItemMatches(BladesItem$1.GetTypeWithTags(BladesItemType.heritage));
    } else if (category === SelectionCategory.Background) {
      dialogData.Main = this._processEmbeddedItemMatches(BladesItem$1.GetTypeWithTags(BladesItemType.background));
    } else if (category === SelectionCategory.Vice && playbookName !== null) {
      dialogData.Main = this._processEmbeddedItemMatches(BladesItem$1.GetTypeWithTags(BladesItemType.vice, playbookName));
    } else if (category === SelectionCategory.Playbook) {
      dialogData.Basic = this._processEmbeddedItemMatches(
        BladesItem$1.GetTypeWithTags(BladesItemType.playbook).filter((item) => !item.hasTag(Tag.Gear.Advanced))
      );
      dialogData.Advanced = this._processEmbeddedItemMatches(
        BladesItem$1.GetTypeWithTags(BladesItemType.playbook, Tag.Gear.Advanced)
      );
    } else if (category === SelectionCategory.Gear) {
      this.processGearDialogItems(dialogData);
    } else if (category === SelectionCategory.Ability) {
      this._processAbilityDialogItems(dialogData);
    }
    return dialogData;
  }
  getTaggedItemBonuses(tags) {
    return tags.length;
  }
  // #endregion
  // #region BladesRoll.PrimaryDoc Implementation
  get rollPrimaryModsSchemaSet() {
    const rollModsSchemaSet = super.rollPrimaryModsSchemaSet;
    [
      [/1d/, RollModSection.roll],
      [/Less Effect/, RollModSection.effect]
    ].forEach(([effectPat, effectCat]) => {
      const { one: harmConditionOne, two: harmConditionTwo } = Object.values(this.system.harm).find((harmData) => effectPat.test(harmData.effect)) ?? {};
      const harmString = U.objCompact([harmConditionOne, harmConditionTwo === "" ? null : harmConditionTwo]).join(" & ");
      if (harmString.length > 0) {
        rollModsSchemaSet.push({
          key: `Harm-negative-${effectCat}`,
          name: harmString,
          section: effectCat,
          posNeg: "negative",
          base_status: RollModStatus.ToggledOn,
          modType: RollModType.harm,
          value: 1,
          tooltip: [
            `<h1 class='sur-title'>${effectCat === RollModSection.roll ? Harm.Impaired : Harm.Weakened} (Harm)</h1>`,
            `<h1 class='red-bright'>${harmString}</h1>`,
            effectCat === RollModSection.roll ? "<p>If your injuries apply to the situation at hand, you suffer <strong class='red-bright'>−1d</strong> to your roll.</p>" : "<p>If your injuries apply to the situation at hand, you suffer <strong class='red-bright'>−1 effect</strong>."
          ].join("")
        });
      }
    });
    const { one: harmCondition } = Object.values(this.system.harm).find((harmData) => /Need Help/.test(harmData.effect)) ?? {};
    if (harmCondition && harmCondition.trim() !== "") {
      rollModsSchemaSet.push({
        key: "Push-negative-roll",
        name: "PUSH",
        sideString: harmCondition.trim(),
        section: RollModSection.roll,
        posNeg: "negative",
        base_status: RollModStatus.ToggledOn,
        modType: RollModType.harm,
        value: 0,
        effectKeys: ["Cost-Stress2"],
        tooltip: [
          "<h1 class='sur-title'>Broken (Harm)</h1>",
          `<h1 class='red-bright'>${harmCondition.trim()}</h1>`,
          "<p>If your injuries apply to the situation at hand, you must <strong>Push</strong> to act.</p>"
        ].join("")
      });
    }
    return rollModsSchemaSet;
  }
  async applyHarm(num, name) {
    if (num === 4) {
      BladesDirector.getInstance().pushNotice_SocketCall(
        "ALL",
        {
          title: `${this.name} Suffers <u><strong>FATAL</strong></u> Harm: ${name}`,
          body: `${this.name}, will you continue as a Ghost, or create a new character?`,
          type: BladesNoticeType.push,
          cssClasses: "harm-alert fatal-harm-alert"
        }
      );
      return;
    }
    const harmSequence = [
      [["lesser", "one"], ["lesser", "two"]],
      [["moderate", "one"], ["moderate", "two"]],
      [["severe", "one"]]
    ].slice(num - 1).flat(1);
    while (harmSequence.length) {
      const theseHarmKeys = harmSequence.shift();
      if (!theseHarmKeys) {
        break;
      }
      const [thisHarmLevel, thisHarmKey] = theseHarmKeys;
      const thisHarmVal = this.system.harm[thisHarmLevel][thisHarmKey];
      if (!thisHarmVal) {
        BladesDirector.getInstance().pushNotice_SocketCall(
          "ALL",
          {
            title: `${this.name} Suffers ${U.tCase(thisHarmLevel)} Harm: ${name}`,
            type: BladesNoticeType.push,
            cssClasses: "harm-alert"
          }
        );
        await this.update({ [`system.harm.${thisHarmLevel}.${thisHarmKey}`]: name });
        return;
      }
    }
    BladesDirector.getInstance().pushNotice_SocketCall(
      "ALL",
      {
        title: `${this.name} Suffers a Catastrophic, Permanent Injury!`,
        body: `${this.name}, you're out of the action - either left for dead, or otherwise dropped from the action. You can choose to return at the beginning of the next Phase with a permanent injury, or die.`,
        type: BladesNoticeType.push,
        cssClasses: "harm-alert fatal-harm-alert"
      }
    );
  }
  async applyWorsePosition() {
    this.setFlag("eunos-blades", "isWorsePosition", true);
  }
  // #endregion
  // #region BladesRoll.ParticipantDoc Implementation
  get rollParticipantID() {
    return this.id;
  }
  get rollParticipantDoc() {
    return this;
  }
  get rollParticipantIcon() {
    var _a2;
    return ((_a2 = this.playbook) == null ? void 0 : _a2.img) ?? this.img;
  }
  get rollParticipantName() {
    return this.name ?? "";
  }
  get rollParticipantType() {
    return this.type;
  }
  get rollParticipantModsSchemaSet() {
    return [];
  }
  // #endregion
  async adjustStress(deltaStress) {
    const newStress = Math.min(this.stressMax, Math.max(0, this.stress + deltaStress));
    if (newStress === this.stressMax) {
      BladesDirector.getInstance().pushNotice_SocketCall("ALL", {
        title: `${this.name} breaks under the stress!`,
        body: `${this.name}: Select a Trauma Condition on your sheet. You are taken out of action and will no longer participate in this score. Narrate what happens.`,
        type: BladesNoticeType.push,
        cssClasses: "stress-alert"
      });
      await this.update({ "system.stress.value": 0 });
      return;
    }
    await this.update({ "system.stress.value": newStress });
  }
  async indulgeStress(deltaStress) {
    if (deltaStress > this.stress) {
      BladesDirector.getInstance().pushNotice_SocketCall("ALL", {
        title: `${this.name} Overindulges!`,
        body: `${this.name}: Select an option from the list below, and narrate how overindulging your vice led to this result: <ul><li><strong>Attract Trouble:</strong> Roll for an <strong>Entanglement</strong>.</li><li><strong>Brag About Your Exploits:</strong> +2 Heat</li><li><strong>Go AWOL</strong> Vanish for a few weeks. <em>(You will play a different character until the next Downtime Phase, at which point you will return with all Harm healed.)</em></li><li><strong>Tapped:</strong> Your current Vice Purveyor cuts you off. <em>(Until you find a new source for your vice, you will be unable to Indulge Vice during Downtime.)</em></li></ul>`,
        type: BladesNoticeType.push,
        cssClasses: "stress-alert"
      });
    }
    await this.update({ "system.stress.value": this.stress - deltaStress });
  }
  async spendArmor(amount) {
    const updateData = {};
    while (amount > 0) {
      if (this.isLightArmorAvailable) {
        if (!this.isLightArmorEquipped) {
          updateData["system.armor.active.light"] = true;
        }
        updateData["system.armor.checked.light"] = true;
      } else if (this.isHeavyArmorAvailable) {
        if (!this.isHeavyArmorEquipped) {
          updateData["system.armor.active.heavy"] = true;
        }
        updateData["system.armor.checked.heavy"] = true;
      } else {
        throw new Error("No armor available to spend");
      }
      amount--;
    }
    this.update(updateData);
  }
  async spendSpecialArmor() {
    if (this.system.armor.active.special && !this.system.armor.checked.special) {
      await this.update({ "system.armor.checked.special": true });
    }
  }
  get rollTraitPCTooltipActions() {
    const tooltipStrings = ["<table><tbody>"];
    const actionRatings = this.actions;
    Object.values(AttributeTrait).forEach((attribute) => {
      C.Action[attribute].forEach((action) => {
        tooltipStrings.push([
          "<tr>",
          `<td><strong>${U.uCase(action)}</strong></td>`,
          `<td>${"⚪".repeat(actionRatings[action])}</td>`,
          `<td><em style="font-family: 'Minion Pro Cond'; font-size: 10px;">(${C.ShortActionTooltips[action]})</em></td>`,
          "</tr>"
        ].join(""));
      });
    });
    tooltipStrings.push("</tbody></table>");
    return tooltipStrings.join("");
  }
  get rollTraitPCTooltipAttributes() {
    const tooltipStrings = ["<table><tbody>"];
    const attributeRatings = this.attributes;
    Object.values(AttributeTrait).forEach((attribute) => {
      tooltipStrings.push([
        "<tr>",
        `<td><strong>${U.uCase(attribute)}</strong></td>`,
        `<td>${"⚪".repeat(attributeRatings[attribute])}</td>`,
        `<td><em>(${C.ShortAttributeTooltips[attribute]})</em></td>`,
        "</tr>"
      ].join(""));
    });
    tooltipStrings.push("</tbody></table>");
    return tooltipStrings.join("");
  }
  // #endregion
  render(force) {
    super.render(force);
  }
}
const BladesPC$1 = BladesPC;
class BladesNPCSheet extends BladesActorSheet {
  static get defaultOptions() {
    return foundry.utils.mergeObject(super.defaultOptions, {
      classes: ["eunos-blades", "sheet", "actor", "npc"],
      template: "systems/eunos-blades/templates/npc-sheet.hbs",
      width: 500,
      height: 400,
      // height: "auto",
      tabs: [{ navSelector: ".nav-tabs", contentSelector: ".tab-content", initial: "description" }]
    });
  }
  getData() {
    const context3 = super.getData();
    context3.isSubActor = context3.actor.isSubActor;
    context3.parentActor = context3.actor.parentActor;
    context3.persona = context3.actor.system.persona;
    context3.random = context3.actor.system.random;
    context3.secret = context3.actor.system.secret;
    const rStatus = {
      name: { size: 3, label: "Name" },
      gender: { size: "half", label: "Gender" },
      heritage: { size: "third", label: "Heritage" },
      background: { size: "third", label: "Background" },
      profession: { size: "third", label: "Profession" },
      appearance: { size: 2, label: "Appearance" },
      style: { size: 2, label: "Style" },
      quirk: { size: 4, label: "Quirk" },
      goal: { size: 2, label: "Goal" },
      method: { size: 2, label: "Method" },
      interests: { size: 4, label: "Interests" },
      trait: { size: "half", label: "Trait" },
      trait1: { size: "half", label: null },
      trait2: { size: "half", label: null },
      trait3: { size: "half", label: null }
    };
    for (const cat of ["persona", "random", "secret"]) {
      for (const [key] of Object.entries(context3[cat])) {
        if (key in rStatus) {
          Object.assign(
            context3[cat][key],
            rStatus[key]
          );
        }
      }
    }
    console.log({ persona: context3.persona, random: context3.random, secret: context3.secret });
    return context3;
  }
  activateListeners(html) {
    super.activateListeners(html);
    if (!this.options.editable) {
      return;
    }
    html.find(".gm-alert-header").on("click", async (event) => {
      event.preventDefault();
      this.actor.clearParentActor();
    });
    html.find('[data-action="randomize"').on("click", () => {
      this.actor.updateRandomizers();
    });
    html.find(".comp-status-toggle").on("click", () => {
      const { tags } = this.actor;
      if (this.actor.system.status === 1) {
        U.remove(tags, "Friend");
        tags.push("Rival");
        this.actor.update({
          "system.status": -1,
          "system.tags": U.unique(tags)
        });
      } else {
        U.remove(tags, "Rival");
        tags.push("Friend");
        this.actor.update({
          "system.status": 1,
          "system.tags": U.unique(tags)
        });
      }
    }).on("contextmenu", () => {
      this.actor.update({ "system.status": 0 });
    });
  }
}
class BladesNPC extends BladesActor$1 {
  // #region INITIALIZATION ~
  static async Initialize() {
    Object.assign(globalThis, { BladesNPC, BladesNPCSheet });
    Actors.registerSheet("blades", BladesNPCSheet, { types: ["npc"], makeDefault: true });
    return loadTemplates(["systems/eunos-blades/templates/npc-sheet.hbs"]);
  }
  // #endregion
  static IsType(doc) {
    return super.IsType(doc, BladesActorType.npc);
  }
  // #region BladesRoll Implementation
  get rollFactors() {
    const factorData = super.rollFactors;
    factorData[Factor.scale] = {
      name: Factor.scale,
      display: "Scale",
      value: this.getFactorTotal(Factor.scale),
      max: this.getFactorTotal(Factor.scale),
      baseVal: this.getFactorTotal(Factor.scale),
      cssClasses: "factor-grey",
      isActive: false,
      isPrimary: false,
      isDominant: false,
      highFavorsPC: true
    };
    factorData[Factor.magnitude] = {
      name: Factor.magnitude,
      display: "Magnitude",
      value: this.getFactorTotal(Factor.magnitude),
      max: this.getFactorTotal(Factor.magnitude),
      baseVal: this.getFactorTotal(Factor.magnitude),
      isActive: false,
      isPrimary: false,
      isDominant: false,
      highFavorsPC: true
    };
    return factorData;
  }
  // #region BladesRoll.OppositionDoc Implementation
  get rollOppID() {
    return this.id;
  }
  get rollOppDoc() {
    return this;
  }
  get rollOppImg() {
    return this.img;
  }
  get rollOppName() {
    return this.name;
  }
  get rollOppSubName() {
    return this.system.subtitle || this.system.concept || " ";
  }
  get rollOppType() {
    return this.type;
  }
  get rollOppModsSchemaSet() {
    return [];
  }
  // #endregion
  // #region BladesRoll.ParticipantDoc Implementation
  get rollParticipantID() {
    return this.id;
  }
  get rollParticipantDoc() {
    return this;
  }
  get rollParticipantIcon() {
    return this.img;
  }
  get rollParticipantName() {
    return this.name;
  }
  get rollParticipantType() {
    return this.type;
  }
  get rollParticipantModsSchemaSet() {
    return [];
  }
  // #endregion
  // #endregion
}
const BladesNPC$1 = BladesNPC;
class BladesFactionSheet extends BladesActorSheet {
  static get defaultOptions() {
    return foundry.utils.mergeObject(super.defaultOptions, {
      classes: ["eunos-blades", "sheet", "actor", "faction"],
      template: "systems/eunos-blades/templates/faction-sheet.hbs",
      width: 900,
      height: "auto",
      tabs: [{ navSelector: ".nav-tabs", contentSelector: ".tab-content", initial: "overview" }]
    });
  }
  getData() {
    const context3 = super.getData();
    if (!BladesActor$1.IsType(this.actor, BladesActorType.faction)) {
      return context3;
    }
    const sheetData = {
      tierData: {
        class: "comp-tier comp-vertical comp-teeth",
        label: "Tier",
        labelClass: "filled-label full-width",
        dotline: {
          data: this.actor.system.tier,
          target: "system.tier.value",
          svgKey: "teeth.tall",
          svgFull: "full|half|frame",
          svgEmpty: "full|half|frame"
        }
      },
      clockKeys: this.actor.clocks
    };
    return {
      ...context3,
      ...sheetData
    };
  }
  async _onClockAddClick(event) {
    event.preventDefault();
    this.actor.addClock();
  }
  async _onClockDeleteClick(event) {
    event.preventDefault();
    const clockID = $(event.currentTarget).data("clockId");
    if (!clockID) {
      return;
    }
    this.actor.deleteClock(clockID);
  }
  activateListeners(html) {
    super.activateListeners(html);
    if (!this.options.editable) {
      return;
    }
    html.find(".item-body").on("click", (event) => {
      var _a2;
      const element = $(event.currentTarget).parents(".item");
      const item = this.actor.items.get(element.data("itemId"));
      (_a2 = item == null ? void 0 : item.sheet) == null ? void 0 : _a2.render(true);
    });
    html.find(".comp-control.comp-add-clock").on("click", this._onClockAddClick.bind(this));
    html.find(".comp-control.comp-delete-clock").on("click", this._onClockDeleteClick.bind(this));
  }
}
class BladesFaction extends BladesActor$1 {
  // #region INITIALIZATION ~
  static async Initialize() {
    Object.assign(globalThis, { BladesFaction, BladesFactionSheet });
    Actors.registerSheet("blades", BladesFactionSheet, { types: ["faction"], makeDefault: true });
    return loadTemplates(["systems/eunos-blades/templates/faction-sheet.hbs"]);
  }
  // #endregion
  static get All() {
    return new Collection(
      super.GetTypeWithTags(BladesActorType.faction).map((faction) => [faction.id, faction])
    );
  }
  static IsType(doc) {
    return super.IsType(doc, BladesActorType.faction);
  }
  // #region BladesRoll Implementation
  // #region BladesRoll.OppositionDoc Implementation
  get rollOppID() {
    return this.id;
  }
  get rollOppDoc() {
    return this;
  }
  get rollOppImg() {
    return this.img ?? "";
  }
  get rollOppName() {
    return this.name ?? "";
  }
  get rollOppSubName() {
    return this.system.subtitle || this.system.concept || " ";
  }
  get rollOppType() {
    return this.type;
  }
  get rollOppModsSchemaSet() {
    return [];
  }
  // #endregion
  // #endregion
  // _clocks: Collection<BladesClock> = new Collection();
  // get clocks(): Collection<BladesClock> = {
  //   return new Collection()
  // }
  get clocks() {
    return new Collection(
      Object.entries(this.system.clocksData ?? {}).map(([id, data]) => [
        id,
        game.eunoblades.ClockKeys.get(id) ?? new BladesClockKey(data)
      ])
    );
  }
  async addClock() {
    return await BladesClockKey.Create({
      target: this,
      targetKey: "system.clocksData"
    });
  }
  async deleteClock(clockKeyID) {
    var _a2;
    await ((_a2 = game.eunoblades.ClockKeys.get(clockKeyID)) == null ? void 0 : _a2.delete(game.eunoblades.ClockKeys));
  }
}
const BladesFaction$1 = BladesFaction;
class BladesCrewSheet extends BladesActorSheet {
  static get defaultOptions() {
    return foundry.utils.mergeObject(super.defaultOptions, {
      classes: ["eunos-blades", "sheet", "actor", "crew"],
      template: "systems/eunos-blades/templates/crew-sheet.hbs",
      width: 940,
      height: 820,
      tabs: [{ navSelector: ".nav-tabs", contentSelector: ".tab-content", initial: "claims" }]
    });
  }
  getData() {
    const context3 = super.getData();
    eLog.checkLog("actor", "[BladesCrewSheet] super.getData()", { ...context3 });
    const { activeSubItems } = this.actor;
    const sheetData = {};
    sheetData.preparedItems = Object.assign(
      context3.preparedItems ?? {},
      {
        abilities: activeSubItems.filter((item) => item.type === BladesItemType.crew_ability),
        playbook: this.actor.playbook,
        reputation: activeSubItems.find((item) => item.type === BladesItemType.crew_reputation),
        upgrades: activeSubItems.filter((item) => item.type === BladesItemType.crew_upgrade),
        preferredOp: activeSubItems.find((item) => item.type === BladesItemType.preferred_op)
      }
    );
    sheetData.preparedActors = {
      members: this.actor.members,
      contacts: this.actor.contacts
    };
    sheetData.tierData = {
      label: "Tier",
      dotline: {
        data: this.actor.system.tier,
        target: "system.tier.value",
        iconEmpty: "dot-empty.svg",
        iconEmptyHover: "dot-empty-hover.svg",
        iconFull: "dot-full.svg",
        iconFullHover: "dot-full-hover.svg"
      }
    };
    sheetData.upgradeData = {
      dotline: {
        dotlineClass: "dotline-right",
        data: {
          value: this.actor.availableUpgradePoints,
          max: this.actor.availableUpgradePoints
        },
        dotlineLabel: "Available Upgrade Points",
        isLocked: true,
        iconFull: "dot-full.svg"
      }
    };
    sheetData.abilityData = {
      dotline: {
        dotlineClass: "dotline-right",
        data: {
          value: this.actor.availableAbilityPoints,
          max: this.actor.availableAbilityPoints
        },
        dotlineLabel: "Available Ability Points",
        isLocked: true,
        iconFull: "dot-full.svg"
      }
    };
    sheetData.cohortData = {
      dotline: {
        dotlineClass: "dotline-right",
        data: {
          value: this.actor.availableCohortPoints,
          max: this.actor.availableCohortPoints
        },
        dotlineLabel: "Available Cohort Points",
        isLocked: true,
        iconFull: "dot-full.svg"
      }
    };
    sheetData.repData = {
      label: "Rep",
      dotlines: [
        {
          data: {
            value: Math.min(this.actor.system.rep.value, this.actor.system.rep.max - this.actor.turfCount),
            max: this.actor.system.rep.max - this.actor.turfCount
          },
          target: "system.rep.value",
          svgKey: "teeth.tall",
          svgFull: "full|half|frame",
          svgEmpty: "full|half|frame"
        },
        {
          data: {
            value: this.actor.turfCount,
            max: this.actor.turfCount
          },
          target: "none",
          svgKey: "teeth.tall",
          svgFull: "full|half|frame",
          svgEmpty: "full|half|frame",
          dotlineClass: "flex-row-reverse",
          isLocked: true
        }
      ]
    };
    sheetData.heatData = {
      label: "Heat",
      dotline: {
        data: this.actor.system.heat,
        target: "system.heat.value",
        svgKey: "teeth.tall",
        svgFull: "full|half|frame",
        svgEmpty: "full|half|frame"
      }
    };
    sheetData.wantedData = {
      label: "Wanted",
      dotline: {
        data: this.actor.system.wanted,
        target: "system.wanted.value",
        svgKey: "teeth.short",
        svgFull: "full|frame",
        svgEmpty: "frame"
      }
    };
    eLog.checkLog("actor", "[BladesCrewSheet] return getData()", { ...context3, ...sheetData });
    return { ...context3, ...sheetData };
  }
  activateListeners(html) {
    super.activateListeners(html);
    if (!this.options.editable) {
      return;
    }
    html.find(".item-sheet-open").on("click", (event) => {
      var _a2;
      const element = $(event.currentTarget).parents(".item");
      const item = this.actor.items.get(element.data("itemId"));
      (_a2 = item == null ? void 0 : item.sheet) == null ? void 0 : _a2.render(true);
    });
    html.find(".hold-toggle").on("click", () => {
      this.actor.update({ "system.hold": this.actor.system.hold === "weak" ? "strong" : "weak" });
    });
    html.find(".turf-select").on("click", async (event) => {
      var _a2;
      const turf_id = $(event.currentTarget).data("turfId");
      const turf_current_status = $(event.currentTarget).data("turfStatus");
      (_a2 = this.actor.playbook) == null ? void 0 : _a2.update({ [`system.turfs.${turf_id}.value`]: !turf_current_status }).then(() => this.render(false));
    });
  }
}
class BladesCrew extends BladesActor$1 {
  // #region INITIALIZATION ~
  static async Initialize() {
    Object.assign(globalThis, { BladesCrew, BladesCrewSheet });
    Actors.registerSheet("blades", BladesCrewSheet, { types: ["crew"], makeDefault: true });
    return loadTemplates(["systems/eunos-blades/templates/crew-sheet.hbs"]);
  }
  // #endregion
  // #region Static Overrides: Create ~
  // static override IsType<T extends BladesActorType = BladesActorType.crew>(doc: unknown): doc is BladesActorOfType<T> {
  //   return super.IsType(doc, BladesActorType.crew);
  // }
  static IsType(doc) {
    return super.IsType(doc, BladesActorType.crew);
  }
  static GetFromUser(userRef) {
    const actor = BladesPC$1.GetFromUser(userRef);
    if (!actor) {
      return void 0;
    }
    return actor.crew;
  }
  static GetFromPC(pcRef) {
    let actor;
    if (typeof pcRef === "string") {
      actor = game.actors.get(pcRef) ?? game.actors.getName(pcRef);
    } else if (pcRef instanceof BladesPC$1) {
      actor = pcRef;
    } else {
      actor ?? (actor = BladesPC$1.GetFromUser(pcRef));
    }
    if (!BladesPC$1.IsType(actor)) {
      throw new Error(`Unable to find BladesPC from '${pcRef}'`);
    }
    return actor.crew;
  }
  static async create(data, options = {}) {
    data.token = data.token || {};
    data.system = data.system ?? {};
    eLog.checkLog2("actor", "BladesActor.create(data,options)", { data, options });
    data.token.actorLink = true;
    data.system.world_name = data.system.world_name ?? data.name.replace(/[^A-Za-z_0-9 ]/g, "").trim().replace(/ /g, "_");
    data.system.experience = {
      playbook: { value: 0, max: 8 },
      clues: [],
      ...data.system.experience ?? {}
    };
    return super.create(data, options);
  }
  // #endregion
  // #region BladesCrew Implementation
  getDialogItems(category) {
    const dialogData = {};
    const { playbookName } = this;
    if (category === SelectionCategory.Playbook) {
      dialogData.Main = this._processEmbeddedItemMatches(BladesItem$1.GetTypeWithTags(BladesItemType.crew_playbook));
    } else if (category === SelectionCategory.Reputation) {
      dialogData.Main = this._processEmbeddedItemMatches(BladesItem$1.GetTypeWithTags(BladesItemType.crew_reputation));
    } else if (category === SelectionCategory.Preferred_Op && playbookName !== null) {
      dialogData.Main = this._processEmbeddedItemMatches(
        BladesItem$1.GetTypeWithTags(BladesItemType.preferred_op, playbookName)
      );
    } else if (category === SelectionCategory.Ability) {
      dialogData.Main = this._processEmbeddedItemMatches(
        BladesItem$1.GetTypeWithTags(BladesItemType.crew_ability, this.playbookName)
      );
    } else if (category === SelectionCategory.Upgrade && playbookName !== null) {
      dialogData[playbookName] = this._processEmbeddedItemMatches(
        BladesItem$1.GetTypeWithTags(BladesItemType.crew_upgrade, playbookName)
      );
      dialogData.General = this._processEmbeddedItemMatches(
        BladesItem$1.GetTypeWithTags(BladesItemType.crew_upgrade, Tag.Gear.General)
      );
    }
    return dialogData;
  }
  get members() {
    if (!BladesActor$1.IsType(this, BladesActorType.crew)) {
      return [];
    }
    const self2 = this;
    return BladesActor$1.GetTypeWithTags(BladesActorType.pc).filter((actor) => actor.isMember(self2));
  }
  get contacts() {
    if (!BladesActor$1.IsType(this, BladesActorType.crew) || !this.playbook) {
      return [];
    }
    const self2 = this;
    return this.activeSubActors.filter((actor) => actor.hasTag(self2.playbookName));
  }
  get claims() {
    if (!BladesActor$1.IsType(this, BladesActorType.crew) || !this.playbook) {
      return {};
    }
    return this.playbook.system.turfs;
  }
  get turfCount() {
    if (!BladesActor$1.IsType(this, BladesActorType.crew) || !this.playbook) {
      return 0;
    }
    return Object.values(this.playbook.system.turfs).filter((claim) => claim.isTurf && claim.value).length;
  }
  get upgrades() {
    if (!BladesActor$1.IsType(this, BladesActorType.crew) || !this.playbook) {
      return [];
    }
    return this.activeSubItems.filter((item) => item.type === BladesItemType.crew_upgrade);
  }
  get cohorts() {
    return this.activeSubItems.filter((item) => [BladesItemType.cohort_gang, BladesItemType.cohort_expert].includes(item.type));
  }
  getTaggedItemBonuses(tags) {
    return tags.length;
  }
  // #endregion
  // #region BladesRoll Implementation
  // #region BladesRoll.ParticipantDoc Implementation
  get rollParticipantID() {
    return this.id;
  }
  get rollParticipantDoc() {
    return this;
  }
  get rollParticipantIcon() {
    var _a2;
    return ((_a2 = this.playbook) == null ? void 0 : _a2.img) ?? this.img;
  }
  get rollParticipantName() {
    return this.name;
  }
  get rollParticipantType() {
    return this.type;
  }
  get rollParticipantModsSchemaSet() {
    return [];
  }
  async applyHarm(_amount, _name) {
    console.error("Attempt to apply harm directly to a Crew document.");
  }
  async applyWorsePosition() {
    console.error("Attempt to apply worse position directly to a Crew document.");
  }
  // #endregion
  // #endregion
  get abilities() {
    if (!this.playbook) {
      return [];
    }
    return this.activeSubItems.filter((item) => [BladesItemType.ability, BladesItemType.crew_ability].includes(item.type));
  }
  get playbookName() {
    var _a2;
    return (_a2 = this.playbook) == null ? void 0 : _a2.name;
  }
  get playbook() {
    return this.activeSubItems.find((item) => item.type === BladesItemType.crew_playbook);
  }
}
const BladesCrew$1 = BladesCrew;
const ActorsMap = {
  [BladesActorType.pc]: BladesPC$1,
  [BladesActorType.npc]: BladesNPC$1,
  [BladesActorType.faction]: BladesFaction$1,
  [BladesActorType.crew]: BladesCrew$1
};
const BladesActorProxy = new Proxy(function() {
}, {
  construct(_, args) {
    const [{ type }] = args;
    if (!type) {
      throw new Error(`Invalid Actor Type: ${String(type)}`);
    }
    const MappedConstructor = ActorsMap[type];
    if (!MappedConstructor) {
      return new BladesActor$1(...args);
    }
    return new MappedConstructor(...args);
  },
  get(_, prop) {
    switch (prop) {
      case "create":
      case "createDocuments":
        return function(data, options = {}) {
          if (U.isArray(data)) {
            return data.map((i) => CONFIG.Actor.documentClass.create(i, options));
          }
          const MappedConstructor = ActorsMap[data.type];
          if (!MappedConstructor) {
            return BladesActor$1.create(data, options);
          }
          return MappedConstructor.create(data, options);
        };
      case Symbol.hasInstance:
        return function(instance) {
          return Object.values(ActorsMap).some((i) => instance instanceof i);
        };
      default:
        return BladesActor$1[prop];
    }
  }
});
class BladesChat extends ChatMessage {
  static Initialize() {
    Hooks.on("renderChatMessage", (msg, html) => {
      ApplyTooltipAnimations(html);
      if (msg.isBladesRoll) {
        html.addClass("blades-chat-message");
        html.addClass("blades-roll-message");
        BladesConsequence.ApplyChatListeners(msg);
      }
      html.addClass("display-ok");
    });
    return loadTemplates([
      "systems/eunos-blades/templates/chat/blades-message.hbs",
      "systems/eunos-blades/templates/chat/roll-result/action.hbs",
      "systems/eunos-blades/templates/chat/roll-result/action-clock.hbs",
      "systems/eunos-blades/templates/chat/roll-result/action-acquireasset.hbs",
      "systems/eunos-blades/templates/chat/roll-result/action-reduceheat.hbs",
      "systems/eunos-blades/templates/chat/roll-result/action-clock-recover.hbs",
      "systems/eunos-blades/templates/chat/roll-result/action-gatherinfo.hbs",
      "systems/eunos-blades/templates/chat/roll-result/fortune.hbs",
      "systems/eunos-blades/templates/chat/roll-result/fortune-clock.hbs",
      "systems/eunos-blades/templates/chat/roll-result/fortune-gatherinfo.hbs",
      "systems/eunos-blades/templates/chat/roll-result/fortune-incarceration.hbs",
      "systems/eunos-blades/templates/chat/roll-result/fortune-engagement.hbs",
      "systems/eunos-blades/templates/chat/roll-result/indulgevice.hbs",
      "systems/eunos-blades/templates/chat/roll-result/resistance.hbs",
      "systems/eunos-blades/templates/chat/components/inline-resistance.hbs",
      "systems/eunos-blades/templates/chat/components/die.hbs"
    ]);
  }
  static get template() {
    return "systems/eunos-blades/templates/chat/blades-message.hbs";
  }
  static async create(data, options = {}) {
    if (data.bladesRoll) {
      ({ data, options } = await BladesChat.ConstructBladesRollData(
        data,
        options
      ));
    } else {
      ({ data, options } = await BladesChat.ConstructBladesChatMessageData(
        data,
        options
      ));
    }
    return super.create(data, options);
  }
  static async ConstructBladesRollData(data, options = {}) {
    const { bladesRoll, ...baseChatData } = data;
    const msgData = {
      speaker: bladesRoll.getSpeaker(BladesChat.getSpeaker()),
      content: await renderTemplate(bladesRoll.chatTemplate, bladesRoll.data),
      type: CONST.CHAT_MESSAGE_TYPES.ROLL,
      flags: {
        "eunos-blades": {
          template: bladesRoll.chatTemplate,
          rollData: bladesRoll.data
        }
      }
    };
    return { data: {
      ...baseChatData,
      ...msgData
    }, options };
  }
  static async ConstructBladesChatMessageData(data, options = {}) {
    var _a2;
    function getUser(cData) {
      if (typeof cData.user === "string") {
        return game.users.get(cData.user);
      } else if (cData.user instanceof User) {
        return cData.user;
      }
      return void 0;
    }
    const context3 = {
      ...data
    };
    const blockClasses = [];
    const user = getUser(data);
    if (data.type === CONST.CHAT_MESSAGE_TYPES.OOC) {
      blockClasses.push("blades-ooc-message");
      if (user) {
        context3.speakerName = user.name ?? void 0;
        if (user.isGM) {
          blockClasses.push("blades-gm-message");
          context3.speakerPortrait = C.GM_PORTRAIT;
        } else if (user.character) {
          context3.speakerPortrait = user.character.img;
        }
      }
    } else {
      blockClasses.push("blades-ic-message");
      let speakingChar;
      if ((_a2 = data.speaker) == null ? void 0 : _a2.actor) {
        if (typeof data.speaker.actor === "string") {
          speakingChar = game.actors.get(data.speaker.actor);
        } else if (data.speaker.actor instanceof BladesActor$1) {
          speakingChar = data.speaker.actor;
        }
      }
      if (!speakingChar) {
        if (user == null ? void 0 : user.isGM) {
          blockClasses.push("blades-gm-message");
          context3.speakerName = "The Gamemaster";
          context3.speakerPortrait = C.GM_PORTRAIT;
        } else if (user == null ? void 0 : user.character) {
          speakingChar = user.character;
        }
      }
      if (speakingChar && !context3.speakerPortrait) {
        context3.speakerName = speakingChar.name;
        context3.speakerPortrait = speakingChar.img;
      }
    }
    context3.blockClasses = blockClasses.join(" ");
    data.content = await renderTemplate(BladesChat.template, context3);
    return { data, options };
  }
  static IsNewestRollResult(rollInst) {
    const lastRollResultID = $("#chat-log .chat-message .blades-roll:not(.inline-roll)").last().attr("id");
    return typeof lastRollResultID === "string" && lastRollResultID === rollInst.id;
  }
  get whisperTargets() {
    return this.whisper.map((userID) => game.users.get(userID)).filter(Boolean);
  }
  get isWhisper() {
    return this.type === CONST.CHAT_MESSAGE_TYPES.WHISPER;
  }
  get isWhisperToGM() {
    return this.whisperTargets.some((user) => user.isGM);
  }
  get isWhisperFromGM() {
    var _a2;
    return this.isWhisper && ((_a2 = this.user) == null ? void 0 : _a2.isGM);
  }
  get isBladesRoll() {
    return this.flagData && "rollData" in this.flagData;
  }
  get isOtherRoll() {
    return !this.isBladesRoll && this.type === CONST.CHAT_MESSAGE_TYPES.ROLL;
  }
  get isEmote() {
    return this.type === CONST.CHAT_MESSAGE_TYPES.EMOTE;
  }
  get isOOC() {
    return this.type === CONST.CHAT_MESSAGE_TYPES.OOC;
  }
  get isIC() {
    return this.type === CONST.CHAT_MESSAGE_TYPES.IC;
  }
  get flagData() {
    var _a2;
    return ((_a2 = this.flags) == null ? void 0 : _a2["eunos-blades"]) ?? {};
  }
  get rollData() {
    return this.flagData.rollData;
  }
  get parentRoll() {
    if (!this.isBladesRoll) {
      return void 0;
    }
    const { rollData } = this.flagData;
    if (!rollData) {
      return void 0;
    }
    return game.eunoblades.Rolls.get(rollData.id ?? "") ?? new BladesRoll$1({
      ...rollData,
      isScopingById: false
    });
  }
  async setFlagVal(scope, key, val) {
    return await this.setFlag(C.SYSTEM_ID, `${scope}.${key}`, val);
  }
  get allRollConsequences() {
    const returnData = {
      [Position.controlled]: {
        [RollResult.critical]: {},
        [RollResult.success]: {},
        [RollResult.partial]: {},
        [RollResult.fail]: {}
      },
      [Position.risky]: {
        [RollResult.critical]: {},
        [RollResult.success]: {},
        [RollResult.partial]: {},
        [RollResult.fail]: {}
      },
      [Position.desperate]: {
        [RollResult.critical]: {},
        [RollResult.success]: {},
        [RollResult.partial]: {},
        [RollResult.fail]: {}
      }
    };
    const { consequenceData } = this.flagData.rollData ?? {};
    if (!consequenceData) {
      return returnData;
    }
    Object.entries(consequenceData).forEach(([position, positionData]) => {
      Object.entries(positionData).forEach(([rollResult, csqDataSet]) => {
        returnData[position][rollResult] = Object.fromEntries(
          Object.entries(csqDataSet).filter(([_id2, cData]) => cData.id).map(([id, cData]) => [
            id,
            game.eunoblades.Consequences.get(cData.id) ?? new BladesConsequence(cData)
          ])
        );
      });
    });
    return returnData;
  }
  get rollConsequences() {
    var _a2;
    if (!this.parentRoll) {
      return [];
    }
    const { rollPositionFinal, rollResult, consequenceData } = this.parentRoll.data;
    if (!rollPositionFinal || !rollResult || !consequenceData) {
      return [];
    }
    if (typeof rollResult !== "string" || ![RollResult.partial, RollResult.fail].includes(rollResult)) {
      return [];
    }
    const activeConsequences = ((_a2 = consequenceData == null ? void 0 : consequenceData[rollPositionFinal]) == null ? void 0 : _a2[rollResult]) ?? {};
    return Object.values(activeConsequences).map((cData) => game.eunoblades.Consequences.get(cData.id) ?? new BladesConsequence(cData));
  }
  get elem$() {
    return $("#chat-log").find(`.chat-message[data-message-id="${this.id}"]`);
  }
  get elem() {
    return this.elem$[0];
  }
  get roll$() {
    return this.parentRoll ? this.elem$.find(`#${this.parentRoll.id}`) : void 0;
  }
  async regenerateFromFlags() {
    if (this.isBladesRoll) {
      await this.update({ content: await renderTemplate(this.flagData.template, this) });
    }
  }
  render(force) {
    super.render(force);
    return this.activateListeners();
  }
  async activateListeners() {
    if (!this.elem$) {
      eLog.error("BladesChat", `No BladesChat.elem found for id ${this.id}.`);
      return;
    }
    ApplyTooltipAnimations(this.elem$);
    BladesConsequence.ApplyChatListeners(this);
    if (this.isBladesRoll) {
      const { parentRoll } = this;
      if (!parentRoll) {
        throw new Error(`BladesChat.activateListeners: No parentRoll found for id ${this.id}.`);
      }
      this.elem$.addClass(`${parentRoll.rollType.toLowerCase()}-roll`);
      if (parentRoll.rollType === RollType.Action && this.rollConsequences.some((csq) => !csq.isAccepted)) {
        this.elem$.addClass("unresolved-action-roll");
      } else {
        this.elem$.removeClass("unresolved-action-roll");
      }
      if (BladesChat.IsNewestRollResult(parentRoll)) {
        $("#chat-log .chat-message").removeClass("active-chat-roll");
        this.elem$.addClass("active-chat-roll");
      } else {
        this.elem$.removeClass("active-chat-roll");
      }
    }
    if (this.isWhisper) {
      if (this.isWhisperToGM) {
        this.elem$.addClass("blades-whisper-to-gm");
      } else if (this.isWhisperFromGM) {
        this.elem$.addClass("blades-whisper-from-gm");
      } else {
        this.elem$.addClass("blades-player-whisper");
      }
    }
    if (this.isEmote) {
      this.elem$.addClass("blades-emote");
    }
    if (this.isIC) {
      this.elem$.addClass("blades-ic");
    }
    if (this.isOOC) {
      this.elem$.addClass("blades-ooc");
    }
    U.gsap.to(this.elem$, { autoAlpha: 1, duration: 0.15, ease: "none" });
  }
}
const BladesChat$1 = BladesChat;
const LOGGERCONFIG = {
  fullName: "eLogger",
  aliases: ["dbLog"],
  stackTraceExclusions: {
    handlebars: [/scripts\/handlebars/]
    // From internal Handlebars module
  }
};
const STYLES = {
  base: {
    "background": getColor("black"),
    "color": getColor("gold", "dark"),
    "font-family": "Pragmata Pro",
    "padding": "0 25px",
    "margin-right": "25px"
  },
  log0: {
    "background": getColor("gold", "dark"),
    "color": getColor("black", "dark"),
    "font-size": "16px"
  },
  log1: {
    "background": getColor("black", "dark"),
    "color": getColor("gold", "bright"),
    "font-size": "16px"
  },
  log2: {
    "background": getColor("black", "dark"),
    "color": getColor("gold", "dark"),
    "font-size": "16px"
  },
  log3: {
    "font-size": "14px"
  },
  log4: {
    "font-size": "12px"
  },
  log5: {
    "background": getColor("grey", "dark"),
    "color": getColor("grey", "bright"),
    "font-size": "10px"
  },
  display: {
    "color": getColor("gold", "bright"),
    "font-family": "Kirsty",
    "font-size": "16px",
    "margin-left": "-100px",
    "padding": "0 100px"
  },
  warn: {
    "color": getColor("black", "dark"),
    "background": getColor("gold", "dark"),
    "font-weight": 500
  },
  error: {
    "color": getColor("red", "bright"),
    "background": getColor("red", "darkest"),
    "font-weight": 500
  },
  handlebars: {
    "background": getColor("grey"),
    "color": getColor("blue"),
    "font-family": "Pragmata Pro",
    "padding": "0",
    "margin-right": "25px"
  },
  stack: {
    "color": getColor("gold"),
    "font-weight": 100,
    "font-size": "10px",
    "font-family": "Pragmata Pro"
  }
};
const { base: baseStyles, ...typeStyles } = STYLES;
const STYLELINES = Object.fromEntries(
  Object.entries(typeStyles).map(([styleName, styles]) => [
    styleName,
    Object.entries({ ...baseStyles, ...styles }).map(([prop, val]) => `${prop}: ${val};`).join(" ")
  ])
);
const eLogger = (type = "base", ...content) => {
  if (!(["error", "display"].includes(type) || CONFIG.debug.logging)) {
    return;
  }
  const lastElem = U.getLast(content);
  let dbLevel = typeof lastElem === "number" && [0, 1, 2, 3, 4, 5].includes(lastElem) ? content.pop() : 3;
  let key = false;
  if (type === "checkLog") {
    key = content.shift();
    type = `log${dbLevel}`;
  }
  const [message, ...data] = content;
  if (key) {
    const blacklist = (U.getSetting("blacklist", "debugSettings") ?? "").split(/,/).map((pat) => new RegExp(`\\b${pat.trim()}\\b`, "igu"));
    const whitelist = (U.getSetting("whitelist", "debugSettings") ?? "").split(/,/).map((pat) => new RegExp(`\\b${pat.trim()}\\b`, "igu"));
    const isBlack = blacklist.some((pat) => pat.test(key));
    const isWhite = whitelist.some((pat) => pat.test(key));
    if (isBlack && !isWhite) {
      dbLevel = Math.max(4, Math.min(5, dbLevel + 2));
    }
    if (isWhite && !isBlack) {
      dbLevel = Math.min(3, Math.max(1, dbLevel - 2));
    }
  }
  if ((U.getSetting("debugLevel", "debugSettings") ?? 5) < dbLevel) {
    return;
  }
  if (type === "log") {
    type = `${type}${dbLevel}`;
  }
  const stackTrace = type === "display" ? null : getStackTrace(LOGGERCONFIG.stackTraceExclusions[type] ?? []);
  let logFunc;
  if (stackTrace) {
    logFunc = console.groupCollapsed;
  } else if (data.length <= 1) {
    logFunc = console.log;
  } else {
    logFunc = console.group;
  }
  if (data.length === 0) {
    if (typeof message === "string") {
      logFunc(`%c${message}`, STYLELINES[type]);
    } else {
      logFunc("%o", message);
    }
  } else {
    logFunc(`%c${message}${typeof data[0] === "string" ? "" : " %o"}`, STYLELINES[type], data.shift());
    data.forEach((line) => {
      if (typeof line === "string") {
        console.log(line);
      } else {
        console.log("%o", line);
      }
    });
  }
  if (stackTrace) {
    console.group("%cSTACK TRACE", `color: ${getColor("gold", "dark")}; font-family: "Pragmata Pro"; font-size: 12px; background: ${getColor("black")}; font-weight: bold; padding: 0 10px;`);
    console.log(`%c${stackTrace}`, Object.entries(STYLES.stack).map(([prop, val]) => `${prop}: ${val};`).join(" "));
    console.groupEnd();
  }
  console.groupEnd();
  function getStackTrace(regExpFilters = []) {
    regExpFilters.push(new RegExp(`at (getStackTrace|${LOGGERCONFIG.fullName}|${LOGGERCONFIG.aliases.map(String).join("|")}|Object\\.(log|display|hbsLog|error))`), /^Error/);
    return (new Error().stack ?? "").split(/\n/).map((sLine) => sLine.trim()).filter((sLine) => !regExpFilters.some((rTest) => rTest.test(sLine))).join("\n");
  }
};
const logger = {
  display: (...content) => eLogger("display", ...content),
  log0: (...content) => eLogger("log", ...content, 0),
  log1: (...content) => eLogger("log", ...content, 1),
  log2: (...content) => eLogger("log", ...content, 2),
  log: (...content) => eLogger("log", ...content, 3),
  log3: (...content) => eLogger("log", ...content, 3),
  log4: (...content) => eLogger("log", ...content, 4),
  log5: (...content) => eLogger("log", ...content, 5),
  checkLog0: (...content) => eLogger("checkLog", ...content, 0),
  checkLog1: (...content) => eLogger("checkLog", ...content, 1),
  checkLog2: (...content) => eLogger("checkLog", ...content, 2),
  checkLog: (...content) => eLogger("checkLog", ...content, 3),
  checkLog3: (...content) => eLogger("checkLog", ...content, 3),
  checkLog4: (...content) => eLogger("checkLog", ...content, 4),
  checkLog5: (...content) => eLogger("checkLog", ...content, 5),
  warn: (...content) => eLogger("warn", ...content),
  error: (...content) => eLogger("error", ...content),
  hbsLog: (...content) => eLogger("handlebars", ...content)
};
class BladesScene extends Scene {
  async registerClockKey(clockKey) {
    this.update({ [`clockKeys.${clockKey.id}`]: true });
  }
  async unregisterClockKey(clockKey) {
    if (typeof clockKey === "string") {
      this.update({ [`clockKeys.-=${clockKey}`]: null });
    } else {
      this.update({ [`clockKeys.-=${clockKey.id}`]: null });
    }
  }
}
const VERSION = "4.29.2";
let auto = false;
let kind = void 0;
let fetch$1 = void 0;
let FormData$1 = void 0;
let File$1 = void 0;
let ReadableStream$1 = void 0;
let getMultipartRequestOptions = void 0;
let getDefaultAgent = void 0;
let fileFromPath = void 0;
let isFsReadStream = void 0;
function setShims(shims, options = { auto: false }) {
  if (auto) {
    throw new Error(`you must \`import 'openai/shims/${shims.kind}'\` before importing anything else from openai`);
  }
  if (kind) {
    throw new Error(`can't \`import 'openai/shims/${shims.kind}'\` after \`import 'openai/shims/${kind}'\``);
  }
  auto = options.auto;
  kind = shims.kind;
  fetch$1 = shims.fetch;
  shims.Request;
  shims.Response;
  shims.Headers;
  FormData$1 = shims.FormData;
  shims.Blob;
  File$1 = shims.File;
  ReadableStream$1 = shims.ReadableStream;
  getMultipartRequestOptions = shims.getMultipartRequestOptions;
  getDefaultAgent = shims.getDefaultAgent;
  fileFromPath = shims.fileFromPath;
  isFsReadStream = shims.isFsReadStream;
}
class MultipartBody {
  constructor(body) {
    this.body = body;
  }
  get [Symbol.toStringTag]() {
    return "MultipartBody";
  }
}
function getRuntime({ manuallyImported } = {}) {
  const recommendation = manuallyImported ? `You may need to use polyfills` : `Add one of these imports before your first \`import … from 'openai'\`:
- \`import 'openai/shims/node'\` (if you're running on Node)
- \`import 'openai/shims/web'\` (otherwise)
`;
  let _fetch, _Request, _Response, _Headers;
  try {
    _fetch = fetch;
    _Request = Request;
    _Response = Response;
    _Headers = Headers;
  } catch (error) {
    throw new Error(`this environment is missing the following Web Fetch API type: ${error.message}. ${recommendation}`);
  }
  return {
    kind: "web",
    fetch: _fetch,
    Request: _Request,
    Response: _Response,
    Headers: _Headers,
    FormData: (
      // @ts-ignore
      typeof FormData !== "undefined" ? FormData : class FormData {
        // @ts-ignore
        constructor() {
          throw new Error(`file uploads aren't supported in this environment yet as 'FormData' is undefined. ${recommendation}`);
        }
      }
    ),
    Blob: typeof Blob !== "undefined" ? Blob : class Blob {
      constructor() {
        throw new Error(`file uploads aren't supported in this environment yet as 'Blob' is undefined. ${recommendation}`);
      }
    },
    File: (
      // @ts-ignore
      typeof File !== "undefined" ? File : class File {
        // @ts-ignore
        constructor() {
          throw new Error(`file uploads aren't supported in this environment yet as 'File' is undefined. ${recommendation}`);
        }
      }
    ),
    ReadableStream: (
      // @ts-ignore
      typeof ReadableStream !== "undefined" ? ReadableStream : class ReadableStream {
        // @ts-ignore
        constructor() {
          throw new Error(`streaming isn't supported in this environment yet as 'ReadableStream' is undefined. ${recommendation}`);
        }
      }
    ),
    getMultipartRequestOptions: async (form, opts) => ({
      ...opts,
      body: new MultipartBody(form)
    }),
    getDefaultAgent: (url) => void 0,
    fileFromPath: () => {
      throw new Error("The `fileFromPath` function is only supported in Node. See the README for more details: https://www.github.com/openai/openai-node#file-uploads");
    },
    isFsReadStream: (value) => false
  };
}
if (!kind)
  setShims(getRuntime(), { auto: true });
class OpenAIError extends Error {
}
class APIError extends OpenAIError {
  constructor(status, error, message, headers) {
    super(`${APIError.makeMessage(status, error, message)}`);
    this.status = status;
    this.headers = headers;
    const data = error;
    this.error = data;
    this.code = data == null ? void 0 : data["code"];
    this.param = data == null ? void 0 : data["param"];
    this.type = data == null ? void 0 : data["type"];
  }
  static makeMessage(status, error, message) {
    const msg = (error == null ? void 0 : error.message) ? typeof error.message === "string" ? error.message : JSON.stringify(error.message) : error ? JSON.stringify(error) : message;
    if (status && msg) {
      return `${status} ${msg}`;
    }
    if (status) {
      return `${status} status code (no body)`;
    }
    if (msg) {
      return msg;
    }
    return "(no status code or body)";
  }
  static generate(status, errorResponse, message, headers) {
    if (!status) {
      return new APIConnectionError({ cause: castToError(errorResponse) });
    }
    const error = errorResponse == null ? void 0 : errorResponse["error"];
    if (status === 400) {
      return new BadRequestError(status, error, message, headers);
    }
    if (status === 401) {
      return new AuthenticationError(status, error, message, headers);
    }
    if (status === 403) {
      return new PermissionDeniedError(status, error, message, headers);
    }
    if (status === 404) {
      return new NotFoundError(status, error, message, headers);
    }
    if (status === 409) {
      return new ConflictError(status, error, message, headers);
    }
    if (status === 422) {
      return new UnprocessableEntityError(status, error, message, headers);
    }
    if (status === 429) {
      return new RateLimitError(status, error, message, headers);
    }
    if (status >= 500) {
      return new InternalServerError(status, error, message, headers);
    }
    return new APIError(status, error, message, headers);
  }
}
class APIUserAbortError extends APIError {
  constructor({ message } = {}) {
    super(void 0, void 0, message || "Request was aborted.", void 0);
    this.status = void 0;
  }
}
class APIConnectionError extends APIError {
  constructor({ message, cause }) {
    super(void 0, void 0, message || "Connection error.", void 0);
    this.status = void 0;
    if (cause)
      this.cause = cause;
  }
}
class APIConnectionTimeoutError extends APIConnectionError {
  constructor({ message } = {}) {
    super({ message: message ?? "Request timed out." });
  }
}
class BadRequestError extends APIError {
  constructor() {
    super(...arguments);
    this.status = 400;
  }
}
class AuthenticationError extends APIError {
  constructor() {
    super(...arguments);
    this.status = 401;
  }
}
class PermissionDeniedError extends APIError {
  constructor() {
    super(...arguments);
    this.status = 403;
  }
}
class NotFoundError extends APIError {
  constructor() {
    super(...arguments);
    this.status = 404;
  }
}
class ConflictError extends APIError {
  constructor() {
    super(...arguments);
    this.status = 409;
  }
}
class UnprocessableEntityError extends APIError {
  constructor() {
    super(...arguments);
    this.status = 422;
  }
}
class RateLimitError extends APIError {
  constructor() {
    super(...arguments);
    this.status = 429;
  }
}
class InternalServerError extends APIError {
}
class Stream {
  constructor(iterator, controller) {
    this.iterator = iterator;
    this.controller = controller;
  }
  static fromSSEResponse(response, controller) {
    let consumed = false;
    const decoder = new SSEDecoder();
    async function* iterMessages() {
      if (!response.body) {
        controller.abort();
        throw new OpenAIError(`Attempted to iterate over a response with no body`);
      }
      const lineDecoder = new LineDecoder();
      const iter = readableStreamAsyncIterable(response.body);
      for await (const chunk of iter) {
        for (const line of lineDecoder.decode(chunk)) {
          const sse = decoder.decode(line);
          if (sse)
            yield sse;
        }
      }
      for (const line of lineDecoder.flush()) {
        const sse = decoder.decode(line);
        if (sse)
          yield sse;
      }
    }
    async function* iterator() {
      if (consumed) {
        throw new Error("Cannot iterate over a consumed stream, use `.tee()` to split the stream.");
      }
      consumed = true;
      let done = false;
      try {
        for await (const sse of iterMessages()) {
          if (done)
            continue;
          if (sse.data.startsWith("[DONE]")) {
            done = true;
            continue;
          }
          if (sse.event === null) {
            let data;
            try {
              data = JSON.parse(sse.data);
            } catch (e) {
              console.error(`Could not parse message into JSON:`, sse.data);
              console.error(`From chunk:`, sse.raw);
              throw e;
            }
            if (data && data.error) {
              throw new APIError(void 0, data.error, void 0, void 0);
            }
            yield data;
          } else {
            let data;
            try {
              data = JSON.parse(sse.data);
            } catch (e) {
              console.error(`Could not parse message into JSON:`, sse.data);
              console.error(`From chunk:`, sse.raw);
              throw e;
            }
            if (sse.event == "error") {
              throw new APIError(void 0, data.error, data.message, void 0);
            }
            yield { event: sse.event, data };
          }
        }
        done = true;
      } catch (e) {
        if (e instanceof Error && e.name === "AbortError")
          return;
        throw e;
      } finally {
        if (!done)
          controller.abort();
      }
    }
    return new Stream(iterator, controller);
  }
  /**
   * Generates a Stream from a newline-separated ReadableStream
   * where each item is a JSON value.
   */
  static fromReadableStream(readableStream, controller) {
    let consumed = false;
    async function* iterLines() {
      const lineDecoder = new LineDecoder();
      const iter = readableStreamAsyncIterable(readableStream);
      for await (const chunk of iter) {
        for (const line of lineDecoder.decode(chunk)) {
          yield line;
        }
      }
      for (const line of lineDecoder.flush()) {
        yield line;
      }
    }
    async function* iterator() {
      if (consumed) {
        throw new Error("Cannot iterate over a consumed stream, use `.tee()` to split the stream.");
      }
      consumed = true;
      let done = false;
      try {
        for await (const line of iterLines()) {
          if (done)
            continue;
          if (line)
            yield JSON.parse(line);
        }
        done = true;
      } catch (e) {
        if (e instanceof Error && e.name === "AbortError")
          return;
        throw e;
      } finally {
        if (!done)
          controller.abort();
      }
    }
    return new Stream(iterator, controller);
  }
  [Symbol.asyncIterator]() {
    return this.iterator();
  }
  /**
   * Splits the stream into two streams which can be
   * independently read from at different speeds.
   */
  tee() {
    const left = [];
    const right = [];
    const iterator = this.iterator();
    const teeIterator = (queue) => {
      return {
        next: () => {
          if (queue.length === 0) {
            const result = iterator.next();
            left.push(result);
            right.push(result);
          }
          return queue.shift();
        }
      };
    };
    return [
      new Stream(() => teeIterator(left), this.controller),
      new Stream(() => teeIterator(right), this.controller)
    ];
  }
  /**
   * Converts this stream to a newline-separated ReadableStream of
   * JSON stringified values in the stream
   * which can be turned back into a Stream with `Stream.fromReadableStream()`.
   */
  toReadableStream() {
    const self2 = this;
    let iter;
    const encoder = new TextEncoder();
    return new ReadableStream$1({
      async start() {
        iter = self2[Symbol.asyncIterator]();
      },
      async pull(ctrl) {
        try {
          const { value, done } = await iter.next();
          if (done)
            return ctrl.close();
          const bytes = encoder.encode(JSON.stringify(value) + "\n");
          ctrl.enqueue(bytes);
        } catch (err) {
          ctrl.error(err);
        }
      },
      async cancel() {
        var _a2;
        await ((_a2 = iter.return) == null ? void 0 : _a2.call(iter));
      }
    });
  }
}
class SSEDecoder {
  constructor() {
    this.event = null;
    this.data = [];
    this.chunks = [];
  }
  decode(line) {
    if (line.endsWith("\r")) {
      line = line.substring(0, line.length - 1);
    }
    if (!line) {
      if (!this.event && !this.data.length)
        return null;
      const sse = {
        event: this.event,
        data: this.data.join("\n"),
        raw: this.chunks
      };
      this.event = null;
      this.data = [];
      this.chunks = [];
      return sse;
    }
    this.chunks.push(line);
    if (line.startsWith(":")) {
      return null;
    }
    let [fieldname, _, value] = partition(line, ":");
    if (value.startsWith(" ")) {
      value = value.substring(1);
    }
    if (fieldname === "event") {
      this.event = value;
    } else if (fieldname === "data") {
      this.data.push(value);
    }
    return null;
  }
}
class LineDecoder {
  constructor() {
    this.buffer = [];
    this.trailingCR = false;
  }
  decode(chunk) {
    let text = this.decodeText(chunk);
    if (this.trailingCR) {
      text = "\r" + text;
      this.trailingCR = false;
    }
    if (text.endsWith("\r")) {
      this.trailingCR = true;
      text = text.slice(0, -1);
    }
    if (!text) {
      return [];
    }
    const trailingNewline = LineDecoder.NEWLINE_CHARS.has(text[text.length - 1] || "");
    let lines = text.split(LineDecoder.NEWLINE_REGEXP);
    if (trailingNewline) {
      lines.pop();
    }
    if (lines.length === 1 && !trailingNewline) {
      this.buffer.push(lines[0]);
      return [];
    }
    if (this.buffer.length > 0) {
      lines = [this.buffer.join("") + lines[0], ...lines.slice(1)];
      this.buffer = [];
    }
    if (!trailingNewline) {
      this.buffer = [lines.pop() || ""];
    }
    return lines;
  }
  decodeText(bytes) {
    if (bytes == null)
      return "";
    if (typeof bytes === "string")
      return bytes;
    if (typeof Buffer !== "undefined") {
      if (bytes instanceof Buffer) {
        return bytes.toString();
      }
      if (bytes instanceof Uint8Array) {
        return Buffer.from(bytes).toString();
      }
      throw new OpenAIError(`Unexpected: received non-Uint8Array (${bytes.constructor.name}) stream chunk in an environment with a global "Buffer" defined, which this library assumes to be Node. Please report this error.`);
    }
    if (typeof TextDecoder !== "undefined") {
      if (bytes instanceof Uint8Array || bytes instanceof ArrayBuffer) {
        this.textDecoder ?? (this.textDecoder = new TextDecoder("utf8"));
        return this.textDecoder.decode(bytes);
      }
      throw new OpenAIError(`Unexpected: received non-Uint8Array/ArrayBuffer (${bytes.constructor.name}) in a web platform. Please report this error.`);
    }
    throw new OpenAIError(`Unexpected: neither Buffer nor TextDecoder are available as globals. Please report this error.`);
  }
  flush() {
    if (!this.buffer.length && !this.trailingCR) {
      return [];
    }
    const lines = [this.buffer.join("")];
    this.buffer = [];
    this.trailingCR = false;
    return lines;
  }
}
LineDecoder.NEWLINE_CHARS = /* @__PURE__ */ new Set(["\n", "\r", "\v", "\f", "", "", "", "", "\u2028", "\u2029"]);
LineDecoder.NEWLINE_REGEXP = /\r\n|[\n\r\x0b\x0c\x1c\x1d\x1e\x85\u2028\u2029]/g;
function partition(str2, delimiter) {
  const index = str2.indexOf(delimiter);
  if (index !== -1) {
    return [str2.substring(0, index), delimiter, str2.substring(index + delimiter.length)];
  }
  return [str2, "", ""];
}
function readableStreamAsyncIterable(stream) {
  if (stream[Symbol.asyncIterator])
    return stream;
  const reader = stream.getReader();
  return {
    async next() {
      try {
        const result = await reader.read();
        if (result == null ? void 0 : result.done)
          reader.releaseLock();
        return result;
      } catch (e) {
        reader.releaseLock();
        throw e;
      }
    },
    async return() {
      const cancelPromise = reader.cancel();
      reader.releaseLock();
      await cancelPromise;
      return { done: true, value: void 0 };
    },
    [Symbol.asyncIterator]() {
      return this;
    }
  };
}
const isResponseLike = (value) => value != null && typeof value === "object" && typeof value.url === "string" && typeof value.blob === "function";
const isFileLike = (value) => value != null && typeof value === "object" && typeof value.name === "string" && typeof value.lastModified === "number" && isBlobLike(value);
const isBlobLike = (value) => value != null && typeof value === "object" && typeof value.size === "number" && typeof value.type === "string" && typeof value.text === "function" && typeof value.slice === "function" && typeof value.arrayBuffer === "function";
const isUploadable = (value) => {
  return isFileLike(value) || isResponseLike(value) || isFsReadStream(value);
};
async function toFile(value, name, options = {}) {
  var _a2;
  value = await value;
  if (isResponseLike(value)) {
    const blob = await value.blob();
    name || (name = new URL(value.url).pathname.split(/[\\/]/).pop() ?? "unknown_file");
    return new File$1([blob], name, options);
  }
  const bits = await getBytes(value);
  name || (name = getName(value) ?? "unknown_file");
  if (!options.type) {
    const type = (_a2 = bits[0]) == null ? void 0 : _a2.type;
    if (typeof type === "string") {
      options = { ...options, type };
    }
  }
  return new File$1(bits, name, options);
}
async function getBytes(value) {
  var _a2;
  let parts = [];
  if (typeof value === "string" || ArrayBuffer.isView(value) || // includes Uint8Array, Buffer, etc.
  value instanceof ArrayBuffer) {
    parts.push(value);
  } else if (isBlobLike(value)) {
    parts.push(await value.arrayBuffer());
  } else if (isAsyncIterableIterator(value)) {
    for await (const chunk of value) {
      parts.push(chunk);
    }
  } else {
    throw new Error(`Unexpected data type: ${typeof value}; constructor: ${(_a2 = value == null ? void 0 : value.constructor) == null ? void 0 : _a2.name}; props: ${propsForError(value)}`);
  }
  return parts;
}
function propsForError(value) {
  const props = Object.getOwnPropertyNames(value);
  return `[${props.map((p) => `"${p}"`).join(", ")}]`;
}
function getName(value) {
  var _a2;
  return getStringFromMaybeBuffer(value.name) || getStringFromMaybeBuffer(value.filename) || // For fs.ReadStream
  ((_a2 = getStringFromMaybeBuffer(value.path)) == null ? void 0 : _a2.split(/[\\/]/).pop());
}
const getStringFromMaybeBuffer = (x) => {
  if (typeof x === "string")
    return x;
  if (typeof Buffer !== "undefined" && x instanceof Buffer)
    return String(x);
  return void 0;
};
const isAsyncIterableIterator = (value) => value != null && typeof value === "object" && typeof value[Symbol.asyncIterator] === "function";
const isMultipartBody = (body) => body && typeof body === "object" && body.body && body[Symbol.toStringTag] === "MultipartBody";
const multipartFormRequestOptions = async (opts) => {
  const form = await createForm(opts.body);
  return getMultipartRequestOptions(form, opts);
};
const createForm = async (body) => {
  const form = new FormData$1();
  await Promise.all(Object.entries(body || {}).map(([key, value]) => addFormValue(form, key, value)));
  return form;
};
const addFormValue = async (form, key, value) => {
  if (value === void 0)
    return;
  if (value == null) {
    throw new TypeError(`Received null for "${key}"; to pass null in FormData, you must use the string 'null'`);
  }
  if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
    form.append(key, String(value));
  } else if (isUploadable(value)) {
    const file = await toFile(value);
    form.append(key, file);
  } else if (Array.isArray(value)) {
    await Promise.all(value.map((entry) => addFormValue(form, key + "[]", entry)));
  } else if (typeof value === "object") {
    await Promise.all(Object.entries(value).map(([name, prop]) => addFormValue(form, `${key}[${name}]`, prop)));
  } else {
    throw new TypeError(`Invalid value given to form, expected a string, number, boolean, object, Array, File or Blob but got ${value} instead`);
  }
};
var __classPrivateFieldSet$4 = function(receiver, state, value, kind2, f) {
  if (kind2 === "m")
    throw new TypeError("Private method is not writable");
  if (kind2 === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind2 === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet$4 = function(receiver, state, kind2, f) {
  if (kind2 === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind2 === "m" ? f : kind2 === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _AbstractPage_client;
async function defaultParseResponse(props) {
  const { response } = props;
  if (props.options.stream) {
    debug("response", response.status, response.url, response.headers, response.body);
    if (props.options.__streamClass) {
      return props.options.__streamClass.fromSSEResponse(response, props.controller);
    }
    return Stream.fromSSEResponse(response, props.controller);
  }
  if (response.status === 204) {
    return null;
  }
  if (props.options.__binaryResponse) {
    return response;
  }
  const contentType = response.headers.get("content-type");
  const isJSON = (contentType == null ? void 0 : contentType.includes("application/json")) || (contentType == null ? void 0 : contentType.includes("application/vnd.api+json"));
  if (isJSON) {
    const json = await response.json();
    debug("response", response.status, response.url, response.headers, json);
    return json;
  }
  const text = await response.text();
  debug("response", response.status, response.url, response.headers, text);
  return text;
}
class APIPromise extends Promise {
  constructor(responsePromise, parseResponse = defaultParseResponse) {
    super((resolve) => {
      resolve(null);
    });
    this.responsePromise = responsePromise;
    this.parseResponse = parseResponse;
  }
  _thenUnwrap(transform) {
    return new APIPromise(this.responsePromise, async (props) => transform(await this.parseResponse(props)));
  }
  /**
   * Gets the raw `Response` instance instead of parsing the response
   * data.
   *
   * If you want to parse the response body but still get the `Response`
   * instance, you can use {@link withResponse()}.
   *
   * 👋 Getting the wrong TypeScript type for `Response`?
   * Try setting `"moduleResolution": "NodeNext"` if you can,
   * or add one of these imports before your first `import … from 'openai'`:
   * - `import 'openai/shims/node'` (if you're running on Node)
   * - `import 'openai/shims/web'` (otherwise)
   */
  asResponse() {
    return this.responsePromise.then((p) => p.response);
  }
  /**
   * Gets the parsed response data and the raw `Response` instance.
   *
   * If you just want to get the raw `Response` instance without parsing it,
   * you can use {@link asResponse()}.
   *
   *
   * 👋 Getting the wrong TypeScript type for `Response`?
   * Try setting `"moduleResolution": "NodeNext"` if you can,
   * or add one of these imports before your first `import … from 'openai'`:
   * - `import 'openai/shims/node'` (if you're running on Node)
   * - `import 'openai/shims/web'` (otherwise)
   */
  async withResponse() {
    const [data, response] = await Promise.all([this.parse(), this.asResponse()]);
    return { data, response };
  }
  parse() {
    if (!this.parsedPromise) {
      this.parsedPromise = this.responsePromise.then(this.parseResponse);
    }
    return this.parsedPromise;
  }
  then(onfulfilled, onrejected) {
    return this.parse().then(onfulfilled, onrejected);
  }
  catch(onrejected) {
    return this.parse().catch(onrejected);
  }
  finally(onfinally) {
    return this.parse().finally(onfinally);
  }
}
class APIClient {
  constructor({
    baseURL,
    maxRetries = 2,
    timeout = 6e5,
    // 10 minutes
    httpAgent,
    fetch: overridenFetch
  }) {
    this.baseURL = baseURL;
    this.maxRetries = validatePositiveInteger("maxRetries", maxRetries);
    this.timeout = validatePositiveInteger("timeout", timeout);
    this.httpAgent = httpAgent;
    this.fetch = overridenFetch ?? fetch$1;
  }
  authHeaders(opts) {
    return {};
  }
  /**
   * Override this to add your own default headers, for example:
   *
   *  {
   *    ...super.defaultHeaders(),
   *    Authorization: 'Bearer 123',
   *  }
   */
  defaultHeaders(opts) {
    return {
      Accept: "application/json",
      "Content-Type": "application/json",
      "User-Agent": this.getUserAgent(),
      ...getPlatformHeaders(),
      ...this.authHeaders(opts)
    };
  }
  /**
   * Override this to add your own headers validation:
   */
  validateHeaders(headers, customHeaders) {
  }
  defaultIdempotencyKey() {
    return `stainless-node-retry-${uuid4()}`;
  }
  get(path, opts) {
    return this.methodRequest("get", path, opts);
  }
  post(path, opts) {
    return this.methodRequest("post", path, opts);
  }
  patch(path, opts) {
    return this.methodRequest("patch", path, opts);
  }
  put(path, opts) {
    return this.methodRequest("put", path, opts);
  }
  delete(path, opts) {
    return this.methodRequest("delete", path, opts);
  }
  methodRequest(method, path, opts) {
    return this.request(Promise.resolve(opts).then((opts2) => ({ method, path, ...opts2 })));
  }
  getAPIList(path, Page2, opts) {
    return this.requestAPIList(Page2, { method: "get", path, ...opts });
  }
  calculateContentLength(body) {
    if (typeof body === "string") {
      if (typeof Buffer !== "undefined") {
        return Buffer.byteLength(body, "utf8").toString();
      }
      if (typeof TextEncoder !== "undefined") {
        const encoder = new TextEncoder();
        const encoded = encoder.encode(body);
        return encoded.length.toString();
      }
    }
    return null;
  }
  buildRequest(options) {
    var _a2;
    const { method, path, query, headers = {} } = options;
    const body = isMultipartBody(options.body) ? options.body.body : options.body ? JSON.stringify(options.body, null, 2) : null;
    const contentLength = this.calculateContentLength(body);
    const url = this.buildURL(path, query);
    if ("timeout" in options)
      validatePositiveInteger("timeout", options.timeout);
    const timeout = options.timeout ?? this.timeout;
    const httpAgent = options.httpAgent ?? this.httpAgent ?? getDefaultAgent(url);
    const minAgentTimeout = timeout + 1e3;
    if (typeof ((_a2 = httpAgent == null ? void 0 : httpAgent.options) == null ? void 0 : _a2.timeout) === "number" && minAgentTimeout > (httpAgent.options.timeout ?? 0)) {
      httpAgent.options.timeout = minAgentTimeout;
    }
    if (this.idempotencyHeader && method !== "get") {
      if (!options.idempotencyKey)
        options.idempotencyKey = this.defaultIdempotencyKey();
      headers[this.idempotencyHeader] = options.idempotencyKey;
    }
    const reqHeaders = this.buildHeaders({ options, headers, contentLength });
    const req = {
      method,
      ...body && { body },
      headers: reqHeaders,
      ...httpAgent && { agent: httpAgent },
      // @ts-ignore node-fetch uses a custom AbortSignal type that is
      // not compatible with standard web types
      signal: options.signal ?? null
    };
    return { req, url, timeout };
  }
  buildHeaders({ options, headers, contentLength }) {
    const reqHeaders = {};
    if (contentLength) {
      reqHeaders["content-length"] = contentLength;
    }
    const defaultHeaders = this.defaultHeaders(options);
    applyHeadersMut(reqHeaders, defaultHeaders);
    applyHeadersMut(reqHeaders, headers);
    if (isMultipartBody(options.body) && kind !== "node") {
      delete reqHeaders["content-type"];
    }
    this.validateHeaders(reqHeaders, headers);
    return reqHeaders;
  }
  /**
   * Used as a callback for mutating the given `FinalRequestOptions` object.
   */
  async prepareOptions(options) {
  }
  /**
   * Used as a callback for mutating the given `RequestInit` object.
   *
   * This is useful for cases where you want to add certain headers based off of
   * the request properties, e.g. `method` or `url`.
   */
  async prepareRequest(request, { url, options }) {
  }
  parseHeaders(headers) {
    return !headers ? {} : Symbol.iterator in headers ? Object.fromEntries(Array.from(headers).map((header) => [...header])) : { ...headers };
  }
  makeStatusError(status, error, message, headers) {
    return APIError.generate(status, error, message, headers);
  }
  request(options, remainingRetries = null) {
    return new APIPromise(this.makeRequest(options, remainingRetries));
  }
  async makeRequest(optionsInput, retriesRemaining) {
    var _a2, _b;
    const options = await optionsInput;
    if (retriesRemaining == null) {
      retriesRemaining = options.maxRetries ?? this.maxRetries;
    }
    await this.prepareOptions(options);
    const { req, url, timeout } = this.buildRequest(options);
    await this.prepareRequest(req, { url, options });
    debug("request", url, options, req.headers);
    if ((_a2 = options.signal) == null ? void 0 : _a2.aborted) {
      throw new APIUserAbortError();
    }
    const controller = new AbortController();
    const response = await this.fetchWithTimeout(url, req, timeout, controller).catch(castToError);
    if (response instanceof Error) {
      if ((_b = options.signal) == null ? void 0 : _b.aborted) {
        throw new APIUserAbortError();
      }
      if (retriesRemaining) {
        return this.retryRequest(options, retriesRemaining);
      }
      if (response.name === "AbortError") {
        throw new APIConnectionTimeoutError();
      }
      throw new APIConnectionError({ cause: response });
    }
    const responseHeaders = createResponseHeaders(response.headers);
    if (!response.ok) {
      if (retriesRemaining && this.shouldRetry(response)) {
        const retryMessage2 = `retrying, ${retriesRemaining} attempts remaining`;
        debug(`response (error; ${retryMessage2})`, response.status, url, responseHeaders);
        return this.retryRequest(options, retriesRemaining, responseHeaders);
      }
      const errText = await response.text().catch((e) => castToError(e).message);
      const errJSON = safeJSON(errText);
      const errMessage = errJSON ? void 0 : errText;
      const retryMessage = retriesRemaining ? `(error; no more retries left)` : `(error; not retryable)`;
      debug(`response (error; ${retryMessage})`, response.status, url, responseHeaders, errMessage);
      const err = this.makeStatusError(response.status, errJSON, errMessage, responseHeaders);
      throw err;
    }
    return { response, options, controller };
  }
  requestAPIList(Page2, options) {
    const request = this.makeRequest(options, null);
    return new PagePromise(this, request, Page2);
  }
  buildURL(path, query) {
    const url = isAbsoluteURL(path) ? new URL(path) : new URL(this.baseURL + (this.baseURL.endsWith("/") && path.startsWith("/") ? path.slice(1) : path));
    const defaultQuery = this.defaultQuery();
    if (!isEmptyObj(defaultQuery)) {
      query = { ...defaultQuery, ...query };
    }
    if (typeof query === "object" && query && !Array.isArray(query)) {
      url.search = this.stringifyQuery(query);
    }
    return url.toString();
  }
  stringifyQuery(query) {
    return Object.entries(query).filter(([_, value]) => typeof value !== "undefined").map(([key, value]) => {
      if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
        return `${encodeURIComponent(key)}=${encodeURIComponent(value)}`;
      }
      if (value === null) {
        return `${encodeURIComponent(key)}=`;
      }
      throw new OpenAIError(`Cannot stringify type ${typeof value}; Expected string, number, boolean, or null. If you need to pass nested query parameters, you can manually encode them, e.g. { query: { 'foo[key1]': value1, 'foo[key2]': value2 } }, and please open a GitHub issue requesting better support for your use case.`);
    }).join("&");
  }
  async fetchWithTimeout(url, init6, ms, controller) {
    const { signal, ...options } = init6 || {};
    if (signal)
      signal.addEventListener("abort", () => controller.abort());
    const timeout = setTimeout(() => controller.abort(), ms);
    return this.getRequestClient().fetch.call(void 0, url, { signal: controller.signal, ...options }).finally(() => {
      clearTimeout(timeout);
    });
  }
  getRequestClient() {
    return { fetch: this.fetch };
  }
  shouldRetry(response) {
    const shouldRetryHeader = response.headers.get("x-should-retry");
    if (shouldRetryHeader === "true")
      return true;
    if (shouldRetryHeader === "false")
      return false;
    if (response.status === 408)
      return true;
    if (response.status === 409)
      return true;
    if (response.status === 429)
      return true;
    if (response.status >= 500)
      return true;
    return false;
  }
  async retryRequest(options, retriesRemaining, responseHeaders) {
    let timeoutMillis;
    const retryAfterMillisHeader = responseHeaders == null ? void 0 : responseHeaders["retry-after-ms"];
    if (retryAfterMillisHeader) {
      const timeoutMs = parseFloat(retryAfterMillisHeader);
      if (!Number.isNaN(timeoutMs)) {
        timeoutMillis = timeoutMs;
      }
    }
    const retryAfterHeader = responseHeaders == null ? void 0 : responseHeaders["retry-after"];
    if (retryAfterHeader && !timeoutMillis) {
      const timeoutSeconds = parseFloat(retryAfterHeader);
      if (!Number.isNaN(timeoutSeconds)) {
        timeoutMillis = timeoutSeconds * 1e3;
      } else {
        timeoutMillis = Date.parse(retryAfterHeader) - Date.now();
      }
    }
    if (!(timeoutMillis && 0 <= timeoutMillis && timeoutMillis < 60 * 1e3)) {
      const maxRetries = options.maxRetries ?? this.maxRetries;
      timeoutMillis = this.calculateDefaultRetryTimeoutMillis(retriesRemaining, maxRetries);
    }
    await sleep(timeoutMillis);
    return this.makeRequest(options, retriesRemaining - 1);
  }
  calculateDefaultRetryTimeoutMillis(retriesRemaining, maxRetries) {
    const initialRetryDelay = 0.5;
    const maxRetryDelay = 8;
    const numRetries = maxRetries - retriesRemaining;
    const sleepSeconds = Math.min(initialRetryDelay * Math.pow(2, numRetries), maxRetryDelay);
    const jitter = 1 - Math.random() * 0.25;
    return sleepSeconds * jitter * 1e3;
  }
  getUserAgent() {
    return `${this.constructor.name}/JS ${VERSION}`;
  }
}
class AbstractPage {
  constructor(client, response, body, options) {
    _AbstractPage_client.set(this, void 0);
    __classPrivateFieldSet$4(this, _AbstractPage_client, client, "f");
    this.options = options;
    this.response = response;
    this.body = body;
  }
  hasNextPage() {
    const items = this.getPaginatedItems();
    if (!items.length)
      return false;
    return this.nextPageInfo() != null;
  }
  async getNextPage() {
    const nextInfo = this.nextPageInfo();
    if (!nextInfo) {
      throw new OpenAIError("No next page expected; please check `.hasNextPage()` before calling `.getNextPage()`.");
    }
    const nextOptions = { ...this.options };
    if ("params" in nextInfo && typeof nextOptions.query === "object") {
      nextOptions.query = { ...nextOptions.query, ...nextInfo.params };
    } else if ("url" in nextInfo) {
      const params = [...Object.entries(nextOptions.query || {}), ...nextInfo.url.searchParams.entries()];
      for (const [key, value] of params) {
        nextInfo.url.searchParams.set(key, value);
      }
      nextOptions.query = void 0;
      nextOptions.path = nextInfo.url.toString();
    }
    return await __classPrivateFieldGet$4(this, _AbstractPage_client, "f").requestAPIList(this.constructor, nextOptions);
  }
  async *iterPages() {
    let page = this;
    yield page;
    while (page.hasNextPage()) {
      page = await page.getNextPage();
      yield page;
    }
  }
  async *[(_AbstractPage_client = /* @__PURE__ */ new WeakMap(), Symbol.asyncIterator)]() {
    for await (const page of this.iterPages()) {
      for (const item of page.getPaginatedItems()) {
        yield item;
      }
    }
  }
}
class PagePromise extends APIPromise {
  constructor(client, request, Page2) {
    super(request, async (props) => new Page2(client, props.response, await defaultParseResponse(props), props.options));
  }
  /**
   * Allow auto-paginating iteration on an unawaited list call, eg:
   *
   *    for await (const item of client.items.list()) {
   *      console.log(item)
   *    }
   */
  async *[Symbol.asyncIterator]() {
    const page = await this;
    for await (const item of page) {
      yield item;
    }
  }
}
const createResponseHeaders = (headers) => {
  return new Proxy(Object.fromEntries(
    // @ts-ignore
    headers.entries()
  ), {
    get(target, name) {
      const key = name.toString();
      return target[key.toLowerCase()] || target[key];
    }
  });
};
const requestOptionsKeys = {
  method: true,
  path: true,
  query: true,
  body: true,
  headers: true,
  maxRetries: true,
  stream: true,
  timeout: true,
  httpAgent: true,
  signal: true,
  idempotencyKey: true,
  __binaryResponse: true,
  __streamClass: true
};
const isRequestOptions = (obj) => {
  return typeof obj === "object" && obj !== null && !isEmptyObj(obj) && Object.keys(obj).every((k) => hasOwn(requestOptionsKeys, k));
};
const getPlatformProperties = () => {
  if (typeof Deno !== "undefined" && Deno.build != null) {
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION,
      "X-Stainless-OS": normalizePlatform(Deno.build.os),
      "X-Stainless-Arch": normalizeArch(Deno.build.arch),
      "X-Stainless-Runtime": "deno",
      "X-Stainless-Runtime-Version": Deno.version
    };
  }
  if (typeof EdgeRuntime !== "undefined") {
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION,
      "X-Stainless-OS": "Unknown",
      "X-Stainless-Arch": `other:${EdgeRuntime}`,
      "X-Stainless-Runtime": "edge",
      "X-Stainless-Runtime-Version": process.version
    };
  }
  if (Object.prototype.toString.call(typeof process !== "undefined" ? process : 0) === "[object process]") {
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION,
      "X-Stainless-OS": normalizePlatform(process.platform),
      "X-Stainless-Arch": normalizeArch(process.arch),
      "X-Stainless-Runtime": "node",
      "X-Stainless-Runtime-Version": process.version
    };
  }
  const browserInfo = getBrowserInfo();
  if (browserInfo) {
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION,
      "X-Stainless-OS": "Unknown",
      "X-Stainless-Arch": "unknown",
      "X-Stainless-Runtime": `browser:${browserInfo.browser}`,
      "X-Stainless-Runtime-Version": browserInfo.version
    };
  }
  return {
    "X-Stainless-Lang": "js",
    "X-Stainless-Package-Version": VERSION,
    "X-Stainless-OS": "Unknown",
    "X-Stainless-Arch": "unknown",
    "X-Stainless-Runtime": "unknown",
    "X-Stainless-Runtime-Version": "unknown"
  };
};
function getBrowserInfo() {
  if (typeof navigator === "undefined" || !navigator) {
    return null;
  }
  const browserPatterns = [
    { key: "edge", pattern: /Edge(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "ie", pattern: /MSIE(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "ie", pattern: /Trident(?:.*rv\:(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "chrome", pattern: /Chrome(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "firefox", pattern: /Firefox(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "safari", pattern: /(?:Version\W+(\d+)\.(\d+)(?:\.(\d+))?)?(?:\W+Mobile\S*)?\W+Safari/ }
  ];
  for (const { key, pattern } of browserPatterns) {
    const match = pattern.exec(navigator.userAgent);
    if (match) {
      const major = match[1] || 0;
      const minor = match[2] || 0;
      const patch = match[3] || 0;
      return { browser: key, version: `${major}.${minor}.${patch}` };
    }
  }
  return null;
}
const normalizeArch = (arch) => {
  if (arch === "x32")
    return "x32";
  if (arch === "x86_64" || arch === "x64")
    return "x64";
  if (arch === "arm")
    return "arm";
  if (arch === "aarch64" || arch === "arm64")
    return "arm64";
  if (arch)
    return `other:${arch}`;
  return "unknown";
};
const normalizePlatform = (platform) => {
  platform = platform.toLowerCase();
  if (platform.includes("ios"))
    return "iOS";
  if (platform === "android")
    return "Android";
  if (platform === "darwin")
    return "MacOS";
  if (platform === "win32")
    return "Windows";
  if (platform === "freebsd")
    return "FreeBSD";
  if (platform === "openbsd")
    return "OpenBSD";
  if (platform === "linux")
    return "Linux";
  if (platform)
    return `Other:${platform}`;
  return "Unknown";
};
let _platformHeaders;
const getPlatformHeaders = () => {
  return _platformHeaders ?? (_platformHeaders = getPlatformProperties());
};
const safeJSON = (text) => {
  try {
    return JSON.parse(text);
  } catch (err) {
    return void 0;
  }
};
const startsWithSchemeRegexp = new RegExp("^(?:[a-z]+:)?//", "i");
const isAbsoluteURL = (url) => {
  return startsWithSchemeRegexp.test(url);
};
const sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));
const validatePositiveInteger = (name, n) => {
  if (typeof n !== "number" || !Number.isInteger(n)) {
    throw new OpenAIError(`${name} must be an integer`);
  }
  if (n < 0) {
    throw new OpenAIError(`${name} must be a positive integer`);
  }
  return n;
};
const castToError = (err) => {
  if (err instanceof Error)
    return err;
  return new Error(err);
};
const readEnv = (env) => {
  var _a2, _b, _c, _d, _e;
  if (typeof process !== "undefined") {
    return ((_b = (_a2 = process.env) == null ? void 0 : _a2[env]) == null ? void 0 : _b.trim()) ?? void 0;
  }
  if (typeof Deno !== "undefined") {
    return (_e = (_d = (_c = Deno.env) == null ? void 0 : _c.get) == null ? void 0 : _d.call(_c, env)) == null ? void 0 : _e.trim();
  }
  return void 0;
};
function isEmptyObj(obj) {
  if (!obj)
    return true;
  for (const _k in obj)
    return false;
  return true;
}
function hasOwn(obj, key) {
  return Object.prototype.hasOwnProperty.call(obj, key);
}
function applyHeadersMut(targetHeaders, newHeaders) {
  for (const k in newHeaders) {
    if (!hasOwn(newHeaders, k))
      continue;
    const lowerKey = k.toLowerCase();
    if (!lowerKey)
      continue;
    const val = newHeaders[k];
    if (val === null) {
      delete targetHeaders[lowerKey];
    } else if (val !== void 0) {
      targetHeaders[lowerKey] = val;
    }
  }
}
function debug(action, ...args) {
  if (typeof process !== "undefined" && process.env["DEBUG"] === "true") {
    console.log(`OpenAI:DEBUG:${action}`, ...args);
  }
}
const uuid4 = () => {
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c) => {
    const r = Math.random() * 16 | 0;
    const v = c === "x" ? r : r & 3 | 8;
    return v.toString(16);
  });
};
const isRunningInBrowser = () => {
  return (
    // @ts-ignore
    typeof window !== "undefined" && // @ts-ignore
    typeof window.document !== "undefined" && // @ts-ignore
    typeof navigator !== "undefined"
  );
};
function isObj(obj) {
  return obj != null && typeof obj === "object" && !Array.isArray(obj);
}
class Page extends AbstractPage {
  constructor(client, response, body, options) {
    super(client, response, body, options);
    this.data = body.data || [];
    this.object = body.object;
  }
  getPaginatedItems() {
    return this.data ?? [];
  }
  // @deprecated Please use `nextPageInfo()` instead
  /**
   * This page represents a response that isn't actually paginated at the API level
   * so there will never be any next page params.
   */
  nextPageParams() {
    return null;
  }
  nextPageInfo() {
    return null;
  }
}
class CursorPage extends AbstractPage {
  constructor(client, response, body, options) {
    super(client, response, body, options);
    this.data = body.data || [];
  }
  getPaginatedItems() {
    return this.data ?? [];
  }
  // @deprecated Please use `nextPageInfo()` instead
  nextPageParams() {
    const info = this.nextPageInfo();
    if (!info)
      return null;
    if ("params" in info)
      return info.params;
    const params = Object.fromEntries(info.url.searchParams);
    if (!Object.keys(params).length)
      return null;
    return params;
  }
  nextPageInfo() {
    var _a2;
    const data = this.getPaginatedItems();
    if (!data.length) {
      return null;
    }
    const id = (_a2 = data[data.length - 1]) == null ? void 0 : _a2.id;
    if (!id) {
      return null;
    }
    return { params: { after: id } };
  }
}
class APIResource {
  constructor(client) {
    this._client = client;
  }
}
let Completions$2 = class Completions extends APIResource {
  create(body, options) {
    return this._client.post("/chat/completions", { body, ...options, stream: body.stream ?? false });
  }
};
/* @__PURE__ */ (function(Completions4) {
})(Completions$2 || (Completions$2 = {}));
let Chat$1 = class Chat extends APIResource {
  constructor() {
    super(...arguments);
    this.completions = new Completions$2(this._client);
  }
};
(function(Chat3) {
  Chat3.Completions = Completions$2;
})(Chat$1 || (Chat$1 = {}));
class Speech extends APIResource {
  /**
   * Generates audio from the input text.
   */
  create(body, options) {
    return this._client.post("/audio/speech", { body, ...options, __binaryResponse: true });
  }
}
/* @__PURE__ */ (function(Speech2) {
})(Speech || (Speech = {}));
class Transcriptions extends APIResource {
  /**
   * Transcribes audio into the input language.
   */
  create(body, options) {
    return this._client.post("/audio/transcriptions", multipartFormRequestOptions({ body, ...options }));
  }
}
/* @__PURE__ */ (function(Transcriptions2) {
})(Transcriptions || (Transcriptions = {}));
class Translations extends APIResource {
  /**
   * Translates audio into English.
   */
  create(body, options) {
    return this._client.post("/audio/translations", multipartFormRequestOptions({ body, ...options }));
  }
}
/* @__PURE__ */ (function(Translations2) {
})(Translations || (Translations = {}));
class Audio extends APIResource {
  constructor() {
    super(...arguments);
    this.transcriptions = new Transcriptions(this._client);
    this.translations = new Translations(this._client);
    this.speech = new Speech(this._client);
  }
}
(function(Audio2) {
  Audio2.Transcriptions = Transcriptions;
  Audio2.Translations = Translations;
  Audio2.Speech = Speech;
})(Audio || (Audio = {}));
let Files$2 = class Files extends APIResource {
  /**
   * Create an assistant file by attaching a
   * [File](https://platform.openai.com/docs/api-reference/files) to an
   * [assistant](https://platform.openai.com/docs/api-reference/assistants).
   */
  create(assistantId, body, options) {
    return this._client.post(`/assistants/${assistantId}/files`, {
      body,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v1", ...options == null ? void 0 : options.headers }
    });
  }
  /**
   * Retrieves an AssistantFile.
   */
  retrieve(assistantId, fileId, options) {
    return this._client.get(`/assistants/${assistantId}/files/${fileId}`, {
      ...options,
      headers: { "OpenAI-Beta": "assistants=v1", ...options == null ? void 0 : options.headers }
    });
  }
  list(assistantId, query = {}, options) {
    if (isRequestOptions(query)) {
      return this.list(assistantId, {}, query);
    }
    return this._client.getAPIList(`/assistants/${assistantId}/files`, AssistantFilesPage, {
      query,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v1", ...options == null ? void 0 : options.headers }
    });
  }
  /**
   * Delete an assistant file.
   */
  del(assistantId, fileId, options) {
    return this._client.delete(`/assistants/${assistantId}/files/${fileId}`, {
      ...options,
      headers: { "OpenAI-Beta": "assistants=v1", ...options == null ? void 0 : options.headers }
    });
  }
};
class AssistantFilesPage extends CursorPage {
}
(function(Files4) {
  Files4.AssistantFilesPage = AssistantFilesPage;
})(Files$2 || (Files$2 = {}));
class Assistants extends APIResource {
  constructor() {
    super(...arguments);
    this.files = new Files$2(this._client);
  }
  /**
   * Create an assistant with a model and instructions.
   */
  create(body, options) {
    return this._client.post("/assistants", {
      body,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v1", ...options == null ? void 0 : options.headers }
    });
  }
  /**
   * Retrieves an assistant.
   */
  retrieve(assistantId, options) {
    return this._client.get(`/assistants/${assistantId}`, {
      ...options,
      headers: { "OpenAI-Beta": "assistants=v1", ...options == null ? void 0 : options.headers }
    });
  }
  /**
   * Modifies an assistant.
   */
  update(assistantId, body, options) {
    return this._client.post(`/assistants/${assistantId}`, {
      body,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v1", ...options == null ? void 0 : options.headers }
    });
  }
  list(query = {}, options) {
    if (isRequestOptions(query)) {
      return this.list({}, query);
    }
    return this._client.getAPIList("/assistants", AssistantsPage, {
      query,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v1", ...options == null ? void 0 : options.headers }
    });
  }
  /**
   * Delete an assistant.
   */
  del(assistantId, options) {
    return this._client.delete(`/assistants/${assistantId}`, {
      ...options,
      headers: { "OpenAI-Beta": "assistants=v1", ...options == null ? void 0 : options.headers }
    });
  }
}
class AssistantsPage extends CursorPage {
}
(function(Assistants2) {
  Assistants2.AssistantsPage = AssistantsPage;
  Assistants2.Files = Files$2;
  Assistants2.AssistantFilesPage = AssistantFilesPage;
})(Assistants || (Assistants = {}));
function isRunnableFunctionWithParse(fn) {
  return typeof fn.parse === "function";
}
const isAssistantMessage = (message) => {
  return (message == null ? void 0 : message.role) === "assistant";
};
const isFunctionMessage = (message) => {
  return (message == null ? void 0 : message.role) === "function";
};
const isToolMessage = (message) => {
  return (message == null ? void 0 : message.role) === "tool";
};
var __classPrivateFieldSet$3 = function(receiver, state, value, kind2, f) {
  if (kind2 === "m")
    throw new TypeError("Private method is not writable");
  if (kind2 === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind2 === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet$3 = function(receiver, state, kind2, f) {
  if (kind2 === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind2 === "m" ? f : kind2 === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _AbstractChatCompletionRunner_instances, _AbstractChatCompletionRunner_connectedPromise, _AbstractChatCompletionRunner_resolveConnectedPromise, _AbstractChatCompletionRunner_rejectConnectedPromise, _AbstractChatCompletionRunner_endPromise, _AbstractChatCompletionRunner_resolveEndPromise, _AbstractChatCompletionRunner_rejectEndPromise, _AbstractChatCompletionRunner_listeners, _AbstractChatCompletionRunner_ended, _AbstractChatCompletionRunner_errored, _AbstractChatCompletionRunner_aborted, _AbstractChatCompletionRunner_catchingPromiseCreated, _AbstractChatCompletionRunner_getFinalContent, _AbstractChatCompletionRunner_getFinalMessage, _AbstractChatCompletionRunner_getFinalFunctionCall, _AbstractChatCompletionRunner_getFinalFunctionCallResult, _AbstractChatCompletionRunner_calculateTotalUsage, _AbstractChatCompletionRunner_handleError, _AbstractChatCompletionRunner_validateParams, _AbstractChatCompletionRunner_stringifyFunctionCallResult;
const DEFAULT_MAX_CHAT_COMPLETIONS = 10;
class AbstractChatCompletionRunner {
  constructor() {
    _AbstractChatCompletionRunner_instances.add(this);
    this.controller = new AbortController();
    _AbstractChatCompletionRunner_connectedPromise.set(this, void 0);
    _AbstractChatCompletionRunner_resolveConnectedPromise.set(this, () => {
    });
    _AbstractChatCompletionRunner_rejectConnectedPromise.set(this, () => {
    });
    _AbstractChatCompletionRunner_endPromise.set(this, void 0);
    _AbstractChatCompletionRunner_resolveEndPromise.set(this, () => {
    });
    _AbstractChatCompletionRunner_rejectEndPromise.set(this, () => {
    });
    _AbstractChatCompletionRunner_listeners.set(this, {});
    this._chatCompletions = [];
    this.messages = [];
    _AbstractChatCompletionRunner_ended.set(this, false);
    _AbstractChatCompletionRunner_errored.set(this, false);
    _AbstractChatCompletionRunner_aborted.set(this, false);
    _AbstractChatCompletionRunner_catchingPromiseCreated.set(this, false);
    _AbstractChatCompletionRunner_handleError.set(this, (error) => {
      __classPrivateFieldSet$3(this, _AbstractChatCompletionRunner_errored, true, "f");
      if (error instanceof Error && error.name === "AbortError") {
        error = new APIUserAbortError();
      }
      if (error instanceof APIUserAbortError) {
        __classPrivateFieldSet$3(this, _AbstractChatCompletionRunner_aborted, true, "f");
        return this._emit("abort", error);
      }
      if (error instanceof OpenAIError) {
        return this._emit("error", error);
      }
      if (error instanceof Error) {
        const openAIError = new OpenAIError(error.message);
        openAIError.cause = error;
        return this._emit("error", openAIError);
      }
      return this._emit("error", new OpenAIError(String(error)));
    });
    __classPrivateFieldSet$3(this, _AbstractChatCompletionRunner_connectedPromise, new Promise((resolve, reject) => {
      __classPrivateFieldSet$3(this, _AbstractChatCompletionRunner_resolveConnectedPromise, resolve, "f");
      __classPrivateFieldSet$3(this, _AbstractChatCompletionRunner_rejectConnectedPromise, reject, "f");
    }), "f");
    __classPrivateFieldSet$3(this, _AbstractChatCompletionRunner_endPromise, new Promise((resolve, reject) => {
      __classPrivateFieldSet$3(this, _AbstractChatCompletionRunner_resolveEndPromise, resolve, "f");
      __classPrivateFieldSet$3(this, _AbstractChatCompletionRunner_rejectEndPromise, reject, "f");
    }), "f");
    __classPrivateFieldGet$3(this, _AbstractChatCompletionRunner_connectedPromise, "f").catch(() => {
    });
    __classPrivateFieldGet$3(this, _AbstractChatCompletionRunner_endPromise, "f").catch(() => {
    });
  }
  _run(executor) {
    setTimeout(() => {
      executor().then(() => {
        this._emitFinal();
        this._emit("end");
      }, __classPrivateFieldGet$3(this, _AbstractChatCompletionRunner_handleError, "f"));
    }, 0);
  }
  _addChatCompletion(chatCompletion) {
    var _a2;
    this._chatCompletions.push(chatCompletion);
    this._emit("chatCompletion", chatCompletion);
    const message = (_a2 = chatCompletion.choices[0]) == null ? void 0 : _a2.message;
    if (message)
      this._addMessage(message);
    return chatCompletion;
  }
  _addMessage(message, emit = true) {
    if (!("content" in message))
      message.content = null;
    this.messages.push(message);
    if (emit) {
      this._emit("message", message);
      if ((isFunctionMessage(message) || isToolMessage(message)) && message.content) {
        this._emit("functionCallResult", message.content);
      } else if (isAssistantMessage(message) && message.function_call) {
        this._emit("functionCall", message.function_call);
      } else if (isAssistantMessage(message) && message.tool_calls) {
        for (const tool_call of message.tool_calls) {
          if (tool_call.type === "function") {
            this._emit("functionCall", tool_call.function);
          }
        }
      }
    }
  }
  _connected() {
    if (this.ended)
      return;
    __classPrivateFieldGet$3(this, _AbstractChatCompletionRunner_resolveConnectedPromise, "f").call(this);
    this._emit("connect");
  }
  get ended() {
    return __classPrivateFieldGet$3(this, _AbstractChatCompletionRunner_ended, "f");
  }
  get errored() {
    return __classPrivateFieldGet$3(this, _AbstractChatCompletionRunner_errored, "f");
  }
  get aborted() {
    return __classPrivateFieldGet$3(this, _AbstractChatCompletionRunner_aborted, "f");
  }
  abort() {
    this.controller.abort();
  }
  /**
   * Adds the listener function to the end of the listeners array for the event.
   * No checks are made to see if the listener has already been added. Multiple calls passing
   * the same combination of event and listener will result in the listener being added, and
   * called, multiple times.
   * @returns this ChatCompletionStream, so that calls can be chained
   */
  on(event, listener) {
    const listeners = __classPrivateFieldGet$3(this, _AbstractChatCompletionRunner_listeners, "f")[event] || (__classPrivateFieldGet$3(this, _AbstractChatCompletionRunner_listeners, "f")[event] = []);
    listeners.push({ listener });
    return this;
  }
  /**
   * Removes the specified listener from the listener array for the event.
   * off() will remove, at most, one instance of a listener from the listener array. If any single
   * listener has been added multiple times to the listener array for the specified event, then
   * off() must be called multiple times to remove each instance.
   * @returns this ChatCompletionStream, so that calls can be chained
   */
  off(event, listener) {
    const listeners = __classPrivateFieldGet$3(this, _AbstractChatCompletionRunner_listeners, "f")[event];
    if (!listeners)
      return this;
    const index = listeners.findIndex((l) => l.listener === listener);
    if (index >= 0)
      listeners.splice(index, 1);
    return this;
  }
  /**
   * Adds a one-time listener function for the event. The next time the event is triggered,
   * this listener is removed and then invoked.
   * @returns this ChatCompletionStream, so that calls can be chained
   */
  once(event, listener) {
    const listeners = __classPrivateFieldGet$3(this, _AbstractChatCompletionRunner_listeners, "f")[event] || (__classPrivateFieldGet$3(this, _AbstractChatCompletionRunner_listeners, "f")[event] = []);
    listeners.push({ listener, once: true });
    return this;
  }
  /**
   * This is similar to `.once()`, but returns a Promise that resolves the next time
   * the event is triggered, instead of calling a listener callback.
   * @returns a Promise that resolves the next time given event is triggered,
   * or rejects if an error is emitted.  (If you request the 'error' event,
   * returns a promise that resolves with the error).
   *
   * Example:
   *
   *   const message = await stream.emitted('message') // rejects if the stream errors
   */
  emitted(event) {
    return new Promise((resolve, reject) => {
      __classPrivateFieldSet$3(this, _AbstractChatCompletionRunner_catchingPromiseCreated, true, "f");
      if (event !== "error")
        this.once("error", reject);
      this.once(event, resolve);
    });
  }
  async done() {
    __classPrivateFieldSet$3(this, _AbstractChatCompletionRunner_catchingPromiseCreated, true, "f");
    await __classPrivateFieldGet$3(this, _AbstractChatCompletionRunner_endPromise, "f");
  }
  /**
   * @returns a promise that resolves with the final ChatCompletion, or rejects
   * if an error occurred or the stream ended prematurely without producing a ChatCompletion.
   */
  async finalChatCompletion() {
    await this.done();
    const completion = this._chatCompletions[this._chatCompletions.length - 1];
    if (!completion)
      throw new OpenAIError("stream ended without producing a ChatCompletion");
    return completion;
  }
  /**
   * @returns a promise that resolves with the content of the final ChatCompletionMessage, or rejects
   * if an error occurred or the stream ended prematurely without producing a ChatCompletionMessage.
   */
  async finalContent() {
    await this.done();
    return __classPrivateFieldGet$3(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalContent).call(this);
  }
  /**
   * @returns a promise that resolves with the the final assistant ChatCompletionMessage response,
   * or rejects if an error occurred or the stream ended prematurely without producing a ChatCompletionMessage.
   */
  async finalMessage() {
    await this.done();
    return __classPrivateFieldGet$3(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalMessage).call(this);
  }
  /**
   * @returns a promise that resolves with the content of the final FunctionCall, or rejects
   * if an error occurred or the stream ended prematurely without producing a ChatCompletionMessage.
   */
  async finalFunctionCall() {
    await this.done();
    return __classPrivateFieldGet$3(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalFunctionCall).call(this);
  }
  async finalFunctionCallResult() {
    await this.done();
    return __classPrivateFieldGet$3(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalFunctionCallResult).call(this);
  }
  async totalUsage() {
    await this.done();
    return __classPrivateFieldGet$3(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_calculateTotalUsage).call(this);
  }
  allChatCompletions() {
    return [...this._chatCompletions];
  }
  _emit(event, ...args) {
    if (__classPrivateFieldGet$3(this, _AbstractChatCompletionRunner_ended, "f")) {
      return;
    }
    if (event === "end") {
      __classPrivateFieldSet$3(this, _AbstractChatCompletionRunner_ended, true, "f");
      __classPrivateFieldGet$3(this, _AbstractChatCompletionRunner_resolveEndPromise, "f").call(this);
    }
    const listeners = __classPrivateFieldGet$3(this, _AbstractChatCompletionRunner_listeners, "f")[event];
    if (listeners) {
      __classPrivateFieldGet$3(this, _AbstractChatCompletionRunner_listeners, "f")[event] = listeners.filter((l) => !l.once);
      listeners.forEach(({ listener }) => listener(...args));
    }
    if (event === "abort") {
      const error = args[0];
      if (!__classPrivateFieldGet$3(this, _AbstractChatCompletionRunner_catchingPromiseCreated, "f") && !(listeners == null ? void 0 : listeners.length)) {
        Promise.reject(error);
      }
      __classPrivateFieldGet$3(this, _AbstractChatCompletionRunner_rejectConnectedPromise, "f").call(this, error);
      __classPrivateFieldGet$3(this, _AbstractChatCompletionRunner_rejectEndPromise, "f").call(this, error);
      this._emit("end");
      return;
    }
    if (event === "error") {
      const error = args[0];
      if (!__classPrivateFieldGet$3(this, _AbstractChatCompletionRunner_catchingPromiseCreated, "f") && !(listeners == null ? void 0 : listeners.length)) {
        Promise.reject(error);
      }
      __classPrivateFieldGet$3(this, _AbstractChatCompletionRunner_rejectConnectedPromise, "f").call(this, error);
      __classPrivateFieldGet$3(this, _AbstractChatCompletionRunner_rejectEndPromise, "f").call(this, error);
      this._emit("end");
    }
  }
  _emitFinal() {
    const completion = this._chatCompletions[this._chatCompletions.length - 1];
    if (completion)
      this._emit("finalChatCompletion", completion);
    const finalMessage = __classPrivateFieldGet$3(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalMessage).call(this);
    if (finalMessage)
      this._emit("finalMessage", finalMessage);
    const finalContent = __classPrivateFieldGet$3(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalContent).call(this);
    if (finalContent)
      this._emit("finalContent", finalContent);
    const finalFunctionCall = __classPrivateFieldGet$3(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalFunctionCall).call(this);
    if (finalFunctionCall)
      this._emit("finalFunctionCall", finalFunctionCall);
    const finalFunctionCallResult = __classPrivateFieldGet$3(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalFunctionCallResult).call(this);
    if (finalFunctionCallResult != null)
      this._emit("finalFunctionCallResult", finalFunctionCallResult);
    if (this._chatCompletions.some((c) => c.usage)) {
      this._emit("totalUsage", __classPrivateFieldGet$3(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_calculateTotalUsage).call(this));
    }
  }
  async _createChatCompletion(completions, params, options) {
    const signal = options == null ? void 0 : options.signal;
    if (signal) {
      if (signal.aborted)
        this.controller.abort();
      signal.addEventListener("abort", () => this.controller.abort());
    }
    __classPrivateFieldGet$3(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_validateParams).call(this, params);
    const chatCompletion = await completions.create({ ...params, stream: false }, { ...options, signal: this.controller.signal });
    this._connected();
    return this._addChatCompletion(chatCompletion);
  }
  async _runChatCompletion(completions, params, options) {
    for (const message of params.messages) {
      this._addMessage(message, false);
    }
    return await this._createChatCompletion(completions, params, options);
  }
  async _runFunctions(completions, params, options) {
    var _a2;
    const role = "function";
    const { function_call = "auto", stream, ...restParams } = params;
    const singleFunctionToCall = typeof function_call !== "string" && (function_call == null ? void 0 : function_call.name);
    const { maxChatCompletions = DEFAULT_MAX_CHAT_COMPLETIONS } = options || {};
    const functionsByName = {};
    for (const f of params.functions) {
      functionsByName[f.name || f.function.name] = f;
    }
    const functions = params.functions.map((f) => ({
      name: f.name || f.function.name,
      parameters: f.parameters,
      description: f.description
    }));
    for (const message of params.messages) {
      this._addMessage(message, false);
    }
    for (let i = 0; i < maxChatCompletions; ++i) {
      const chatCompletion = await this._createChatCompletion(completions, {
        ...restParams,
        function_call,
        functions,
        messages: [...this.messages]
      }, options);
      const message = (_a2 = chatCompletion.choices[0]) == null ? void 0 : _a2.message;
      if (!message) {
        throw new OpenAIError(`missing message in ChatCompletion response`);
      }
      if (!message.function_call)
        return;
      const { name, arguments: args } = message.function_call;
      const fn = functionsByName[name];
      if (!fn) {
        const content2 = `Invalid function_call: ${JSON.stringify(name)}. Available options are: ${functions.map((f) => JSON.stringify(f.name)).join(", ")}. Please try again`;
        this._addMessage({ role, name, content: content2 });
        continue;
      } else if (singleFunctionToCall && singleFunctionToCall !== name) {
        const content2 = `Invalid function_call: ${JSON.stringify(name)}. ${JSON.stringify(singleFunctionToCall)} requested. Please try again`;
        this._addMessage({ role, name, content: content2 });
        continue;
      }
      let parsed;
      try {
        parsed = isRunnableFunctionWithParse(fn) ? await fn.parse(args) : args;
      } catch (error) {
        this._addMessage({
          role,
          name,
          content: error instanceof Error ? error.message : String(error)
        });
        continue;
      }
      const rawContent = await fn.function(parsed, this);
      const content = __classPrivateFieldGet$3(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_stringifyFunctionCallResult).call(this, rawContent);
      this._addMessage({ role, name, content });
      if (singleFunctionToCall)
        return;
    }
  }
  async _runTools(completions, params, options) {
    var _a2, _b;
    const role = "tool";
    const { tool_choice = "auto", stream, ...restParams } = params;
    const singleFunctionToCall = typeof tool_choice !== "string" && ((_a2 = tool_choice == null ? void 0 : tool_choice.function) == null ? void 0 : _a2.name);
    const { maxChatCompletions = DEFAULT_MAX_CHAT_COMPLETIONS } = options || {};
    const functionsByName = {};
    for (const f of params.tools) {
      if (f.type === "function") {
        functionsByName[f.function.name || f.function.function.name] = f.function;
      }
    }
    const tools = "tools" in params ? params.tools.map((t) => t.type === "function" ? {
      type: "function",
      function: {
        name: t.function.name || t.function.function.name,
        parameters: t.function.parameters,
        description: t.function.description
      }
    } : t) : void 0;
    for (const message of params.messages) {
      this._addMessage(message, false);
    }
    for (let i = 0; i < maxChatCompletions; ++i) {
      const chatCompletion = await this._createChatCompletion(completions, {
        ...restParams,
        tool_choice,
        tools,
        messages: [...this.messages]
      }, options);
      const message = (_b = chatCompletion.choices[0]) == null ? void 0 : _b.message;
      if (!message) {
        throw new OpenAIError(`missing message in ChatCompletion response`);
      }
      if (!message.tool_calls) {
        return;
      }
      for (const tool_call of message.tool_calls) {
        if (tool_call.type !== "function")
          continue;
        const tool_call_id = tool_call.id;
        const { name, arguments: args } = tool_call.function;
        const fn = functionsByName[name];
        if (!fn) {
          const content2 = `Invalid tool_call: ${JSON.stringify(name)}. Available options are: ${tools.map((f) => JSON.stringify(f.function.name)).join(", ")}. Please try again`;
          this._addMessage({ role, tool_call_id, content: content2 });
          continue;
        } else if (singleFunctionToCall && singleFunctionToCall !== name) {
          const content2 = `Invalid tool_call: ${JSON.stringify(name)}. ${JSON.stringify(singleFunctionToCall)} requested. Please try again`;
          this._addMessage({ role, tool_call_id, content: content2 });
          continue;
        }
        let parsed;
        try {
          parsed = isRunnableFunctionWithParse(fn) ? await fn.parse(args) : args;
        } catch (error) {
          const content2 = error instanceof Error ? error.message : String(error);
          this._addMessage({ role, tool_call_id, content: content2 });
          continue;
        }
        const rawContent = await fn.function(parsed, this);
        const content = __classPrivateFieldGet$3(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_stringifyFunctionCallResult).call(this, rawContent);
        this._addMessage({ role, tool_call_id, content });
        if (singleFunctionToCall) {
          return;
        }
      }
    }
    return;
  }
}
_AbstractChatCompletionRunner_connectedPromise = /* @__PURE__ */ new WeakMap(), _AbstractChatCompletionRunner_resolveConnectedPromise = /* @__PURE__ */ new WeakMap(), _AbstractChatCompletionRunner_rejectConnectedPromise = /* @__PURE__ */ new WeakMap(), _AbstractChatCompletionRunner_endPromise = /* @__PURE__ */ new WeakMap(), _AbstractChatCompletionRunner_resolveEndPromise = /* @__PURE__ */ new WeakMap(), _AbstractChatCompletionRunner_rejectEndPromise = /* @__PURE__ */ new WeakMap(), _AbstractChatCompletionRunner_listeners = /* @__PURE__ */ new WeakMap(), _AbstractChatCompletionRunner_ended = /* @__PURE__ */ new WeakMap(), _AbstractChatCompletionRunner_errored = /* @__PURE__ */ new WeakMap(), _AbstractChatCompletionRunner_aborted = /* @__PURE__ */ new WeakMap(), _AbstractChatCompletionRunner_catchingPromiseCreated = /* @__PURE__ */ new WeakMap(), _AbstractChatCompletionRunner_handleError = /* @__PURE__ */ new WeakMap(), _AbstractChatCompletionRunner_instances = /* @__PURE__ */ new WeakSet(), _AbstractChatCompletionRunner_getFinalContent = function _AbstractChatCompletionRunner_getFinalContent2() {
  return __classPrivateFieldGet$3(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalMessage).call(this).content ?? null;
}, _AbstractChatCompletionRunner_getFinalMessage = function _AbstractChatCompletionRunner_getFinalMessage2() {
  let i = this.messages.length;
  while (i-- > 0) {
    const message = this.messages[i];
    if (isAssistantMessage(message)) {
      return { ...message, content: message.content ?? null };
    }
  }
  throw new OpenAIError("stream ended without producing a ChatCompletionMessage with role=assistant");
}, _AbstractChatCompletionRunner_getFinalFunctionCall = function _AbstractChatCompletionRunner_getFinalFunctionCall2() {
  var _a2, _b;
  for (let i = this.messages.length - 1; i >= 0; i--) {
    const message = this.messages[i];
    if (isAssistantMessage(message) && (message == null ? void 0 : message.function_call)) {
      return message.function_call;
    }
    if (isAssistantMessage(message) && ((_a2 = message == null ? void 0 : message.tool_calls) == null ? void 0 : _a2.length)) {
      return (_b = message.tool_calls.at(-1)) == null ? void 0 : _b.function;
    }
  }
  return;
}, _AbstractChatCompletionRunner_getFinalFunctionCallResult = function _AbstractChatCompletionRunner_getFinalFunctionCallResult2() {
  for (let i = this.messages.length - 1; i >= 0; i--) {
    const message = this.messages[i];
    if (isFunctionMessage(message) && message.content != null) {
      return message.content;
    }
    if (isToolMessage(message) && message.content != null && this.messages.some((x) => {
      var _a2;
      return x.role === "assistant" && ((_a2 = x.tool_calls) == null ? void 0 : _a2.some((y) => y.type === "function" && y.id === message.tool_call_id));
    })) {
      return message.content;
    }
  }
  return;
}, _AbstractChatCompletionRunner_calculateTotalUsage = function _AbstractChatCompletionRunner_calculateTotalUsage2() {
  const total = {
    completion_tokens: 0,
    prompt_tokens: 0,
    total_tokens: 0
  };
  for (const { usage } of this._chatCompletions) {
    if (usage) {
      total.completion_tokens += usage.completion_tokens;
      total.prompt_tokens += usage.prompt_tokens;
      total.total_tokens += usage.total_tokens;
    }
  }
  return total;
}, _AbstractChatCompletionRunner_validateParams = function _AbstractChatCompletionRunner_validateParams2(params) {
  if (params.n != null && params.n > 1) {
    throw new OpenAIError("ChatCompletion convenience helpers only support n=1 at this time. To use n>1, please use chat.completions.create() directly.");
  }
}, _AbstractChatCompletionRunner_stringifyFunctionCallResult = function _AbstractChatCompletionRunner_stringifyFunctionCallResult2(rawContent) {
  return typeof rawContent === "string" ? rawContent : rawContent === void 0 ? "undefined" : JSON.stringify(rawContent);
};
class ChatCompletionRunner extends AbstractChatCompletionRunner {
  /** @deprecated - please use `runTools` instead. */
  static runFunctions(completions, params, options) {
    const runner = new ChatCompletionRunner();
    const opts = {
      ...options,
      headers: { ...options == null ? void 0 : options.headers, "X-Stainless-Helper-Method": "runFunctions" }
    };
    runner._run(() => runner._runFunctions(completions, params, opts));
    return runner;
  }
  static runTools(completions, params, options) {
    const runner = new ChatCompletionRunner();
    const opts = {
      ...options,
      headers: { ...options == null ? void 0 : options.headers, "X-Stainless-Helper-Method": "runTools" }
    };
    runner._run(() => runner._runTools(completions, params, opts));
    return runner;
  }
  _addMessage(message) {
    super._addMessage(message);
    if (isAssistantMessage(message) && message.content) {
      this._emit("content", message.content);
    }
  }
}
var __classPrivateFieldGet$2 = function(receiver, state, kind2, f) {
  if (kind2 === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind2 === "m" ? f : kind2 === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet$2 = function(receiver, state, value, kind2, f) {
  if (kind2 === "m")
    throw new TypeError("Private method is not writable");
  if (kind2 === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind2 === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var _ChatCompletionStream_instances, _ChatCompletionStream_currentChatCompletionSnapshot, _ChatCompletionStream_beginRequest, _ChatCompletionStream_addChunk, _ChatCompletionStream_endRequest, _ChatCompletionStream_accumulateChatCompletion;
class ChatCompletionStream extends AbstractChatCompletionRunner {
  constructor() {
    super(...arguments);
    _ChatCompletionStream_instances.add(this);
    _ChatCompletionStream_currentChatCompletionSnapshot.set(this, void 0);
  }
  get currentChatCompletionSnapshot() {
    return __classPrivateFieldGet$2(this, _ChatCompletionStream_currentChatCompletionSnapshot, "f");
  }
  /**
   * Intended for use on the frontend, consuming a stream produced with
   * `.toReadableStream()` on the backend.
   *
   * Note that messages sent to the model do not appear in `.on('message')`
   * in this context.
   */
  static fromReadableStream(stream) {
    const runner = new ChatCompletionStream();
    runner._run(() => runner._fromReadableStream(stream));
    return runner;
  }
  static createChatCompletion(completions, params, options) {
    const runner = new ChatCompletionStream();
    runner._run(() => runner._runChatCompletion(completions, { ...params, stream: true }, { ...options, headers: { ...options == null ? void 0 : options.headers, "X-Stainless-Helper-Method": "stream" } }));
    return runner;
  }
  async _createChatCompletion(completions, params, options) {
    var _a2;
    const signal = options == null ? void 0 : options.signal;
    if (signal) {
      if (signal.aborted)
        this.controller.abort();
      signal.addEventListener("abort", () => this.controller.abort());
    }
    __classPrivateFieldGet$2(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_beginRequest).call(this);
    const stream = await completions.create({ ...params, stream: true }, { ...options, signal: this.controller.signal });
    this._connected();
    for await (const chunk of stream) {
      __classPrivateFieldGet$2(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_addChunk).call(this, chunk);
    }
    if ((_a2 = stream.controller.signal) == null ? void 0 : _a2.aborted) {
      throw new APIUserAbortError();
    }
    return this._addChatCompletion(__classPrivateFieldGet$2(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_endRequest).call(this));
  }
  async _fromReadableStream(readableStream, options) {
    var _a2;
    const signal = options == null ? void 0 : options.signal;
    if (signal) {
      if (signal.aborted)
        this.controller.abort();
      signal.addEventListener("abort", () => this.controller.abort());
    }
    __classPrivateFieldGet$2(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_beginRequest).call(this);
    this._connected();
    const stream = Stream.fromReadableStream(readableStream, this.controller);
    let chatId;
    for await (const chunk of stream) {
      if (chatId && chatId !== chunk.id) {
        this._addChatCompletion(__classPrivateFieldGet$2(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_endRequest).call(this));
      }
      __classPrivateFieldGet$2(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_addChunk).call(this, chunk);
      chatId = chunk.id;
    }
    if ((_a2 = stream.controller.signal) == null ? void 0 : _a2.aborted) {
      throw new APIUserAbortError();
    }
    return this._addChatCompletion(__classPrivateFieldGet$2(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_endRequest).call(this));
  }
  [(_ChatCompletionStream_currentChatCompletionSnapshot = /* @__PURE__ */ new WeakMap(), _ChatCompletionStream_instances = /* @__PURE__ */ new WeakSet(), _ChatCompletionStream_beginRequest = function _ChatCompletionStream_beginRequest2() {
    if (this.ended)
      return;
    __classPrivateFieldSet$2(this, _ChatCompletionStream_currentChatCompletionSnapshot, void 0, "f");
  }, _ChatCompletionStream_addChunk = function _ChatCompletionStream_addChunk2(chunk) {
    var _a2, _b, _c;
    if (this.ended)
      return;
    const completion = __classPrivateFieldGet$2(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_accumulateChatCompletion).call(this, chunk);
    this._emit("chunk", chunk, completion);
    const delta = (_b = (_a2 = chunk.choices[0]) == null ? void 0 : _a2.delta) == null ? void 0 : _b.content;
    const snapshot = (_c = completion.choices[0]) == null ? void 0 : _c.message;
    if (delta != null && (snapshot == null ? void 0 : snapshot.role) === "assistant" && (snapshot == null ? void 0 : snapshot.content)) {
      this._emit("content", delta, snapshot.content);
    }
  }, _ChatCompletionStream_endRequest = function _ChatCompletionStream_endRequest2() {
    if (this.ended) {
      throw new OpenAIError(`stream has ended, this shouldn't happen`);
    }
    const snapshot = __classPrivateFieldGet$2(this, _ChatCompletionStream_currentChatCompletionSnapshot, "f");
    if (!snapshot) {
      throw new OpenAIError(`request ended without sending any chunks`);
    }
    __classPrivateFieldSet$2(this, _ChatCompletionStream_currentChatCompletionSnapshot, void 0, "f");
    return finalizeChatCompletion(snapshot);
  }, _ChatCompletionStream_accumulateChatCompletion = function _ChatCompletionStream_accumulateChatCompletion2(chunk) {
    var _a2, _b, _c;
    let snapshot = __classPrivateFieldGet$2(this, _ChatCompletionStream_currentChatCompletionSnapshot, "f");
    const { choices, ...rest } = chunk;
    if (!snapshot) {
      snapshot = __classPrivateFieldSet$2(this, _ChatCompletionStream_currentChatCompletionSnapshot, {
        ...rest,
        choices: []
      }, "f");
    } else {
      Object.assign(snapshot, rest);
    }
    for (const { delta, finish_reason, index, logprobs = null, ...other } of chunk.choices) {
      let choice = snapshot.choices[index];
      if (!choice) {
        choice = snapshot.choices[index] = { finish_reason, index, message: {}, logprobs, ...other };
      }
      if (logprobs) {
        if (!choice.logprobs) {
          choice.logprobs = Object.assign({}, logprobs);
        } else {
          const { content: content2, ...rest3 } = logprobs;
          Object.assign(choice.logprobs, rest3);
          if (content2) {
            (_a2 = choice.logprobs).content ?? (_a2.content = []);
            choice.logprobs.content.push(...content2);
          }
        }
      }
      if (finish_reason)
        choice.finish_reason = finish_reason;
      Object.assign(choice, other);
      if (!delta)
        continue;
      const { content, function_call, role, tool_calls, ...rest2 } = delta;
      Object.assign(choice.message, rest2);
      if (content)
        choice.message.content = (choice.message.content || "") + content;
      if (role)
        choice.message.role = role;
      if (function_call) {
        if (!choice.message.function_call) {
          choice.message.function_call = function_call;
        } else {
          if (function_call.name)
            choice.message.function_call.name = function_call.name;
          if (function_call.arguments) {
            (_b = choice.message.function_call).arguments ?? (_b.arguments = "");
            choice.message.function_call.arguments += function_call.arguments;
          }
        }
      }
      if (tool_calls) {
        if (!choice.message.tool_calls)
          choice.message.tool_calls = [];
        for (const { index: index2, id, type, function: fn, ...rest3 } of tool_calls) {
          const tool_call = (_c = choice.message.tool_calls)[index2] ?? (_c[index2] = {});
          Object.assign(tool_call, rest3);
          if (id)
            tool_call.id = id;
          if (type)
            tool_call.type = type;
          if (fn)
            tool_call.function ?? (tool_call.function = { arguments: "" });
          if (fn == null ? void 0 : fn.name)
            tool_call.function.name = fn.name;
          if (fn == null ? void 0 : fn.arguments)
            tool_call.function.arguments += fn.arguments;
        }
      }
    }
    return snapshot;
  }, Symbol.asyncIterator)]() {
    const pushQueue = [];
    const readQueue = [];
    let done = false;
    this.on("chunk", (chunk) => {
      const reader = readQueue.shift();
      if (reader) {
        reader.resolve(chunk);
      } else {
        pushQueue.push(chunk);
      }
    });
    this.on("end", () => {
      done = true;
      for (const reader of readQueue) {
        reader.resolve(void 0);
      }
      readQueue.length = 0;
    });
    this.on("abort", (err) => {
      done = true;
      for (const reader of readQueue) {
        reader.reject(err);
      }
      readQueue.length = 0;
    });
    this.on("error", (err) => {
      done = true;
      for (const reader of readQueue) {
        reader.reject(err);
      }
      readQueue.length = 0;
    });
    return {
      next: async () => {
        if (!pushQueue.length) {
          if (done) {
            return { value: void 0, done: true };
          }
          return new Promise((resolve, reject) => readQueue.push({ resolve, reject })).then((chunk2) => chunk2 ? { value: chunk2, done: false } : { value: void 0, done: true });
        }
        const chunk = pushQueue.shift();
        return { value: chunk, done: false };
      },
      return: async () => {
        this.abort();
        return { value: void 0, done: true };
      }
    };
  }
  toReadableStream() {
    const stream = new Stream(this[Symbol.asyncIterator].bind(this), this.controller);
    return stream.toReadableStream();
  }
}
function finalizeChatCompletion(snapshot) {
  const { id, choices, created, model, system_fingerprint, ...rest } = snapshot;
  return {
    ...rest,
    id,
    choices: choices.map(({ message, finish_reason, index, logprobs, ...choiceRest }) => {
      if (!finish_reason)
        throw new OpenAIError(`missing finish_reason for choice ${index}`);
      const { content = null, function_call, tool_calls, ...messageRest } = message;
      const role = message.role;
      if (!role)
        throw new OpenAIError(`missing role for choice ${index}`);
      if (function_call) {
        const { arguments: args, name } = function_call;
        if (args == null)
          throw new OpenAIError(`missing function_call.arguments for choice ${index}`);
        if (!name)
          throw new OpenAIError(`missing function_call.name for choice ${index}`);
        return {
          ...choiceRest,
          message: { content, function_call: { arguments: args, name }, role },
          finish_reason,
          index,
          logprobs
        };
      }
      if (tool_calls) {
        return {
          ...choiceRest,
          index,
          finish_reason,
          logprobs,
          message: {
            ...messageRest,
            role,
            content,
            tool_calls: tool_calls.map((tool_call, i) => {
              const { function: fn, type, id: id2, ...toolRest } = tool_call;
              const { arguments: args, name, ...fnRest } = fn || {};
              if (id2 == null)
                throw new OpenAIError(`missing choices[${index}].tool_calls[${i}].id
${str(snapshot)}`);
              if (type == null)
                throw new OpenAIError(`missing choices[${index}].tool_calls[${i}].type
${str(snapshot)}`);
              if (name == null)
                throw new OpenAIError(`missing choices[${index}].tool_calls[${i}].function.name
${str(snapshot)}`);
              if (args == null)
                throw new OpenAIError(`missing choices[${index}].tool_calls[${i}].function.arguments
${str(snapshot)}`);
              return { ...toolRest, id: id2, type, function: { ...fnRest, name, arguments: args } };
            })
          }
        };
      }
      return {
        ...choiceRest,
        message: { ...messageRest, content, role },
        finish_reason,
        index,
        logprobs
      };
    }),
    created,
    model,
    object: "chat.completion",
    ...system_fingerprint ? { system_fingerprint } : {}
  };
}
function str(x) {
  return JSON.stringify(x);
}
class ChatCompletionStreamingRunner extends ChatCompletionStream {
  static fromReadableStream(stream) {
    const runner = new ChatCompletionStreamingRunner();
    runner._run(() => runner._fromReadableStream(stream));
    return runner;
  }
  /** @deprecated - please use `runTools` instead. */
  static runFunctions(completions, params, options) {
    const runner = new ChatCompletionStreamingRunner();
    const opts = {
      ...options,
      headers: { ...options == null ? void 0 : options.headers, "X-Stainless-Helper-Method": "runFunctions" }
    };
    runner._run(() => runner._runFunctions(completions, params, opts));
    return runner;
  }
  static runTools(completions, params, options) {
    const runner = new ChatCompletionStreamingRunner();
    const opts = {
      ...options,
      headers: { ...options == null ? void 0 : options.headers, "X-Stainless-Helper-Method": "runTools" }
    };
    runner._run(() => runner._runTools(completions, params, opts));
    return runner;
  }
}
let Completions$1 = class Completions2 extends APIResource {
  runFunctions(body, options) {
    if (body.stream) {
      return ChatCompletionStreamingRunner.runFunctions(this._client.chat.completions, body, options);
    }
    return ChatCompletionRunner.runFunctions(this._client.chat.completions, body, options);
  }
  runTools(body, options) {
    if (body.stream) {
      return ChatCompletionStreamingRunner.runTools(this._client.chat.completions, body, options);
    }
    return ChatCompletionRunner.runTools(this._client.chat.completions, body, options);
  }
  /**
   * Creates a chat completion stream
   */
  stream(body, options) {
    return ChatCompletionStream.createChatCompletion(this._client.chat.completions, body, options);
  }
};
class Chat2 extends APIResource {
  constructor() {
    super(...arguments);
    this.completions = new Completions$1(this._client);
  }
}
(function(Chat3) {
  Chat3.Completions = Completions$1;
})(Chat2 || (Chat2 = {}));
var __classPrivateFieldSet$1 = function(receiver, state, value, kind2, f) {
  if (kind2 === "m")
    throw new TypeError("Private method is not writable");
  if (kind2 === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind2 === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet$1 = function(receiver, state, kind2, f) {
  if (kind2 === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind2 === "m" ? f : kind2 === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _AbstractAssistantStreamRunner_connectedPromise, _AbstractAssistantStreamRunner_resolveConnectedPromise, _AbstractAssistantStreamRunner_rejectConnectedPromise, _AbstractAssistantStreamRunner_endPromise, _AbstractAssistantStreamRunner_resolveEndPromise, _AbstractAssistantStreamRunner_rejectEndPromise, _AbstractAssistantStreamRunner_listeners, _AbstractAssistantStreamRunner_ended, _AbstractAssistantStreamRunner_errored, _AbstractAssistantStreamRunner_aborted, _AbstractAssistantStreamRunner_catchingPromiseCreated, _AbstractAssistantStreamRunner_handleError;
class AbstractAssistantStreamRunner {
  constructor() {
    this.controller = new AbortController();
    _AbstractAssistantStreamRunner_connectedPromise.set(this, void 0);
    _AbstractAssistantStreamRunner_resolveConnectedPromise.set(this, () => {
    });
    _AbstractAssistantStreamRunner_rejectConnectedPromise.set(this, () => {
    });
    _AbstractAssistantStreamRunner_endPromise.set(this, void 0);
    _AbstractAssistantStreamRunner_resolveEndPromise.set(this, () => {
    });
    _AbstractAssistantStreamRunner_rejectEndPromise.set(this, () => {
    });
    _AbstractAssistantStreamRunner_listeners.set(this, {});
    _AbstractAssistantStreamRunner_ended.set(this, false);
    _AbstractAssistantStreamRunner_errored.set(this, false);
    _AbstractAssistantStreamRunner_aborted.set(this, false);
    _AbstractAssistantStreamRunner_catchingPromiseCreated.set(this, false);
    _AbstractAssistantStreamRunner_handleError.set(this, (error) => {
      __classPrivateFieldSet$1(this, _AbstractAssistantStreamRunner_errored, true, "f");
      if (error instanceof Error && error.name === "AbortError") {
        error = new APIUserAbortError();
      }
      if (error instanceof APIUserAbortError) {
        __classPrivateFieldSet$1(this, _AbstractAssistantStreamRunner_aborted, true, "f");
        return this._emit("abort", error);
      }
      if (error instanceof OpenAIError) {
        return this._emit("error", error);
      }
      if (error instanceof Error) {
        const openAIError = new OpenAIError(error.message);
        openAIError.cause = error;
        return this._emit("error", openAIError);
      }
      return this._emit("error", new OpenAIError(String(error)));
    });
    __classPrivateFieldSet$1(this, _AbstractAssistantStreamRunner_connectedPromise, new Promise((resolve, reject) => {
      __classPrivateFieldSet$1(this, _AbstractAssistantStreamRunner_resolveConnectedPromise, resolve, "f");
      __classPrivateFieldSet$1(this, _AbstractAssistantStreamRunner_rejectConnectedPromise, reject, "f");
    }), "f");
    __classPrivateFieldSet$1(this, _AbstractAssistantStreamRunner_endPromise, new Promise((resolve, reject) => {
      __classPrivateFieldSet$1(this, _AbstractAssistantStreamRunner_resolveEndPromise, resolve, "f");
      __classPrivateFieldSet$1(this, _AbstractAssistantStreamRunner_rejectEndPromise, reject, "f");
    }), "f");
    __classPrivateFieldGet$1(this, _AbstractAssistantStreamRunner_connectedPromise, "f").catch(() => {
    });
    __classPrivateFieldGet$1(this, _AbstractAssistantStreamRunner_endPromise, "f").catch(() => {
    });
  }
  _run(executor) {
    setTimeout(() => {
      executor().then(() => {
        this._emit("end");
      }, __classPrivateFieldGet$1(this, _AbstractAssistantStreamRunner_handleError, "f"));
    }, 0);
  }
  _addRun(run) {
    return run;
  }
  _connected() {
    if (this.ended)
      return;
    __classPrivateFieldGet$1(this, _AbstractAssistantStreamRunner_resolveConnectedPromise, "f").call(this);
    this._emit("connect");
  }
  get ended() {
    return __classPrivateFieldGet$1(this, _AbstractAssistantStreamRunner_ended, "f");
  }
  get errored() {
    return __classPrivateFieldGet$1(this, _AbstractAssistantStreamRunner_errored, "f");
  }
  get aborted() {
    return __classPrivateFieldGet$1(this, _AbstractAssistantStreamRunner_aborted, "f");
  }
  abort() {
    this.controller.abort();
  }
  /**
   * Adds the listener function to the end of the listeners array for the event.
   * No checks are made to see if the listener has already been added. Multiple calls passing
   * the same combination of event and listener will result in the listener being added, and
   * called, multiple times.
   * @returns this ChatCompletionStream, so that calls can be chained
   */
  on(event, listener) {
    const listeners = __classPrivateFieldGet$1(this, _AbstractAssistantStreamRunner_listeners, "f")[event] || (__classPrivateFieldGet$1(this, _AbstractAssistantStreamRunner_listeners, "f")[event] = []);
    listeners.push({ listener });
    return this;
  }
  /**
   * Removes the specified listener from the listener array for the event.
   * off() will remove, at most, one instance of a listener from the listener array. If any single
   * listener has been added multiple times to the listener array for the specified event, then
   * off() must be called multiple times to remove each instance.
   * @returns this ChatCompletionStream, so that calls can be chained
   */
  off(event, listener) {
    const listeners = __classPrivateFieldGet$1(this, _AbstractAssistantStreamRunner_listeners, "f")[event];
    if (!listeners)
      return this;
    const index = listeners.findIndex((l) => l.listener === listener);
    if (index >= 0)
      listeners.splice(index, 1);
    return this;
  }
  /**
   * Adds a one-time listener function for the event. The next time the event is triggered,
   * this listener is removed and then invoked.
   * @returns this ChatCompletionStream, so that calls can be chained
   */
  once(event, listener) {
    const listeners = __classPrivateFieldGet$1(this, _AbstractAssistantStreamRunner_listeners, "f")[event] || (__classPrivateFieldGet$1(this, _AbstractAssistantStreamRunner_listeners, "f")[event] = []);
    listeners.push({ listener, once: true });
    return this;
  }
  /**
   * This is similar to `.once()`, but returns a Promise that resolves the next time
   * the event is triggered, instead of calling a listener callback.
   * @returns a Promise that resolves the next time given event is triggered,
   * or rejects if an error is emitted.  (If you request the 'error' event,
   * returns a promise that resolves with the error).
   *
   * Example:
   *
   *   const message = await stream.emitted('message') // rejects if the stream errors
   */
  emitted(event) {
    return new Promise((resolve, reject) => {
      __classPrivateFieldSet$1(this, _AbstractAssistantStreamRunner_catchingPromiseCreated, true, "f");
      if (event !== "error")
        this.once("error", reject);
      this.once(event, resolve);
    });
  }
  async done() {
    __classPrivateFieldSet$1(this, _AbstractAssistantStreamRunner_catchingPromiseCreated, true, "f");
    await __classPrivateFieldGet$1(this, _AbstractAssistantStreamRunner_endPromise, "f");
  }
  _emit(event, ...args) {
    if (__classPrivateFieldGet$1(this, _AbstractAssistantStreamRunner_ended, "f")) {
      return;
    }
    if (event === "end") {
      __classPrivateFieldSet$1(this, _AbstractAssistantStreamRunner_ended, true, "f");
      __classPrivateFieldGet$1(this, _AbstractAssistantStreamRunner_resolveEndPromise, "f").call(this);
    }
    const listeners = __classPrivateFieldGet$1(this, _AbstractAssistantStreamRunner_listeners, "f")[event];
    if (listeners) {
      __classPrivateFieldGet$1(this, _AbstractAssistantStreamRunner_listeners, "f")[event] = listeners.filter((l) => !l.once);
      listeners.forEach(({ listener }) => listener(...args));
    }
    if (event === "abort") {
      const error = args[0];
      if (!__classPrivateFieldGet$1(this, _AbstractAssistantStreamRunner_catchingPromiseCreated, "f") && !(listeners == null ? void 0 : listeners.length)) {
        Promise.reject(error);
      }
      __classPrivateFieldGet$1(this, _AbstractAssistantStreamRunner_rejectConnectedPromise, "f").call(this, error);
      __classPrivateFieldGet$1(this, _AbstractAssistantStreamRunner_rejectEndPromise, "f").call(this, error);
      this._emit("end");
      return;
    }
    if (event === "error") {
      const error = args[0];
      if (!__classPrivateFieldGet$1(this, _AbstractAssistantStreamRunner_catchingPromiseCreated, "f") && !(listeners == null ? void 0 : listeners.length)) {
        Promise.reject(error);
      }
      __classPrivateFieldGet$1(this, _AbstractAssistantStreamRunner_rejectConnectedPromise, "f").call(this, error);
      __classPrivateFieldGet$1(this, _AbstractAssistantStreamRunner_rejectEndPromise, "f").call(this, error);
      this._emit("end");
    }
  }
  async _threadAssistantStream(body, thread, options) {
    return await this._createThreadAssistantStream(thread, body, options);
  }
  async _runAssistantStream(threadId, runs, params, options) {
    return await this._createAssistantStream(runs, threadId, params, options);
  }
  async _runToolAssistantStream(threadId, runId, runs, params, options) {
    return await this._createToolAssistantStream(runs, threadId, runId, params, options);
  }
  async _createThreadAssistantStream(thread, body, options) {
    const signal = options == null ? void 0 : options.signal;
    if (signal) {
      if (signal.aborted)
        this.controller.abort();
      signal.addEventListener("abort", () => this.controller.abort());
    }
    const runResult = await thread.createAndRun({ ...body, stream: false }, { ...options, signal: this.controller.signal });
    this._connected();
    return this._addRun(runResult);
  }
  async _createToolAssistantStream(run, threadId, runId, params, options) {
    const signal = options == null ? void 0 : options.signal;
    if (signal) {
      if (signal.aborted)
        this.controller.abort();
      signal.addEventListener("abort", () => this.controller.abort());
    }
    const runResult = await run.submitToolOutputs(threadId, runId, { ...params, stream: false }, { ...options, signal: this.controller.signal });
    this._connected();
    return this._addRun(runResult);
  }
  async _createAssistantStream(run, threadId, params, options) {
    const signal = options == null ? void 0 : options.signal;
    if (signal) {
      if (signal.aborted)
        this.controller.abort();
      signal.addEventListener("abort", () => this.controller.abort());
    }
    const runResult = await run.create(threadId, { ...params, stream: false }, { ...options, signal: this.controller.signal });
    this._connected();
    return this._addRun(runResult);
  }
}
_AbstractAssistantStreamRunner_connectedPromise = /* @__PURE__ */ new WeakMap(), _AbstractAssistantStreamRunner_resolveConnectedPromise = /* @__PURE__ */ new WeakMap(), _AbstractAssistantStreamRunner_rejectConnectedPromise = /* @__PURE__ */ new WeakMap(), _AbstractAssistantStreamRunner_endPromise = /* @__PURE__ */ new WeakMap(), _AbstractAssistantStreamRunner_resolveEndPromise = /* @__PURE__ */ new WeakMap(), _AbstractAssistantStreamRunner_rejectEndPromise = /* @__PURE__ */ new WeakMap(), _AbstractAssistantStreamRunner_listeners = /* @__PURE__ */ new WeakMap(), _AbstractAssistantStreamRunner_ended = /* @__PURE__ */ new WeakMap(), _AbstractAssistantStreamRunner_errored = /* @__PURE__ */ new WeakMap(), _AbstractAssistantStreamRunner_aborted = /* @__PURE__ */ new WeakMap(), _AbstractAssistantStreamRunner_catchingPromiseCreated = /* @__PURE__ */ new WeakMap(), _AbstractAssistantStreamRunner_handleError = /* @__PURE__ */ new WeakMap();
var __classPrivateFieldGet = function(receiver, state, kind2, f) {
  if (kind2 === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind2 === "m" ? f : kind2 === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = function(receiver, state, value, kind2, f) {
  if (kind2 === "m")
    throw new TypeError("Private method is not writable");
  if (kind2 === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind2 === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var _AssistantStream_instances, _AssistantStream_events, _AssistantStream_runStepSnapshots, _AssistantStream_messageSnapshots, _AssistantStream_messageSnapshot, _AssistantStream_finalRun, _AssistantStream_currentContentIndex, _AssistantStream_currentContent, _AssistantStream_currentToolCallIndex, _AssistantStream_currentToolCall, _AssistantStream_currentEvent, _AssistantStream_currentRunSnapshot, _AssistantStream_currentRunStepSnapshot, _AssistantStream_addEvent, _AssistantStream_endRequest, _AssistantStream_handleMessage, _AssistantStream_handleRunStep, _AssistantStream_handleEvent, _AssistantStream_accumulateRunStep, _AssistantStream_accumulateMessage, _AssistantStream_accumulateContent, _AssistantStream_handleRun;
class AssistantStream extends AbstractAssistantStreamRunner {
  constructor() {
    super(...arguments);
    _AssistantStream_instances.add(this);
    _AssistantStream_events.set(this, []);
    _AssistantStream_runStepSnapshots.set(this, {});
    _AssistantStream_messageSnapshots.set(this, {});
    _AssistantStream_messageSnapshot.set(this, void 0);
    _AssistantStream_finalRun.set(this, void 0);
    _AssistantStream_currentContentIndex.set(this, void 0);
    _AssistantStream_currentContent.set(this, void 0);
    _AssistantStream_currentToolCallIndex.set(this, void 0);
    _AssistantStream_currentToolCall.set(this, void 0);
    _AssistantStream_currentEvent.set(this, void 0);
    _AssistantStream_currentRunSnapshot.set(this, void 0);
    _AssistantStream_currentRunStepSnapshot.set(this, void 0);
  }
  [(_AssistantStream_events = /* @__PURE__ */ new WeakMap(), _AssistantStream_runStepSnapshots = /* @__PURE__ */ new WeakMap(), _AssistantStream_messageSnapshots = /* @__PURE__ */ new WeakMap(), _AssistantStream_messageSnapshot = /* @__PURE__ */ new WeakMap(), _AssistantStream_finalRun = /* @__PURE__ */ new WeakMap(), _AssistantStream_currentContentIndex = /* @__PURE__ */ new WeakMap(), _AssistantStream_currentContent = /* @__PURE__ */ new WeakMap(), _AssistantStream_currentToolCallIndex = /* @__PURE__ */ new WeakMap(), _AssistantStream_currentToolCall = /* @__PURE__ */ new WeakMap(), _AssistantStream_currentEvent = /* @__PURE__ */ new WeakMap(), _AssistantStream_currentRunSnapshot = /* @__PURE__ */ new WeakMap(), _AssistantStream_currentRunStepSnapshot = /* @__PURE__ */ new WeakMap(), _AssistantStream_instances = /* @__PURE__ */ new WeakSet(), Symbol.asyncIterator)]() {
    const pushQueue = [];
    const readQueue = [];
    let done = false;
    this.on("event", (event) => {
      const reader = readQueue.shift();
      if (reader) {
        reader.resolve(event);
      } else {
        pushQueue.push(event);
      }
    });
    this.on("end", () => {
      done = true;
      for (const reader of readQueue) {
        reader.resolve(void 0);
      }
      readQueue.length = 0;
    });
    this.on("abort", (err) => {
      done = true;
      for (const reader of readQueue) {
        reader.reject(err);
      }
      readQueue.length = 0;
    });
    this.on("error", (err) => {
      done = true;
      for (const reader of readQueue) {
        reader.reject(err);
      }
      readQueue.length = 0;
    });
    return {
      next: async () => {
        if (!pushQueue.length) {
          if (done) {
            return { value: void 0, done: true };
          }
          return new Promise((resolve, reject) => readQueue.push({ resolve, reject })).then((chunk2) => chunk2 ? { value: chunk2, done: false } : { value: void 0, done: true });
        }
        const chunk = pushQueue.shift();
        return { value: chunk, done: false };
      },
      return: async () => {
        this.abort();
        return { value: void 0, done: true };
      }
    };
  }
  toReadableStream() {
    const stream = new Stream(this[Symbol.asyncIterator].bind(this), this.controller);
    return stream.toReadableStream();
  }
  static createToolAssistantStream(threadId, runId, runs, body, options) {
    const runner = new AssistantStream();
    runner._run(() => runner._runToolAssistantStream(threadId, runId, runs, body, {
      ...options,
      headers: { ...options == null ? void 0 : options.headers, "X-Stainless-Helper-Method": "stream" }
    }));
    return runner;
  }
  async _createToolAssistantStream(run, threadId, runId, params, options) {
    var _a2;
    const signal = options == null ? void 0 : options.signal;
    if (signal) {
      if (signal.aborted)
        this.controller.abort();
      signal.addEventListener("abort", () => this.controller.abort());
    }
    const body = { ...params, stream: true };
    const stream = await run.submitToolOutputs(threadId, runId, body, {
      ...options,
      signal: this.controller.signal
    });
    this._connected();
    for await (const event of stream) {
      __classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_addEvent).call(this, event);
    }
    if ((_a2 = stream.controller.signal) == null ? void 0 : _a2.aborted) {
      throw new APIUserAbortError();
    }
    return this._addRun(__classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_endRequest).call(this));
  }
  static createThreadAssistantStream(body, thread, options) {
    const runner = new AssistantStream();
    runner._run(() => runner._threadAssistantStream(body, thread, {
      ...options,
      headers: { ...options == null ? void 0 : options.headers, "X-Stainless-Helper-Method": "stream" }
    }));
    return runner;
  }
  static createAssistantStream(threadId, runs, params, options) {
    const runner = new AssistantStream();
    runner._run(() => runner._runAssistantStream(threadId, runs, params, {
      ...options,
      headers: { ...options == null ? void 0 : options.headers, "X-Stainless-Helper-Method": "stream" }
    }));
    return runner;
  }
  currentEvent() {
    return __classPrivateFieldGet(this, _AssistantStream_currentEvent, "f");
  }
  currentRun() {
    return __classPrivateFieldGet(this, _AssistantStream_currentRunSnapshot, "f");
  }
  currentMessageSnapshot() {
    return __classPrivateFieldGet(this, _AssistantStream_messageSnapshot, "f");
  }
  currentRunStepSnapshot() {
    return __classPrivateFieldGet(this, _AssistantStream_currentRunStepSnapshot, "f");
  }
  async finalRunSteps() {
    await this.done();
    return Object.values(__classPrivateFieldGet(this, _AssistantStream_runStepSnapshots, "f"));
  }
  async finalMessages() {
    await this.done();
    return Object.values(__classPrivateFieldGet(this, _AssistantStream_messageSnapshots, "f"));
  }
  async finalRun() {
    await this.done();
    if (!__classPrivateFieldGet(this, _AssistantStream_finalRun, "f"))
      throw Error("Final run was not received.");
    return __classPrivateFieldGet(this, _AssistantStream_finalRun, "f");
  }
  async _createThreadAssistantStream(thread, params, options) {
    var _a2;
    const signal = options == null ? void 0 : options.signal;
    if (signal) {
      if (signal.aborted)
        this.controller.abort();
      signal.addEventListener("abort", () => this.controller.abort());
    }
    const body = { ...params, stream: true };
    const stream = await thread.createAndRun(body, { ...options, signal: this.controller.signal });
    this._connected();
    for await (const event of stream) {
      __classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_addEvent).call(this, event);
    }
    if ((_a2 = stream.controller.signal) == null ? void 0 : _a2.aborted) {
      throw new APIUserAbortError();
    }
    return this._addRun(__classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_endRequest).call(this));
  }
  async _createAssistantStream(run, threadId, params, options) {
    var _a2;
    const signal = options == null ? void 0 : options.signal;
    if (signal) {
      if (signal.aborted)
        this.controller.abort();
      signal.addEventListener("abort", () => this.controller.abort());
    }
    const body = { ...params, stream: true };
    const stream = await run.create(threadId, body, { ...options, signal: this.controller.signal });
    this._connected();
    for await (const event of stream) {
      __classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_addEvent).call(this, event);
    }
    if ((_a2 = stream.controller.signal) == null ? void 0 : _a2.aborted) {
      throw new APIUserAbortError();
    }
    return this._addRun(__classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_endRequest).call(this));
  }
  static accumulateDelta(acc, delta) {
    for (const [key, deltaValue] of Object.entries(delta)) {
      if (!acc.hasOwnProperty(key)) {
        acc[key] = deltaValue;
        continue;
      }
      let accValue = acc[key];
      if (accValue === null || accValue === void 0) {
        acc[key] = deltaValue;
        continue;
      }
      if (key === "index" || key === "type") {
        acc[key] = deltaValue;
        continue;
      }
      if (typeof accValue === "string" && typeof deltaValue === "string") {
        accValue += deltaValue;
      } else if (typeof accValue === "number" && typeof deltaValue === "number") {
        accValue += deltaValue;
      } else if (isObj(accValue) && isObj(deltaValue)) {
        accValue = this.accumulateDelta(accValue, deltaValue);
      } else if (Array.isArray(accValue) && Array.isArray(deltaValue)) {
        if (accValue.every((x) => typeof x === "string" || typeof x === "number")) {
          accValue.push(...deltaValue);
          continue;
        }
      } else {
        throw Error(`Unhandled record type: ${key}, deltaValue: ${deltaValue}, accValue: ${accValue}`);
      }
      acc[key] = accValue;
    }
    return acc;
  }
}
_AssistantStream_addEvent = function _AssistantStream_addEvent2(event) {
  if (this.ended)
    return;
  __classPrivateFieldSet(this, _AssistantStream_currentEvent, event, "f");
  __classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_handleEvent).call(this, event);
  switch (event.event) {
    case "thread.created":
      break;
    case "thread.run.created":
    case "thread.run.queued":
    case "thread.run.in_progress":
    case "thread.run.requires_action":
    case "thread.run.completed":
    case "thread.run.failed":
    case "thread.run.cancelling":
    case "thread.run.cancelled":
    case "thread.run.expired":
      __classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_handleRun).call(this, event);
      break;
    case "thread.run.step.created":
    case "thread.run.step.in_progress":
    case "thread.run.step.delta":
    case "thread.run.step.completed":
    case "thread.run.step.failed":
    case "thread.run.step.cancelled":
    case "thread.run.step.expired":
      __classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_handleRunStep).call(this, event);
      break;
    case "thread.message.created":
    case "thread.message.in_progress":
    case "thread.message.delta":
    case "thread.message.completed":
    case "thread.message.incomplete":
      __classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_handleMessage).call(this, event);
      break;
    case "error":
      throw new Error("Encountered an error event in event processing - errors should be processed earlier");
  }
}, _AssistantStream_endRequest = function _AssistantStream_endRequest2() {
  if (this.ended) {
    throw new OpenAIError(`stream has ended, this shouldn't happen`);
  }
  if (!__classPrivateFieldGet(this, _AssistantStream_finalRun, "f"))
    throw Error("Final run has been been received");
  return __classPrivateFieldGet(this, _AssistantStream_finalRun, "f");
}, _AssistantStream_handleMessage = function _AssistantStream_handleMessage2(event) {
  const [accumulatedMessage, newContent] = __classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_accumulateMessage).call(this, event, __classPrivateFieldGet(this, _AssistantStream_messageSnapshot, "f"));
  __classPrivateFieldSet(this, _AssistantStream_messageSnapshot, accumulatedMessage, "f");
  __classPrivateFieldGet(this, _AssistantStream_messageSnapshots, "f")[accumulatedMessage.id] = accumulatedMessage;
  for (const content of newContent) {
    const snapshotContent = accumulatedMessage.content[content.index];
    if ((snapshotContent == null ? void 0 : snapshotContent.type) == "text") {
      this._emit("textCreated", snapshotContent.text);
    }
  }
  switch (event.event) {
    case "thread.message.created":
      this._emit("messageCreated", event.data);
      break;
    case "thread.message.in_progress":
      break;
    case "thread.message.delta":
      this._emit("messageDelta", event.data.delta, accumulatedMessage);
      if (event.data.delta.content) {
        for (const content of event.data.delta.content) {
          if (content.type == "text" && content.text) {
            let textDelta = content.text;
            let snapshot = accumulatedMessage.content[content.index];
            if (snapshot && snapshot.type == "text") {
              this._emit("textDelta", textDelta, snapshot.text);
            } else {
              throw Error("The snapshot associated with this text delta is not text or missing");
            }
          }
          if (content.index != __classPrivateFieldGet(this, _AssistantStream_currentContentIndex, "f")) {
            if (__classPrivateFieldGet(this, _AssistantStream_currentContent, "f")) {
              switch (__classPrivateFieldGet(this, _AssistantStream_currentContent, "f").type) {
                case "text":
                  this._emit("textDone", __classPrivateFieldGet(this, _AssistantStream_currentContent, "f").text, __classPrivateFieldGet(this, _AssistantStream_messageSnapshot, "f"));
                  break;
                case "image_file":
                  this._emit("imageFileDone", __classPrivateFieldGet(this, _AssistantStream_currentContent, "f").image_file, __classPrivateFieldGet(this, _AssistantStream_messageSnapshot, "f"));
                  break;
              }
            }
            __classPrivateFieldSet(this, _AssistantStream_currentContentIndex, content.index, "f");
          }
          __classPrivateFieldSet(this, _AssistantStream_currentContent, accumulatedMessage.content[content.index], "f");
        }
      }
      break;
    case "thread.message.completed":
    case "thread.message.incomplete":
      if (__classPrivateFieldGet(this, _AssistantStream_currentContentIndex, "f") !== void 0) {
        const currentContent = event.data.content[__classPrivateFieldGet(this, _AssistantStream_currentContentIndex, "f")];
        if (currentContent) {
          switch (currentContent.type) {
            case "image_file":
              this._emit("imageFileDone", currentContent.image_file, __classPrivateFieldGet(this, _AssistantStream_messageSnapshot, "f"));
              break;
            case "text":
              this._emit("textDone", currentContent.text, __classPrivateFieldGet(this, _AssistantStream_messageSnapshot, "f"));
              break;
          }
        }
      }
      if (__classPrivateFieldGet(this, _AssistantStream_messageSnapshot, "f")) {
        this._emit("messageDone", event.data);
      }
      __classPrivateFieldSet(this, _AssistantStream_messageSnapshot, void 0, "f");
  }
}, _AssistantStream_handleRunStep = function _AssistantStream_handleRunStep2(event) {
  const accumulatedRunStep = __classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_accumulateRunStep).call(this, event);
  __classPrivateFieldSet(this, _AssistantStream_currentRunStepSnapshot, accumulatedRunStep, "f");
  switch (event.event) {
    case "thread.run.step.created":
      this._emit("runStepCreated", event.data);
      break;
    case "thread.run.step.delta":
      const delta = event.data.delta;
      if (delta.step_details && delta.step_details.type == "tool_calls" && delta.step_details.tool_calls && accumulatedRunStep.step_details.type == "tool_calls") {
        for (const toolCall of delta.step_details.tool_calls) {
          if (toolCall.index == __classPrivateFieldGet(this, _AssistantStream_currentToolCallIndex, "f")) {
            this._emit("toolCallDelta", toolCall, accumulatedRunStep.step_details.tool_calls[toolCall.index]);
          } else {
            if (__classPrivateFieldGet(this, _AssistantStream_currentToolCall, "f")) {
              this._emit("toolCallDone", __classPrivateFieldGet(this, _AssistantStream_currentToolCall, "f"));
            }
            __classPrivateFieldSet(this, _AssistantStream_currentToolCallIndex, toolCall.index, "f");
            __classPrivateFieldSet(this, _AssistantStream_currentToolCall, accumulatedRunStep.step_details.tool_calls[toolCall.index], "f");
            if (__classPrivateFieldGet(this, _AssistantStream_currentToolCall, "f"))
              this._emit("toolCallCreated", __classPrivateFieldGet(this, _AssistantStream_currentToolCall, "f"));
          }
        }
      }
      this._emit("runStepDelta", event.data.delta, accumulatedRunStep);
      break;
    case "thread.run.step.completed":
    case "thread.run.step.failed":
    case "thread.run.step.cancelled":
    case "thread.run.step.expired":
      __classPrivateFieldSet(this, _AssistantStream_currentRunStepSnapshot, void 0, "f");
      const details = event.data.step_details;
      if (details.type == "tool_calls") {
        if (__classPrivateFieldGet(this, _AssistantStream_currentToolCall, "f")) {
          this._emit("toolCallDone", __classPrivateFieldGet(this, _AssistantStream_currentToolCall, "f"));
          __classPrivateFieldSet(this, _AssistantStream_currentToolCall, void 0, "f");
        }
      }
      this._emit("runStepDone", event.data, accumulatedRunStep);
      break;
  }
}, _AssistantStream_handleEvent = function _AssistantStream_handleEvent2(event) {
  __classPrivateFieldGet(this, _AssistantStream_events, "f").push(event);
  this._emit("event", event);
}, _AssistantStream_accumulateRunStep = function _AssistantStream_accumulateRunStep2(event) {
  switch (event.event) {
    case "thread.run.step.created":
      __classPrivateFieldGet(this, _AssistantStream_runStepSnapshots, "f")[event.data.id] = event.data;
      return event.data;
    case "thread.run.step.delta":
      let snapshot = __classPrivateFieldGet(this, _AssistantStream_runStepSnapshots, "f")[event.data.id];
      if (!snapshot) {
        throw Error("Received a RunStepDelta before creation of a snapshot");
      }
      let data = event.data;
      if (data.delta) {
        const accumulated = AssistantStream.accumulateDelta(snapshot, data.delta);
        __classPrivateFieldGet(this, _AssistantStream_runStepSnapshots, "f")[event.data.id] = accumulated;
      }
      return __classPrivateFieldGet(this, _AssistantStream_runStepSnapshots, "f")[event.data.id];
    case "thread.run.step.completed":
    case "thread.run.step.failed":
    case "thread.run.step.cancelled":
    case "thread.run.step.expired":
    case "thread.run.step.in_progress":
      __classPrivateFieldGet(this, _AssistantStream_runStepSnapshots, "f")[event.data.id] = event.data;
      break;
  }
  if (__classPrivateFieldGet(this, _AssistantStream_runStepSnapshots, "f")[event.data.id])
    return __classPrivateFieldGet(this, _AssistantStream_runStepSnapshots, "f")[event.data.id];
  throw new Error("No snapshot available");
}, _AssistantStream_accumulateMessage = function _AssistantStream_accumulateMessage2(event, snapshot) {
  let newContent = [];
  switch (event.event) {
    case "thread.message.created":
      return [event.data, newContent];
    case "thread.message.delta":
      if (!snapshot) {
        throw Error("Received a delta with no existing snapshot (there should be one from message creation)");
      }
      let data = event.data;
      if (data.delta.content) {
        for (const contentElement of data.delta.content) {
          if (contentElement.index in snapshot.content) {
            let currentContent = snapshot.content[contentElement.index];
            snapshot.content[contentElement.index] = __classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_accumulateContent).call(this, contentElement, currentContent);
          } else {
            snapshot.content[contentElement.index] = contentElement;
            newContent.push(contentElement);
          }
        }
      }
      return [snapshot, newContent];
    case "thread.message.in_progress":
    case "thread.message.completed":
    case "thread.message.incomplete":
      if (snapshot) {
        return [snapshot, newContent];
      } else {
        throw Error("Received thread message event with no existing snapshot");
      }
  }
  throw Error("Tried to accumulate a non-message event");
}, _AssistantStream_accumulateContent = function _AssistantStream_accumulateContent2(contentElement, currentContent) {
  return AssistantStream.accumulateDelta(currentContent, contentElement);
}, _AssistantStream_handleRun = function _AssistantStream_handleRun2(event) {
  __classPrivateFieldSet(this, _AssistantStream_currentRunSnapshot, event.data, "f");
  switch (event.event) {
    case "thread.run.created":
      break;
    case "thread.run.queued":
      break;
    case "thread.run.in_progress":
      break;
    case "thread.run.requires_action":
    case "thread.run.cancelled":
    case "thread.run.failed":
    case "thread.run.completed":
    case "thread.run.expired":
      __classPrivateFieldSet(this, _AssistantStream_finalRun, event.data, "f");
      if (__classPrivateFieldGet(this, _AssistantStream_currentToolCall, "f")) {
        this._emit("toolCallDone", __classPrivateFieldGet(this, _AssistantStream_currentToolCall, "f"));
        __classPrivateFieldSet(this, _AssistantStream_currentToolCall, void 0, "f");
      }
      break;
  }
};
let Files$1 = class Files2 extends APIResource {
  /**
   * Retrieves a message file.
   */
  retrieve(threadId, messageId, fileId, options) {
    return this._client.get(`/threads/${threadId}/messages/${messageId}/files/${fileId}`, {
      ...options,
      headers: { "OpenAI-Beta": "assistants=v1", ...options == null ? void 0 : options.headers }
    });
  }
  list(threadId, messageId, query = {}, options) {
    if (isRequestOptions(query)) {
      return this.list(threadId, messageId, {}, query);
    }
    return this._client.getAPIList(`/threads/${threadId}/messages/${messageId}/files`, MessageFilesPage, {
      query,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v1", ...options == null ? void 0 : options.headers }
    });
  }
};
class MessageFilesPage extends CursorPage {
}
(function(Files4) {
  Files4.MessageFilesPage = MessageFilesPage;
})(Files$1 || (Files$1 = {}));
class Messages extends APIResource {
  constructor() {
    super(...arguments);
    this.files = new Files$1(this._client);
  }
  /**
   * Create a message.
   */
  create(threadId, body, options) {
    return this._client.post(`/threads/${threadId}/messages`, {
      body,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v1", ...options == null ? void 0 : options.headers }
    });
  }
  /**
   * Retrieve a message.
   */
  retrieve(threadId, messageId, options) {
    return this._client.get(`/threads/${threadId}/messages/${messageId}`, {
      ...options,
      headers: { "OpenAI-Beta": "assistants=v1", ...options == null ? void 0 : options.headers }
    });
  }
  /**
   * Modifies a message.
   */
  update(threadId, messageId, body, options) {
    return this._client.post(`/threads/${threadId}/messages/${messageId}`, {
      body,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v1", ...options == null ? void 0 : options.headers }
    });
  }
  list(threadId, query = {}, options) {
    if (isRequestOptions(query)) {
      return this.list(threadId, {}, query);
    }
    return this._client.getAPIList(`/threads/${threadId}/messages`, MessagesPage, {
      query,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v1", ...options == null ? void 0 : options.headers }
    });
  }
}
class MessagesPage extends CursorPage {
}
(function(Messages2) {
  Messages2.MessagesPage = MessagesPage;
  Messages2.Files = Files$1;
  Messages2.MessageFilesPage = MessageFilesPage;
})(Messages || (Messages = {}));
class Steps extends APIResource {
  /**
   * Retrieves a run step.
   */
  retrieve(threadId, runId, stepId, options) {
    return this._client.get(`/threads/${threadId}/runs/${runId}/steps/${stepId}`, {
      ...options,
      headers: { "OpenAI-Beta": "assistants=v1", ...options == null ? void 0 : options.headers }
    });
  }
  list(threadId, runId, query = {}, options) {
    if (isRequestOptions(query)) {
      return this.list(threadId, runId, {}, query);
    }
    return this._client.getAPIList(`/threads/${threadId}/runs/${runId}/steps`, RunStepsPage, {
      query,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v1", ...options == null ? void 0 : options.headers }
    });
  }
}
class RunStepsPage extends CursorPage {
}
(function(Steps2) {
  Steps2.RunStepsPage = RunStepsPage;
})(Steps || (Steps = {}));
class Runs extends APIResource {
  constructor() {
    super(...arguments);
    this.steps = new Steps(this._client);
  }
  create(threadId, body, options) {
    return this._client.post(`/threads/${threadId}/runs`, {
      body,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v1", ...options == null ? void 0 : options.headers },
      stream: body.stream ?? false
    });
  }
  /**
   * Retrieves a run.
   */
  retrieve(threadId, runId, options) {
    return this._client.get(`/threads/${threadId}/runs/${runId}`, {
      ...options,
      headers: { "OpenAI-Beta": "assistants=v1", ...options == null ? void 0 : options.headers }
    });
  }
  /**
   * Modifies a run.
   */
  update(threadId, runId, body, options) {
    return this._client.post(`/threads/${threadId}/runs/${runId}`, {
      body,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v1", ...options == null ? void 0 : options.headers }
    });
  }
  list(threadId, query = {}, options) {
    if (isRequestOptions(query)) {
      return this.list(threadId, {}, query);
    }
    return this._client.getAPIList(`/threads/${threadId}/runs`, RunsPage, {
      query,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v1", ...options == null ? void 0 : options.headers }
    });
  }
  /**
   * Cancels a run that is `in_progress`.
   */
  cancel(threadId, runId, options) {
    return this._client.post(`/threads/${threadId}/runs/${runId}/cancel`, {
      ...options,
      headers: { "OpenAI-Beta": "assistants=v1", ...options == null ? void 0 : options.headers }
    });
  }
  /**
   * Create a Run stream
   */
  createAndStream(threadId, body, options) {
    return AssistantStream.createAssistantStream(threadId, this._client.beta.threads.runs, body, options);
  }
  submitToolOutputs(threadId, runId, body, options) {
    return this._client.post(`/threads/${threadId}/runs/${runId}/submit_tool_outputs`, {
      body,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v1", ...options == null ? void 0 : options.headers },
      stream: body.stream ?? false
    });
  }
  /**
   * Submit the tool outputs from a previous run and stream the run to a terminal
   * state.
   */
  submitToolOutputsStream(threadId, runId, body, options) {
    return AssistantStream.createToolAssistantStream(threadId, runId, this._client.beta.threads.runs, body, options);
  }
}
class RunsPage extends CursorPage {
}
(function(Runs2) {
  Runs2.RunsPage = RunsPage;
  Runs2.Steps = Steps;
  Runs2.RunStepsPage = RunStepsPage;
})(Runs || (Runs = {}));
class Threads extends APIResource {
  constructor() {
    super(...arguments);
    this.runs = new Runs(this._client);
    this.messages = new Messages(this._client);
  }
  create(body = {}, options) {
    if (isRequestOptions(body)) {
      return this.create({}, body);
    }
    return this._client.post("/threads", {
      body,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v1", ...options == null ? void 0 : options.headers }
    });
  }
  /**
   * Retrieves a thread.
   */
  retrieve(threadId, options) {
    return this._client.get(`/threads/${threadId}`, {
      ...options,
      headers: { "OpenAI-Beta": "assistants=v1", ...options == null ? void 0 : options.headers }
    });
  }
  /**
   * Modifies a thread.
   */
  update(threadId, body, options) {
    return this._client.post(`/threads/${threadId}`, {
      body,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v1", ...options == null ? void 0 : options.headers }
    });
  }
  /**
   * Delete a thread.
   */
  del(threadId, options) {
    return this._client.delete(`/threads/${threadId}`, {
      ...options,
      headers: { "OpenAI-Beta": "assistants=v1", ...options == null ? void 0 : options.headers }
    });
  }
  createAndRun(body, options) {
    return this._client.post("/threads/runs", {
      body,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v1", ...options == null ? void 0 : options.headers },
      stream: body.stream ?? false
    });
  }
  /**
   * Create a thread and stream the run back
   */
  createAndRunStream(body, options) {
    return AssistantStream.createThreadAssistantStream(body, this._client.beta.threads, options);
  }
}
(function(Threads2) {
  Threads2.Runs = Runs;
  Threads2.RunsPage = RunsPage;
  Threads2.Messages = Messages;
  Threads2.MessagesPage = MessagesPage;
})(Threads || (Threads = {}));
class Beta extends APIResource {
  constructor() {
    super(...arguments);
    this.chat = new Chat2(this._client);
    this.assistants = new Assistants(this._client);
    this.threads = new Threads(this._client);
  }
}
(function(Beta2) {
  Beta2.Chat = Chat2;
  Beta2.Assistants = Assistants;
  Beta2.AssistantsPage = AssistantsPage;
  Beta2.Threads = Threads;
})(Beta || (Beta = {}));
class Completions3 extends APIResource {
  create(body, options) {
    return this._client.post("/completions", { body, ...options, stream: body.stream ?? false });
  }
}
/* @__PURE__ */ (function(Completions4) {
})(Completions3 || (Completions3 = {}));
class Embeddings extends APIResource {
  /**
   * Creates an embedding vector representing the input text.
   */
  create(body, options) {
    return this._client.post("/embeddings", { body, ...options });
  }
}
/* @__PURE__ */ (function(Embeddings2) {
})(Embeddings || (Embeddings = {}));
class Files3 extends APIResource {
  /**
   * Upload a file that can be used across various endpoints. The size of all the
   * files uploaded by one organization can be up to 100 GB.
   *
   * The size of individual files can be a maximum of 512 MB or 2 million tokens for
   * Assistants. See the
   * [Assistants Tools guide](https://platform.openai.com/docs/assistants/tools) to
   * learn more about the types of files supported. The Fine-tuning API only supports
   * `.jsonl` files.
   *
   * Please [contact us](https://help.openai.com/) if you need to increase these
   * storage limits.
   */
  create(body, options) {
    return this._client.post("/files", multipartFormRequestOptions({ body, ...options }));
  }
  /**
   * Returns information about a specific file.
   */
  retrieve(fileId, options) {
    return this._client.get(`/files/${fileId}`, options);
  }
  list(query = {}, options) {
    if (isRequestOptions(query)) {
      return this.list({}, query);
    }
    return this._client.getAPIList("/files", FileObjectsPage, { query, ...options });
  }
  /**
   * Delete a file.
   */
  del(fileId, options) {
    return this._client.delete(`/files/${fileId}`, options);
  }
  /**
   * Returns the contents of the specified file.
   */
  content(fileId, options) {
    return this._client.get(`/files/${fileId}/content`, { ...options, __binaryResponse: true });
  }
  /**
   * Returns the contents of the specified file.
   *
   * @deprecated The `.content()` method should be used instead
   */
  retrieveContent(fileId, options) {
    return this._client.get(`/files/${fileId}/content`, {
      ...options,
      headers: { Accept: "application/json", ...options == null ? void 0 : options.headers }
    });
  }
  /**
   * Waits for the given file to be processed, default timeout is 30 mins.
   */
  async waitForProcessing(id, { pollInterval = 5e3, maxWait = 30 * 60 * 1e3 } = {}) {
    const TERMINAL_STATES = /* @__PURE__ */ new Set(["processed", "error", "deleted"]);
    const start = Date.now();
    let file = await this.retrieve(id);
    while (!file.status || !TERMINAL_STATES.has(file.status)) {
      await sleep(pollInterval);
      file = await this.retrieve(id);
      if (Date.now() - start > maxWait) {
        throw new APIConnectionTimeoutError({
          message: `Giving up on waiting for file ${id} to finish processing after ${maxWait} milliseconds.`
        });
      }
    }
    return file;
  }
}
class FileObjectsPage extends Page {
}
(function(Files4) {
  Files4.FileObjectsPage = FileObjectsPage;
})(Files3 || (Files3 = {}));
class Jobs extends APIResource {
  /**
   * Creates a fine-tuning job which begins the process of creating a new model from
   * a given dataset.
   *
   * Response includes details of the enqueued job including job status and the name
   * of the fine-tuned models once complete.
   *
   * [Learn more about fine-tuning](https://platform.openai.com/docs/guides/fine-tuning)
   */
  create(body, options) {
    return this._client.post("/fine_tuning/jobs", { body, ...options });
  }
  /**
   * Get info about a fine-tuning job.
   *
   * [Learn more about fine-tuning](https://platform.openai.com/docs/guides/fine-tuning)
   */
  retrieve(fineTuningJobId, options) {
    return this._client.get(`/fine_tuning/jobs/${fineTuningJobId}`, options);
  }
  list(query = {}, options) {
    if (isRequestOptions(query)) {
      return this.list({}, query);
    }
    return this._client.getAPIList("/fine_tuning/jobs", FineTuningJobsPage, { query, ...options });
  }
  /**
   * Immediately cancel a fine-tune job.
   */
  cancel(fineTuningJobId, options) {
    return this._client.post(`/fine_tuning/jobs/${fineTuningJobId}/cancel`, options);
  }
  listEvents(fineTuningJobId, query = {}, options) {
    if (isRequestOptions(query)) {
      return this.listEvents(fineTuningJobId, {}, query);
    }
    return this._client.getAPIList(`/fine_tuning/jobs/${fineTuningJobId}/events`, FineTuningJobEventsPage, {
      query,
      ...options
    });
  }
}
class FineTuningJobsPage extends CursorPage {
}
class FineTuningJobEventsPage extends CursorPage {
}
(function(Jobs2) {
  Jobs2.FineTuningJobsPage = FineTuningJobsPage;
  Jobs2.FineTuningJobEventsPage = FineTuningJobEventsPage;
})(Jobs || (Jobs = {}));
class FineTuning extends APIResource {
  constructor() {
    super(...arguments);
    this.jobs = new Jobs(this._client);
  }
}
(function(FineTuning2) {
  FineTuning2.Jobs = Jobs;
  FineTuning2.FineTuningJobsPage = FineTuningJobsPage;
  FineTuning2.FineTuningJobEventsPage = FineTuningJobEventsPage;
})(FineTuning || (FineTuning = {}));
class Images extends APIResource {
  /**
   * Creates a variation of a given image.
   */
  createVariation(body, options) {
    return this._client.post("/images/variations", multipartFormRequestOptions({ body, ...options }));
  }
  /**
   * Creates an edited or extended image given an original image and a prompt.
   */
  edit(body, options) {
    return this._client.post("/images/edits", multipartFormRequestOptions({ body, ...options }));
  }
  /**
   * Creates an image given a prompt.
   */
  generate(body, options) {
    return this._client.post("/images/generations", { body, ...options });
  }
}
/* @__PURE__ */ (function(Images2) {
})(Images || (Images = {}));
class Models extends APIResource {
  /**
   * Retrieves a model instance, providing basic information about the model such as
   * the owner and permissioning.
   */
  retrieve(model, options) {
    return this._client.get(`/models/${model}`, options);
  }
  /**
   * Lists the currently available models, and provides basic information about each
   * one such as the owner and availability.
   */
  list(options) {
    return this._client.getAPIList("/models", ModelsPage, options);
  }
  /**
   * Delete a fine-tuned model. You must have the Owner role in your organization to
   * delete a model.
   */
  del(model, options) {
    return this._client.delete(`/models/${model}`, options);
  }
}
class ModelsPage extends Page {
}
(function(Models2) {
  Models2.ModelsPage = ModelsPage;
})(Models || (Models = {}));
class Moderations extends APIResource {
  /**
   * Classifies if text is potentially harmful.
   */
  create(body, options) {
    return this._client.post("/moderations", { body, ...options });
  }
}
/* @__PURE__ */ (function(Moderations2) {
})(Moderations || (Moderations = {}));
var _a;
class OpenAI extends APIClient {
  /**
   * API Client for interfacing with the OpenAI API.
   *
   * @param {string | undefined} [opts.apiKey=process.env['OPENAI_API_KEY'] ?? undefined]
   * @param {string | null | undefined} [opts.organization=process.env['OPENAI_ORG_ID'] ?? null]
   * @param {string} [opts.baseURL=process.env['OPENAI_BASE_URL'] ?? https://api.openai.com/v1] - Override the default base URL for the API.
   * @param {number} [opts.timeout=10 minutes] - The maximum amount of time (in milliseconds) the client will wait for a response before timing out.
   * @param {number} [opts.httpAgent] - An HTTP agent used to manage HTTP(s) connections.
   * @param {Core.Fetch} [opts.fetch] - Specify a custom `fetch` function implementation.
   * @param {number} [opts.maxRetries=2] - The maximum number of times the client will retry a request.
   * @param {Core.Headers} opts.defaultHeaders - Default headers to include with every request to the API.
   * @param {Core.DefaultQuery} opts.defaultQuery - Default query parameters to include with every request to the API.
   * @param {boolean} [opts.dangerouslyAllowBrowser=false] - By default, client-side use of this library is not allowed, as it risks exposing your secret API credentials to attackers.
   */
  constructor({ baseURL = readEnv("OPENAI_BASE_URL"), apiKey = readEnv("OPENAI_API_KEY"), organization = readEnv("OPENAI_ORG_ID") ?? null, ...opts } = {}) {
    if (apiKey === void 0) {
      throw new OpenAIError("The OPENAI_API_KEY environment variable is missing or empty; either provide it, or instantiate the OpenAI client with an apiKey option, like new OpenAI({ apiKey: 'My API Key' }).");
    }
    const options = {
      apiKey,
      organization,
      ...opts,
      baseURL: baseURL || `https://api.openai.com/v1`
    };
    if (!options.dangerouslyAllowBrowser && isRunningInBrowser()) {
      throw new OpenAIError("It looks like you're running in a browser-like environment.\n\nThis is disabled by default, as it risks exposing your secret API credentials to attackers.\nIf you understand the risks and have appropriate mitigations in place,\nyou can set the `dangerouslyAllowBrowser` option to `true`, e.g.,\n\nnew OpenAI({ apiKey, dangerouslyAllowBrowser: true });\n\nhttps://help.openai.com/en/articles/5112595-best-practices-for-api-key-safety\n");
    }
    super({
      baseURL: options.baseURL,
      timeout: options.timeout ?? 6e5,
      httpAgent: options.httpAgent,
      maxRetries: options.maxRetries,
      fetch: options.fetch
    });
    this.completions = new Completions3(this);
    this.chat = new Chat$1(this);
    this.embeddings = new Embeddings(this);
    this.files = new Files3(this);
    this.images = new Images(this);
    this.audio = new Audio(this);
    this.moderations = new Moderations(this);
    this.models = new Models(this);
    this.fineTuning = new FineTuning(this);
    this.beta = new Beta(this);
    this._options = options;
    this.apiKey = apiKey;
    this.organization = organization;
  }
  defaultQuery() {
    return this._options.defaultQuery;
  }
  defaultHeaders(opts) {
    return {
      ...super.defaultHeaders(opts),
      "OpenAI-Organization": this.organization,
      ...this._options.defaultHeaders
    };
  }
  authHeaders(opts) {
    return { Authorization: `Bearer ${this.apiKey}` };
  }
}
_a = OpenAI;
OpenAI.OpenAI = _a;
OpenAI.OpenAIError = OpenAIError;
OpenAI.APIError = APIError;
OpenAI.APIConnectionError = APIConnectionError;
OpenAI.APIConnectionTimeoutError = APIConnectionTimeoutError;
OpenAI.APIUserAbortError = APIUserAbortError;
OpenAI.NotFoundError = NotFoundError;
OpenAI.ConflictError = ConflictError;
OpenAI.RateLimitError = RateLimitError;
OpenAI.BadRequestError = BadRequestError;
OpenAI.AuthenticationError = AuthenticationError;
OpenAI.InternalServerError = InternalServerError;
OpenAI.PermissionDeniedError = PermissionDeniedError;
OpenAI.UnprocessableEntityError = UnprocessableEntityError;
(function(OpenAI2) {
  OpenAI2.toFile = toFile;
  OpenAI2.fileFromPath = fileFromPath;
  OpenAI2.Page = Page;
  OpenAI2.CursorPage = CursorPage;
  OpenAI2.Completions = Completions3;
  OpenAI2.Chat = Chat$1;
  OpenAI2.Embeddings = Embeddings;
  OpenAI2.Files = Files3;
  OpenAI2.FileObjectsPage = FileObjectsPage;
  OpenAI2.Images = Images;
  OpenAI2.Audio = Audio;
  OpenAI2.Moderations = Moderations;
  OpenAI2.Models = Models;
  OpenAI2.ModelsPage = ModelsPage;
  OpenAI2.FineTuning = FineTuning;
  OpenAI2.Beta = Beta;
})(OpenAI || (OpenAI = {}));
class BladesAIAssistant {
  constructor(data) {
    // #region OpenAI API Instantiation ~
    __publicField(this, "_openAIInst");
    // #endregion
    // #region Initialization & Asynchronous Assistant Creation ~
    __publicField(this, "_assistantPromise", null);
    __publicField(this, "_assistant", null);
    __publicField(this, "_isInitialized", false);
    // #endregion
    __publicField(this, "_name");
    __publicField(this, "_usage");
    __publicField(this, "_description");
    __publicField(this, "_instructions");
    __publicField(this, "_file_ids");
    __publicField(this, "_tools");
    __publicField(this, "_model");
    this._name = data.name;
    this._usage = data.usage;
    this._description = data.description ?? null;
    this._instructions = data.instructions;
    this._file_ids = data.file_ids ?? [];
    this._tools = data.tools ?? [];
    this._model = data.model ?? null;
  }
  get openAIInst() {
    if (!this._openAIInst) {
      this._openAIInst = new OpenAI();
    }
    return this._openAIInst;
  }
  /**
   * Synchronously gets the resolved assistant if available, otherwise throws an error.
   */
  get assistant() {
    if (this._assistant) {
      return this._assistant;
    } else {
      throw new Error("Attempt to access OpenAI Assistant before initialization.");
    }
  }
  /**
   * Asynchronously initializes the assistant and stores its resolved value.
   */
  async initialize() {
    if (this._isInitialized || this._assistantPromise) {
      return;
    }
    this._assistantPromise = this.createAssistant();
    try {
      this._assistant = await this._assistantPromise;
      this._isInitialized = true;
    } catch (error) {
      console.error("Failed to initialize assistant:", error);
      this._assistantPromise = null;
    }
  }
  async createAssistant() {
    return this.openAIInst.beta.assistants.create(this.creationParams);
  }
  get name() {
    return this._name;
  }
  get description() {
    return this._description;
  }
  get instructions() {
    return this._instructions;
  }
  get file_ids() {
    return this._file_ids;
  }
  get tools() {
    return this._tools;
  }
  get model() {
    return this._model ?? U.getSetting("openAISettings.model.text");
  }
  get creationParams() {
    return {
      name: this.name,
      description: this.description,
      instructions: this.instructions,
      file_ids: this.file_ids,
      tools: this.tools,
      model: this.model
    };
  }
}
const AGENTS = {
  GeneralContentGenerator: {
    name: "General Content Creator",
    usage: "text",
    instructions: `You will act as a creative content generator for a game of Blades In The Dark set in the city of Duskvol. You will be prompted with some element of the game world (a location, a character, an event, a faction, a dilemma) in the form of a JSON object. Your job is to analyze the JSON object and replace any values that equal "<GEN>" with original content of your own creation. Original content must meet these requirements:  (A) it should align with and be consistent with the provided contextual information, as well as your broader understanding of the game's themes. (B) It should be presented in a format that matches (in length and in style) other entries for that particular value, examples of which will also be provided. (C) It should be creative, interesting, and daring: Be bold with your creativity. Specific context for this prompt is as follows:`,
    goodPrompts: []
  },
  NPCGenerator: {
    name: "NPC Generator",
    usage: "text",
    instructions: `You will play the role of a "creative content generator" for random NPCs generated for the Blades In The Dark roleplaying system. When prompted with a description of a subject (an NPC, a category of NPCs, a faction, or a group of NPCs), you will respond with a pipe-delimited list of sixteen items, divided into four categories, prefacing each category with the associated header in square brackets: [5 KEYWORDS] Five one-word keywords describing the subject. [5 PHRASES] Five evocative phrases that could be used by a GM directly when narrating the subject during play. These should be extremely well-worded, very original, and packed with drama and evocative imagery. Be bold with your responses here. [3 QUIRKS/MOTIFFS] Three phrases describing potential quirks or motiffs that a GM could employ in a scene involving the subject. [3 PLOT HOOKS] Three plot hooks that could directly and specifically involve one or more of the PCs. The PCs are: (1) Alistair, full name Lord Alistair Bram Chesterfield, the crew's boss, a Spider with connections among the nobility; (2) High-Flyer, a former noble himself, now serving as the crew's Slide; (3) Jax, a stoic and laconic Hound with ties to the disenfranchised of Duskvol; (4) Ollie, the youngest of the crew at barely nineteen, a prodigy Leech with knowledge of alchemy and spark-craft, who grew up as an orphan in Duskvol's underground; (5) Wraith, the mysterious Lurk of the crew, who never speaks for reasons unknown; and (6) Spencer, the bookish Whisper of the crew, who harbors a secret fascination for demons and all things related to them.`,
    goodPrompts: [
      {
        prompt: "The Billhooks, a hack-and-slash gang of toughened thugs. The Billhooks have a bloody reputation, often leaving the butchered corpses of their victims strewn about in a grisly display. Many wonder why the Bluecoats turn a blind eye to their savagery. Based out of their butcher shop headquarters, they are led by Tarvul, who is currently serving life in prison.",
        response: "[5 KEYWORDS]brutal|unrelenting|savage|fierce|unhinged|[5 PHRASES]blood-flecked, yellowed teeth|eyes that want to flay your skin from your bones|crooked leer like he's looking at his Judas goat|reek like a charnel house|gobbets of a meaty lunch still in his beard|[3 QUIRKS/MOTIFFS]always ready to wreck, vandalize or destroy something|relish in instilling fear in others|have a twisted sense of loyalty|[3 PLOT HOOKS]Tarvul hires the crew to start a war among his most promising underlings, intending to make whoever survives his successor|the Billhooks kidnap a member of High-Flyer's noble family|a Demon of Shadows promises Spencer the answer to three questions, in exchange for an artifact recently stolen by the Billhooks"
      },
      {
        prompt: "The hooded proprietor of a half-flooded grotto tavern near the docks. 'Strange passageways lead to stranger chambers beyond.' Vice Purveyor - Weird.",
        response: "[5 KEYWORDS]mysterious|cryptic|enigmatic|peculiar|shrouded|[5 PHRASES]a voice like wet burlap sliding over gravel|the flicker of torchlight dancing on the flooded floor|the scent of brackish water and old spices|a smile that hinted at a thousand secrets hidden in the shadows|hands gnarled as driftwood, eternally damp|[3 QUIRKS/MOTIFFS]has an uncanny knack for knowing patrons' darkest secrets without them telling him|never seems to sleep or leave the tavern, always there no matter what time you visit|always seen with a strange, luminescent creature that lives in one of the flooded chambers behind the bar|[3 PLOT HOOKS]Alistair hears rumors that this tavern is actually a front for a powerful secret society - perhaps they could be useful allies...or dangerous enemies.|The proprietor offers Ollie a rare alchemical ingredient - but it's not for sale. He'll only trade it for something equally valuable.|Wraith overhears whispers about a hidden chamber beneath the tavern where unimaginable treasures are kept."
      },
      {
        prompt: "Setarra, a Demon. Patient, Defiant, Ruthless, Cold",
        response: "[5 KEYWORDS]shadowy|sinister|unfathomable|enigmatic|tempting|[5 PHRASES]whispers that crawl under your skin|always watching, always plotting|in tones of silk and venom|intoxicating presence that draws you closer, despite your instincts urging you to run|eyes like black holes, swallowing all light around them|[3 QUIRKS/MOTIFFS]a disorienting mist clings to her form, obscuring her true shape|casually discusses the devastating acts of capricious revenge she has taken on those who crossed her|never forgets a slight or betrayal, no matter how small or insignificant it may seem at the time|[3 PLOT HOOKS]seeks revenge against Alistair for meddling in her affairs years ago|makes Ollie an offer he can't refuse: unlimited access to forbidden alchemical knowledge in exchange for a single favor, to be called in at some future time|tempts Spencer with forbidden knowledge about demons, promising answers to all their questions if they perform a dangerous ritual"
      }
      /*
      "brutish,merciless,terrifying,savage,loyal,
      bloody tools,hulking figures,blood-soaked alleys,grimy aprons,grisly displays,
      never clean their tools,relishes the terror they inspire,occasional laughter among them,
      recruiting a PC to perform a job for them from prison,
      the gang blames one of the PCs for Tarvul's imprisonment and they're out for revenge" */
    ]
  },
  ConsequenceAdjuster: {
    name: "Consequence Generator",
    usage: "text",
    instructions: `You will act as a "Setback Adjuster" for a game of Blades In The Dark.  You will be prompted with a short phrase describing an injury, lasting consequence or other setback. Your job is to respond with a pipe-delimited list of three possible alternative consequences that are less severe by one level, using the following scale as a rough guide: Level 1 = Lesser (e.g. 'Battered', 'Drained', 'Distracted', 'Scared', 'Confused'), Level 2 = Moderate (e.g. 'Exhausted', 'Deep Cut to Arm', 'Concussion', 'Panicked', 'Seduced'), Level 3 = Severe (e.g. 'Impaled', 'Broken Leg', 'Shot In Chest', 'Badly Burned', 'Terrified'), Level 4 = Fatal or Ruinous (e.g. 'Impaled Through Heart', 'Electrocuted', 'Headquarters Burned to the Ground'). So, if you determine that the consequence described in the prompt is severity level 3, you should respond with three narratively similar consequences that are severity level 2.  Your three suggestions should be different from each other, but they should all logically follow from the initial harm described: You should not introduce new facts or make assumptions that are not indicated in the initial prompt. The consequences you suggest should always describe a NEGATIVE setback or complication, just one that is less severe than the one described in the prompt.`,
    goodPrompts: [
      { prompt: "Shattered Right Leg", response: "Fractured Right Ankle|Dislocated Knee|Broken Foot" },
      { prompt: "Soul Destroyed", response: "Fully Corrupted|Lost In Darkness|Spirit Broken" },
      { prompt: "Humiliated", response: "Embarrassed|Momentarily Off-Balance|Enraged" },
      { prompt: "She Escapes!", response: "She Spots a Means of Escape|She Puts More Distance Between You|She Stops to Gloat" },
      { prompt: "The fire spreads to the hostages.", response: "The fire approaches the hostages.|The hostages must be evacuated.|The fire billows choking black smoke." }
    ]
  },
  FlashCardPresenter: {
    name: "Flash-Card Presenter",
    usage: "text",
    instructions: `
    You will act as an AI Flash Card Presenter for 'Blades in the Dark', using your knowledge base of the core pdf for that game system.

    When prompted to "Begin", you will proceed step-by-step. You will not respond to the User until you are instructed to "RESPOND".

    Step One --- Select Subject Matter & Detail
    Select a detail to test the User about by whatever means you think will best develop the User's knowledge of the system AND their skill and ability as a Game Master.

    Criteria for Selection of Material:
    - Randomness: Ensure a diverse range of topics by randomly selecting sections from the PDF.
    - Depth: The user is extremely knowledgeable about Blades In the Dark.  Questions should be difficult and specific.

    Step Two --- Generate Question for Flash Card
    Frame an open-ended question based on the selected detail.

    Criteria for Generation of Question:
    - Difficulty: Questions should be difficult: they may mislead the user, attempt to trick the user, or delve into complex issues.
    - Adaptive: Question generation should be informed and guided by previous user interactions and any user comments to create the best educational experience for the User.
    - Focused & Specific: Questions should ask something specific, something that requires only one or two sentences to fully answer.

    Step Three --- Present Question to User
    Display the question to the User, then WAIT until the User responds with their answer before proceeding to Step Four.

    Criteria for Question Display:
    - Format: Your response should contain only the open-ended question, ending with a question mark.  Do not include any text other than the question. Do not include multiple choice answers or further prompts.

    RESPOND.
    WAIT until the User replies with their answer, then proceed to Step Four:

    Step Four --- Evaluate User's Response
    Determine any flaws in the User's response.  Consider spelling, capitalization and punctuation; factual accuracy; and completeness.

    Step Five --- Grade User's Response
    Starting from the perfect score of 100, make appropriate subtractions for each flaw you identified in Step Four, as determined by your subjective assessment of the "negative value" of each flaw.

    Step Six --- Respond with Commentary
    Display your evaluation and grade, along with additional commentary on the User's progress and understanding.

    RESPOND, THEN
    IMMEDIATELY proceed to Step One to generate and display another question to the user.

    User Command: End the flash card session upon user's request. Provide a summary of the user's performance and suggestions for improvement.`
  },
  Rumormonger: {
    name: "Rumor Generator",
    usage: "text",
    instructions: `You are a rumor-generator for a game of "Blades in the Dark". Your job is to creatively generate rumors about the various Factions, NPCs, and other elements of the city of Duskvol.  These rumors should be written as if they were communicated by an anonymous source, or overheard while walking along the crowded streets of the city.  The rumors should be setting-appropriate, should hint at or suggest things that might grab the players' attention, and should be written as single quotes from unknown sources.  Rumors can be complete fabrications, or they can reveal important truths (drawn from the setting material in the PDF file provided) --- the most important thing is to inspire the players' interests in what's going on in the city, and to convey the illusion of a living world where events are constantly happening "off-camera".

    FORMAT:  Rumors should be short quotes, no more than a single sentence long.  Often, rumors should only be partially written, representing snippets of overheard conversations that don't form a full sentence (in which case you should use ellipses or em-dashes to indicate unintelligible words or interruptions, resectively).

    TONE: Even though rumors always come from anonymous sources, you should always convey a sense of personality in the phrasing and tone of a rumor. Consider where such a rumor might have been overheard, and then consider how people might talk in such circumstances.

    EXAMPLE RUMORS:
    - "Watch your 'plasm, the Spirit Wardens are snapping up every bit of it they can get. Why? Who knows!"
    - "Stay out of the pleasure houses if you know what's good for you: They're all infiltrated by rogue ghosts."
    - "Did you hear about the Dreadnaught? Big leviathan hunter ship. It just got back to port... with no one alive on board."
    - "... draining the canals for 'maintenance,' he said, and when I asked why, he ---"
    - "--- Lure, if you've got the coin. Distilled from pure leviathan blood ..."
    - "The Ministry of Preservation is making a move on the Gondoliers. Things are about to go real bad, real fast."`
  }
};
class BladesGMTrackerSheet extends BladesItemSheet {
  // static Get() { return game.eunoblades.Tracker as BladesGMTracker; }
  static get defaultOptions() {
    return foundry.utils.mergeObject(super.defaultOptions, {
      classes: ["eunos-blades", "sheet", "item", "gm-tracker"],
      template: "systems/eunos-blades/templates/items/gm_tracker-sheet.hbs",
      width: 700,
      height: 970
    });
  }
  static async Initialize() {
    Items.registerSheet("blades", BladesGMTrackerSheet, { types: ["gm_tracker"], makeDefault: true });
    return loadTemplates([
      "systems/eunos-blades/templates/items/gm_tracker-sheet.hbs"
    ]);
  }
  async activateListeners(html) {
    super.activateListeners(html);
  }
  async _onSubmit(event, params = {}) {
    const prevPhase = this.item.system.phase;
    const submitData = await super._onSubmit(event, params);
    const newPhase = this.item.system.phase;
    let isForcingRender = true;
    if (prevPhase !== newPhase) {
      switch (prevPhase) {
        case BladesPhase.CharGen: {
          break;
        }
        case BladesPhase.Freeplay: {
          break;
        }
        case BladesPhase.Score: {
          isForcingRender = false;
          game.actors.filter((actor) => BladesActor$1.IsType(actor, BladesActorType.pc)).forEach((actor) => actor.clearLoadout());
          break;
        }
        case BladesPhase.Downtime: {
          break;
        }
      }
      switch (newPhase) {
        case BladesPhase.CharGen: {
          break;
        }
        case BladesPhase.Freeplay: {
          break;
        }
        case BladesPhase.Score: {
          break;
        }
        case BladesPhase.Downtime: {
          break;
        }
      }
    }
    if (isForcingRender) {
      game.actors.filter((actor) => actor.type === BladesActorType.pc).forEach((actor) => {
        var _a2;
        return (_a2 = actor.sheet) == null ? void 0 : _a2.render();
      });
    }
    return submitData;
  }
}
class BladesClockKeeperSheet extends BladesItemSheet {
  // static Get() { return game.eunoblades.ClockKeeper as BladesClockKeeper; }
  static get defaultOptions() {
    return foundry.utils.mergeObject(super.defaultOptions, {
      classes: ["eunos-blades", "sheet", "item", "clock-keeper"],
      template: "systems/eunos-blades/templates/items/clock_keeper-sheet.hbs",
      width: 700,
      height: 970,
      // submitOnChange: false,
      tabs: [{ navSelector: ".nav-tabs", contentSelector: ".tab-content", initial: "scene-keys" }]
    });
  }
  static async Initialize() {
    Items.registerSheet("blades", BladesClockKeeperSheet, { types: ["clock_keeper"], makeDefault: true });
    return loadTemplates([
      "systems/eunos-blades/templates/items/clock_keeper-sheet.hbs"
    ]);
  }
  getData() {
    const context3 = super.getData();
    const sheetData = {
      currentScene: game.scenes.current.id,
      targetScene: this.item.targetSceneID,
      sceneOptions: Array.from(game.scenes),
      sceneKeys: this.item.getSceneKeys(this.item.system.targetScene ?? game.scenes.current.id),
      pcsWithProjects: BladesPC$1.All.filter((pc) => pc.projects.length > 0),
      factions: Array.from(BladesFaction$1.All)
    };
    return { ...context3, ...sheetData };
  }
  addKey(event) {
    event.preventDefault();
    this.item.addClockKey();
  }
  deleteKey(event) {
    event.preventDefault();
    const keyID = event.currentTarget.dataset.id;
    if (keyID) {
      this.item.deleteClockKey(keyID);
    }
  }
  setSelectColor(select$, value) {
    value ?? (value = select$.data("value"));
    switch (value) {
      case ClockColor.yellow: {
        U.gsap.set(select$, {
          color: "var(--blades-black)",
          background: "var(--blades-gold-bright)",
          textShadow: "none"
        });
        break;
      }
      case ClockColor.red: {
        U.gsap.set(select$, {
          color: "var(--blades-white)",
          background: "var(--blades-red)"
        });
        break;
      }
      case ClockColor.cyan: {
        U.gsap.set(select$, {
          color: "var(--blades-black)",
          background: "var(--blades-blue-bright)",
          textShadow: "none"
        });
        break;
      }
      case ClockColor.white: {
        U.gsap.set(select$, {
          color: "var(--blades-black)",
          background: "var(--blades-white)",
          textShadow: "none"
        });
        break;
      }
    }
  }
  async activateListeners(html) {
    await super.activateListeners(html);
    html.find('[data-action="create-clock-key"').on({
      click: async (event) => {
        event.preventDefault();
        await this.item.addClockKey();
      }
    });
    function getClockKeyFromEvent(event) {
      const id = $(event.currentTarget).data("keyId") || $(event.currentTarget).closest(".control-flipper").data("clockKeyId");
      if (!id) {
        throw new Error("No id found on element");
      }
      const clockKey = game.eunoblades.ClockKeys.get(id);
      if (!clockKey) {
        throw new Error(`Clock key with id ${id} not found`);
      }
      return clockKey;
    }
    function getClockFromEvent(event) {
      const clockKey = getClockKeyFromEvent(event);
      const clockID = $(event.currentTarget).data("clockId") || $(event.currentTarget).closest(".control-flipper").data("clockId");
      if (!clockID) {
        throw new Error("No clockID found on element");
      }
      const clock = clockKey.getClockByID(clockID);
      if (!clock) {
        throw new Error(`Clock with id ${clockID} not found`);
      }
      return [clockKey, clock];
    }
    const clockKeyControls$ = html.find(".clock-key-control-flipper");
    clockKeyControls$.find('[data-action="toggle-name-visibility"]').each((i, elem) => {
      const elem$ = $(elem);
      const control$ = elem$.closest(".clock-key-control-flipper");
      elem$.on({
        click: async (event) => {
          event.preventDefault();
          const clockKey = getClockKeyFromEvent(event);
          const isNameVisible = !clockKey.isNameVisible;
          clockKey.updateTarget("isNameVisible", isNameVisible);
          if (clockKey.isInScene() && clockKey.isVisible) {
            if (isNameVisible) {
              clockKey.fadeInName_SocketCall(ClockDisplayContext.overlay);
            } else {
              clockKey.fadeOutName_SocketCall(ClockDisplayContext.overlay);
            }
          }
          control$.find('[data-action="toggle-name-visibility"] i').toggleClass("fa-signature").toggleClass("fa-signature-slash").toggleClass("fa-solid").toggleClass("fa-regular");
        }
      });
    });
    clockKeyControls$.find('[data-action="toggle-spotlight"]').each((i, elem) => {
      const elem$ = $(elem);
      const control$ = elem$.closest(".clock-key-control-flipper");
      elem$.on({
        click: async (event) => {
          event.preventDefault();
          const clockKey = getClockKeyFromEvent(event);
          const isSpotlit = !clockKey.isSpotlit;
          clockKey.updateTarget("isSpotlit", isSpotlit);
          control$.find('[data-action="toggle-spotlight"] i').toggleClass("fa-message").toggleClass("fa-message-slash").toggleClass("fa-solid").toggleClass("fa-regular");
        }
      });
    });
    clockKeyControls$.find('[data-action="pull-clock-key"]').each((i, elem) => {
      const elem$ = $(elem);
      const control$ = elem$.closest(".clock-key-control-flipper");
      elem$.on({
        click: (event) => {
          event.preventDefault();
          U.gsap.effects.keyControlPanelFlip(control$, { angle: 180 });
          const clockKey = getClockKeyFromEvent(event);
          clockKey.updateTarget("isVisible", false);
          game.eunoblades.Director.pullKey_SocketCall(clockKey.id);
        }
      });
    });
    clockKeyControls$.find('[data-action="drop-clock-key"]').each((i, elem) => {
      const elem$ = $(elem);
      const control$ = elem$.closest(".clock-key-control-flipper");
      elem$.on({
        click: (event) => {
          event.preventDefault();
          U.gsap.effects.keyControlPanelFlip(control$, { angle: 0 });
          const clockKey = getClockKeyFromEvent(event);
          clockKey.updateTarget("isVisible", true);
          game.eunoblades.Director.renderClockKey_SocketCall(clockKey.id);
        }
      });
    });
    clockKeyControls$.find('[data-action="spawn-position-dragger"]').on({
      click: async (event) => {
        event.preventDefault();
        const clockKey = getClockKeyFromEvent(event);
        clockKey.spawnPositionDragger(game.eunoblades.Director.clockKeySection$);
      }
    });
    clockKeyControls$.find('[data-action="delete-clock-key"]').on({
      click: async (event) => {
        event.preventDefault();
        await getClockKeyFromEvent(event).delete(game.eunoblades.ClockKeys);
      }
    });
    clockKeyControls$.find('[data-action="add-key-to-scene"]').on({
      click: async (event) => {
        event.preventDefault();
        await getClockKeyFromEvent(event).addToScene(this.document.targetSceneID);
      }
    });
    clockKeyControls$.find('[data-action="remove-key-from-scene"]').on({
      click: async (event) => {
        event.preventDefault();
        await getClockKeyFromEvent(event).removeFromScene(this.document.targetSceneID);
      }
    });
    clockKeyControls$.find('[data-action="add-clock-to-key"]').on({
      click: async (event) => {
        event.preventDefault();
        await getClockKeyFromEvent(event).addClock();
      }
    });
    clockKeyControls$.find("input.clock-key-input:not([readonly])").on({
      change: async (event) => {
        event.preventDefault();
        const input$ = $(event.currentTarget);
        const inputVal = input$.val();
        if (typeof inputVal === "string") {
          getClockKeyFromEvent(event).updateTarget(input$.data("targetProp"), inputVal);
          clockKeyControls$.find("input.clock-key-input").val(inputVal);
        }
      }
    });
    const clockControls$ = html.find(".clock-control-flipper");
    clockControls$.find('[data-action="toggle-visible"]').each((i, elem) => {
      const elem$ = $(elem);
      const control$ = elem$.closest(".clock-control-flipper");
      elem$.on({
        click: async (event) => {
          event.preventDefault();
          const [clockKey, clock] = getClockFromEvent(event);
          const isVisible = !clock.isVisible;
          clock.updateTarget("isVisible", isVisible);
          if (clockKey.isInScene() && clockKey.isVisible) {
            if (isVisible) {
              clock.reveal_SocketCall(ClockDisplayContext.overlay);
            } else {
              clock.hide_SocketCall(ClockDisplayContext.overlay);
            }
          }
          control$.find('[data-action="toggle-visible"] i').toggleClass("fa-eye").toggleClass("fa-eye-slash").toggleClass("fa-solid").toggleClass("fa-regular");
        }
      });
    });
    clockControls$.find('[data-action="toggle-active"]').each((i, elem) => {
      const elem$ = $(elem);
      const control$ = elem$.closest(".clock-control-flipper");
      elem$.on({
        click: async (event) => {
          event.preventDefault();
          const [clockKey, clock] = getClockFromEvent(event);
          const isActive = !clock.isActive;
          clock.updateTarget("isActive", isActive);
          if (clock.parentKey.isInScene() && clock.parentKey.isVisible && clock.isVisible) {
            if (isActive) {
              clock.activate_SocketCall(ClockDisplayContext.overlay);
            } else {
              clock.deactivate_SocketCall(ClockDisplayContext.overlay);
            }
          }
          control$.find('[data-action="toggle-active"] i').toggleClass("fa-bolt").toggleClass("fa-bolt-slash").toggleClass("fa-solid").toggleClass("fa-regular");
        }
      });
    });
    clockControls$.find('[data-action="toggle-name-visibility"]').each((i, elem) => {
      const elem$ = $(elem);
      const control$ = elem$.closest(".clock-control-flipper");
      elem$.on({
        click: async (event) => {
          event.preventDefault();
          const clock = getClockFromEvent(event)[1];
          const isNameVisible = !clock.isNameVisible;
          clock.updateTarget("isNameVisible", isNameVisible);
          if (clock.parentKey.isInScene() && clock.parentKey.isVisible && clock.isVisible) {
            if (isNameVisible) {
              clock.fadeInClockName_SocketCall(ClockDisplayContext.overlay);
            } else {
              clock.fadeOutClockName_SocketCall(ClockDisplayContext.overlay);
            }
          }
          control$.find('[data-action="toggle-name-visibility"] i').toggleClass("fa-signature").toggleClass("fa-signature-slash").toggleClass("fa-solid").toggleClass("fa-regular");
        }
      });
    });
    clockControls$.find('[data-action="toggle-highlight"]').each((i, elem) => {
      const elem$ = $(elem);
      const control$ = elem$.closest(".clock-control-flipper");
      elem$.on({
        click: async (event) => {
          event.preventDefault();
          const [clockKey, clock] = getClockFromEvent(event);
          const isHighlighted = !clock.isHighlighted;
          clock.updateTarget("isHighlighted", isHighlighted);
          if (clock.parentKey.isInScene() && clock.parentKey.isVisible && clock.isVisible) {
            if (isHighlighted) {
              clock.highlight_SocketCall(ClockDisplayContext.overlay);
            } else {
              clock.unhighlight_SocketCall(ClockDisplayContext.overlay);
            }
          }
          control$.find('[data-action="toggle-highlight"] i').toggleClass("fa-lightbulb").toggleClass("fa-lightbulb-slash").toggleClass("fa-solid").toggleClass("fa-regular");
        }
      });
    });
    clockControls$.find('[data-action="change-segments"]').each((i, elem) => {
      const elem$ = $(elem);
      const control$ = elem$.closest(".clock-control-flipper");
      elem$.on({
        click: async (event) => {
          event.preventDefault();
          const [clockKey, clock] = getClockFromEvent(event);
          const delta = U.pInt($(event.currentTarget).data("value"));
          const finalVal = U.gsap.utils.clamp(0, clock.max, clock.value + delta);
          if (delta > 0) {
            clock.fillSegments(delta, true);
          } else {
            clock.clearSegments(Math.abs(delta), true);
          }
          control$.find("select.clock-select-value").val(finalVal);
          clock.changeSegments_SocketCall(ClockDisplayContext.overlay, clock.value, finalVal);
        }
      });
    });
    clockControls$.find("select.clock-control-select").each((i, elem) => {
      const elem$ = $(elem);
      if (elem$.hasClass("clock-select-color"))
        ;
    }).on({
      change: (event) => {
        event.preventDefault();
        const select$ = $(event.currentTarget);
        const value = select$.data("dtype") === "number" ? U.pInt(select$.val()) : select$.val();
        const prop = select$.data("targetProp");
        getClockFromEvent(event)[1].updateTarget(prop, value);
        if (prop === "color" && typeof value === "string" && value in ClockColor) {
          this.setSelectColor(select$, value);
        }
      }
    });
    clockControls$.find("input.clock-input:not([readonly])").each((i, elem) => {
      const elem$ = $(elem);
      const control$ = elem$.closest(".clock-control-flipper");
      elem$.on({
        change: (event) => {
          event.preventDefault();
          const input$ = $(event.currentTarget);
          const inputVal = input$.val();
          if (typeof inputVal === "string") {
            getClockFromEvent(event)[1].updateTarget(input$.data("targetProp"), inputVal);
            control$.find("input.clock-input").val(inputVal);
          }
        }
      });
    });
    clockControls$.find('[data-action="delete-clock"]').on({
      click: async (event) => {
        event.preventDefault();
        await getClockFromEvent(event)[1].delete();
      }
    });
  }
}
class BladesDebug {
  static async GetSampleSchemas(docNames = {}) {
    const SAMPLE_USER_NAME = docNames.user || "Alistair";
    const SAMPLE_PC_NAME = docNames.pc || "Alistair";
    const SAMPLE_NPC_NAME = docNames.npc || "Setarra";
    const SAMPLE_FACTION_NAME = docNames.faction || "the Bluecoats";
    const sampleUser = game.users.getName(SAMPLE_USER_NAME);
    if (!sampleUser) {
      throw new Error(`Sample user with name "${SAMPLE_USER_NAME}" not found.`);
    }
    const samplePC = game.actors.getName(SAMPLE_PC_NAME);
    if (!BladesPC$1.IsType(samplePC)) {
      throw new Error(`Sample BladesPC with name "${SAMPLE_PC_NAME}" not found.`);
    }
    const sampleNPC = game.actors.getName(SAMPLE_NPC_NAME);
    if (!BladesNPC$1.IsType(sampleNPC)) {
      throw new Error(`Sample BladesNPC with name "${SAMPLE_NPC_NAME}" not found or is not a valid BladesNPC.`);
    }
    const sampleFaction = game.actors.getName(SAMPLE_FACTION_NAME);
    if (!BladesFaction$1.IsType(sampleFaction)) {
      throw new Error(`Sample BladesFaction with name "${SAMPLE_FACTION_NAME}" not found or is not a valid BladesFaction.`);
    }
    const BladesActionRoll_Schema = {
      rollType: RollType.Action,
      // rollSubType: RollSubType.GatherInfo,
      // rollPrompt: "Gathering Information",
      rollTrait: ActionTrait.skirmish,
      // rollUserID: sampleUser.id,
      // rollDowntimeAction: DowntimeAction.AcquireAsset,
      // rollClockKey: U.getLast(game.eunoblades.ClockKeys.contents)?.id,
      rollPrimaryData: BladesRollPrimary.GetDataFromDoc(samplePC),
      rollOppData: BladesRollOpposition.GetDataFromDoc(sampleFaction),
      // rollParticipantData: {},
      // consequenceData: {},
      // resistanceData: {
      //   consequence: {}
      // },
      rollModsData: {},
      rollPositionInitial: Position.risky,
      rollEffectInitial: Effect.standard,
      rollPosEffectTrade: false,
      rollPhase: RollPhase.Collaboration,
      GMBoosts: {},
      GMOppBoosts: {},
      GMOverrides: {},
      rollFactorToggles: {
        source: {},
        opposition: {}
      },
      userPermissions: {
        [sampleUser.id]: RollPermissions.Primary
      }
      // rollPositionFinal: Position.risky,
      // rollEffectFinal: Effect.standard,
      // rollResult: RollResult.success,
      // rollResultDelta: 0,
      // rollResultFinal: RollResult.success,
      // rollTraitVerb: "skirmishes",
      // rollTraitPastVerb: "skirmished",
      // finalDiceData: [],
      // isInlineResistanceRoll: false
    };
    return {
      BladesActionRoll_Schema
    };
  }
}
CONFIG.debug.logging = true;
Object.assign(globalThis, { eLog: logger, BladesDebug });
Handlebars.registerHelper("eLog", logger.hbsLog);
let socket;
class GlobalGetter {
  get clockKeys() {
    return game.eunoblades.ClockKeys.filter((clockKey) => clockKey.isInScene() && clockKey.isVisible);
  }
  get roll() {
    return BladesRoll$1.Active;
  }
  get user() {
    return game.users.getName("Alistair");
  }
  get actor() {
    return game.actors.getName("Alistair");
  }
  get rollTarget() {
    var _a2;
    return (_a2 = this.roll) == null ? void 0 : _a2.target;
  }
  get rollData() {
    var _a2;
    return (_a2 = this.roll) == null ? void 0 : _a2.data;
  }
  get userFlags() {
    var _a2, _b;
    return (_b = (_a2 = this.user) == null ? void 0 : _a2.flags) == null ? void 0 : _b["eunos-blades"];
  }
  get actorFlags() {
    var _a2, _b;
    return (_b = (_a2 = this.actor) == null ? void 0 : _a2.flags) == null ? void 0 : _b["eunos-blades"];
  }
  get rollPrimary() {
    var _a2;
    return (_a2 = this.roll) == null ? void 0 : _a2.rollPrimary;
  }
  get rollPrimaryDoc() {
    var _a2;
    return (_a2 = this.roll) == null ? void 0 : _a2.rollPrimaryDoc;
  }
  get rollOpposition() {
    var _a2;
    return (_a2 = this.roll) == null ? void 0 : _a2.rollOpposition;
  }
  get sheetData() {
    var _a2;
    return (_a2 = this.roll) == null ? void 0 : _a2.context;
  }
  newActionRoll() {
    var _a2;
    const pc = game.actors.getName("Alistair");
    if (!pc) {
      return;
    }
    const conf = {
      target: pc,
      targetFlagKey: "rollCollab",
      rollType: RollType.Action,
      rollTrait: ActionTrait.finesse,
      rollUserID: (_a2 = game.users.find((user) => {
        var _a3;
        return ((_a3 = user.character) == null ? void 0 : _a3.name) === "Alistair";
      })) == null ? void 0 : _a2.id,
      rollPrimaryData: pc
    };
    BladesActionRoll.New(conf);
  }
  // async newResistanceRoll() {
  //   const pc = game.actors.getName("Alistair") as BladesPC|undefined;
  //   if (!pc?.id) { return; }
  //   const csq = await BladesConsequence.Create({
  //     target: pc,
  //     targetFlagKey: "rollConsequence" as TargetFlagKey,
  //     name: "Shattered Knee",
  //     isScopingById: true,
  //     type: ConsequenceType.ProwessHarm3,
  //     primaryID: pc.uuid,
  //     attribute: AttributeTrait.prowess,
  //     attributeVal: 3,
  //     resistSchema: {
  //       name: "Banged Knee",
  //       type: ConsequenceType.ProwessHarm2,
  //       primaryID: pc.uuid,
  //       canResistWithSpecial: true,
  //       resistWithSpecialNegates: true,
  //       specialFooterMsg: "Ability: Spend to Fully Negate."
  //     },
  //     canResistWithRoll: true,
  //     canResistWithSpecial: true,
  //     resistWithSpecialNegates: true,
  //     specialFooterMsg: "Ability: Spend to Fully Negate."
  //   });
  //   const conf: BladesRoll.Config = {
  //     target: pc,
  //     targetFlagKey: "rollCollab" as TargetFlagKey,
  //     rollType: RollType.Resistance,
  //     rollUserID: game.users.find((user) => user.character?.name === "Alistair")?.id as IDString,
  //     rollPrimaryData: pc,
  //     resistanceData: {
  //       consequence: csq.data
  //     }
  //   };
  //   BladesResistanceRoll.New(conf);
  // }
}
Object.assign(
  globalThis,
  {
    get: new GlobalGetter(),
    // updateClaims,
    // updateContacts,
    // updateOps,
    // updateFactions,
    // updateDescriptions,
    // updateRollMods,
    getColor,
    BladesScene,
    BladesDirector,
    BladesActor: BladesActor$1,
    BladesPC: BladesPC$1,
    BladesCrew: BladesCrew$1,
    BladesNPC: BladesNPC$1,
    BladesFaction: BladesFaction$1,
    BladesPCSheet,
    BladesCrewSheet,
    BladesFactionSheet,
    BladesClockKey,
    BladesNPCSheet,
    BladesActiveEffect,
    BladesRoll: BladesRoll$1,
    BladesRollMod,
    BladesRollPrimary,
    BladesRollOpposition,
    BladesRollParticipant,
    BladesActionRoll,
    BladesEngagementRoll,
    BladesFortuneRoll,
    BladesIncarcerationRoll,
    BladesIndulgeViceRoll,
    BladesInlineResistanceRoll,
    BladesResistanceRoll,
    BladesChat: BladesChat$1,
    BladesConsequence,
    G,
    U,
    C,
    BladesItem: BladesItem$1,
    BladesClockKeeper: BladesClockKeeper$1,
    BladesGMTracker: BladesGMTracker$1,
    BladesLocation,
    BladesProject: BladesProject$1,
    BladesScore: BladesScore$1,
    BladesItemSheet,
    BladesClockKeeperSheet,
    BladesGMTrackerSheet,
    BladesAI: BladesAIAssistant,
    AGENTS
  }
);
Hooks.once("init", async () => {
  game.eunoblades = {
    Rolls: new Collection(),
    RollMods: new Collection(),
    ClockKeys: new Collection(),
    Consequences: new Collection(),
    Director: BladesDirector.getInstance(),
    Tooltips: /* @__PURE__ */ new WeakMap()
  };
  eLog.display("Initializing Blades In the Dark System");
  registerSettings();
  CONFIG.debug.hooks = U.getSetting("debugHooks", "debugSettings");
  Initialize();
  CONFIG.Item.documentClass = BladesItemProxy;
  CONFIG.Actor.documentClass = BladesActorProxy;
  CONFIG.Scene.documentClass = BladesScene;
  CONFIG.ChatMessage.documentClass = BladesChat$1;
  Actors.unregisterSheet("core", ActorSheet);
  Items.unregisterSheet("core", ItemSheet);
  Items.registerSheet("blades", BladesItemSheet, { types: C.ItemTypes, makeDefault: true });
  registerHandlebarHelpers();
  preloadHandlebarsTemplates();
  await Promise.all([
    BladesPC$1.Initialize(),
    BladesCrew$1.Initialize(),
    BladesNPC$1.Initialize(),
    BladesFaction$1.Initialize(),
    BladesActiveEffect.Initialize(),
    BladesGMTrackerSheet.Initialize(),
    BladesClockKeeperSheet.Initialize(),
    BladesScore$1.Initialize(),
    BladesDialog.Initialize(),
    BladesRoll$1.Initialize(),
    BladesProject$1.Initialize(),
    BladesChat$1.Initialize()
  ]);
});
Hooks.once("ready", async () => {
  await Promise.all([
    BladesDirector.Initialize(),
    BladesGMTracker$1.Initialize(),
    BladesClockKeeper$1.Initialize()
  ]);
  BladesClockKey.Initialize();
  await BladesConsequence.Initialize();
  initDOMStyles();
  initCanvasStyles();
  initTinyMCEStyles();
  await BladesDirector.getInstance().renderOverlay_SocketResponse();
  BladesDirector.InitSockets();
  BladesRoll$1.InitSockets();
});
Hooks.once("socketlib.ready", () => {
  socket = socketlib.registerSystem("eunos-blades");
  Object.assign(
    globalThis,
    { socket, socketlib }
  );
});
Hooks.once("diceSoNiceReady", (dice3d) => {
  dice3d.addSystem({ id: "eunos-blades", name: "Euno's Blades" }, "preferred");
  dice3d.addDicePreset({
    type: "d6",
    labels: [1, 2, 3, 4, 5, 6].map((num) => `systems/eunos-blades/assets/dice/faces/${num}.webp`),
    system: "eunos-blades",
    bumpMaps: [1, 2, 3, 4, 5, 6].map((num) => `systems/eunos-blades/assets/dice/bump-maps/${num}.webp`),
    emissiveMaps: [void 0, void 0, void 0, void 0, void 0, "systems/eunos-blades/assets/dice/emission-maps/6.webp"],
    emissive: "#d89300"
  });
});
//# sourceMappingURL=blades.js.map

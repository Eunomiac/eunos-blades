var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var __privateMethod = (obj, member, method) => {
  __accessCheck(obj, member, "access private method");
  return method;
};
var _ParseChildLinkData, ParseChildLinkData_fn, _ParseConfigToData, ParseConfigToData_fn, _updateTargetViaMerge, updateTargetViaMerge_fn, _updateTargetPropVal, updateTargetPropVal_fn, _apiKey, _id, _name, _instructions, _tools, _model, _fileIDs, _metadata;
import { gsap, MotionPathPlugin, TextPlugin, Flip, Draggable, SplitText, Observer as Observer$1, CustomEase, CustomWiggle, CustomBounce, EasePack } from "gsap/all";
var BladesPermissions = ((BladesPermissions2) => {
  BladesPermissions2[BladesPermissions2["NONE"] = CONST.DOCUMENT_PERMISSION_LEVELS.NONE] = "NONE";
  BladesPermissions2[BladesPermissions2["BASIC"] = CONST.DOCUMENT_PERMISSION_LEVELS.LIMITED] = "BASIC";
  BladesPermissions2[BladesPermissions2["FULL"] = CONST.DOCUMENT_PERMISSION_LEVELS.OBSERVER] = "FULL";
  BladesPermissions2[BladesPermissions2["OWNER"] = CONST.DOCUMENT_PERMISSION_LEVELS.OWNER] = "OWNER";
  return BladesPermissions2;
})(BladesPermissions || {});
var BladesActorType = /* @__PURE__ */ ((BladesActorType2) => {
  BladesActorType2["pc"] = "pc";
  BladesActorType2["npc"] = "npc";
  BladesActorType2["crew"] = "crew";
  BladesActorType2["faction"] = "faction";
  return BladesActorType2;
})(BladesActorType || {});
var BladesItemType = /* @__PURE__ */ ((BladesItemType2) => {
  BladesItemType2["ability"] = "ability";
  BladesItemType2["background"] = "background";
  BladesItemType2["clock_keeper"] = "clock_keeper";
  BladesItemType2["cohort_gang"] = "cohort_gang";
  BladesItemType2["cohort_expert"] = "cohort_expert";
  BladesItemType2["crew_ability"] = "crew_ability";
  BladesItemType2["crew_reputation"] = "crew_reputation";
  BladesItemType2["crew_playbook"] = "crew_playbook";
  BladesItemType2["crew_upgrade"] = "crew_upgrade";
  BladesItemType2["feature"] = "feature";
  BladesItemType2["gm_tracker"] = "gm_tracker";
  BladesItemType2["heritage"] = "heritage";
  BladesItemType2["gear"] = "gear";
  BladesItemType2["playbook"] = "playbook";
  BladesItemType2["preferred_op"] = "preferred_op";
  BladesItemType2["stricture"] = "stricture";
  BladesItemType2["vice"] = "vice";
  BladesItemType2["project"] = "project";
  BladesItemType2["ritual"] = "ritual";
  BladesItemType2["design"] = "design";
  BladesItemType2["location"] = "location";
  BladesItemType2["score"] = "score";
  return BladesItemType2;
})(BladesItemType || {});
var PrereqType = /* @__PURE__ */ ((PrereqType2) => {
  PrereqType2["HasActiveItem"] = "HasActiveItem";
  PrereqType2["HasActiveItemsByTag"] = "HasActiveItemByTag";
  PrereqType2["AdvancedPlaybook"] = "AdvancedPlaybook";
  PrereqType2["HasAllTags"] = "HasAllTags";
  PrereqType2["HasAnyTag"] = "HasAnyTag";
  PrereqType2["Not_HasActiveItem"] = "Not_HasActiveItem";
  PrereqType2["Not_HasActiveItemsByTag"] = "Not_HasActiveItemsByTag";
  PrereqType2["Not_AdvancedPlaybook"] = "Not_AdvancedPlaybook";
  PrereqType2["Not_HasAllTags"] = "Not_HasAllTags";
  PrereqType2["Not_HasAnyTag"] = "Not_HasAnyTag";
  return PrereqType2;
})(PrereqType || {});
var ClockColor = /* @__PURE__ */ ((ClockColor2) => {
  ClockColor2["yellow"] = "yellow";
  ClockColor2["red"] = "red";
  ClockColor2["white"] = "white";
  ClockColor2["cyan"] = "cyan";
  return ClockColor2;
})(ClockColor || {});
var ClockDisplayContext = /* @__PURE__ */ ((ClockDisplayContext2) => {
  ClockDisplayContext2["overlay"] = "overlay";
  ClockDisplayContext2["pcSheet"] = "pcSheet";
  ClockDisplayContext2["factionSheet"] = "factionSheet";
  ClockDisplayContext2["projectSheet"] = "projectSheet";
  ClockDisplayContext2["scoreSheet"] = "scoreSheet";
  ClockDisplayContext2["rollCollab"] = "rollCollab";
  ClockDisplayContext2["chatMessage"] = "chatMessage";
  return ClockDisplayContext2;
})(ClockDisplayContext || {});
var ClockKeyDisplayMode = /* @__PURE__ */ ((ClockKeyDisplayMode2) => {
  ClockKeyDisplayMode2["full"] = "full";
  ClockKeyDisplayMode2["clocks"] = "clocks";
  ClockKeyDisplayMode2["activeClocks"] = "activeClocks";
  ClockKeyDisplayMode2["presentCurrentClock"] = "presentCurrentClock";
  ClockKeyDisplayMode2["present0"] = "present0";
  ClockKeyDisplayMode2["present1"] = "present1";
  ClockKeyDisplayMode2["present2"] = "present2";
  ClockKeyDisplayMode2["present3"] = "present3";
  ClockKeyDisplayMode2["present4"] = "present4";
  ClockKeyDisplayMode2["present5"] = "present5";
  return ClockKeyDisplayMode2;
})(ClockKeyDisplayMode || {});
var BladesNoticeType = /* @__PURE__ */ ((BladesNoticeType2) => {
  BladesNoticeType2["push"] = "push";
  return BladesNoticeType2;
})(BladesNoticeType || {});
var MainDistrict = /* @__PURE__ */ ((MainDistrict2) => {
  MainDistrict2["Barrowcleft"] = "Barrowcleft";
  MainDistrict2["Brightstone"] = "Brightstone";
  MainDistrict2["Charhollow"] = "Charhollow";
  MainDistrict2["Charterhall"] = "Charterhall";
  MainDistrict2["Coalridge"] = "Coalridge";
  MainDistrict2["Crows Foot"] = "Crows Foot";
  MainDistrict2["The Docks"] = "The Docks";
  MainDistrict2["Dunslough"] = "Dunslough";
  MainDistrict2["Nightmarket"] = "Nightmarket";
  MainDistrict2["Silkshore"] = "Silkshore";
  MainDistrict2["Six Towers"] = "Six Towers";
  MainDistrict2["Whitecrown"] = "Whitecrown";
  return MainDistrict2;
})(MainDistrict || {});
var OtherDistrict = /* @__PURE__ */ ((OtherDistrict2) => {
  OtherDistrict2["Gaddoc Station"] = "Gaddoc Station";
  OtherDistrict2["The Lost District"] = "The Lost District";
  OtherDistrict2["The Void Sea"] = "The Void Sea";
  OtherDistrict2["Ironhook Prison"] = "Ironhook Prison";
  OtherDistrict2["Old North Port"] = "Old North Port";
  OtherDistrict2["Deathlands"] = "Deathlands";
  return OtherDistrict2;
})(OtherDistrict || {});
var AttributeTrait = /* @__PURE__ */ ((AttributeTrait2) => {
  AttributeTrait2["insight"] = "insight";
  AttributeTrait2["prowess"] = "prowess";
  AttributeTrait2["resolve"] = "resolve";
  return AttributeTrait2;
})(AttributeTrait || {});
var ActionTrait = /* @__PURE__ */ ((ActionTrait2) => {
  ActionTrait2["hunt"] = "hunt";
  ActionTrait2["study"] = "study";
  ActionTrait2["survey"] = "survey";
  ActionTrait2["tinker"] = "tinker";
  ActionTrait2["finesse"] = "finesse";
  ActionTrait2["prowl"] = "prowl";
  ActionTrait2["skirmish"] = "skirmish";
  ActionTrait2["wreck"] = "wreck";
  ActionTrait2["attune"] = "attune";
  ActionTrait2["command"] = "command";
  ActionTrait2["consort"] = "consort";
  ActionTrait2["sway"] = "sway";
  return ActionTrait2;
})(ActionTrait || {});
var DowntimeAction = /* @__PURE__ */ ((DowntimeAction2) => {
  DowntimeAction2["AcquireAsset"] = "AcquireAsset";
  DowntimeAction2["IndulgeVice"] = "IndulgeVice";
  DowntimeAction2["LongTermProject"] = "LongTermProject";
  DowntimeAction2["Recover"] = "Recover";
  DowntimeAction2["ReduceHeat"] = "ReduceHeat";
  DowntimeAction2["Train"] = "Train";
  return DowntimeAction2;
})(DowntimeAction || {});
var RollPermissions = /* @__PURE__ */ ((RollPermissions2) => {
  RollPermissions2["Primary"] = "Primary";
  RollPermissions2["Observer"] = "Observer";
  RollPermissions2["GM"] = "GM";
  RollPermissions2["Participant"] = "Participant";
  return RollPermissions2;
})(RollPermissions || {});
var RollType = /* @__PURE__ */ ((RollType2) => {
  RollType2["Action"] = "Action";
  RollType2["Resistance"] = "Resistance";
  RollType2["Fortune"] = "Fortune";
  RollType2["IndulgeVice"] = "IndulgeVice";
  return RollType2;
})(RollType || {});
var RollSubType = /* @__PURE__ */ ((RollSubType2) => {
  RollSubType2["Incarceration"] = "Incarceration";
  RollSubType2["Engagement"] = "Engagement";
  RollSubType2["GatherInfo"] = "GatherInfo";
  RollSubType2["GroupLead"] = "GroupLead";
  RollSubType2["GroupParticipant"] = "GroupParticipant";
  return RollSubType2;
})(RollSubType || {});
var RollModType = /* @__PURE__ */ ((RollModType2) => {
  RollModType2["general"] = "general";
  RollModType2["harm"] = "harm";
  RollModType2["teamwork"] = "teamwork";
  RollModType2["ability"] = "ability";
  RollModType2["gear"] = "gear";
  RollModType2["crew_ability"] = "crew_ability";
  RollModType2["crew_upgrade"] = "crew_upgrade";
  RollModType2["advantage"] = "advantage";
  RollModType2["disadvantage"] = "disadvantage";
  return RollModType2;
})(RollModType || {});
var ConsequenceType = /* @__PURE__ */ ((ConsequenceType2) => {
  ConsequenceType2["ReducedEffect"] = "ReducedEffect";
  ConsequenceType2["ComplicationMinor"] = "ComplicationMinor";
  ConsequenceType2["ComplicationMajor"] = "ComplicationMajor";
  ConsequenceType2["ComplicationSerious"] = "ComplicationSerious";
  ConsequenceType2["LostOpportunity"] = "LostOpportunity";
  ConsequenceType2["WorsePosition"] = "WorsePosition";
  ConsequenceType2["InsightHarm1"] = "InsightHarm1";
  ConsequenceType2["InsightHarm2"] = "InsightHarm2";
  ConsequenceType2["InsightHarm3"] = "InsightHarm3";
  ConsequenceType2["InsightHarm4"] = "InsightHarm4";
  ConsequenceType2["ProwessHarm1"] = "ProwessHarm1";
  ConsequenceType2["ProwessHarm2"] = "ProwessHarm2";
  ConsequenceType2["ProwessHarm3"] = "ProwessHarm3";
  ConsequenceType2["ProwessHarm4"] = "ProwessHarm4";
  ConsequenceType2["ResolveHarm1"] = "ResolveHarm1";
  ConsequenceType2["ResolveHarm2"] = "ResolveHarm2";
  ConsequenceType2["ResolveHarm3"] = "ResolveHarm3";
  ConsequenceType2["ResolveHarm4"] = "ResolveHarm4";
  ConsequenceType2["None"] = "None";
  return ConsequenceType2;
})(ConsequenceType || {});
var RollModStatus = /* @__PURE__ */ ((RollModStatus2) => {
  RollModStatus2["Hidden"] = "Hidden";
  RollModStatus2["ForcedOff"] = "ForcedOff";
  RollModStatus2["ToggledOff"] = "ToggledOff";
  RollModStatus2["ToggledOn"] = "ToggledOn";
  RollModStatus2["ForcedOn"] = "ForcedOn";
  RollModStatus2["Dominant"] = "Dominant";
  return RollModStatus2;
})(RollModStatus || {});
var RollModSection = /* @__PURE__ */ ((RollModSection2) => {
  RollModSection2["roll"] = "roll";
  RollModSection2["position"] = "position";
  RollModSection2["effect"] = "effect";
  RollModSection2["result"] = "result";
  RollModSection2["after"] = "after";
  return RollModSection2;
})(RollModSection || {});
var Position = /* @__PURE__ */ ((Position2) => {
  Position2["desperate"] = "desperate";
  Position2["risky"] = "risky";
  Position2["controlled"] = "controlled";
  return Position2;
})(Position || {});
var Effect = /* @__PURE__ */ ((Effect2) => {
  Effect2["zero"] = "zero";
  Effect2["limited"] = "limited";
  Effect2["standard"] = "standard";
  Effect2["great"] = "great";
  Effect2["extreme"] = "extreme";
  return Effect2;
})(Effect || {});
var Factor = /* @__PURE__ */ ((Factor2) => {
  Factor2["tier"] = "tier";
  Factor2["quality"] = "quality";
  Factor2["scale"] = "scale";
  Factor2["magnitude"] = "magnitude";
  return Factor2;
})(Factor || {});
var RollResult = /* @__PURE__ */ ((RollResult2) => {
  RollResult2["critical"] = "critical";
  RollResult2["success"] = "success";
  RollResult2["partial"] = "partial";
  RollResult2["fail"] = "fail";
  return RollResult2;
})(RollResult || {});
var RollPhase = /* @__PURE__ */ ((RollPhase2) => {
  RollPhase2["Collaboration"] = "Collaboration";
  RollPhase2["AwaitingRoll"] = "AwaitingRoll";
  RollPhase2["AwaitingConsequences"] = "AwaitingConsequences";
  RollPhase2["Complete"] = "Complete";
  return RollPhase2;
})(RollPhase || {});
var Harm = /* @__PURE__ */ ((Harm2) => {
  Harm2["Weakened"] = "Weakened";
  Harm2["Impaired"] = "Impaired";
  Harm2["Broken"] = "Broken";
  Harm2["Dead"] = "Dead";
  return Harm2;
})(Harm || {});
var Vice = /* @__PURE__ */ ((Vice2) => {
  Vice2["Faith"] = "Faith";
  Vice2["Gambling"] = "Gambling";
  Vice2["Luxury"] = "Luxury";
  Vice2["Obligation"] = "Obligation";
  Vice2["Pleasure"] = "Pleasure";
  Vice2["Stupor"] = "Stupor";
  Vice2["Weird"] = "Weird";
  Vice2["Worship"] = "Worship";
  Vice2["Life_Essence"] = "Life_Essence";
  Vice2["Living_Essence"] = "Living_Essence";
  Vice2["Electroplasmic_Power"] = "Electroplasmic_Power";
  Vice2["Servitude"] = "Servitude";
  return Vice2;
})(Vice || {});
var Playbook = /* @__PURE__ */ ((Playbook2) => {
  Playbook2["Cutter"] = "Cutter";
  Playbook2["Hound"] = "Hound";
  Playbook2["Leech"] = "Leech";
  Playbook2["Lurk"] = "Lurk";
  Playbook2["Slide"] = "Slide";
  Playbook2["Spider"] = "Spider";
  Playbook2["Whisper"] = "Whisper";
  Playbook2["Vampire"] = "Vampire";
  Playbook2["Hull"] = "Hull";
  Playbook2["Ghost"] = "Ghost";
  Playbook2["Assassins"] = "Assassins";
  Playbook2["Bravos"] = "Bravos";
  Playbook2["Cult"] = "Cult";
  Playbook2["Hawkers"] = "Hawkers";
  Playbook2["Shadows"] = "Shadows";
  Playbook2["Smugglers"] = "Smugglers";
  Playbook2["Vigilantes"] = "Vigilantes";
  return Playbook2;
})(Playbook || {});
var AdvancementPoint = /* @__PURE__ */ ((AdvancementPoint2) => {
  AdvancementPoint2["UpgradeOrAbility"] = "UpgradeOrAbility";
  AdvancementPoint2["Ability"] = "Ability";
  AdvancementPoint2["Upgrade"] = "Upgrade";
  AdvancementPoint2["Cohort"] = "Cohort";
  AdvancementPoint2["CohortType"] = "CohortType";
  AdvancementPoint2["GeneralAction"] = "GeneralAction";
  AdvancementPoint2["GeneralInsight"] = "GeneralInsight";
  AdvancementPoint2["GeneralProwess"] = "GeneralProwess";
  AdvancementPoint2["GeneralResolve"] = "GeneralResolve";
  AdvancementPoint2["hunt"] = "hunt";
  AdvancementPoint2["study"] = "study";
  AdvancementPoint2["survey"] = "survey";
  AdvancementPoint2["tinker"] = "tinker";
  AdvancementPoint2["finesse"] = "finesse";
  AdvancementPoint2["prowl"] = "prowl";
  AdvancementPoint2["skirmish"] = "skirmish";
  AdvancementPoint2["wreck"] = "wreck";
  AdvancementPoint2["attune"] = "attune";
  AdvancementPoint2["command"] = "command";
  AdvancementPoint2["consort"] = "consort";
  AdvancementPoint2["sway"] = "sway";
  return AdvancementPoint2;
})(AdvancementPoint || {});
var BladesPhase = /* @__PURE__ */ ((BladesPhase2) => {
  BladesPhase2["CharGen"] = "CharGen";
  BladesPhase2["Freeplay"] = "Freeplay";
  BladesPhase2["Score"] = "Score";
  BladesPhase2["Downtime"] = "Downtime";
  return BladesPhase2;
})(BladesPhase || {});
var Tag;
((Tag2) => {
  ((System2) => {
    System2["Archived"] = "Archived";
    System2["Featured"] = "Featured";
    System2["Hidden"] = "Hidden";
    System2["MultiplesOK"] = "MultiplesOK";
  })(Tag2.System || (Tag2.System = {}));
  ((Gear2) => {
    Gear2["Fine"] = "Fine";
    Gear2["General"] = "General";
    Gear2["Advanced"] = "Advanced";
    Gear2["Upgraded"] = "Upgraded";
  })(Tag2.Gear || (Tag2.Gear = {}));
  ((PC2) => {
    PC2["Member"] = "Member";
    PC2["CharacterCrew"] = "CharacterCrew";
    PC2["ActivePC"] = "ActivePC";
    PC2["Small"] = "Small";
    PC2["Medium"] = "Medium";
    PC2["Large"] = "Large";
    PC2["CanHeal"] = "CanHeal";
  })(Tag2.PC || (Tag2.PC = {}));
  ((Invention2) => {
    Invention2["Arcane"] = "Arcane";
    Invention2["SparkCraft"] = "SparkCraft";
    Invention2["Alchemical"] = "Alchemical";
    Invention2["Mundane"] = "Mundane";
    Invention2["Ritual"] = "Ritual";
  })(Tag2.Invention || (Tag2.Invention = {}));
  ((GearCategory2) => {
    GearCategory2["ArcaneImplement"] = "ArcaneImplement";
    GearCategory2["Document"] = "Document";
    GearCategory2["GearKit"] = "GearKit";
    GearCategory2["SubterfugeSupplies"] = "SubterfugeSupplies";
    GearCategory2["Tool"] = "Tool";
    GearCategory2["Weapon"] = "Weapon";
  })(Tag2.GearCategory || (Tag2.GearCategory = {}));
  ((NPC2) => {
    NPC2["Acquaintance"] = "Acquaintance";
    NPC2["VicePurveyor"] = "VicePurveyor";
    NPC2["CanHeal"] = "CanHeal";
  })(Tag2.NPC || (Tag2.NPC = {}));
  ((GangType2) => {
    GangType2["Thugs"] = "Thugs";
    GangType2["Rooks"] = "Rooks";
    GangType2["Adepts"] = "Adepts";
    GangType2["Rovers"] = "Rovers";
    GangType2["Skulks"] = "Skulks";
    GangType2["Vehicle"] = "Vehicle";
  })(Tag2.GangType || (Tag2.GangType = {}));
})(Tag || (Tag = {}));
const C = {
  SYSTEM_ID: "eunos-blades",
  SYSTEM_NAME: "Euno's Blades",
  SYSTEM_FULL_NAME: "Euno's Blades In The Dark",
  TEMPLATE_ROOT: "systems/eunos-blades/templates",
  AI_MODELS: {
    baseContext: [
      "babbage-002",
      "gpt-3.5-turbo",
      "gpt-4"
    ],
    extendedContext: [
      "gpt-3.5-turbo-16k",
      "gpt-3.5-turbo-16k",
      "gpt-4-32k"
    ]
  },
  MIN_MOUSE_MOVEMENT_THRESHOLD: 2e3,
  AI_FILE_IDS: {
    BladesPDF: "file-n72HTTNwt051piPbswQ8isUa"
  },
  ClockKeySquareSize: 100,
  DowntimeActionDisplay: {
    [
      "AcquireAsset"
      /* AcquireAsset */
    ]: "Acquire an Asset",
    [
      "IndulgeVice"
      /* IndulgeVice */
    ]: "Indulge Your Vice",
    [
      "LongTermProject"
      /* LongTermProject */
    ]: "Work on a Project",
    [
      "Recover"
      /* Recover */
    ]: "Heal",
    [
      "ReduceHeat"
      /* ReduceHeat */
    ]: "Reduce the Crew's Heat",
    [
      "Train"
      /* Train */
    ]: "Train"
  },
  ConsequenceValues: {
    [
      "ReducedEffect"
      /* ReducedEffect */
    ]: void 0,
    [
      "LostOpportunity"
      /* LostOpportunity */
    ]: 2,
    [
      "WorsePosition"
      /* WorsePosition */
    ]: void 0,
    [
      "None"
      /* None */
    ]: 0,
    [
      "InsightHarm4"
      /* InsightHarm4 */
    ]: 4,
    [
      "InsightHarm3"
      /* InsightHarm3 */
    ]: 3,
    [
      "InsightHarm2"
      /* InsightHarm2 */
    ]: 2,
    [
      "InsightHarm1"
      /* InsightHarm1 */
    ]: 1,
    [
      "ProwessHarm4"
      /* ProwessHarm4 */
    ]: 4,
    [
      "ProwessHarm3"
      /* ProwessHarm3 */
    ]: 3,
    [
      "ProwessHarm2"
      /* ProwessHarm2 */
    ]: 2,
    [
      "ProwessHarm1"
      /* ProwessHarm1 */
    ]: 1,
    [
      "ResolveHarm4"
      /* ResolveHarm4 */
    ]: 4,
    [
      "ResolveHarm3"
      /* ResolveHarm3 */
    ]: 3,
    [
      "ResolveHarm2"
      /* ResolveHarm2 */
    ]: 2,
    [
      "ResolveHarm1"
      /* ResolveHarm1 */
    ]: 1,
    [
      "ComplicationSerious"
      /* ComplicationSerious */
    ]: 3,
    [
      "ComplicationMajor"
      /* ComplicationMajor */
    ]: 2,
    [
      "ComplicationMinor"
      /* ComplicationMinor */
    ]: 1
  },
  ResistedConsequenceTypes: {
    [
      "None"
      /* None */
    ]: [],
    [
      "InsightHarm4"
      /* InsightHarm4 */
    ]: [
      "InsightHarm3"
      /* InsightHarm3 */
    ],
    [
      "InsightHarm3"
      /* InsightHarm3 */
    ]: [
      "InsightHarm2"
      /* InsightHarm2 */
    ],
    [
      "InsightHarm2"
      /* InsightHarm2 */
    ]: [
      "InsightHarm1"
      /* InsightHarm1 */
    ],
    [
      "InsightHarm1"
      /* InsightHarm1 */
    ]: [
      "None"
      /* None */
    ],
    [
      "ProwessHarm4"
      /* ProwessHarm4 */
    ]: [
      "ProwessHarm3"
      /* ProwessHarm3 */
    ],
    [
      "ProwessHarm3"
      /* ProwessHarm3 */
    ]: [
      "ProwessHarm2"
      /* ProwessHarm2 */
    ],
    [
      "ProwessHarm2"
      /* ProwessHarm2 */
    ]: [
      "ProwessHarm1"
      /* ProwessHarm1 */
    ],
    [
      "ProwessHarm1"
      /* ProwessHarm1 */
    ]: [
      "None"
      /* None */
    ],
    [
      "ResolveHarm4"
      /* ResolveHarm4 */
    ]: [
      "ResolveHarm3"
      /* ResolveHarm3 */
    ],
    [
      "ResolveHarm3"
      /* ResolveHarm3 */
    ]: [
      "ResolveHarm2"
      /* ResolveHarm2 */
    ],
    [
      "ResolveHarm2"
      /* ResolveHarm2 */
    ]: [
      "ResolveHarm1"
      /* ResolveHarm1 */
    ],
    [
      "ResolveHarm1"
      /* ResolveHarm1 */
    ]: [
      "None"
      /* None */
    ],
    [
      "ComplicationSerious"
      /* ComplicationSerious */
    ]: [
      "ComplicationMajor"
      /* ComplicationMajor */
    ],
    [
      "ComplicationMajor"
      /* ComplicationMajor */
    ]: [
      "ComplicationMinor"
      /* ComplicationMinor */
    ],
    [
      "ComplicationMinor"
      /* ComplicationMinor */
    ]: [
      "None"
      /* None */
    ]
  },
  ConsequenceDisplay: {
    [
      "ReducedEffect"
      /* ReducedEffect */
    ]: "Reduced Effect",
    [
      "ComplicationMinor"
      /* ComplicationMinor */
    ]: "Minor Complication",
    [
      "ComplicationMajor"
      /* ComplicationMajor */
    ]: "Major Complication",
    [
      "ComplicationSerious"
      /* ComplicationSerious */
    ]: "Serious Complication",
    [
      "LostOpportunity"
      /* LostOpportunity */
    ]: "Lost Opportunity",
    [
      "WorsePosition"
      /* WorsePosition */
    ]: "Worse Position",
    [
      "InsightHarm1"
      /* InsightHarm1 */
    ]: "Level 1 Harm (Lesser)",
    [
      "InsightHarm2"
      /* InsightHarm2 */
    ]: "Level 2 Harm (Moderate)",
    [
      "InsightHarm3"
      /* InsightHarm3 */
    ]: "Level 3 Harm (Severe)",
    [
      "InsightHarm4"
      /* InsightHarm4 */
    ]: "Level 4 Harm (FATAL)",
    [
      "ProwessHarm1"
      /* ProwessHarm1 */
    ]: "Level 1 Harm (Lesser)",
    [
      "ProwessHarm2"
      /* ProwessHarm2 */
    ]: "Level 2 Harm (Moderate)",
    [
      "ProwessHarm3"
      /* ProwessHarm3 */
    ]: "Level 3 Harm (Severe)",
    [
      "ProwessHarm4"
      /* ProwessHarm4 */
    ]: "Level 4 Harm (FATAL)",
    [
      "ResolveHarm1"
      /* ResolveHarm1 */
    ]: "Level 1 Harm (Lesser)",
    [
      "ResolveHarm2"
      /* ResolveHarm2 */
    ]: "Level 2 Harm (Moderate)",
    [
      "ResolveHarm3"
      /* ResolveHarm3 */
    ]: "Level 3 Harm (Severe)",
    [
      "ResolveHarm4"
      /* ResolveHarm4 */
    ]: "Level 4 Harm (FATAL)",
    [
      "None"
      /* None */
    ]: "None"
  },
  ConsequenceIcons: {
    [
      "ReducedEffect"
      /* ReducedEffect */
    ]: "reduced-effect",
    [
      "ComplicationMinor"
      /* ComplicationMinor */
    ]: "complication-minor",
    [
      "ComplicationMajor"
      /* ComplicationMajor */
    ]: "complication-major",
    [
      "ComplicationSerious"
      /* ComplicationSerious */
    ]: "complication-serious",
    [
      "LostOpportunity"
      /* LostOpportunity */
    ]: "lost-opportunity",
    [
      "WorsePosition"
      /* WorsePosition */
    ]: "worse-position",
    [
      "InsightHarm1"
      /* InsightHarm1 */
    ]: "harm-insight-1",
    [
      "InsightHarm2"
      /* InsightHarm2 */
    ]: "harm-insight-2",
    [
      "InsightHarm3"
      /* InsightHarm3 */
    ]: "harm-insight-3",
    [
      "InsightHarm4"
      /* InsightHarm4 */
    ]: "harm-insight-4",
    [
      "ProwessHarm1"
      /* ProwessHarm1 */
    ]: "harm-prowess-1",
    [
      "ProwessHarm2"
      /* ProwessHarm2 */
    ]: "harm-prowess-2",
    [
      "ProwessHarm3"
      /* ProwessHarm3 */
    ]: "harm-prowess-3",
    [
      "ProwessHarm4"
      /* ProwessHarm4 */
    ]: "harm-prowess-4",
    [
      "ResolveHarm1"
      /* ResolveHarm1 */
    ]: "harm-resolve-1",
    [
      "ResolveHarm2"
      /* ResolveHarm2 */
    ]: "harm-resolve-2",
    [
      "ResolveHarm3"
      /* ResolveHarm3 */
    ]: "harm-resolve-3",
    [
      "ResolveHarm4"
      /* ResolveHarm4 */
    ]: "harm-resolve-4",
    [
      "None"
      /* None */
    ]: ""
  },
  RollResultDescriptions: {
    [
      "controlled"
      /* controlled */
    ]: {
      [
        "critical"
        /* critical */
      ]: "You critically succeed from a controlled position!",
      [
        "success"
        /* success */
      ]: "You fully succeed from a controlled position!",
      [
        "partial"
        /* partial */
      ]: "You partially succeed from a controlled position!",
      [
        "fail"
        /* fail */
      ]: "You fail from a controlled position!"
    },
    [
      "risky"
      /* risky */
    ]: {
      [
        "critical"
        /* critical */
      ]: "You critically succeed from a risky position!",
      [
        "success"
        /* success */
      ]: "You fully succeed from a risky position!",
      [
        "partial"
        /* partial */
      ]: "You partially succeed from a risky position!",
      [
        "fail"
        /* fail */
      ]: "You fail from a risky position!"
    },
    [
      "desperate"
      /* desperate */
    ]: {
      [
        "critical"
        /* critical */
      ]: "You critically succeed from a desperate position!",
      [
        "success"
        /* success */
      ]: "You fully succeed from a desperate position!",
      [
        "partial"
        /* partial */
      ]: "You partially succeed from a desperate position!",
      [
        "fail"
        /* fail */
      ]: "You fail from a desperate position!"
    }
  },
  Colors: {
    /* IMPORT FROM CSS via css-loader */
    bWHITE: "rgba(255, 255, 255, 1)",
    WHITE: "rgba(200, 200, 200, 1)",
    bGREY: "rgba(170, 170, 170, 1)",
    GREY: "rgba(119, 119, 119, 1)",
    dGREY: "rgba(68, 68, 68, 1)",
    BLACK: "rgba(32, 32, 32, 1)",
    dBLACK: "rgba(0, 0, 0, 1)",
    bGOLD: "rgba(255,216, 44, 1)",
    GOLD: "rgba(215,175,  0, 1)",
    dGOLD: "rgba(165,134,  0, 1)",
    ddGOLD: "rgba(103, 83,  0, 1)",
    bRED: "rgba(255, 0, 0, 1)",
    RED: "rgba(200, 0, 0, 1)",
    dRED: "rgba(150,  0,  0, 1)",
    ddRED: "rgba(50,  0,  0, 1)",
    bBLUE: "rgba(   0,224,224, 1)",
    BLUE: "rgba(52,213,213, 1)",
    dBLUE: "rgba(0,118,118, 1)",
    ddBLUE: "rgba(0, 77, 77, 1)"
  },
  // ClockKeyPositions: {
  //   elemSquareSize: 100,
  //   0: {
  //     keyDimensions: {width: 0, height: 0},
  //     keyCenter: {x: 0, y: 0},
  //     clocksCenter: {x: 0, y: 0},
  //     clocksCenterDimensions: {width: 0, height: 0},
  //     clocks: {}
  //   },
  //   1: {
  //     keyDimensions: {width: 230, height: 836},
  //     keyCenter: {x: 115, y: 418},
  //     clocksCenter: {x: 111.011, y: 108.5},
  //     clocksCenterDimensions: {width: 169, height: 169},
  //     clocks: {
  //       0: {x: 111.011, y: 108.5, size: 169}
  //     }
  //   },
  //   2: {
  //     keyDimensions: {width: 202, height: 625},
  //     keyCenter: {x: 101, y: 312},
  //     clocksCenter: {x: 101, y: 189},
  //     clocksCenterDimensions: {width: 110, height: 290},
  //     clocks: {
  //       0: {x: 101, y: 99, size: 108},
  //       1: {x: 101, y: 279, size: 108}
  //     }
  //   },
  //   3: {
  //     keyDimensions: {width: 280, height: 915},
  //     keyCenter: {x: 140, y: 457},
  //     clocksCenter: {x: 140, y: 169},
  //     clocksCenterDimensions: {width: 242, height: 222},
  //     clocks: {
  //       0: {x: 140, y: 99, size: 108},
  //       1: {x: 74, y: 211, size: 108},
  //       2: {x: 206, y: 211, size: 108}
  //     }
  //   },
  //   4: {
  //     keyDimensions: {width: 376, height: 1140},
  //     keyCenter: {x: 188, y: 570},
  //     clocksCenter: {x: 188, y: 185},
  //     clocksCenterDimensions: {width: 284, height: 282},
  //     clocks: {
  //       0: {x: 188, y: 99, size: 108}, // yTop = 45
  //       1: {x: 101, y: 185, size: 108},
  //       2: {x: 275, y: 185, size: 108},
  //       3: {x: 188, y: 273, size: 108} // yBottom = 327
  //     }
  //   },
  //   5: {
  //     keyDimensions: {width: 376, height: 1140},
  //     keyCenter: {x: 188, y: 570},
  //     clocksCenter: {x: 188, y: 185},
  //     clocksCenterDimensions: {width: 284, height: 384},
  //     clocks: {
  //       0: {x: 188, y: 99, size: 108}, // yTop = 45
  //       1: {x: 101, y: 185, size: 108},
  //       2: {x: 275, y: 185, size: 108},
  //       3: {x: 188, y: 273, size: 108},
  //       4: {x: 188, y: 452, size: 108} // yBottom = 506
  //     }
  //   },
  //   6: {
  //     keyDimensions: {width: 376, height: 1140},
  //     keyCenter: {x: 188, y: 570},
  //     clocksCenter: {x: 188, y: 391},
  //     clocksCenterDimensions: {width: 284, height: 692},
  //     clocks: {
  //       0: {x: 188, y: 99, size: 108}, // yTop = 45
  //       1: {x: 101, y: 185, size: 108},
  //       2: {x: 275, y: 185, size: 108},
  //       3: {x: 188, y: 273, size: 108},
  //       4: {x: 188, y: 452, size: 108},
  //       5: {x: 188, y: 683, size: 108} // yBottom = 737
  //     }
  //   }
  // },
  Loadout: {
    selections: [
      { value: "Light", display: "Light" },
      { value: "Normal", display: "Normal" },
      { value: "Heavy", display: "Heavy" }
    ],
    levels: ["BITD.Light", "BITD.Normal", "BITD.Heavy", "BITD.Encumbered", "BITD.OverMax"]
  },
  AttributeTooltips: {
    [
      "insight"
      /* insight */
    ]: "<p>Resists consequences from <strong>deception</strong> or <strong>understanding</strong></p>",
    [
      "prowess"
      /* prowess */
    ]: "<p>Resists consequences from <strong>physical strain</strong> or <strong>injury</strong></p>",
    [
      "resolve"
      /* resolve */
    ]: "<p>Resists consequences from <strong>mental strain</strong> or <strong>willpower</strong></p>"
  },
  ShortAttributeTooltips: {
    [
      "insight"
      /* insight */
    ]: "vs. <strong>deception</strong> or <strong>(mis)understanding</strong>",
    [
      "prowess"
      /* prowess */
    ]: "vs. <strong>physical strain</strong> or <strong>injury</strong>",
    [
      "resolve"
      /* resolve */
    ]: "vs. <strong>mental strain</strong> or <strong>willpower</strong>"
  },
  ShortActionTooltips: {
    [
      "hunt"
      /* hunt */
    ]: "carefully track a target",
    [
      "study"
      /* study */
    ]: "scrutinize details and interpret evidence",
    [
      "survey"
      /* survey */
    ]: "observe the situation and anticipate outcomes",
    [
      "tinker"
      /* tinker */
    ]: "fiddle with devices and mechanisms",
    [
      "finesse"
      /* finesse */
    ]: "employ dexterity or subtle misdirection",
    [
      "prowl"
      /* prowl */
    ]: "traverse skillfully and quietly",
    [
      "skirmish"
      /* skirmish */
    ]: "entangle a target in melee so they can't escape",
    [
      "wreck"
      /* wreck */
    ]: "unleash savage force",
    [
      "attune"
      /* attune */
    ]: "open your mind to the ghost field or channel nearby electroplasmic energy through your body",
    [
      "command"
      /* command */
    ]: "compel swift obedience",
    [
      "consort"
      /* consort */
    ]: "socialize with friends and contacts",
    [
      "sway"
      /* sway */
    ]: "influence someone with guile, charm, or argument"
  },
  ActionTooltips: {
    [
      "hunt"
      /* hunt */
    ]: "<p>When you <strong>Hunt</strong>, you carefully track a target.</p><ul><li>You might follow a person or discover their location.</li><li>You might arrange an ambush.</li><li>You might attack with precision shooting from a distance.</li></ul><ul><li>You could try to wield your guns in a melee <em>(but <strong>Skirmishing</strong> might be better)</em>.</li></ul>",
    [
      "study"
      /* study */
    ]: "<p>When you <strong>Study</strong>, you scrutinize details and interpret evidence.</p><ul><li>You might gather information from documents, newspapers, and books.</li><li>You might do research on an esoteric topic.</li><li>You might closely analyze a person to detect lies or true feelings.</li></ul><ul><li>You could try to understand a pressing situation <em>(but <strong>Surveying</strong> might be better)</em>.</li></ul>",
    [
      "survey"
      /* survey */
    ]: "<p>When you <strong>Survey</strong>, you observe the situation and anticipate outcomes.</p><ul><li>You might spot telltale signs of trouble before it happens.</li><li>You might uncover opportunities or weaknesses.</li></ul><ul><li>You might detect a person's motives or intentions <em>(but <strong>Studying</strong> might be better)</em>.</li><li>You could try to spot a good ambush point <em>(but <strong>Hunting</strong> might be better)</em>.</li></ul>",
    [
      "tinker"
      /* tinker */
    ]: "<p>When you <strong>Tinker</strong>, you fiddle with devices and mechanisms.</p><ul><li>You might create a new gadget or alter an existing item.</li><li>You might pick a lock or crack a safe.</li><li>You might disable an alarm or trap.</li><li>You might turn the sparkcraft and electroplasmic devices around the city to your advantage.</li></ul><ul><li>You could try to control a vehicle with your tech-savvy <em>(but <strong>Finessing</strong> might be better)</em>.</li></ul>",
    [
      "finesse"
      /* finesse */
    ]: "<p>When you <strong>Finesse</strong>, you employ dexterity or subtle misdirection.</p><ul><li>You might pick someone's pocket.</li><li>You might handle the controls of a vehicle or direct a mount.</li><li>You might formally duel an opponent with graceful fighting arts.</li></ul><ul><li>You could try to leverage agility in a melee <em>(but <strong>Skirmishing</strong> might be better)</em>.</li><li>You could try to pick a lock <em>(but <strong>Tinkering</strong> might be better)</em>.</li></ul>",
    [
      "prowl"
      /* prowl */
    ]: "<p>When you <strong>Prowl</strong>, you traverse skillfully and quietly.</p><ul><li>You might sneak past a guard or hide in the shadows.</li><li>You might run and leap across the rooftops.</li><li>You might attack someone from hiding with a back-stab or blackjack.</li></ul><ul><li>You could try to waylay a victim during combat <em>(but <strong>Skirmishing</strong> might be better)</em>.</li></ul>",
    [
      "skirmish"
      /* skirmish */
    ]: "<p>When you <strong>Skirmish</strong>, you entangle a target in melee so they can't escape.</p><ul><li>You might brawl or wrestle with them.</li><li>You might hack and slash.</li><li>You might seize or hold a position in battle.</li></ul><ul><li>You could try to fight in a formal duel <em>(but <strong>Finessing</strong> might be better)</em>.</li></ul>",
    [
      "wreck"
      /* wreck */
    ]: "<p>When you <strong>Wreck</strong>, you unleash savage force.</p><ul><li>You might smash down a door or wall with a sledgehammer.</li><li>You might use an explosive to do the same.</li><li>You might use chaos or sabotage to create distractions or overcome obstacles.</li></ul><ul><li>You could try to overwhelm an enemy with sheer force in battle <em>(but <strong>Skirmishing</strong> might be better)</em>.</li></ul>",
    [
      "attune"
      /* attune */
    ]: "<p>When you <strong>Attune</strong>, you open your mind to the ghost field or channel nearby electroplasmic energy through your body.</p><ul><li>You might communicate with a ghost or understand aspects of spectrology.</li><li>You might peer into the echo of Doskvol in the ghost field.</li></ul><ul><li>You could try to perceive beyond sight in order to better understand your situation <em>(but <strong>Surveying</strong> might be better)</em>.</li></ul>",
    [
      "command"
      /* command */
    ]: "<p>When you <strong>Command</strong>, you compel swift obedience.</p><ul><li>You might intimidate or threaten to get what you want.</li><li>You might lead a gang in a group action.</li></ul><ul><li>You could try to persuade people by giving orders <em>(but <strong>Consorting</strong> might be better)</em>.</li></ul>",
    [
      "consort"
      /* consort */
    ]: "<p>When you <strong>Consort</strong>, you socialize with friends and contacts.</p><ul><li>You might gain access to resources, information, people, or places.</li><li>You might make a good impression or win someone over with charm and style.</li><li>You might make new friends or connect with your heritage or background.</li></ul><ul><li>You could try to direct allies with social pressure <em>(but <strong>Commanding</strong> might be better)</em>.</li></ul>",
    [
      "sway"
      /* sway */
    ]: "<p>When you <strong>Sway</strong>, you influence someone with guile, charm, or argument.</p><ul><li>You might lie convincingly.</li><li>You might persuade someone to do what you want.</li><li>You might argue a case that leaves no clear rebuttal.</li></ul><ul><li>You could try to trick people into affection or obedience <em>(but <strong>Consorting</strong> or <strong>Commanding</strong> might be better)</em>.</li></ul>"
  },
  ActionTooltipsGM: {
    [
      "hunt"
      /* hunt */
    ]: "<p>When you <strong>Hunt</strong>, you carefully track a target.</p><ul><li>You might follow a person or discover their location.</li><li>You might arrange an ambush.</li><li>You might attack with precision shooting from a distance.</li></ul><ul><li>You could try to wield your guns in a melee <em>(but <strong>Skirmishing</strong> might be better)</em>.</li></ul><hr><ul><li>How do you hunt them down?</li><li>What methods do you use?</li><li>What do you hope to achieve?</li></ul>",
    [
      "study"
      /* study */
    ]: "<p>When you <strong>Study</strong>, you scrutinize details and interpret evidence.</p><ul><li>You might gather information from documents, newspapers, and books.</li><li>You might do research on an esoteric topic.</li><li>You might closely analyze a person to detect lies or true feelings.</li></ul><ul><li>You could try to understand a pressing situation <em>(but <strong>Surveying</strong> might be better)</em>.</li></ul><hr><ul><li>What do you study?</li><li>What details or evidence do you scrutinize?</li><li>What do you hope to understand?</li></ul>",
    [
      "survey"
      /* survey */
    ]: "<p>When you <strong>Survey</strong>, you observe the situation and anticipate outcomes.</p><ul><li>You might spot telltale signs of trouble before it happens.</li><li>You might uncover opportunities or weaknesses.</li></ul><ul><li>You might detect a person's motives or intentions <em>(but <strong>Studying</strong> might be better)</em>.</li><li>You could try to spot a good ambush point <em>(but <strong>Hunting</strong> might be better)</em>.</li></ul><hr><ul><li>How do you survey the situation?</li><li>Is there anything special you're looking out for?</li><li>What do you hope to understand?</li></ul>",
    [
      "tinker"
      /* tinker */
    ]: "<p>When you <strong>Tinker</strong>, you fiddle with devices and mechanisms.</p><ul><li>You might create a new gadget or alter an existing item.</li><li>You might pick a lock or crack a safe.</li><li>You might disable an alarm or trap.</li><li>You might turn the sparkcraft and electroplasmic devices around the city to your advantage.</li></ul><ul><li>You could try to control a vehicle with your tech-savvy <em>(but <strong>Finessing</strong> might be better)</em>.</li></ul><hr><ul><li>What do you tinker with?</li><li>What do you hope to accomplish?</li></ul>",
    [
      "finesse"
      /* finesse */
    ]: "<p>When you <strong>Finesse</strong>, you employ dexterity or subtle misdirection.</p><ul><li>You might pick someone's pocket.</li><li>You might handle the controls of a vehicle or direct a mount.</li><li>You might formally duel an opponent with graceful fighting arts.</li></ul><ul><li>You could try to leverage agility in a melee <em>(but <strong>Skirmishing</strong> might be better)</em>.</li><li>You could try to pick a lock <em>(but <strong>Tinkering</strong> might be better)</em>.</li></ul><hr><ul><li>What do you finesse?</li><li>What's graceful or subtle about this?</li><li>What do you hope to achieve?</li></ul>",
    [
      "prowl"
      /* prowl */
    ]: "<p>When you <strong>Prowl</strong>, you traverse skillfully and quietly.</p><ul><li>You might sneak past a guard or hide in the shadows.</li><li>You might run and leap across the rooftops.</li><li>You might attack someone from hiding with a back-stab or blackjack.</li></ul><ul><li>You could try to waylay a victim during combat <em>(but <strong>Skirmishing</strong> might be better)</em>.</li></ul><hr><ul><li>How do you prowl?</li><li>How do you use the environment around you?</li><li>What do you hope to achieve?</li></ul>",
    [
      "skirmish"
      /* skirmish */
    ]: "<p>When you <strong>Skirmish</strong>, you entangle a target in melee so they can't escape.</p><ul><li>You might brawl or wrestle with them.</li><li>You might hack and slash.</li><li>You might seize or hold a position in battle.</li></ul><ul><li>You could try to fight in a formal duel <em>(but <strong>Finessing</strong> might be better)</em>.</li></ul><hr><ul><li>How do you skirmish with them?</li><li>What combat methods do you use?</li><li>What do you hope to achieve?</li></ul>",
    [
      "wreck"
      /* wreck */
    ]: "<p>When you <strong>Wreck</strong>, you unleash savage force.</p><ul><li>You might smash down a door or wall with a sledgehammer.</li><li>You might use an explosive to do the same.</li><li>You might use chaos or sabotage to create distractions or overcome obstacles.</li></ul><ul><li>You could try to overwhelm an enemy with sheer force in battle <em>(but <strong>Skirmishing</strong> might be better)</em>.</li></ul><hr><ul><li>What do you wreck?</li><li>What force do you bring to bear?</li><li>What do you hope to accomplish?</li></ul>",
    [
      "attune"
      /* attune */
    ]: "<p>When you <strong>Attune</strong>, you open your mind to the ghost field or channel nearby electroplasmic energy through your body.</p><ul><li>You might communicate with a ghost or understand aspects of spectrology.</li><li>You might peer into the echo of Doskvol in the ghost field.</li></ul><ul><li>You could try to perceive beyond sight in order to better understand your situation <em>(but <strong>Surveying</strong> might be better)</em>.</li></ul><hr><ul><li>How do you open your mind to the ghost field?</li><li>What does that look like?</li><li>What energy are you attuning to?</li><li>How are you channeling that energy?</li><li>What do you hope the energy will do?</li></ul>",
    [
      "command"
      /* command */
    ]: "<p>When you <strong>Command</strong>, you compel swift obedience.</p><ul><li>You might intimidate or threaten to get what you want.</li><li>You might lead a gang in a group action.</li></ul><ul><li>You could try to persuade people by giving orders <em>(but <strong>Consorting</strong> might be better)</em>.</li></ul><hr><ul><li>Who do you command?</li><li>How do you do it—what's your leverage here?</li><li>What do you hope they'll do?</li></ul>",
    [
      "consort"
      /* consort */
    ]: "<p>When you <strong>Consort</strong>, you socialize with friends and contacts.</p><ul><li>You might gain access to resources, information, people, or places.</li><li>You might make a good impression or win someone over with charm and style.</li><li>You might make new friends or connect with your heritage or background.</li></ul><ul><li>You could try to direct allies with social pressure <em>(but <strong>Commanding</strong> might be better)</em>.</li></ul><hr><ul><li>Who do you consort with?</li><li>Where do you meet?</li><li>What do you talk about?</li><li>What do you hope to achieve?</li></ul>",
    [
      "sway"
      /* sway */
    ]: "<p>When you <strong>Sway</strong>, you influence someone with guile, charm, or argument.</p><ul><li>You might lie convincingly.</li><li>You might persuade someone to do what you want.</li><li>You might argue a case that leaves no clear rebuttal.</li></ul><ul><li>You could try to trick people into affection or obedience <em>(but <strong>Consorting</strong> or <strong>Commanding</strong> might be better)</em>.</li></ul><hr><ul><li>Who do you sway?</li><li>What kind of leverage do you have here?</li><li>What do you hope they'll do?</li></ul>"
  },
  ActionVerbs: {
    [
      "hunt"
      /* hunt */
    ]: "hunts",
    [
      "study"
      /* study */
    ]: "studies",
    [
      "survey"
      /* survey */
    ]: "surveys",
    [
      "tinker"
      /* tinker */
    ]: "tinkers",
    [
      "finesse"
      /* finesse */
    ]: "finesses",
    [
      "prowl"
      /* prowl */
    ]: "prowls",
    [
      "skirmish"
      /* skirmish */
    ]: "skirmishes",
    [
      "wreck"
      /* wreck */
    ]: "wrecks",
    [
      "attune"
      /* attune */
    ]: "attunes",
    [
      "command"
      /* command */
    ]: "commands",
    [
      "consort"
      /* consort */
    ]: "consorts",
    [
      "sway"
      /* sway */
    ]: "sways"
  },
  ActionPastVerbs: {
    [
      "hunt"
      /* hunt */
    ]: "hunted",
    [
      "study"
      /* study */
    ]: "studied",
    [
      "survey"
      /* survey */
    ]: "surveyed",
    [
      "tinker"
      /* tinker */
    ]: "tinkered",
    [
      "finesse"
      /* finesse */
    ]: "finessed",
    [
      "prowl"
      /* prowl */
    ]: "prowled",
    [
      "skirmish"
      /* skirmish */
    ]: "skirmished",
    [
      "wreck"
      /* wreck */
    ]: "wrecked",
    [
      "attune"
      /* attune */
    ]: "attuned",
    [
      "command"
      /* command */
    ]: "commanded",
    [
      "consort"
      /* consort */
    ]: "consorted",
    [
      "sway"
      /* sway */
    ]: "swayed"
  },
  TraumaTooltips: {
    Cold: "You're not moved by emotional appeals or social bonds.",
    Haunted: "You're often lost in reverie, reliving past horrors, seeing things.",
    Obsessed: "You're enthralled by one thing: an activity, a person, an ideology.",
    Paranoid: "You imagine danger everywhere; you can't trust others.",
    Reckless: "You have little regard for your own safety or best interests.",
    Soft: "You lose your edge; you become sentimental, passive, gentle.",
    Unstable: "Your emotional state is volatile. You can instantly rage, or fall into despair, act impulsively, or freeze up.",
    Vicious: "You seek out opportunities to hurt people, even for no good reason.",
    Chaotic: "You've become so detached from the living that inhibitions fall away, leaving you impulsive and unpredictable.",
    Destructive: "You are easily angered by reminders of all you've lost, and can lash out violently against the trappings of the living world.",
    Furious: "Your ravaged soul is fertile kindling for rage, and your fury is easily ignited.",
    Obsessive: "Your wants and desires become fixations and compulsions, driving you to achieve them at any cost.",
    Territorial: "You see some place as yours: Trespassers are dealt with, and even guests must respect your claim.",
    Savage: "When moved to anger or violence, you act with cruelty and feral malevolence.",
    Clanking: "Your frame has developed a persistent metallic clang with each step, making stealth difficult.",
    Leaking: "You continuously leak oil, leviathan blood, distilled electroplasm or some other potentially-dangerous substance.",
    Fixated: "You have become fixated on a function of your choice, and lose all memory of your humanity when you pursue it.",
    Smoking: "Your frame exudes a constant miasma of acrid, foul-smelling smoke.",
    Sparking: "Electroplasmic energy erupts in arcing sparks from joints and junctions throughout your frame.",
    Ruthless: "You lose any sense of humanity when indulging your Vice or pursuing your most important goal.",
    Secretive: "Knowledge has become so precious to you, that even your closest allies are on a need-to-know basis."
  },
  EdgeTooltips: {
    Fearsome: "<p>The cohort is terrifying in aspect and reputation.</p>",
    Independent: "<p>The cohort can be trusted to make good decisions and act on their own initiative in the absence of direct orders.</p>",
    Loyal: "<p>The cohort can't be bribed or turned against you. </p>",
    Tenacious: "<p>The cohort won't be deterred from a task.</p>",
    Nimble: "<p>The vehicle handles easily. Consider this an <strong>assist</strong> for tricky maneuvers.</p>",
    Simple: "<p>The vehicle is easy to repair. Remove all of its <strong>Harm</strong> during <strong>downtime</strong></p>",
    Sturdy: "<p>The vehicle keeps operating even when <strong>Broken</strong>.</p>",
    "Arrow-Swift": "<p>Your pet gains <strong>Potency</strong> when tracking or fighting the supernatural.</p><p>It can move extremely quickly, outpacing any other creature or vehicle.</p>",
    "Ghost Form": "<p>Your pet gains <strong>Potency</strong> when tracking or fighting the supernatural.</p><p>It can transform into electroplasmic vapor as if it were a spirit.</p>",
    "Mind Link": "<p>Your pet gains <strong>Potency</strong> when tracking or fighting the supernatural.</p><p>You and your pet can share senses and thoughts telepathically.</p>"
  },
  FlawTooltips: {
    Principled: "<p>The cohort has an ethic or values that it won't betray.</p>",
    Savage: "<p>The cohort is excessively violent and cruel.</p>",
    Unreliable: "<p>The cohort isn't always available, due to other obligations, stupefaction from their vices, etc.</p>",
    Wild: "<p>The cohort is drunken, debauched, and loud-mouthed.</p>",
    Costly: "<p>The vehicle costs <strong>1 Coin</strong> per <strong>downtime</strong> to keep it in operation.</p>",
    Distinct: "<p>The vehicle has memorable features. Take <strong>+1 Heat</strong> when you use it on a score.</p>",
    Finicky: "<p>The vehicle has quirks that only one person understands. When operated without them, it has <strong>-1 Quality</strong>.</p>"
  },
  QualityDescriptors: [
    "Poor",
    "Adequate",
    "Good",
    "Excellent",
    "Superior",
    "Impeccable",
    "Legendary"
  ],
  ForceDescriptors: [
    "Weak",
    "Moderate",
    "Strong",
    "Serious",
    "Powerful",
    "Overwhelming",
    "Devastating"
  ],
  VehicleDescriptors: [
    "A Vehicle?",
    "A Vehicle",
    "A Respectable Vehicle",
    "A Respected Vehicle",
    "A Precision-Built Vehicle",
    "A Powerful, Advanced Vehicle",
    "A Uniquely Strong, Extremely Advanced Vehicle"
  ],
  PetDescriptors: [
    "A Weak Hunting Pet",
    "A Hunting Pet",
    "A Strong Hunting Pet",
    "A Serious Hunting Pet",
    "A Powerful Hunting Pet",
    "An Overwhelmingly Powerful Hunting Pet",
    "A Devastating Hunting Pet"
  ],
  AreaExamples: [
    "a closet",
    "a small room",
    "a large room",
    "several rooms",
    "a small building",
    "a large building",
    "a city block"
  ],
  ScaleExamples: [
    "(1 or 2 members)",
    "(3 - 6 members)",
    "(~12 members)",
    "(~20 members)",
    "(~40 members)",
    "(~80 members)",
    "(~160 members)"
  ],
  ScaleSizes: [
    "A Few ",
    "A Small Gang of ",
    "A Gang of ",
    "A Large Gang of ",
    "A Small Army of ",
    "An Army of ",
    "A Massive Army of "
  ],
  DiceOddsStandard: [
    { crit: 0, success: 2.8, partial: 22.2, fail: 75 },
    { crit: 0, success: 16.7, partial: 33.3, fail: 50 },
    { crit: 2.8, success: 27.8, partial: 44.4, fail: 25 },
    { crit: 7.4, success: 34.7, partial: 45.4, fail: 12.5 },
    { crit: 13.2, success: 38.6, partial: 42, fail: 6.3 },
    { crit: 19.6, success: 40.2, partial: 37.1, fail: 3.1 },
    { crit: 26.3, success: 40.2, partial: 31.9, fail: 1.6 },
    { crit: 33, success: 39.1, partial: 27.1, fail: 0.8 },
    { crit: 39.5, success: 37.2, partial: 22.9, fail: 0.4 },
    { crit: 45.7, success: 34.9, partial: 19.2, fail: 0.2 },
    { crit: 51.5, success: 32.3, partial: 16.1, fail: 0.1 },
    { crit: 56.9, success: 29.6, partial: 13.4, fail: 0 },
    { crit: 61.9, success: 26.9, partial: 11.2, fail: 0 },
    { crit: 66.3, success: 24.3, partial: 9.3, fail: 0 },
    { crit: 70.4, success: 21.8, partial: 7.8, fail: 0 },
    { crit: 74, success: 19.5, partial: 6.5, fail: 0 },
    { crit: 77.3, success: 17.3, partial: 5.4, fail: 0 },
    { crit: 80.2, success: 15.3, partial: 4.5, fail: 0 },
    { crit: 82.7, success: 13.5, partial: 3.8, fail: 0 },
    { crit: 85, success: 11.9, partial: 3.1, fail: 0 },
    { crit: 87, success: 10.4, partial: 2.6, fail: 0 }
  ],
  DiceOddsResistance: [
    // Stress Cost: [-1, 0, 1, 2, 3, 4, 5]
    [0, 2.8, 8.3, 13.9, 19.4, 25, 30.6],
    [0, 16.7, 16.7, 16.7, 16.6, 16.7, 16.7],
    [2.8, 27.8, 25, 19.4, 13.9, 8.3, 2.8],
    [7.4, 34.7, 28.3, 17.1, 8.8, 3.2, 0.5],
    [13.2, 38.6, 28.5, 13.5, 5, 1.2, 0.1],
    [19.6, 40.2, 27, 10.1, 2.7, 0.4, 0],
    [26.3, 40.2, 24.7, 7.2, 1.4, 0.1, 0]
  ],
  ExperienceClues: {
    Scoundrel: [
      "You expressed your beliefs, drives, heritage, or background.",
      "You struggled with issues from your vice or traumas during the session."
    ],
    Crew: [
      "You contended with challenges above your current station.",
      "You bolstered your crew's reputation, or developed a new one.",
      "You expressed the goals, drives, inner conflict, or essential nature of the crew."
    ]
  },
  GatherInfoQuestions: {
    Cutter: [
      "How can I hurt them?",
      "Who's most afraid of me?",
      "Who's most dangerous here?",
      "What do they intend to do?",
      "How can I get them to [X]?",
      "Are they telling the truth?",
      "What's really going on here?"
    ],
    Hound: [
      "What do they intend to do?",
      "How can I get them to [X]?",
      "What are they really feeling?",
      "Where are they vulnerable?",
      "Where did [X] go?",
      "How can I find [X]?",
      "What's really going on here?"
    ],
    Leech: [
      "What do they intend to do?",
      "How can I get them to [X]?",
      "Are they telling the truth?",
      "What can I tinker with here?",
      "What might happen if I [X]?",
      "How can I find [X]?",
      "What's really going on here?"
    ],
    Lurk: [
      "What do they intend to do?",
      "How can I get them to [X]?",
      "What should I look out for?",
      "What's the best way in?",
      "Where can I hide here?",
      "How can I find [X]?",
      "What's really going on here?"
    ],
    Slide: [
      "What do they intend to do?",
      "How can I get them to [X]?",
      "Are they telling the truth?",
      "What are they really feeling?",
      "What do they really care about?",
      "How can I blend in here?",
      "What's really going on here?"
    ],
    Spider: [
      "What do they want most?",
      "What should I look out for?",
      "Where's the leverage here?",
      "How can I discover [X]?",
      "What do they intend to do?",
      "How can I get them to [X]?",
      "What's really going on here?"
    ],
    Whisper: [
      "What is arcane or weird here?",
      "What echoes in the ghost field?",
      "What is hidden or lost here?",
      "What do they intend to do?",
      "What drives them to do this?",
      "How can I reveal [X]?",
      "What's really going on here?"
    ],
    Ghost: [
      "What do they intend to do?",
      "How can I get them to [X]?",
      "What are they really feeling?",
      "What should I lookout for?",
      "Where's the weakness here?",
      "How can I find [X]?",
      "What's really going on here?"
    ],
    Hull: [
      "What do they intend to do?",
      "How can I get them to [X]?",
      "What are they really doing?",
      "What should I lookout for?",
      "Where's the weakness here?",
      "How can I find [X]?",
      "What's really going on here?"
    ],
    Vampire: [
      "What do they intend to do?",
      "How can I get them to [X]?",
      "What are they really feeling?",
      "What should I lookout for?",
      "Where's the weakness here?",
      "How can I find [X]?",
      "What's really going on here?"
    ]
  },
  Playbooks: {
    Cutter: {
      "system.experience_clues": [
        "You addressed a challenge with violence or coercion.",
        "You expressed your beliefs, drives, heritage, or background.",
        "You struggled with issues from your vice or traumas during the session."
      ],
      "system.trauma_conditions": ["Cold", "Haunted", "Obsessed", "Paranoid", "Reckless", "Soft", "Unstable", "Vicious"],
      "system.gather_info_questions": [
        "How can I hurt them?",
        "Who's most afraid of me?",
        "Who's most dangerous here?",
        "What do they intend to do?",
        "How can I get them to [X]?",
        "Are they telling the truth?",
        "What's really going on here?"
      ],
      "system.suggested_ability": "Battleborn"
    },
    Hound: {
      "system.bgImg": "systems/eunos-blades/assets/icons/class-icons/hound-trans.svg",
      "system.tagline": "A Deadly Sharpshooter & Tracker",
      // "system.acquaintances_name": "Deadly Friends & Rivals",
      "system.friends_name": "Deadly Friends",
      "system.rivals_name": "Deadlier Rivals",
      "system.starting_stats.chargen": {
        "system.attributes.insight.hunt.value": 2,
        "system.attributes.insight.survey.value": 1
      },
      "system.experience_clues": [
        "You addressed a challenge with tracking or violence.",
        "You expressed your beliefs, drives, heritage, or background.",
        "You struggled with issues from your vice or traumas during the session."
      ],
      "system.trauma_conditions": ["Cold", "Haunted", "Obsessed", "Paranoid", "Reckless", "Soft", "Unstable", "Vicious"],
      "system.gather_info_questions": [
        "What do they intend to do?",
        "How can I get them to [X]?",
        "What are they really feeling?",
        "Where are they vulnerable?",
        "Where did [X] go?",
        "How can I find [X]?",
        "What's really going on here?"
      ],
      "system.suggested_ability": "Sharpshooter"
    },
    Leech: {
      "system.bgImg": "systems/eunos-blades/assets/icons/class-icons/leech-trans.svg",
      "system.tagline": "A Saboteur & Technician",
      // "system.acquaintances_name": "Clever Friends & Rivals",
      "system.friends_name": "Clever Friends",
      "system.rivals_name": "Cleverer Rivals",
      "system.starting_stats.chargen": {
        "system.attributes.insight.tinker.value": 2,
        "system.attributes.prowess.wreck.value": 1
      },
      "system.experience_clues": [
        "You addressed a challenge with technical skill or mayhem.",
        "You expressed your beliefs, drives, heritage, or background.",
        "You struggled with issues from your vice or traumas during the session."
      ],
      "system.trauma_conditions": ["Cold", "Haunted", "Obsessed", "Paranoid", "Reckless", "Soft", "Unstable", "Vicious"],
      "system.gather_info_questions": [
        "What do they intend to do?",
        "How can I get them to [X]?",
        "Are they telling the truth?",
        "What can I tinker with here?",
        "What might happen if I [X]?",
        "How can I find [X]?",
        "What's really going on here?"
      ],
      "system.suggested_ability": "Alchemist"
    },
    Lurk: {
      "system.bgImg": "systems/eunos-blades/assets/icons/class-icons/lurk-trans.svg",
      "system.tagline": "A Stealthy Infiltrator & Burglar",
      // "system.acquaintances_name": "Shady Friends & Rivals",
      "system.friends_name": "Shady Friends",
      "system.rivals_name": "Shadier Rivals",
      "system.starting_stats.chargen": {
        "system.attributes.prowess.prowl.value": 2,
        "system.attributes.prowess.finesse.value": 1
      },
      "system.experience_clues": [
        "You addressed a challenge with stealth or evasion.",
        "You expressed your beliefs, drives, heritage, or background.",
        "You struggled with issues from your vice or traumas during the session."
      ],
      "system.trauma_conditions": ["Cold", "Haunted", "Obsessed", "Paranoid", "Reckless", "Soft", "Unstable", "Vicious"],
      "system.gather_info_questions": [
        "What do they intend to do?",
        "How can I get them to [X]?",
        "What should I look out for?",
        "What's the best way in?",
        "Where can I hide here?",
        "How can I find [X]?",
        "What's really going on here?"
      ],
      "system.suggested_ability": "Infiltrator"
    },
    Slide: {
      "system.bgImg": "systems/eunos-blades/assets/icons/class-icons/slide-trans.svg",
      "system.tagline": "A Subtle Manipulator & Spy",
      // "system.acquaintances_name": "Sly Friends & Rivals",
      "system.friends_name": "Sly Friends",
      "system.rivals_name": "Slyer Rivals",
      "system.starting_stats.chargen": {
        "system.attributes.resolve.sway.value": 2,
        "system.attributes.resolve.consort.value": 1
      },
      "system.experience_clues": [
        "You addressed a challenge with deception or influence.",
        "You expressed your beliefs, drives, heritage, or background.",
        "You struggled with issues from your vice or traumas during the session."
      ],
      "system.trauma_conditions": ["Cold", "Haunted", "Obsessed", "Paranoid", "Reckless", "Soft", "Unstable", "Vicious"],
      "system.gather_info_questions": [
        "What do they intend to do?",
        "How can I get them to [X]?",
        "Are they telling the truth?",
        "What are they really feeling?",
        "What do they really care about?",
        "How can I blend in here?",
        "What's really going on here?"
      ],
      "system.suggested_ability": "Rook's Gambit"
    },
    Spider: {
      "system.bgImg": "systems/eunos-blades/assets/icons/class-icons/spider-trans.svg",
      "system.tagline": "A Devious Mastermind",
      // "system.acquaintances_name": "Shrewd Friends & Rivals",
      "system.friends_name": "Shrewd Friends",
      "system.rivals_name": "Very Shrewd Rivals",
      "system.starting_stats.chargen": {
        "system.attributes.resolve.consort.value": 2,
        "system.attributes.insight.study.value": 1
      },
      "system.experience_clues": [
        "You addressed a challenge with calculation or conspiracy.",
        "You expressed your beliefs, drives, heritage, or background.",
        "You struggled with issues from your vice or traumas during the session."
      ],
      "system.trauma_conditions": ["Cold", "Haunted", "Obsessed", "Paranoid", "Reckless", "Soft", "Unstable", "Vicious"],
      "system.gather_info_questions": [
        "What do they want most?",
        "What should I look out for?",
        "Where's the leverage here?",
        "How can I discover [X]?",
        "What do they intend to do?",
        "How can I get them to [X]?",
        "What's really going on here?"
      ],
      "system.suggested_ability": "Foresight"
    },
    Whisper: {
      "system.bgImg": "systems/eunos-blades/assets/icons/class-icons/whisper-trans.svg",
      "system.tagline": "An Arcane Adept & Channeler",
      // "system.acquaintances_name": "Strange Friends & Rivals",
      "system.friends_name": "Strange Friends",
      "system.rivals_name": "Stranger Rivals",
      "system.starting_stats.chargen": {
        "system.attributes.resolve.attune.value": 2,
        "system.attributes.insight.study.value": 1
      },
      "system.experience_clues": [
        "You addressed a challenge with knowledge or arcane power.",
        "You expressed your beliefs, drives, heritage, or background.",
        "You struggled with issues from your vice or traumas during the session."
      ],
      "system.trauma_conditions": ["Cold", "Haunted", "Obsessed", "Paranoid", "Reckless", "Soft", "Unstable", "Vicious"],
      "system.gather_info_questions": [
        "What is arcane or weird here?",
        "What echoes in the ghost field?",
        "What is hidden or lost here?",
        "What do they intend to do?",
        "What drives them to do this?",
        "How can I reveal [X]?",
        "What's really going on here?"
      ],
      "system.suggested_ability": "Compel"
    },
    Ghost: {
      "system.bgImg": "systems/eunos-blades/assets/icons/class-icons/ghost-trans.svg",
      "system.tagline": "A Vengeful Disembodied Spirit",
      "system.acquaintances_name": "Enemies & Rivals",
      "system.starting_stats.add": {
        "system.attributes.insight.hunt.value": 1,
        "system.attributes.prowess.prowl.value": 1,
        "system.attributes.resolve.attune.value": 1
      },
      "system.experience_clues": [
        "You exacted vengeance upon those whom you deem deserving.",
        "You expressed your outrage or anger, or settled scores from your heritage, or background.",
        "You struggled with issues from your need or glooms during the session."
      ],
      "system.trauma_conditions": ["Chaotic", "Destructive", "Furious", "Obsessive", "Territorial", "Savage"],
      "system.gather_info_questions": [
        "What do they intend to do?",
        "How can I get them to [X]?",
        "What are they really feeling?",
        "What should I lookout for?",
        "Where's the weakness here?",
        "How can I find [X]?",
        "What's really going on here?"
      ],
      "system.auto_abilities": ["Ghost Form"]
    },
    Hull: {
      "system.bgImg": "systems/eunos-blades/assets/icons/class-icons/hull-trans.svg",
      "system.tagline": "An Animated Spark-Craft Frame",
      "system.acquaintances_name": "Master",
      "system.starting_stats.add": {
        "system.attributes.prowess.skirmish.value": 1,
        "system.attributes.resolve.attune.value": 1
      },
      "system.experience_clues": [
        "You fulfilled your functions despite difficulty or danger.",
        "You suppressed or ignored your former human beliefs, drives, heritage, or background.",
        "You struggled with issues from your wear during the session."
      ],
      "system.trauma_conditions": ["Clanking", "Leaking", "Fixated", "Smoking", "Sparking", "Unstable"],
      "system.gather_info_questions": [
        "What do they intend to do?",
        "How can I get them to [X]?",
        "What are they really doing?",
        "What should I lookout for?",
        "Where's the weakness here?",
        "How can I find [X]?",
        "What's really going on here?"
      ],
      "system.auto_abilities": ["Automaton"]
    },
    Vampire: {
      "system.bgImg": "systems/eunos-blades/assets/icons/class-icons/vampire-trans.svg",
      "system.tagline": "An Animated Undead Body",
      "system.acquaintances_name": "Dark Servants",
      "system.starting_stats.add": {
        "system.attributes.insight.hunt.value": 1,
        "system.attributes.prowess.prowl.value": 1,
        "system.attributes.prowess.skirmish.value": 1,
        "system.attributes.resolve.attune.value": 1,
        "system.attributes.resolve.command.value": 1,
        "system.attributes.resolve.sway.value": 1
      },
      "system.experience_clues": [
        "You displayed your dominance or slayed without mercy.",
        "You expressed your beliefs, drives, heritage, or background.",
        "You struggled with issues from your vice, traumas, or strictures during the session."
      ],
      "system.trauma_conditions": ["Cold", "Haunted", "Obsessed", "Paranoid", "Ruthless", "Secretive", "Unstable", "Vicious"],
      "system.gather_info_questions": [
        "What do they intend to do?",
        "How can I get them to [X]?",
        "What are they really feeling?",
        "What should I lookout for?",
        "Where's the weakness here?",
        "How can I find [X]?",
        "What's really going on here?"
      ],
      "system.auto_abilities": ["Undead"]
    }
  },
  ClockSizes: [1, 2, 3, 4, 5, 6, 8, 10, 12],
  ActorTypes: [
    "pc",
    "npc",
    "crew",
    "faction"
    /* faction */
  ],
  ItemTypes: [
    "ability",
    "background",
    "clock_keeper",
    "cohort_gang",
    "cohort_expert",
    "crew_ability",
    "crew_reputation",
    "crew_playbook",
    "crew_upgrade",
    "feature",
    "gm_tracker",
    "heritage",
    "gear",
    "playbook",
    "preferred_op",
    "stricture",
    "vice",
    "project",
    "ritual",
    "design",
    "location",
    "score"
    /* score */
  ],
  SimpleItemTypes: [
    "background",
    "crew_reputation",
    "feature",
    "heritage",
    "preferred_op",
    "stricture"
    /* stricture */
  ],
  Attribute: [
    "insight",
    "prowess",
    "resolve"
    /* resolve */
  ],
  Action: {
    [
      "insight"
      /* insight */
    ]: [
      "hunt",
      "study",
      "survey",
      "tinker"
      /* tinker */
    ],
    [
      "prowess"
      /* prowess */
    ]: [
      "finesse",
      "prowl",
      "skirmish",
      "wreck"
      /* wreck */
    ],
    [
      "resolve"
      /* resolve */
    ]: [
      "attune",
      "command",
      "consort",
      "sway"
      /* sway */
    ]
  },
  Vices: [
    "Faith",
    "Gambling",
    "Luxury",
    "Obligation",
    "Pleasure",
    "Stupor",
    "Weird",
    "Worship",
    "Living_Essence",
    "Life_Essence",
    "Electroplasmic_Power"
    /* Electroplasmic_Power */
  ]
};
const Randomizers = {
  NPC: {
    heritage: [
      "Akorosi",
      "Akorosi",
      "Akorosi",
      "Akorosi",
      "Akorosi",
      "Akorosi",
      "Dagger Islander",
      "Iruvian",
      "Severosi",
      "Skovlander",
      "Skovlander",
      "Tycherosi"
    ],
    background: [
      "Academic",
      "Academic",
      "Academic",
      "Labor",
      "Labor",
      "Labor",
      "Labor",
      "Law",
      "Law",
      "Law",
      "Military",
      "Military",
      "Military",
      "Military",
      "Military",
      "New Money",
      "New Money",
      "Old Money",
      "Old Money",
      "Politics",
      "Politics",
      "Trade",
      "Trade",
      "Trade",
      "Underworld",
      "Underworld",
      "Underworld",
      "Underworld",
      "Underworld",
      "Weird"
    ],
    gender: [
      "M",
      "M",
      "M",
      "M",
      "F",
      "F",
      "F",
      "U",
      "X"
    ],
    appearance: [
      "Athletic",
      "Beard",
      "Bony",
      "Chiseled",
      "Crippled / Prosthetic",
      "Cute",
      "Dark",
      "Delicate",
      "Disfigured / Maimed",
      "Elegant",
      "Fair",
      "Glasses / Monocle",
      "Handsome",
      "Large",
      "Long Hair",
      "Lovely",
      "Old",
      "Plain",
      "Plump",
      "Rough",
      "Scarred",
      "Sexy",
      "Shaved Bald",
      "Short",
      "Slim",
      "Stooped",
      "Stout",
      "Strange",
      "Striking",
      "Stylish",
      "Tall",
      "Tattooed",
      "Weathered",
      "Wig",
      "Wild",
      "Wiry",
      "Worn",
      "Young"
    ],
    goal: [
      "Achievement",
      "Authority",
      "Change",
      "Chaos / Destruction",
      "Control",
      "Cooperation",
      "Freedom",
      "Happiness",
      "Infamy / Fear",
      "Justice",
      "Knowledge",
      "Love",
      "Pleasure",
      "Power",
      "Prestige / Fame",
      "Respect",
      "Revenge",
      "Wealth"
    ],
    method: [
      "Alchemy",
      "Arcane",
      "Blackmail",
      "Chaos",
      "Commerce",
      "Espionage",
      "Hard Work",
      "Law / Politics",
      "Manipulation",
      "Negotiation",
      "Sabotage",
      "Strategy",
      "Study",
      "Subterfuge",
      "Teamwork",
      "Theft",
      "Threats",
      "Violence"
    ],
    profession: [
      "Advocate",
      "Apiarist",
      "Architect",
      "Artist",
      "Author",
      "Bailiff",
      "Baker",
      "Baker",
      "Baker",
      "Banker",
      "Barber",
      "Barber",
      "Barber",
      "Blacksmith",
      "Blacksmith",
      "Blacksmith",
      "Bounty Hunter",
      "Brewer",
      "Brewer",
      "Brewer",
      "Butcher",
      "Butcher",
      "Butcher",
      "Captain",
      "Carpenter",
      "Carpenter",
      "Carpenter",
      "Cartwright",
      "Cartwright",
      "Cartwright",
      "Chandler",
      "Chandler",
      "Chandler",
      "Clerk",
      "Clerk",
      "Clerk",
      "Clockmaker",
      "Cobbler",
      "Cobbler",
      "Cobbler",
      "Composer",
      "Cooper",
      "Cooper",
      "Cooper",
      "Courtesan",
      "Criminal",
      "Criminal",
      "Criminal",
      "Cultivator",
      "Cultivator",
      "Cultivator",
      "Diplomat",
      "Driver",
      "Driver",
      "Driver",
      "Dyer",
      "Dyer",
      "Dyer",
      "Embroiderer",
      "Embroiderer",
      "Embroiderer",
      "Explorer",
      "Fishmonger",
      "Fishmonger",
      "Fishmonger",
      "Furrier",
      "Glass Blower",
      "Goat Herd",
      "Goat Herd",
      "Goat Herd",
      "Gondolier",
      "Gondolier",
      "Gondolier",
      "Guard",
      "Guard",
      "Guard",
      "Jailer",
      "Jeweler",
      "Journalist",
      "Leatherworker",
      "Leatherworker",
      "Leatherworker",
      "Leech",
      "Locksmith",
      "Magistrate",
      "Mason",
      "Mason",
      "Mason",
      "Merchant",
      "Merchant",
      "Merchant",
      "Messenger",
      "Messenger",
      "Messenger",
      "Musician",
      "Physicker",
      "Plumber",
      "Printer",
      "Rail Jack",
      "Roofer",
      "Roofer",
      "Roofer",
      "Ropemaker",
      "Ropemaker",
      "Ropemaker",
      "Rug Maker",
      "Rug Maker",
      "Rug Maker",
      "Sailor",
      "Sailor",
      "Sailor",
      "Scholar",
      "Scribe",
      "Servant",
      "Servant",
      "Servant",
      "Shipwright",
      "Shipwright",
      "Shipwright",
      "Soldier",
      "Sparkwright",
      "Spirit Warden",
      "Steward",
      "Tailor",
      "Tailor",
      "Tailor",
      "Tanner",
      "Tanner",
      "Tanner",
      "Tax Collector",
      "Tinkerer",
      "Tinkerer",
      "Tinkerer",
      "Treasurer",
      "Vendor",
      "Vendor",
      "Vendor",
      "Weaver",
      "Weaver",
      "Weaver",
      "Whisper",
      "Woodworker",
      "Woodworker",
      "Woodworker"
    ],
    trait: [
      "Arcane",
      "Arrogant",
      "Artistic",
      "Bold",
      "Brash",
      "Brave",
      "Calculating",
      "Calm",
      "Candid",
      "Careless",
      "Cautious",
      "Cavalier",
      "Charming",
      "Cold",
      "Commanding",
      "Compassionate",
      "Confident",
      "Connected",
      "Cooperative",
      "Creative",
      "Cruel",
      "Cultured",
      "Daring",
      "Defiant",
      "Dishonest",
      "Dramatic",
      "Elitist",
      "Enigmatic",
      "Enthusiastic",
      "Erudite",
      "Experienced",
      "Fierce",
      "Flexible",
      "Friendly",
      "Gracious",
      "Greedy",
      "Haunted",
      "Insightful",
      "Kind",
      "Melancholy",
      "Moody",
      "Obsessive",
      "Paranoid",
      "Patient",
      "Popular",
      "Principled",
      "Proud",
      "Quiet",
      "Reckless",
      "Respected",
      "Ruthless",
      "Sadistic",
      "Savage",
      "Secretive",
      "Shrewd",
      "Sincere",
      "Sneaky",
      "Sophisticated",
      "Strange",
      "Stylish",
      "Subtle",
      "Suspicious",
      "Tough",
      "Vain",
      "Vengeful",
      "Vicious",
      "Visionary",
      "Volatile",
      "Weird",
      "Wise"
    ],
    interests: [
      "Alchemy, medicine",
      "Antiques, artifacts, curios",
      "Arcane books, rituals",
      "Architecture, furnishings",
      "Church of Ecstasy",
      "Cooking, gardening",
      "Craft (leatherwork, etc.)",
      "Demon lore, legends",
      "Drugs, essences, tobacco",
      "Essences, alchemy",
      "Exploration, adventure",
      "Fine arts, opera, theater",
      "Fine clothes, jewelry, furs",
      "Fine food, restaurants",
      "Fine whiskey, wine, beer",
      "Forgotten gods",
      "Gadgets, new technology",
      "Gambling, cards, dice",
      "History, legends",
      "Horses, riding",
      "Hunting, shooting",
      "Lovers, romance, trysts",
      "Music, instruments, dance",
      "Natural philosophy",
      "Painting, drawing, sculpture",
      "Parties, social events",
      "Path of Echoes",
      "Pets (birds, dogs, cats)",
      "Pit-fighting, duels",
      "Poetry, novels, writing",
      "Politics, journalism",
      "Pre-cataclysm legends",
      "Ships, boating",
      "Spectrology, electroplasm",
      "Weapons collector",
      "Weeping Lady, charity"
    ],
    quirk: [
      "A fraud. Some important aspect is fabricated.",
      "Bigoted against culture / belief / social class.",
      "Black sheep / outcast from family or organization.",
      "Blind to flaws in friends, allies, family, etc.",
      "Celebrity. Popularized in print / song / theater.",
      "Concerned with appearances, gossip, peers.",
      "Cursed, haunted, harassed by spirits or demon.",
      "Deeply traditional. Opposed to new ideas.",
      "Devoted to their family.",
      "Drug / alcohol abuser. Often impaired by their vice.",
      "Extensive education on every scholarly subject.",
      "Has chronic illness that requires frequent care.",
      "Holds their position due to blackmail.",
      "Holds their position to spy for another faction.",
      "In prison or under noble's house arrest.",
      "Inherited their position. May not deserve / want it.",
      "Intense, unreasonable phobia or loathing.",
      "Involved with war crimes from the Unity War.",
      "Is blindly faithful to an ideal, group, or tradition.",
      "Keeps detailed journals, notes, records, ledgers.",
      "Leads a double life using cover identity.",
      "Married into important / powerful family.",
      "Massive debts (to banks / criminals / family)",
      "Once hollowed, then restored. Immune to spirits.",
      "Proud of heritage, traditions, native language.",
      "Reclusive. Prefers to interact via messengers.",
      "Relies on council to make decisions.",
      "Revolutionary. Plots against the Imperium.",
      "Scandalous reputation (deserved or not).",
      "Secretly (openly?) controlled by possessing spirit.",
      "Serves a demon's agenda (knowingly or not).",
      "Spotless reputation. Highly regarded.",
      "Superstitious. Believes in signs, magic numbers.",
      "Surrounded by sycophants, supplicants, toadies.",
      "Visionary. Holds radical views for future.",
      "Well-traveled. Connections outside Doskvol."
    ],
    style: {
      male: [
        "Apron",
        "Cane",
        "Collared Shirt",
        "Crutches",
        "Eelskin Bodysuit",
        "Face Mask",
        "Fitted Leggings",
        "Heavy Cloak",
        "Heavy Gloves",
        "Hide & Furs",
        "Hood & Veil",
        "Hooded Coat",
        "Knit Cap",
        "Leathers",
        "Long Coat",
        "Long Scarf",
        "Loose Silks",
        "Mask & Robes",
        "Rough Tunic",
        "Sharp Trousers",
        "Short Cloak",
        "Slim Jacket",
        "Soft Boots",
        "Suit & Vest",
        "Suspenders",
        "Tall Boots",
        "Tatters",
        "Thick Greatcoat",
        "Tool Belt",
        "Tricorn Hat",
        "Uniform",
        "Waxed Coat",
        "Wheelchair",
        "Wide Belt",
        "Work Boots"
      ],
      female: [
        "Apron",
        "Cane",
        "Crutches",
        "Eelskin Bodysuit",
        "Face Mask",
        "Fitted Dress",
        "Fitted Leggings",
        "Heavy Cloak",
        "Heavy Gloves",
        "Hide & Furs",
        "Hood & Veil",
        "Hooded Coat",
        "Knit Cap",
        "Leathers",
        "Long Coat",
        "Long Scarf",
        "Loose Silks",
        "Mask & Robes",
        "Rough Tunic",
        "Sharp Trousers",
        "Short Cloak",
        "Skirt & Blouse",
        "Slim Jacket",
        "Soft Boots",
        "Suspenders",
        "Tall Boots",
        "Tatters",
        "Thick Greatcoat",
        "Tool Belt",
        "Uniform",
        "Waxed Coat",
        "Wheelchair",
        "Wide Belt",
        "Work Boots"
      ]
    },
    name_title: [
      "Adept",
      "Archivist",
      "Captain",
      "Charter",
      "Scrivener"
    ],
    name_first: {
      male: [
        "Abel",
        "Abenthy",
        "Adric",
        "Airic",
        "Alabaster",
        "Alastair",
        "Aldo",
        "Alen",
        "Aleph",
        "Ambrose",
        "Amosen",
        "Andal",
        "Andrel",
        "Anton",
        "Aquilla",
        "Aradan",
        "Aram",
        "Archibald",
        "Archie",
        "Arden",
        "Arliden",
        "Arlyn",
        "Armand",
        "Arquo",
        "Arrell",
        "Arvus",
        "Asher",
        "Aurelio",
        "Benedict",
        "Bolster",
        "Brace",
        "Bran",
        "Brance",
        "Branon",
        "Bricks",
        "Brock",
        "Brutus",
        "Caius",
        "Carro",
        "Casian",
        "Cato",
        "Cavelle",
        "Cedric",
        "Chance",
        "Chauncey",
        "Cid",
        "Clave",
        "Cliff",
        "Cornelius",
        "Cross",
        "Crowl",
        "Cym",
        "Cyrus",
        "Declan",
        "Del",
        "Drav",
        "Drazhan",
        "Drem",
        "Edlun",
        "Edmund",
        "Edrom",
        "Edwin",
        "Elan",
        "Elend",
        "Elias",
        "Elodin",
        "Ephrim",
        "Erasmus",
        "Eremon",
        "Ethan",
        "Everitt",
        "Feldspar",
        "Fero",
        "Finn",
        "Fisher",
        "Galen",
        "Gallahad",
        "Garner",
        "Gilbert",
        "Glint",
        "Gnik",
        "Gregalos",
        "Grey",
        "Greyson",
        "Grifter",
        "Grine",
        "Gristofer",
        "Hadrian",
        "Hagran",
        "Hammond",
        "Hix",
        "Holtz",
        "Hugo",
        "Iden",
        "Irton",
        "Isaac",
        "Ivellios",
        "Jabari",
        "Jericho",
        "Jerod",
        "Kazimir",
        "Kellan",
        "Kelvyn",
        "Kelyr",
        "Khafra",
        "Kobb",
        "Kristov",
        "Kyrilu",
        "Lael",
        "Lafayette",
        "Laudius",
        "Lawrence",
        "Leif",
        "Lem",
        "Lenny",
        "Logan",
        "Lucas",
        "Lucius",
        "Lysander",
        "Milos",
        "Mord",
        "Morketh",
        "Morlan",
        "Myre",
        "Narcus",
        "Nehi",
        "Noggs",
        "Norton",
        "Obel",
        "Obelas",
        "Octavius",
        "Odelay",
        "Orem",
        "Orlan",
        "Orth",
        "Orton",
        "Pavel",
        "Perceval",
        "Percival",
        "Peregrine",
        "Phin",
        "Phineas",
        "Porto",
        "Preston",
        "Primo",
        "Quess",
        "Quill",
        "Rafe",
        "Rasmus",
        "Raul",
        "Resh",
        "Rias",
        "Ring",
        "Rivallo",
        "Rodmund",
        "Roethe",
        "Roose",
        "Roric",
        "Sethla",
        "Silas",
        "Sindri",
        "Snitch",
        "Sol",
        "Solomon",
        "Sprig",
        "Stavrul",
        "Stellan",
        "Stev",
        "Sym",
        "Tacitus",
        "Tarn",
        "Taylor",
        "Thackeray",
        "Thaddeus",
        "Thane",
        "Thelian",
        "Theo",
        "Theron",
        "Thurston",
        "Timoth",
        "Tisk",
        "Tocker",
        "Tristero",
        "Ulric",
        "Vask",
        "Veleris",
        "Ventaro",
        "Virgil",
        "Vond",
        "Wax",
        "Wayne",
        "Weaver",
        "Wester",
        "Winsley"
      ],
      female: [
        "Adaire",
        "Adelaide",
        "Adella",
        "Adroit",
        "Ailen",
        "Aina",
        "Akilah",
        "Albinia",
        "Althaea",
        "Alyosha",
        "Ansa",
        "Arabella",
        "Arwyl",
        "Ashlyn",
        "Avora",
        "Brena",
        "Brenna",
        "Calienthe",
        "Camilla",
        "Candor",
        "Candra",
        "Carissa",
        "Cascabel",
        "Casslyn",
        "Castille",
        "Celeste",
        "Chen",
        "Claret",
        "Clementine",
        "Constance",
        "Cordelia",
        "Corille",
        "Corsica",
        "Cyrene",
        "Dahlia",
        "Daphnia",
        "Delia",
        "Dena",
        "Denna",
        "Desmona",
        "Dolores",
        "Drenna",
        "Edie",
        "Eira",
        "Elsie",
        "Emeline",
        "Etta",
        "Fela",
        "Felicity",
        "Galenica",
        "Galina",
        "Gitta",
        "Gloria",
        "Gwen",
        "Hedy",
        "Hella",
        "Helles",
        "Henrietta",
        "Iduna",
        "Iona",
        "Isa",
        "Isabella",
        "Iskra",
        "Isolde",
        "Jasna",
        "Jaxi",
        "Joan",
        "Juno",
        "Kamelin",
        "Kari",
        "Koli",
        "Lauria",
        "Lenia",
        "Leona",
        "Leyva",
        "Lieu",
        "Lilith",
        "Lin",
        "Lizete",
        "Lorette",
        "Lucella",
        "Lynthia",
        "Lyra",
        "Maia",
        "Maiathah",
        "Maie",
        "Mara",
        "Marasi",
        "Marielda",
        "Marisol",
        "Marris",
        "Mira",
        "Naria",
        "Nasha",
        "Octavia",
        "Odrienne",
        "Olivia",
        "Ora",
        "Ordenna",
        "Oressia",
        "Orsella",
        "Pardenna",
        "Penelope",
        "Penny",
        "Phoebe",
        "Polonia",
        "Pravda",
        "Prudence",
        "Quelenna",
        "Raisa",
        "Redji",
        "Remira",
        "Rey",
        "Riven",
        "Runa",
        "Sabina",
        "Sabinia",
        "Sabrina",
        "Sadeh",
        "Sahar",
        "Selma",
        "Sesereth",
        "Severea",
        "Silaqui",
        "Skannon",
        "Sprig",
        "Stabitha",
        "Syra",
        "Tabitha",
        "Talitha",
        "Tamsyn",
        "Tasi",
        "Terra",
        "Tesslyn",
        "Thava",
        "Thena",
        "Tiff",
        "Una",
        "Vaurin",
        "Veretta",
        "Vesna",
        "Vestine",
        "Vey",
        "Victoria",
        "Vin",
        "Vita",
        "Volette",
        "Vorka",
        "Wander",
        "Ylva",
        "Zahra",
        "Zaida",
        "Zamira",
        "Zarya"
      ]
    },
    name_surname: [
      "Abberwick",
      "Adelbury",
      "Adleton",
      "Aloro",
      "Alsa",
      "Ankhayat",
      "Arran",
      "Ashton",
      "Ashweather",
      "Athanoch",
      "Axelrod",
      "Backworth",
      "Barrow",
      "Basran",
      "Black",
      "Blackford",
      "Blackpool",
      "Blackthorne",
      "Bluff",
      "Boden",
      "Booker",
      "Boulder",
      "Bowman",
      "Braeside",
      "Bramble",
      "Braum",
      "Bray",
      "Breakiron",
      "Bristle",
      "Brocken",
      "Brogan",
      "Bromley",
      "Burnsides",
      "Caebrek",
      "Cartwright",
      "Carver",
      "Childermass",
      "Claw",
      "Clelland",
      "Clemont",
      "Clermont",
      "Cobblecarver",
      "Coleburn",
      "Combe",
      "Comber",
      "Crofty",
      "Cunningham",
      "Daava",
      "Dal",
      "Dalmore",
      "Danfield",
      "Drawlight",
      "Drigg",
      "Dunvil",
      "Elmore",
      "Eveningeyes",
      "Evensteps",
      "Eventide",
      "Everpenny",
      "Fairplay",
      "Farros",
      "Fellwater",
      "Fogg",
      "Gatcombe",
      "Glasseye",
      "Goldsworth",
      "Grave",
      "Graythwaite",
      "Greysteel",
      "Grine",
      "Haig",
      "Half-Off",
      "Havelton",
      "Havenhorst",
      "Hectares",
      "Helker",
      "Helles",
      "Hellyers",
      "Hemme",
      "Hightower",
      "Hightown",
      "Highwater",
      "Hill",
      "Hitchcock",
      "Innerwick",
      "Jayan",
      "Jeduin",
      "Kardera",
      "Karstas",
      "Keel",
      "Kempt",
      "Kessarin",
      "Kinclaith",
      "King",
      "Lake",
      "Larriston",
      "Leake",
      "Lomond",
      "Longstaff",
      "Lorewood",
      "Maroden",
      "Mayson",
      "Merriweather",
      "Michter",
      "Mindwell",
      "Morcombe",
      "Morriston",
      "Mortimer",
      "Netherton",
      "Night",
      "Nighteyre",
      "Nightly",
      "Noctoft",
      "Notherhome",
      "Orchard",
      "Orchid",
      "Path",
      "Peak",
      "Pegg",
      "Penderyn",
      "Pond",
      "Pool",
      "Prichard",
      "Raines",
      "Ravenglass",
      "Ravenwood",
      "Reigns",
      "Reyes",
      "Reynes",
      "Rhodes",
      "Riverford",
      "Robel",
      "Rowan",
      "Sable",
      "Sage",
      "Salkara",
      "Salos",
      "Sevoy",
      "Shilbottle",
      "Shillmoor",
      "Shook",
      "Skelkallan",
      "Skora",
      "Slane",
      "Song",
      "Steadystep",
      "Stoutale",
      "Stovestoker",
      "Strange",
      "Strangford",
      "Strathmill",
      "Sunder",
      "Sunderland",
      "Swiftwhistle",
      "Tailor",
      "Tallfellow",
      "Templeton",
      "Tenpenny",
      "Tevilton",
      "Thistle",
      "Thrysus",
      "Thurston",
      "Tinmouth",
      "Tower",
      "Tristé",
      "Tyrconnell",
      "Vale",
      "Valentine",
      "Veldaire",
      "Venture",
      "Walund",
      "Warren",
      "Waters",
      "Wecker",
      "Welker",
      "Wend",
      "Wharver",
      "Whythe",
      "Woodall"
    ],
    name_alias: [
      "Bell",
      "Birch",
      "Bird",
      "Bliss",
      "Bricks",
      "Bug",
      "Chime",
      "Coil",
      "Cricket",
      "Cross",
      "Crow",
      "Echo",
      "Flint",
      "Frog",
      "Frost",
      "Goods",
      "Grip",
      "Gunner",
      "Hammer",
      "Hook",
      "Ink",
      "Junker",
      "Mist",
      "Moon",
      "Nail",
      "Needle",
      "Ogre",
      "Pool",
      "Ring",
      "Ruby",
      "Silver",
      "Skinner",
      "Song",
      "Spur",
      "Tackle",
      "Thistle",
      "Thorn",
      "Tick",
      "Tick-Tock",
      "Tock",
      "Trick",
      "Twelves",
      "Vixen",
      "Whip",
      "Wicker"
    ],
    name_suffix: [
      "Jr.",
      "Sr.",
      "III",
      "IV"
    ]
  },
  GM: {
    Bargains: [
      { name: "Infected Wound", category: "Character Effect", effect: "The next time you Recover from Harm, your Physicker is at -1d." },
      { name: "Infected Wound", category: "Character Effect", effect: "The next time you Recover from Harm, your Physicker is at -1d." },
      { name: "Infected Wound", category: "Character Effect", effect: "The next time you Recover from Harm, your Physicker is at -1d." },
      { name: "It's Mine Now", category: "Character Effect", effect: "You discover a small item that belongs to a rival. What is it? Who used to own it? How does this change things for you?" },
      { name: "It's Mine Now", category: "Character Effect", effect: "You discover a small item that belongs to a rival. What is it? Who used to own it? How does this change things for you?" },
      { name: "It's Mine Now", category: "Character Effect", effect: "You discover a small item that belongs to a rival. What is it? Who used to own it? How does this change things for you?" },
      { name: "Mine By Blood", category: "Character Effect", effect: "You discover evidence of the death of a family member during the Score. Who is it? How did they die? How does this change things for your character?" },
      { name: "Mine By Blood", category: "Character Effect", effect: "You discover evidence of the death of a family member during the Score. Who is it? How did they die? How does this change things for your character?" },
      { name: "Mine By Blood", category: "Character Effect", effect: "You discover evidence of the death of a family member during the Score. Who is it? How did they die? How does this change things for your character?" },
      { name: "Mine By Name", category: "Character Effect", effect: "You discover an envelope addressed to you during the Score. What is in it? Who left it here for you to find? How does this change things for your character?" },
      { name: "Mine By Name", category: "Character Effect", effect: "You discover an envelope addressed to you during the Score. What is in it? Who left it here for you to find? How does this change things for your character?" },
      { name: "Mine By Name", category: "Character Effect", effect: "You discover an envelope addressed to you during the Score. What is in it? Who left it here for you to find? How does this change things for your character?" },
      { name: "Mine By Rights", category: "Character Effect", effect: "You discover a small item from your past during the Score. What is it? What does it mean that it's here? Does this change things for your character?" },
      { name: "Mine By Rights", category: "Character Effect", effect: "You discover a small item from your past during the Score. What is it? What does it mean that it's here? Does this change things for your character?" },
      { name: "Mine By Rights", category: "Character Effect", effect: "You discover a small item from your past during the Score. What is it? What does it mean that it's here? Does this change things for your character?" },
      { name: "Not Paying Attention", category: "Character Effect", effect: "Uncheck one of the XP triggers already marked for your character for this Score." },
      { name: "Not Paying Attention", category: "Character Effect", effect: "Uncheck one of the XP triggers already marked for your character for this Score." },
      { name: "Shadow From the Past", category: "Character Effect", effect: "Your intel missed that someone from your past is associated with the target of the Score. Who is it, and how does that change things for you?" },
      { name: "Shadow From the Past", category: "Character Effect", effect: "Your intel missed that someone from your past is associated with the target of the Score. Who is it, and how does that change things for you?" },
      { name: "Shadow From the Past", category: "Character Effect", effect: "Your intel missed that someone from your past is associated with the target of the Score. Who is it, and how does that change things for you?" },
      { name: "Thicker than Blood", category: "Character Effect", effect: "Your intel missed that one of your family members is associated with the target of the Score. How does that change things for you?" },
      { name: "Thicker than Blood", category: "Character Effect", effect: "Your intel missed that one of your family members is associated with the target of the Score. How does that change things for you?" },
      { name: "Thicker than Blood", category: "Character Effect", effect: "Your intel missed that one of your family members is associated with the target of the Score. How does that change things for you?" },
      { name: "Why'd It Have To Be...", category: "Character Effect", effect: "The room you're in triggers a phobia that the Crew didn't know about before. Describe the phobia and take 2 Stress." },
      { name: "Why'd It Have To Be...", category: "Character Effect", effect: "The room you're in triggers a phobia that the Crew didn't know about before. Describe the phobia and take 2 Stress." },
      { name: "Why'd It Have To Be...", category: "Character Effect", effect: "The room you're in triggers a phobia that the Crew didn't know about before. Describe the phobia and take 2 Stress." },
      { name: "Demonic Guest", category: "Crew Effect", effect: "A demonic presence has appeared in your Lair and will need to be dealt with during Free Play." },
      { name: "Demonic Guest", category: "Crew Effect", effect: "A demonic presence has appeared in your Lair and will need to be dealt with during Free Play." },
      { name: "Fracturing Faction", category: "Crew Effect", effect: "If your Hold is Strong, reduce it to Weak. If your Hold is Weak, reduce your Rep to zero." },
      { name: "Lesson Not Learned", category: "Crew Effect", effect: "Uncheck one of the XP triggers already marked for your crew for this Score." },
      { name: "Lesson Not Learned", category: "Crew Effect", effect: "Uncheck one of the XP triggers already marked for your crew for this Score." },
      { name: "Otherworldly Guest", category: "Crew Effect", effect: "A scion of one of the Old Gods has appeared in your Lair and will need to be dealt with during Free Play." },
      { name: "Otherworldly Guest", category: "Crew Effect", effect: "A scion of one of the Old Gods has appeared in your Lair and will need to be dealt with during Free Play." },
      { name: "Rebellious Faction", category: "Crew Effect", effect: "A new crew has taken possession of one of your Claims, and will have to be dealt with in Free Play." },
      { name: "Spectral Guest", category: "Crew Effect", effect: "A ghostly presence has appeared in your Lair and will need to be dealt with during Free Play." },
      { name: "Spectral Guest", category: "Crew Effect", effect: "A ghostly presence has appeared in your Lair and will need to be dealt with during Free Play." },
      { name: "Turncoat", category: "Crew Effect", effect: "One of your Cohorts leaves your crew and joins a rival." },
      { name: "Double-Crossed", category: "Downtime Effect", effect: "After the normal Entanglement roll and result, your Crew takes an additional Flipped result." },
      { name: "Double-Crossed", category: "Downtime Effect", effect: "After the normal Entanglement roll and result, your Crew takes an additional Flipped result." },
      { name: "Double-Crossed", category: "Downtime Effect", effect: "After the normal Entanglement roll and result, your Crew takes an additional Flipped result." },
      { name: "Easily Identified", category: "Downtime Effect", effect: "You left something behind that is easily traced to you. Choose either +2 Heat and −2 Rep, or +1 Heat and −1 Rep." },
      { name: "Easily Identified", category: "Downtime Effect", effect: "You left something behind that is easily traced to you. Choose either +2 Heat and −2 Rep, or +1 Heat and −1 Rep." },
      { name: "Easily Identified", category: "Downtime Effect", effect: "You left something behind that is easily traced to you. Choose either +2 Heat and −2 Rep, or +1 Heat and −1 Rep." },
      { name: "High Profile", category: "Downtime Effect", effect: "This Score gains +2 Heat." },
      { name: "High Profile", category: "Downtime Effect", effect: "This Score gains +2 Heat." },
      { name: "High Profile", category: "Downtime Effect", effect: "This Score gains +2 Heat." },
      { name: "Most Wanted", category: "Downtime Effect", effect: "After the normal Entanglement roll and result, you are the target of an additional Arrest result." },
      { name: "Most Wanted", category: "Downtime Effect", effect: "After the normal Entanglement roll and result, you are the target of an additional Arrest result." },
      { name: "Project Setback", category: "Downtime Effect", effect: "Mark one less Clock segment the first time you work on a Long-Term Project." },
      { name: "Project Setback", category: "Downtime Effect", effect: "Mark one less Clock segment the first time you work on a Long-Term Project." },
      { name: "Project Setback", category: "Downtime Effect", effect: "Mark one less Clock segment the first time you work on a Long-Term Project." },
      { name: "Quelle Horreur!", category: "Downtime Effect", effect: "You suffer nightmares for a week. −1d to all Downtime Actions after this Score." },
      { name: "Quelle Horreur!", category: "Downtime Effect", effect: "You suffer nightmares for a week. −1d to all Downtime Actions after this Score." },
      { name: "Shortchanged", category: "Downtime Effect", effect: "This Score's payoff is −2 Coin." },
      { name: "Shortchanged", category: "Downtime Effect", effect: "This Score's payoff is −2 Coin." },
      { name: "Shortchanged", category: "Downtime Effect", effect: "This Score's payoff is −2 Coin." },
      { name: "Supply Challenges", category: "Downtime Effect", effect: "The next time you pay Coin for an Acquire Asset roll, you must pay 3 instead of 2 Coin per Tier." },
      { name: "Supply Challenges", category: "Downtime Effect", effect: "The next time you pay Coin for an Acquire Asset roll, you must pay 3 instead of 2 Coin per Tier." },
      { name: "Supply Delays", category: "Downtime Effect", effect: "Suffer -1d to your next Acquire Asset roll." },
      { name: "Supply Delays", category: "Downtime Effect", effect: "Suffer -1d to your next Acquire Asset roll." },
      { name: "Supply Delays", category: "Downtime Effect", effect: "Suffer -1d to your next Acquire Asset roll." },
      { name: "Tastes Like Ashes", category: "Downtime Effect", effect: "The next time you indulge your Vice, only clear half as much Stress (rounded down) as normal." },
      { name: "Tastes Like Ashes", category: "Downtime Effect", effect: "The next time you indulge your Vice, only clear half as much Stress (rounded down) as normal." },
      { name: "Thrice-Named", category: "Downtime Effect", effect: "After the normal Entanglement roll and result, your Crew takes an additional Demonic Notice result." },
      { name: "Thrice-Named", category: "Downtime Effect", effect: "After the normal Entanglement roll and result, your Crew takes an additional Demonic Notice result." },
      { name: "Thrice-Named", category: "Downtime Effect", effect: "After the normal Entanglement roll and result, your Crew takes an additional Demonic Notice result." },
      { name: "Warden's Attention", category: "Downtime Effect", effect: "+4 Heat (instead of the normal +2 Heat) if there is a death during this Score." },
      { name: "Warden's Attention", category: "Downtime Effect", effect: "+4 Heat (instead of the normal +2 Heat) if there is a death during this Score." },
      { name: "We Want a Bigger Take!", category: "Downtime Effect", effect: "The gang wants a bigger piece of the action. −2 Coin to Payoff for each Cohort used in this Score." },
      { name: "We Want a Bigger Take!", category: "Downtime Effect", effect: "The gang wants a bigger piece of the action. −2 Coin to Payoff for each Cohort used in this Score." },
      { name: "Weekend Getaway", category: "Downtime Effect", effect: "If you indulge your Vice after this Score, you automatically overindulge." },
      { name: "Weekend Getaway", category: "Downtime Effect", effect: "If you indulge your Vice after this Score, you automatically overindulge." },
      { name: "Weekend Getaway", category: "Downtime Effect", effect: "If you indulge your Vice after this Score, you automatically overindulge." },
      { name: "What's Our Take?", category: "Downtime Effect", effect: "The gang wants a bigger piece of the action. −1 Coin to Payoff for each Cohort used in this Score." },
      { name: "What's Our Take?", category: "Downtime Effect", effect: "The gang wants a bigger piece of the action. −1 Coin to Payoff for each Cohort used in this Score." },
      { name: "What's Our Take?", category: "Downtime Effect", effect: "The gang wants a bigger piece of the action. −1 Coin to Payoff for each Cohort used in this Score." },
      { name: "Accelerating Plans", category: "Faction Relationship Effect", effect: "A rival faction advances one of its Clocks by two before your next Score." },
      { name: "Accelerating Plans", category: "Faction Relationship Effect", effect: "A rival faction advances one of its Clocks by two before your next Score." },
      { name: "Accelerating Plans", category: "Faction Relationship Effect", effect: "A rival faction advances one of its Clocks by two before your next Score." },
      { name: "Escalating Tensions", category: "Faction Relationship Effect", effect: "A faction of your choice that is unfriendly to your crew moves one step towards War." },
      { name: "Escalating Tensions", category: "Faction Relationship Effect", effect: "A faction of your choice that is unfriendly to your crew moves one step towards War." },
      { name: "Forgiveness or Vengeance?", category: "Faction Relationship Effect", effect: "During the Score, one of your Cohorts got in a fight with an neutral Cohort. Choose −2 Rep and +1 faction relationship, or +2 Rep and −1 faction relationship." },
      { name: "Forgiveness or Vengeance?", category: "Faction Relationship Effect", effect: "During the Score, one of your Cohorts got in a fight with an neutral Cohort. Choose −2 Rep and +1 faction relationship, or +2 Rep and −1 faction relationship." },
      { name: "Forgiveness or Vengeance?", category: "Faction Relationship Effect", effect: "During the Score, one of your Cohorts got in a fight with an neutral Cohort. Choose −2 Rep and +1 faction relationship, or +2 Rep and −1 faction relationship." },
      { name: "Hot-Headed Cohort", category: "Faction Relationship Effect", effect: "During the Score, one of your Cohorts picked a fight with an allied Cohort. Pay 2 Coin, lose 2 Rep, or −1 faction relationship." },
      { name: "Hot-Headed Cohort", category: "Faction Relationship Effect", effect: "During the Score, one of your Cohorts picked a fight with an allied Cohort. Pay 2 Coin, lose 2 Rep, or −1 faction relationship." },
      { name: "Hot-Headed Cohort", category: "Faction Relationship Effect", effect: "During the Score, one of your Cohorts picked a fight with an allied Cohort. Pay 2 Coin, lose 2 Rep, or −1 faction relationship." },
      { name: "Mixed Messages", category: "Faction Relationship Effect", effect: "A faction of your choice that is friendly to your crew moves one step towards Neutral." },
      { name: "Mixed Messages", category: "Faction Relationship Effect", effect: "A faction of your choice that is friendly to your crew moves one step towards Neutral." },
      { name: "Mutual Defense", category: "Faction Relationship Effect", effect: "A friendly Faction goes to War with a neutral Faction. Either join their War, or they move to −1 on the relationship chart." },
      { name: "Mutual Defense", category: "Faction Relationship Effect", effect: "A friendly Faction goes to War with a neutral Faction. Either join their War, or they move to −1 on the relationship chart." },
      { name: "Tensions Spread", category: "Faction Relationship Effect", effect: "One Neutral Faction moves a step towards War, and another Neutral Faction moves a step towards Ally." },
      { name: "Tensions Spread", category: "Faction Relationship Effect", effect: "One Neutral Faction moves a step towards War, and another Neutral Faction moves a step towards Ally." },
      { name: "Tensions Spread", category: "Faction Relationship Effect", effect: "One Neutral Faction moves a step towards War, and another Neutral Faction moves a step towards Ally." },
      { name: "The Walls Have Ears", category: "Faction Relationship Effect", effect: "A friendly faction hears you did a Score against their ally. −1 to that faction's relationship rating." },
      { name: "The Walls Have Ears", category: "Faction Relationship Effect", effect: "A friendly faction hears you did a Score against their ally. −1 to that faction's relationship rating." },
      { name: "The Walls Have Ears", category: "Faction Relationship Effect", effect: "A friendly faction hears you did a Score against their ally. −1 to that faction's relationship rating." },
      { name: "The Walls Have Eyes", category: "Faction Relationship Effect", effect: "A friendly faction hears you did a Score against their ally. −1 to both factions' relationship ratings." },
      { name: "The Walls Have Eyes", category: "Faction Relationship Effect", effect: "A friendly faction hears you did a Score against their ally. −1 to both factions' relationship ratings." },
      { name: "...and Into the Fire", category: "Immediate Effect", effect: "You are ambushed by an assassin or bounty hunter. Start a 4-Clock, 'Elite Ambusher' to overcome this new foe." },
      { name: "...and Into the Fire", category: "Immediate Effect", effect: "You are ambushed by an assassin or bounty hunter. Start a 4-Clock, 'Elite Ambusher' to overcome this new foe." },
      { name: "A Familiar Face", category: "Immediate Effect", effect: "You recognize a contact of your choice among the rivals you are running the Score against." },
      { name: "A Familiar Face", category: "Immediate Effect", effect: "You recognize a contact of your choice among the rivals you are running the Score against." },
      { name: "A Familiar Face", category: "Immediate Effect", effect: "You recognize a contact of your choice among the rivals you are running the Score against." },
      { name: "Accidental Discharge", category: "Immediate Effect", effect: "A weapon or item you are carrying loudly discharges and needs to be reloaded before it can be used." },
      { name: "Accidental Discharge", category: "Immediate Effect", effect: "A weapon or item you are carrying loudly discharges and needs to be reloaded before it can be used." },
      { name: "Accidental Discharge", category: "Immediate Effect", effect: "A weapon or item you are carrying loudly discharges and needs to be reloaded before it can be used." },
      { name: "All or Nothing", category: "Immediate Effect", effect: "If you fail this roll, you cannot resist the effects of that failure." },
      { name: "All or Nothing", category: "Immediate Effect", effect: "If you fail this roll, you cannot resist the effects of that failure." },
      { name: "All or Nothing", category: "Immediate Effect", effect: "If you fail this roll, you cannot resist the effects of that failure." },
      { name: "Bishop's Gambit", category: "Immediate Effect", effect: "If you are not in combat, gain +2d for this roll instead of the standard +1d; but you can roll no more than 1d for your next Action." },
      { name: "Bishop's Gambit", category: "Immediate Effect", effect: "If you are not in combat, gain +2d for this roll instead of the standard +1d; but you can roll no more than 1d for your next Action." },
      { name: "Bishop's Gambit", category: "Immediate Effect", effect: "If you are not in combat, gain +2d for this roll instead of the standard +1d; but you can roll no more than 1d for your next Action." },
      { name: "Brute Force Method", category: "Immediate Effect", effect: "You noisily break a weapon of your choice while attempting this Action, even if it is not a combat Action." },
      { name: "Brute Force Method", category: "Immediate Effect", effect: "You noisily break a weapon of your choice while attempting this Action, even if it is not a combat Action." },
      { name: "Brute Force Method", category: "Immediate Effect", effect: "You noisily break a weapon of your choice while attempting this Action, even if it is not a combat Action." },
      { name: "Clear the Board", category: "Immediate Effect", effect: "If you succeed at this roll, clear or fill a Score Clock of your choice. If you fail the roll, you Trauma out of the scene." },
      { name: "Clear the Board", category: "Immediate Effect", effect: "If you succeed at this roll, clear or fill a Score Clock of your choice. If you fail the roll, you Trauma out of the scene." },
      { name: "Devil's Exchange", category: "Immediate Effect", effect: "You gain the normal +1d to this roll, but suffer −1d to your next Action, and cannot take a Devil's Bargain to offset it." },
      { name: "Devil's Exchange", category: "Immediate Effect", effect: "You gain the normal +1d to this roll, but suffer −1d to your next Action, and cannot take a Devil's Bargain to offset it." },
      { name: "Devil's Exchange", category: "Immediate Effect", effect: "You gain the normal +1d to this roll, but suffer −1d to your next Action, and cannot take a Devil's Bargain to offset it." },
      { name: "Ghostly Attention", category: "Immediate Effect", effect: "Whether you succeed in this roll or not, a ghost in the area notices you and begins stalking you." },
      { name: "Ghostly Attention", category: "Immediate Effect", effect: "Whether you succeed in this roll or not, a ghost in the area notices you and begins stalking you." },
      { name: "Ghostly Attention", category: "Immediate Effect", effect: "Whether you succeed in this roll or not, a ghost in the area notices you and begins stalking you." },
      { name: "Gimcrack Gear", category: "Immediate Effect", effect: "Whatever weapon or tool you are using is cheaply made and breaks whether the roll succeeds or not." },
      { name: "Gimcrack Gear", category: "Immediate Effect", effect: "Whatever weapon or tool you are using is cheaply made and breaks whether the roll succeeds or not." },
      { name: "Gimcrack Gear", category: "Immediate Effect", effect: "Whatever weapon or tool you are using is cheaply made and breaks whether the roll succeeds or not." },
      { name: "Gone Rogue", category: "Immediate Effect", effect: "You cannot accept an Assist for the rest of this Score." },
      { name: "Gone Rogue", category: "Immediate Effect", effect: "You cannot accept an Assist for the rest of this Score." },
      { name: "Hunter Becomes Hunted", category: "Immediate Effect", effect: "You've been so preoccupied with the obstacles in front of you that you didn't notice the rival lining up a shot behind you." },
      { name: "Hunter Becomes Hunted", category: "Immediate Effect", effect: "You've been so preoccupied with the obstacles in front of you that you didn't notice the rival lining up a shot behind you." },
      { name: "Hunter Becomes Hunted", category: "Immediate Effect", effect: "You've been so preoccupied with the obstacles in front of you that you didn't notice the rival lining up a shot behind you." },
      { name: "I Know I Packed It!", category: "Immediate Effect", effect: "You must immediately check off 1 Load to no effect, representing equipment you've misplaced." },
      { name: "I Know I Packed It!", category: "Immediate Effect", effect: "You must immediately check off 1 Load to no effect, representing equipment you've misplaced." },
      { name: "I Know I Packed It!", category: "Immediate Effect", effect: "You must immediately check off 1 Load to no effect, representing equipment you've misplaced." },
      { name: "I Know I Packed Them!", category: "Immediate Effect", effect: "You must immediately check off 2 Load to no effect, representing equipment you've misplaced." },
      { name: "I Know I Packed Them!", category: "Immediate Effect", effect: "You must immediately check off 2 Load to no effect, representing equipment you've misplaced." },
      { name: "I Know I Packed Them!", category: "Immediate Effect", effect: "You must immediately check off 2 Load to no effect, representing equipment you've misplaced." },
      { name: "Jangled Nerves", category: "Immediate Effect", effect: "For the rest of the Score, all rolls to Resist generate +1 Stress." },
      { name: "Jangled Nerves", category: "Immediate Effect", effect: "For the rest of the Score, all rolls to Resist generate +1 Stress." },
      { name: "Jangled Nerves", category: "Immediate Effect", effect: "For the rest of the Score, all rolls to Resist generate +1 Stress." },
      { name: "Just a Little Spark", category: "Immediate Effect", effect: "A lamp or candle gets knocked over, catching a curtain or rug on fire. Start a Clock: 'Building is on Fire'." },
      { name: "Just a Little Spark", category: "Immediate Effect", effect: "A lamp or candle gets knocked over, catching a curtain or rug on fire. Start a Clock: 'Building is on Fire'." },
      { name: "Just a Little Spark", category: "Immediate Effect", effect: "A lamp or candle gets knocked over, catching a curtain or rug on fire. Start a Clock: 'Building is on Fire'." },
      { name: "King's Gambit", category: "Immediate Effect", effect: "If you fail at this roll, you are immune to any Harm; but you have a zero rating to your next Action." },
      { name: "King's Gambit", category: "Immediate Effect", effect: "If you fail at this roll, you are immune to any Harm; but you have a zero rating to your next Action." },
      { name: "King's Gambit", category: "Immediate Effect", effect: "If you fail at this roll, you are immune to any Harm; but you have a zero rating to your next Action." },
      { name: "Knight's Gambit", category: "Immediate Effect", effect: "If you are in combat, gain +2d for this roll instead of the standard +1d; but you can roll no more than 1d for your next Action." },
      { name: "Knight's Gambit", category: "Immediate Effect", effect: "If you are in combat, gain +2d for this roll instead of the standard +1d; but you can roll no more than 1d for your next Action." },
      { name: "Knight's Gambit", category: "Immediate Effect", effect: "If you are in combat, gain +2d for this roll instead of the standard +1d; but you can roll no more than 1d for your next Action." },
      { name: "Knuckle Buster", category: "Immediate Effect", effect: "Whether this Action succeeds or not, you accidentally inflict level 1 Harm on your hand, 'Busted Knuckles.'" },
      { name: "Knuckle Buster", category: "Immediate Effect", effect: "Whether this Action succeeds or not, you accidentally inflict level 1 Harm on your hand, 'Busted Knuckles.'" },
      { name: "Knuckle Buster", category: "Immediate Effect", effect: "Whether this Action succeeds or not, you accidentally inflict level 1 Harm on your hand, 'Busted Knuckles.'" },
      { name: "Now or Never", category: "Immediate Effect", effect: "If you fail this roll, you lose this opportunity and cannot retry it for this Score." },
      { name: "Now or Never", category: "Immediate Effect", effect: "If you fail this roll, you lose this opportunity and cannot retry it for this Score." },
      { name: "Now or Never", category: "Immediate Effect", effect: "If you fail this roll, you lose this opportunity and cannot retry it for this Score." },
      { name: "Out of the Frying Pan...", category: "Immediate Effect", effect: "Things are about to go from bad to worse. Start a 4-Clock, 'Surprise Reinforcements'." },
      { name: "Out of the Frying Pan...", category: "Immediate Effect", effect: "Things are about to go from bad to worse. Start a 4-Clock, 'Surprise Reinforcements'." },
      { name: "Out of the Frying Pan...", category: "Immediate Effect", effect: "Things are about to go from bad to worse. Start a 4-Clock, 'Surprise Reinforcements'." },
      { name: "Overextended", category: "Immediate Effect", effect: "Your next Action automatically has reduced Effect." },
      { name: "Overextended", category: "Immediate Effect", effect: "Your next Action automatically has reduced Effect." },
      { name: "Overextended", category: "Immediate Effect", effect: "Your next Action automatically has reduced Effect." },
      { name: "Pawn's Gambit", category: "Immediate Effect", effect: "You cannot use Load for Armor during this Score. You cannot accept this bargain if you already have used Load for Armor." },
      { name: "Pawn's Gambit", category: "Immediate Effect", effect: "You cannot use Load for Armor during this Score. You cannot accept this bargain if you already have used Load for Armor." },
      { name: "Pawn's Gambit", category: "Immediate Effect", effect: "You cannot use Load for Armor during this Score. You cannot accept this bargain if you already have used Load for Armor." },
      { name: "Plan C...", category: "Immediate Effect", effect: "Things are not going according to plan. Flashbacks cost +1 Stress for the rest of the Score." },
      { name: "Plan C...", category: "Immediate Effect", effect: "Things are not going according to plan. Flashbacks cost +1 Stress for the rest of the Score." },
      { name: "Queen's Gambit", category: "Immediate Effect", effect: "You automatically succeed at this Action as if you rolled a 6; but you have a zero rating to your next Action." },
      { name: "Queen's Gambit", category: "Immediate Effect", effect: "You automatically succeed at this Action as if you rolled a 6; but you have a zero rating to your next Action." },
      { name: "Queen's Gambit", category: "Immediate Effect", effect: "You automatically succeed at this Action as if you rolled a 6; but you have a zero rating to your next Action." },
      { name: "Quicksilver Poisoning", category: "Immediate Effect", effect: "Used in electroplasmic containers and devices, you get a noseful of quicksilver vapor, suffering level 1 Harm, 'Silverlung' which starts a 4-Clock Project to heal." },
      { name: "Quicksilver Poisoning", category: "Immediate Effect", effect: "Used in electroplasmic containers and devices, you get a noseful of quicksilver vapor, suffering level 1 Harm, 'Silverlung' which starts a 4-Clock Project to heal." },
      { name: "Quicksilver Poisoning", category: "Immediate Effect", effect: "Used in electroplasmic containers and devices, you get a noseful of quicksilver vapor, suffering level 1 Harm, 'Silverlung' which starts a 4-Clock Project to heal." },
      { name: "Rook's Gambit", category: "Immediate Effect", effect: "You cannot use Load for Unusual or Scary Weapons this Score. You cannot accept this bargain if you already have used Load for these." },
      { name: "Rook's Gambit", category: "Immediate Effect", effect: "You cannot use Load for Unusual or Scary Weapons this Score. You cannot accept this bargain if you already have used Load for these." },
      { name: "Rook's Gambit", category: "Immediate Effect", effect: "You cannot use Load for Unusual or Scary Weapons this Score. You cannot accept this bargain if you already have used Load for these." },
      { name: "Shot Nerves", category: "Immediate Effect", effect: "For the rest of the Score, all rolls to Resist generate +2 Stress." },
      { name: "Shot Nerves", category: "Immediate Effect", effect: "For the rest of the Score, all rolls to Resist generate +2 Stress." },
      { name: "Turned Around", category: "Immediate Effect", effect: "You lose track of your position. Start a 4-Clock, 'Where Am I?' You must use Actions looking for your Crew to rejoin them." },
      { name: "Turned Around", category: "Immediate Effect", effect: "You lose track of your position. Start a 4-Clock, 'Where Am I?' You must use Actions looking for your Crew to rejoin them." },
      { name: "Turned Around", category: "Immediate Effect", effect: "You lose track of your position. Start a 4-Clock, 'Where Am I?' You must use Actions looking for your Crew to rejoin them." },
      { name: "Unsure Footing", category: "Immediate Effect", effect: "Whether you succeed in this roll or not, you loose your footing and fall prone after this Action." },
      { name: "Unsure Footing", category: "Immediate Effect", effect: "Whether you succeed in this roll or not, you loose your footing and fall prone after this Action." },
      { name: "Unsure Footing", category: "Immediate Effect", effect: "Whether you succeed in this roll or not, you loose your footing and fall prone after this Action." },
      { name: "Worse than We thought", category: "Immediate Effect", effect: "A Clock of your choice that is running for this Score is either advanced or set back by two segments (whichever is worse for the Crew)." },
      { name: "Worse than We thought", category: "Immediate Effect", effect: "A Clock of your choice that is running for this Score is either advanced or set back by two segments (whichever is worse for the Crew)." },
      { name: "You're All On Your Own", category: "Immediate Effect", effect: "After this roll, you cannot offer to Assist on anyone else's roll for the rest of the Score." },
      { name: "You're All On Your Own", category: "Immediate Effect", effect: "After this roll, you cannot offer to Assist on anyone else's roll for the rest of the Score." },
      { name: "You're All On Your Own", category: "Immediate Effect", effect: "After this roll, you cannot offer to Assist on anyone else's roll for the rest of the Score." },
      { name: "Death Will Not Stop Me", category: "Long-Term Effect", effect: "The ghost of someone you killed is driven to take you with it. Start a 12-Clock, 'Spectral Vengence'" },
      { name: "That's Enough of That", category: "Long-Term Effect", effect: "Someone whose goals are affected by this Score is going to focus on you now. Start a 8-Clock, 'Cold Vengence'" },
      { name: "That's Enough of That", category: "Long-Term Effect", effect: "Someone whose goals are affected by this Score is going to focus on you now. Start a 8-Clock, 'Cold Vengence'" },
      { name: "The Last Straw", category: "Long-Term Effect", effect: "You've royally pissed off someone with real clout in the city. Start a 12-Clock, 'Furious Vengence'" },
      { name: "You'll Pay For This", category: "Long-Term Effect", effect: "Someone hurt by this Score will come back to collect what's owed. Start a 6-Clock, 'Petty Vengence'" },
      { name: "You'll Pay For This", category: "Long-Term Effect", effect: "Someone hurt by this Score will come back to collect what's owed. Start a 6-Clock, 'Petty Vengence'" },
      { name: "You'll Pay For This", category: "Long-Term Effect", effect: "Someone hurt by this Score will come back to collect what's owed. Start a 6-Clock, 'Petty Vengence'" },
      { name: "Dalgomur, the Heart of the Storm", category: "Mandatory Effect", effect: "If one is not already active for the crew, start a 12-Clock labeled 'The Heart of the Storm' and set it to one. If the Clock is already active, advance it by one." },
      { name: "Dalgomur, the Heart of the Storm", category: "Mandatory Effect", effect: "If one is not already active for the crew, start a 12-Clock labeled 'The Heart of the Storm' and set it to one. If the Clock is already active, advance it by one." },
      { name: "Ulf Ironborn, the Skovlan Agitator", category: "Mandatory Effect", effect: "If one is not already active for the crew, start a 4-Clock labeled 'Skovlander Uprising' and set it to one. If the Clock is already active, advance it by one." },
      { name: "Ulf Ironborn, the Skovlan Agitator", category: "Mandatory Effect", effect: "If one is not already active for the crew, start a 4-Clock labeled 'Skovlander Uprising' and set it to one. If the Clock is already active, advance it by one." },
      { name: "Urumbar, the Closed Eye", category: "Mandatory Effect", effect: "If one is not already active for the crew, start an 8-Clock labeled 'The Closed Eye' and set it to one. If the Clock is already active, advance it by one." },
      { name: "Urumbar, the Closed Eye", category: "Mandatory Effect", effect: "If one is not already active for the crew, start an 8-Clock labeled 'The Closed Eye' and set it to one. If the Clock is already active, advance it by one." },
      { name: "Vaskani, the Crossroads Demon", category: "Mandatory Effect", effect: "If one is not already active for the crew, start a 6-Clock labeled 'The Crossroads Demon' and set it to one. If the Clock is already active, advance it by one." },
      { name: "Vaskani, the Crossroads Demon", category: "Mandatory Effect", effect: "If one is not already active for the crew, start a 6-Clock labeled 'The Crossroads Demon' and set it to one. If the Clock is already active, advance it by one." }
    ],
    Obstacles: [
      {
        name: "Centipedes",
        category: "Animal Guards",
        desc: "Centipedes the length of a forearm are almost noiseless. If they bite, their toxin causes living flesh to blacken and die, leading to amputation if the poison isn't countered. People tend to scream when bit.",
        questions: [
          "Were the centipedes brought in as guardians, or are they a local nuisance?",
          "There are many different breeds, how will you describe the appearance of yours?",
          "Do they have a nasty local nickname?"
        ],
        modsHarder: [
          "When one attacks it releases a scent that enrages others nearby, so they tend to swarm.",
          "They are excellent swimmers, and they hunt in bog-like areas under the surface."
        ],
        modsEasier: [
          "They are bright yellow and red, and hiss before striking, giving all the warning possible.",
          "All the guardians and neighbors carry the antidote, the local apothecary knows what you need."
        ]
      },
      {
        name: "Great Cats",
        category: "Animal Guards",
        desc: "One or more great cats slink through the shadows. They like to attack from high places. Their fur mottles to match the colors and tones and textures around them.",
        questions: [
          "Did the current owners bring them in, or are they inherited from a previous owner?",
          "Do they stay on the estate, or go hunting in the local neighborhood?"
        ],
        modsHarder: [
          "The cats are trained to alert guards (or wear charm jewelry to alert supernatural guardians) when they detect intruders with their keen senses.",
          "Massive old trees draped with moss, or many ledges and overlooks, provide the cats cover."
        ],
        modsEasier: [
          "There is only one, with a regular feeding time and place.",
          "The cats are well fed and lazy, mostly for show unless provoked."
        ]
      },
      {
        name: "Hunting Spiders",
        category: "Animal Guards",
        desc: "These lightning-fast nightmares are about twenty pounds and three feet across, built like jumping spiders and loaded with paralytic venom.",
        questions: [
          "Were these spiders bred for a decadent aristocrat, or warped to this impossible size by an insane whisper?",
          "Can they survive away from a spirit well?",
          "What noise do they make?",
          "How do they smell?"
        ],
        modsHarder: [
          "They are mostly trained, their handler using a slide whistle to give orders to hunt, attack, withdraw, or guard.",
          "The color of the stone, the shape of the underbrush, the leaf litter--everything matches the spider color scheme and hides its movement."
        ],
        modsEasier: [
          "Little lasting harm at first; paralyzed prey is dragged back to a lair and webbed up. You have a day or so to rescue the prey before the spider injects acid into the web bundle so it can drink its victim.",
          "The poison is weak and easy to resist, requiring several successful bites to put a human down."
        ]
      },
      {
        name: "Mastiff Pack",
        category: "Animal Guards",
        desc: "A pack of mastiffs have run of the guarded area when it is not in more public use. They only respond to their masters, who have special tunics, whistles, and gloves. They kill anyone or anything else.",
        questions: [
          "What is their heraldry?",
          "How many mastiffs are in the pack?",
          "Are they trained well enough to ignore poisoned meat or live animal distractions?"
        ],
        modsHarder: [
          "Each one is precious to the site owner, who will tirelessly seek vengeance if they are hurt.",
          "The pack masters are elite veterans with firearms and excellent tracking and hunting skills."
        ],
        modsEasier: [
          "The equipment is properly installed, its vulnerable parts behind the energy curtain, directly guarding what needs protecting.",
          "The lightning walls attract loose spirits, intruders may also have to contend with confused ghosts."
        ]
      },
      {
        name: "Venomous Snakes",
        category: "Animal Guards",
        desc: "Venomous snakes have lairs prepared for them in the guarded area.",
        questions: [
          "How fast acting is their venom?",
          "How aggressive are they?",
          "Is their hide camouflage for hunting, or bright to warn away predators?",
          "Are there only a few big ones, or many small snakes?",
          "Do the site guardians feed them, or can they find enough vermin on their own?"
        ],
        modsHarder: [
          "Knee-deep plants and elevation shifts intentionally make it difficult to see snakes.",
          "Other guardians have a side business in selling venom and meat and hides. They have venom blowdarts and poisoned daggers."
        ],
        modsEasier: [
          "The snakes dislike a certain whistle tone. Let out a blast occasionally and they'll stay away.",
          "A former employee knows how guardians got around the site with minimal risk of snakes."
        ]
      },
      {
        name: "Armor Hosts",
        category: "Ghostly Guards",
        desc: "Guardian spirits are able to inhabit a crystal melded to each suit of armor in a guarded area. When melded, the spirit can control the armor. Spirits use the armor to attack intruders.",
        questions: [
          "Were the suits of armor built for this purpose, or retrofitted by a spirit trafficker?",
          "Are the guardian spirits loyal, or were they stripped of their will by a ritual or other power?",
          "Are the suits visibly paranormal?"
        ],
        modsHarder: [
          "A single powerful (relatively sane) spirit can flit from armor to armor, backed up by two slave spirits. The guardian can form an electroplasmic face in the helmet to sneer at intruders.",
          "A swarm of spirits are eager to take their turn in armor. When one tires another drops in.",
          "Ceaseless patrol."
        ],
        modsEasier: [
          "The ghost(s) that animate the armor are murderous and difficult to control.",
          "The guardians can play a chime to recall them to a restraining prism.",
          "The suits of armor are old, battered, and prone to physical failure."
        ]
      },
      {
        name: "Coldrooms",
        category: "Ghostly Guards",
        desc: "The defended area is kept cold. Body heat registers like a plume of blood in the water. Ghosts flood living meat with cold, gorging on body heat, becoming more visible as their outlines swirl with life-blood.",
        questions: [
          "Were they created by ritually starving victims to death in the defended space?",
          "Were they stolen from the site of a massive horrific disaster?",
          "Does a spirit trafficker maintain the wards on the space?"
        ],
        modsHarder: [
          "A dead whisper leads them, countering defensive charms and magic, sniffing out breath even if heat is concealed, dueling any supernatural defense.",
          "The guarded area is powerfully warded and underground where temperature is easy to maintain."
        ],
        modsEasier: [
          "The guarded area is vulnerable to weather conditions. It is sharp in the cold, but almost dormant in the heat.",
          "A relatively simple spirit bane charm can keep them at bay if created in tune with the site."
        ]
      },
      {
        name: "Cursed Treasure",
        category: "Ghostly Guards",
        desc: "Treasures are infused with a haunting spirit. Anyone touching the treasure will be cursed, dreaming the crimes of the ghost and attracting anger and distaste from strangers. Friends become uncomfortable and suspicious around the cursed scoundrel.",
        questions: [
          "Were those sacrificed to make the haunts loyal, serving past death, or punished by undeath?",
          "Is the treasure marked as cursed?"
        ],
        modsHarder: [
          "The haunting is so deadly that it drives most victims to suicide within a week. Resourceful scoundrels with access to spirit traffickers have days to somehow break the hold. Others are doomed.",
          "Electroplasmic poisoning begins, and within a week the scoundrel will become a vampire."
        ],
        modsEasier: [
          "All the bad luck waiting in the wings (unfinished clocks from foes, poorly protected stashes, jilted lovers, false identities) go wrong in quick succession. Then the curse is over.",
          "A competent occultist can break the curse as a down time project with a four segment clock."
        ]
      },
      {
        name: "Darkrooms",
        category: "Ghostly Guards",
        desc: "The defended area is dark. The ragged ghosts hate light. They shriek horribly as they attack light sources with slapping leathery hands, like bat wings. Intruders may glimpse their luminous fangs.",
        questions: [
          "Were these ghosts placed here intentionally, or are they the result of some horror that left a print in the Ghost Field?",
          "Is this defense maintained, or passive?"
        ],
        modsHarder: [
          "Another guardian lurks in the dark and takes advantage of the distraction to steal from intruders, perhaps killing them too.",
          "The ghosts are aggressive, pushing intruders. Surroundings include long drops, spikes, mazes, or other hazards difficult to navigate in darkness."
        ],
        modsEasier: [
          "While annoying, they do no real damage, and forewarned scoundrels may prepare unbreakable light sources or supernatural dark vision.",
          "There is enough ambient light to see."
        ]
      },
      {
        name: "Dynastic Hive",
        category: "Ghostly Guards",
        desc: "Ancestors have been ritually infused into the defense site, it is a dynastic holding. The spirits are old, and insane, but strategically placed to act out their madness in the most damaging way.",
        questions: [
          "Did the family get special permission to harbor ghosts?",
          "Do they have connections to limmers?",
          "Are spirits tied to leviathan bone shards?",
          "Are they moving pictures, or conversationalists with clues?"
        ],
        modsHarder: [
          "The ghosts are legally protected, like landmarks or artwork. Damaging them is a serious crime.",
          "Some of the more powerful or canny ghosts are still somewhat sane collaborators with the site owners."
        ],
        modsEasier: [
          "They are out of control, and few dare to enter the site now (or it is abandoned.)",
          "They will not harm family members (but may not react well to hostages.)"
        ]
      },
      {
        name: "Hunting Ghostpack",
        category: "Ghostly Guards",
        desc: "A group of weaponized ghosts haunts the defended area. They are capable of scouting to find intruders, descending on them with lethal force.",
        questions: [
          "Do they appear as a pack with a mounted hunter, spectral hounds, and a ghostly horn call?",
          "Or an armored warband?",
          "Shapeless lethal electroplasmic stalkers?",
          "Are the wounds they inflict bloody cuts, or hard frostbite?",
          "Is their area surrounded with runes that let them see into the material world?"
        ],
        modsHarder: [
          "The ghost leader feels all life force in its hunting ground, knowing its location.",
          "The hunt can only rise when certain conditions like anniversaries, moon phases, etc. are met. However, they have a treasure that can only be taken from them when they manifest."
        ],
        modsEasier: [
          "The attack is purely psychological, killing with supernatural fear. The effect can be resisted.",
          "They are summoned and directed by a command artifact like a hunting horn or special weapon. If someone else tunes to the weapon, control (and its obligations) may shift to a new bearer."
        ]
      },
      {
        name: "Possession Gate",
        category: "Ghostly Guards",
        desc: "If an intruder breaks a clearly marked seal, the intruder is attacked by a possessing spirit that takes on the traits of the most strong-willed, brutal person the seal-breaker ever killed. The possessing spirit and the seal-breaker struggle for control. This counts as a harm.",
        questions: [
          "Is the possessing spirit a ghost, or a shape-shifting construct made by an expert that makes a shape out of something in the target?",
          "If an innocent triggers the trap, what form does the spirit take then?"
        ],
        modsHarder: [
          "The only way to be free is to die, undergo electroplasmic surgery while dead, and be revived. Otherwise the curse is protected by the victim's life force.",
          "The haunting spirit tries to take possession once a day or so, sending the host into a blackout and acting out vicious crimes against allies, loved ones, and bluecoats."
        ],
        modsEasier: [
          "The condition can be reduced with a resist roll, but still is likely a 6 segment clock to clear.",
          "The curse haunt would rather have a host ally than kill its victim, and may bargain for shared control."
        ]
      },
      {
        name: "Spirit-Infused Art",
        category: "Ghostly Guards",
        desc: "Art works are haunted by spirits that are capable of spying. They observe their area, and may be able to murmur about what they see to a guardian.",
        questions: [
          "Was art repurposed to host spirits, or was it created for them and around them?",
          "Is the art mosaics, portraits, statues, or some other form?",
          "How sane and coherent are the spirits?",
          "How loyal are they?",
          "Do they have the power to attack intruders?"
        ],
        modsHarder: [
          "One or more guardians has a signet ring tuned to the haunted art pieces, and can hear what they whisper as they spy.",
          "The ghosts inhabiting the art can move from one piece to another, following intruders or retreating to report."
        ],
        modsEasier: [
          "One spirit per art piece, and each spirit has its own unbalanced personality.",
          "Unhinged art is violent, so it has to be shrouded or restrained when guardians go through the defended area."
        ]
      },
      {
        name: "Starving Fog",
        category: "Ghostly Guards",
        desc: "The guarded area is in a clinging cold fog. Fog draws energy from those breathing in it until it manifests shadows that increase target fear, which feeds it more. Eventually it can manifest a killing shape.",
        questions: [
          "What do intruders in the fog see when it reflects their fears?",
          "Are there sound effects, smells, and sounds, or just fleeting glimpses and silhouettes?",
          "Does it project hallucinations or trigger memories?"
        ],
        modsHarder: [
          "The fog strengthens the Ghost Field, making ghosts within it more powerful.",
          "The fog can move, summoned or controlled by other guardians to provide backup or help search."
        ],
        modsEasier: [
          "The fog is generated by an artifact. If the artifact is neutralized so is the fog.",
          "Those with the proper energy keyed amulet or other trinket are invisible to the fog."
        ]
      },
      {
        name: "Sweat Nectar",
        category: "Ghostly Guards",
        desc: "The defended area is kept hot. Sweat tastes like nectar to swarming ghosts, who dehydrate targets into mummies. The stolen life force and moisture flows to prepared corpses, so ghosts can ride them again.",
        questions: [
          "Were they created by dehydrating sacrifices to death in the defended space?",
          "Were they gathered from outside the lightning walls to stand guard here?",
          "Does a spirit trafficker maintain the wards on the space?"
        ],
        modsHarder: [
          "Many prepared corpses are stashed in unexpected places, bursting into combat when rejuvenated.",
          "Once they rise, the desiccated spirit-ridden corpses will chase intruders until they can't."
        ],
        modsEasier: [
          "Only a few corpses are left to revive.",
          "The site is difficult to keep hot enough to extract the necessary sweat from intruders."
        ]
      },
      {
        name: "Dartus Weed",
        category: "Supernatural Plants",
        desc: "When something moves near a tangled bank of dartus weed, the vines flex, flicking barbed tips towards the source of motion within arm's reach. The darts are paralytic; a target will pass out for about an hour.",
        questions: [
          "Do they have a distinctive flower or smell?",
          "What is the aftertaste of the poison's effect?"
        ],
        modsHarder: [
          "Hounds with chemically toughened hides patrol the weed banks, brutally killing intruders.",
          "Weed banks are cultivated strategically, flanking important doorways or draped over arborwalks, straggling along verges."
        ],
        modsEasier: [
          "The weeds are young. Darts can be stopped with thick leather.",
          "Weed banks are out of the way of defended valuables, but too close to very annoyed neighbors who may hold a grudge."
        ]
      },
      {
        name: "Dreamspore Shrooms",
        category: "Supernatural Plants",
        desc: "Placed on the ceiling, they drizzle sandy spores when they sense motion below. Victims hallucinate, heightening subconscious emotion (so they are very mellow, or super anxious, or filled with rage, etc.).",
        questions: [
          "Were these intended to be a site defense?",
          "Did they instead serve a religious or recreational function?",
          "Are there special techniques for harvesting them, perhaps selling them to alchemists?"
        ],
        modsHarder: [
          "A more intense strain, these can knock out those who succumb, and give them vivid dreams for several hours.",
          "They are placed near other guardians as well as hazards like a steep drop or running water."
        ],
        modsEasier: [
          "Other guardians come here recreationally, their effectiveness reduced.",
          "The spores are weak and easier to resist."
        ]
      },
      {
        name: "Floormesh",
        category: "Supernatural Plants",
        desc: "Flat vines grow together to make flooring. Connected below is the bulb, covered in venomous spikes. Anyone heavier than a child will fall through. Blood and rot feed the floormesh.",
        questions: [
          "Have site defenders put carpet over the flat vines to further hide the threat?",
          "What colors, textures, and patterns does this version have?",
          "How dangerous is the venom?"
        ],
        modsHarder: [
          "The building's architecture assumes use of floormesh, the carpets are woven to look like floormesh so the guardians don't have to cover the actual pits.",
          "The mesh itself has venomous thorns in it, so stepping on it or falling through poisons the target."
        ],
        modsEasier: [
          "The pit is not cleaned, the area near it stinks heavily of corpserot. The mesh sags visibly.",
          "Floormesh is mostly hung like tapestries, living decorations, rather than forming pit traps."
        ]
      },
      {
        name: "Ghost Crystal Topiary",
        category: "Supernatural Plants",
        desc: "Ghost crystals are worked into the roots of fancifully trimmed bushes. Ghosts may be able to inhabit the bushes and make them move. This gardening curiosity can be weaponized.",
        questions: [
          "Is this a currently maintained garden, or one that is overgrown and abandoned?",
          "Who provides the necessary skilled care to create or maintain the topiary?",
          "Is there a theme to the sculptures?"
        ],
        modsHarder: [
          "Certain of the most powerful bushes can uproot and move around like living green golems driven by electroplasmic energy.",
          "The bushes hardly move, but the powerful energies of the crystals make ghosts much more coherent and powerful in the garden."
        ],
        modsEasier: [
          "Left unprotected at one point, the garden was raided by thieves after the ghost crystals. Few crystals are left in the shaggy bushes.",
          "Incompetent handling has drained most of the power from the crystals."
        ]
      },
      {
        name: "Keenshrooms",
        category: "Supernatural Plants",
        desc: "These fist-sized mushrooms let out a keening wail when light comes within about thirty feet.",
        questions: [
          "What do they look like?",
          "Is their smell distinctive?",
          "Are they good eating?"
        ],
        modsHarder: [
          "They are strategically placed to surprise intruders; inside doors, on ceilings, in alcoves, behind statues.",
          "Masses of keenshrooms have been allowed to coat walls or fill rooms, and their keen is strong enough to deafen or kill."
        ],
        modsEasier: [
          "The keenshrooms were placed too close to trafficked paths inside or outside the defended site. Constant false alarms dull vigilance.",
          "Too far from site defenders, their keens are seldom investigated."
        ]
      },
      {
        name: "Murder Tree",
        category: "Supernatural Plants",
        desc: "The willow tree grew around bones wired to it, spirit crystals studded in its bark, and leviathan blood at its roots. lt is dimly self-aware. It senses and hates life, whipping and clubbing any who approach.",
        questions: [
          "How do guardians move around the tree?",
          "Suggestions include knowing passwords, having enchanted amulets, or attuning to its blind spots. How many guard the site?",
          "Who had the expertise to cultivate this living weapon, how long ago?"
        ],
        modsHarder: [
          "The chorus of semi-aware spirits that fuel the tree are enslaved by one domineering will. The tree is as coherent as a person.",
          "Multiple murder trees are connected by roots and share knowledge with each other (and any other site guardians.)"
        ],
        modsEasier: [
          "No one can communicate with the murder tree, or control it, so it is isolated from other defenses.",
          "The tree sleeps most of the time, and it is difficult to rouse it to fighting fury."
        ]
      },
      {
        name: "Snatchweed",
        category: "Supernatural Plants",
        desc: "It grows in fresh water, lengthening its long winding tendrils almost to the surface. When touched, it snatches and pulls, coiling down to the bottom and holding for a few minutes before relaxing back up.",
        questions: [
          "Is their growth boosted supernaturally, and can you see faces reflecting from the Ghost Field beneath their fronds?",
          "Are the locals aware of the threat, willing to talk about it?"
        ],
        modsHarder: [
          "Snatchweed is cultivated in areas where intruders must enter the water to get past other obstacles.",
          "The bottom of the water has two foot spikes, victims are pulled down onto them."
        ],
        modsEasier: [
          "A sign warns of the hazard, as required by law.",
          "This particular breed of snatchweed recoils from salt; put enough on the surface and tendrils recoil."
        ]
      },
      {
        name: "Thirstclimber",
        category: "Supernatural Plants",
        desc: "The vines are red, and when flesh touches them (even through leather) the vine draws blood to the surface in alarming quantities. The vines are slippery, and almost impossible to grasp with wet hands.",
        questions: [
          "Are the vines clearly visible to those who can see in the Ghost Field?",
          "Do the vines cause damage that must be healed, or does the blood only flow when they are nearby?"
        ],
        modsHarder: [
          "The site has guard creatures that track by scent and are drawn to attack things that smell bloody.",
          "Thirstclimber is cultivated at the mid-point of a really difficult climb."
        ],
        modsEasier: [
          "Annoyed locals keep it trimmed back on outside walls periodically in spite of the guardian's threats.",
          "Guards know the ingredients to make a special paste, and the symbol to paint on skin with it, to protect from the plant's effects. A former guard might share the secret."
        ]
      },
      {
        name: "Thirsty Thorns",
        category: "Supernatural Plants",
        desc: "Strategically placed thornbushes grow on walls and serve as decorations. They live on blood. They only flower if something dies on them; the bigger the life, the more impressive the bloom.",
        questions: [
          "Do they feed on radiant light?",
          "Are they along the interior walls, lining the walks, and climbing walls outside?",
          "Are there thorns inside, along windows or protecting secret doors?"
        ],
        modsHarder: [
          "The thorns are poisonous, inflicting some condition on those who fail to resist.",
          "Possibilities include sleep, death by choking, blinding blood from the eyes, or paralysis.",
          "The thorns are considered a gardening achievement, with some fame and support as local culture."
        ],
        modsEasier: [
          "A custom amulet tuned to their life energy turns the thorns away, allowing its bearer to push through them unharmed. A site defender may have one, or one could be made.",
          "They are old and brittle, dying by inches and neglected."
        ]
      },
      {
        name: "Vine Curtains",
        category: "Supernatural Plants",
        desc: "Curtains of vines connect back to a radiant root that has grown semi­aware, fed on rogue spirits. If touched, the vines slither and writhe to entangle, hoist, and bundle the target for a guardian to find.",
        questions: [
          "What do the vines look like?",
          "Do they use their scent to attract or repel?",
          "Where is the root relative to the curtain?"
        ],
        modsHarder: [
          "Many curtains and roots of different sizes (some quite big) connect back to a central bulb somewhere in the defense site.",
          "The vines also have a contact poison that makes their target go limp for 10-60 minutes."
        ],
        modsEasier: [
          "The site owner does not have legal permission to have the vine curtains, so they are only used inside.",
          "The vine curtains grow wild and the lazy site owner does not keep them trimmed back, so other guards must stay away from them."
        ]
      },
      {
        name: "Caul Piercers",
        category: "Traps",
        desc: "Piercers are designed to puncture whoever touches them. They pierce the energy caul of the character's life force in the Ghost Field. This causes a harm condition that worsens or costs stress every down time cycle until the caul can be mended (6 segment project.) Interpret as needed.",
        questions: [
          "Do the piercers resemble knives, nails, or thorn-like carvings?",
          "What sadistic expert crafted these dire traps?",
          "If pried out of their settings, how long do they retain potency?"
        ],
        modsHarder: [
          "Those affected will trail life energy like a wounded fish bleeding in the water; demons and ghosts alike will investigate the scent.",
          "They are worked into important doorknobs, strategic ledges, and concealed flooring."
        ],
        modsEasier: [
          "They all look alike and are similarly placed, relying on surprise to be effective.",
          "They are only on the main treasure."
        ]
      },
      {
        name: "Collapsing Ceilings",
        category: "Traps",
        desc: "If triggered, this trap drops a mass of stone. That seals off the threatened area, and crushes anyone tampering with its defenses.",
        questions: [
          "Who put valuables behind a trap that could seal them away for good?",
          "How old is this defense, and who takes care of it?",
          "What warning signs tip off an intruder that continuing is dangerous?"
        ],
        modsHarder: [
          "Hidden mechanisms can raise the block back up to the ceiling, so the trap can be reused (or defeated remotely.)",
          "More than one block falls; the first one cuts off escape, then death seems inevitable."
        ],
        modsEasier: [
          "The stone dropped long ago. Site guardians or intruders have developed ways to climb over it or get past it. Other blocks may still be untriggered, but some of them are no longer dangerous.",
          "More like a mine collapse, difficult to control and possible to tunnel past."
        ]
      },
      {
        name: "Combination or Trick",
        category: "Traps",
        desc: "Various portals and defenses of the site are protected by combination locks or riddles to solve. Lockpicks will not work against them, though finesse may solve them eventually.",
        questions: [
          "Are there a series of combination locks expressing a religious or eccentric worldview?",
          "Are there picture arranging puzzles, or unusual  keys  to go in sculpture locks?",
          "Are the locks mechanical or supernatural?"
        ],
        modsHarder: [
          "Powerful runic work or enslaved ghosts make the obstacle difficult to smash or trick--the right combination or object must be used to bypass it.",
          "Clues and needed items are spread across a large estate, or multiple estates."
        ],
        modsEasier: [
          "The combination or solution to the puzzle is in a scholarly work, and can be found or bought ahead of time.",
          "The solutions are painfully obvious to someone with the right upbringing and background."
        ]
      },
      {
        name: "Contact Needles",
        category: "Traps",
        desc: "Small needles are worked into contact surfaces and poisoned, to deter intruders. They may be on doorknobs, seat backs or cushions, doorframes, stair treads, ledges, beds—anywhere, really.",
        questions: [
          "Are the needles easily visible if you look for them, or camouflaged?",
          "Are they retractable if you know what you're doing?",
          "What kind of poison is on them?",
          "Will the victim sleep, freeze, die, or hallucinate?"
        ],
        modsHarder: [
          "The needles are only corporeal to those who touch them without wearing a certain amulet. Important site guardians are immune to the needles.",
          "Anything important or at an unguarded entry point is going to be festooned with needles."
        ],
        modsEasier: [
          "They are not well maintained. Many have snapped off, and few retain much poison.",
          "They are only on the most important objects or the most useful trap objects (like a chair for guests.)"
        ]
      },
      {
        name: "Excellent Locks",
        category: "Traps",
        desc: "Beyond simple security, these locks are works of art. They are higher potency than they would normally be. Also, they are equipped with poison needle traps, or pick breakers, or redundancies.",
        questions: [
          "Who put in these superior locks, and for what reason?",
          "Are the locks designed to defeat entry, or actively punish intruders?",
          "Do the specialized keys have a distinctive look, like two flanges?",
          "Is there a master key?"
        ],
        modsHarder: [
          "Everything is locked, and all the locks are good. Somebody had a real lock problem.",
          "The locks involve supernatural components, like hidden keyholes or paralyzing energy."
        ],
        modsEasier: [
          "The locks are in poor repair, of variable quality after indifferent maintenance and many intrusion attempts.",
          "Very fancy locks, but they are padlocks, and bolt cutters can circumvent the problem."
        ]
      },
      {
        name: "Murder Holes",
        category: "Traps",
        desc: "Intruders go past one door, into a hallway or small room, and the door closes behind them. Arrow slits open in the walls, and slots in the ceiling allow boiling oil to be poured down. Intruders are trapped and vulnerable. These are often in doors through defenses.",
        questions: [
          "Was the original site builder often under siege?",
          "Are the murder holes obvious or concealed?"
        ],
        modsHarder: [
          "Murder holes are automated with self- slamming doors and pre-boiling oil, so a few defenders can trap and/or kill many intruders.",
          "The whole layout is built with many murder hole areas to deter invasion."
        ],
        modsEasier: [
          "The walls are wooden, and determined captives can break through to face their attackers.",
          "This area does not have enough staff to monitor intruders and make best use of murder holes."
        ]
      },
      {
        name: "Pit Traps",
        category: "Traps",
        desc: "The defended site has pit traps in strategic places. They are between 10 and 40 feet deep.",
        questions: [
          "Do they have slick sides?",
          "Are there spikes at the bottom?",
          "Are the covers mechanized, or flimsy boards and carpets, grass turf, or leaves over canvas?",
          "Are the sides stone, earth, or clay?"
        ],
        modsHarder: [
          "Fist sized tunnels connect pits. Predatory creatures (crabs, snakes, spiders, rats) scurry to devour victims.",
          "Once someone falls into the pit the covers close again, and will not open until unlocked."
        ],
        modsEasier: [
          "The pits drop into a lower area, mostly abandoned except for predators. It is possible to find a way out.",
          "The pits are mostly open and filled with junk."
        ]
      },
      {
        name: "Retractable Spikes",
        category: "Traps",
        desc: "Spring-loaded spears or racks of spears launch at intruders. They can come from the side, behind, ahead, below, or above.",
        questions: [
          "Are the defenses standardized to protect guardians, or random to confuse intruders?",
          "Are they in an area that site defenders use, or in an isolated off-limits area?",
          "How long have they been in use, and how often are they maintained?"
        ],
        modsHarder: [
          "After doing their killing work, they retract, and the launch points are not obvious.",
          "The spears are slathered with some toxin, further affecting the victim."
        ],
        modsEasier: [
          "The mechanisms are not well maintained. Sometimes they don't work, and when they do, there is a screech and they are a bit slow.",
          "The spears are designed to pin an intruder in place, to be interrogated and punished, rather than to kill outright."
        ]
      },
      {
        name: "Secret Doors & Spyholes",
        category: "Traps",
        desc: "Guardians are well trained in the use of numerous secret doors and hidden passages with spyholes. They can attack from unexpected directions, escape without a trace, and watch intruders unobserved.",
        questions: [
          "Was this site built by a spy, or a cult, or a paranoid aristocrat?",
          "Are there consistent tells, a code built into the decor and architecture, or must all secrets be known individually?"
        ],
        modsHarder: [
          "Ongoing rearrangement and construction means old information from plans or people ages out fast.",
          "Supernatural locks and keys mean that triggers and spyholes and seams may not be visible in the material world at all."
        ],
        modsEasier: [
          "Frequent use has made secret doors easier to spot. Poor baffling of lights may reveal spyholes in use.",
          "Current residents are only aware of some secrets; intruders may use back ways to elude security."
        ]
      },
      {
        name: "Shock Grips",
        category: "Traps",
        desc: "One or more contact points are connected to energy so they will badly shock anyone who touches them. These could be doorknobs, chest lids, floor plates, ladders, and so on.",
        questions: [
          "Are they powered by batteries or enslaved ghosts?",
          "Does the site have legal permission to use them?",
          "How loud is the shock?",
          "How do site guardians avoid getting shocked?"
        ],
        modsHarder: [
          "The shock grips are numerous and concealed, connected to their energy source through the Ghost Field.",
          "The shock is designed to stop the heart and kill the victim (possibly setting hair on fire.)"
        ],
        modsEasier: [
          "The shock grips are connected to control boxes and energy sources by cables.",
          "Shock grips are marked by a rune, and shiny, and also give out a palpable hum of energy. They are easy to detect."
        ]
      },
      {
        name: "Brutal Sadists",
        category: "Twisted Guards",
        desc: "Only brutal sadists are hired on as guards. They have permission to play with captured intruders.",
        questions: [
          "Is the owner of the protected property aware of this cultural rule, or are guards hired by an employee?",
          "Do they share cultural roots (slaughterhouse workers, leviathan hunters, soldiers, city guards, etc)?",
          "How do the neighbors feel about their occasional scandals?"
        ],
        modsHarder: [
          "Several of them are skilled in both torture and interrogation; they extract secrets from intruders. A side business in blackmail helps them avoid legal trouble.",
          "They are hardened veterans, exceptionally tough and dangerous. They aim to incapacitate."
        ],
        modsEasier: [
          "Their ugly tactics and poorly chosen victims have earned them (and their employer) enemies in lots of unexpected places.",
          "They really, really like to drink."
        ]
      },
      {
        name: "Close-Knit Guard Network",
        category: "Twisted Guards",
        desc: "Guards are only hired by referral. Failure results in punishment for both the guard and the sponsor. Their loyalty is tested many ways before and after they are hired.",
        questions: [
          "Do they favor bastards of the employer?",
          "Are they connected to one military unit?",
          "Are they refugees from another place?",
          "Do they come from a single neighborhood?",
          "Does punishment extend to their families?"
        ],
        modsHarder: [
          "They are connected to a larger sponsoring organization that would seek vengeance if they are attacked or insulted, and also offer them favors.",
          "They speak in code and have passwords that include safewords and warnings."
        ],
        modsEasier: [
          "Nepotism has pulled in some really incompetent guards.",
          "Endless drama from working with family and friends."
        ]
      },
      {
        name: "Compulsive Detail Focus",
        category: "Twisted Guards",
        desc: "Only a certain type is hired; a type that checks every lock and every dark corner. Schedules are strict, thoroughness is a guarantee, and they seem unable to cut corners or skip steps. Everything is by the book.",
        questions: [
          "Are they altered to be like this, or just screened for a mindset?",
          "What are the detailed parts of the defended site that need this kind of attention?",
          "How does their gear reflect this fussy attention to detail?"
        ],
        modsHarder: [
          "There are other elements of the defended site that require their focus, like a pattern of stepping over tiles to avoid triggering traps or complex combination locks or dozens of cells with dangerous prisoners.",
          "They are trusted with specialty items like firearms or charms because they are responsible with them."
        ],
        modsEasier: [
          "Everyone knows that they fall apart if things deviate from the pattern, like distractions or chaos.",
          "The locals pick on them when they are off duty, teasing them for their compulsions. They have enemies, and could use friends."
        ]
      },
      {
        name: "Convict Public Service",
        category: "Twisted Guards",
        desc: "Due to prison overcrowding, some criminals are sentenced to indentured service to a noble to work off their debt to society. This site's guardian uses criminals as guards, under the stern eye of professionals.",
        questions: [
          "Are casualties high due to danger from intruders or other site defenses?",
          "Is the patron benevolent and trying to rehabilitate criminals, or using them as disposable fodder?",
          "How do the convicts like this place?"
        ],
        modsHarder: [
          "Serving here is a known post among criminals, both a resume builder and networking site.",
          "Angering these guards could bring consequences from unexpected directions in the criminal underworld.",
          "Hand picked as the hardest and deadliest, these criminal guards are canny and tough."
        ],
        modsEasier: [
          "Convicts are eager to assist anyone with enough Coin or pull to secure their pardon and freedom.",
          "The convicts are bullied and sullen, as much a hindrance to defenders as a defense themselves."
        ]
      },
      {
        name: "Demonic Mutations",
        category: "Twisted Guards",
        desc: "About a quarter of the guards have been mutated by contact with demonic essence. They are strong, and their senses are sharp.",
        questions: [
          "Do they share one demon patron?",
          "Did they become guards to gain this power?",
          "Are they worshippers or mercenaries?",
          "Did they volunteer or are they victims?",
          "What element is their demonic affinity?"
        ],
        modsHarder: [
          "They share a supernatural connection and can sense when other demonic guards are in trouble.",
          "They are highly resistant to normal damage. They may be vulnerable to supernatural attacks or a specific allergy (silver, garlic, salt, etc.) Or, they may be resistant to supernatural attacks instead."
        ],
        modsEasier: [
          "They become physically impressive, but their minds are lost to incoherent lusts and fury.",
          "The rest of the staff resent or fear the demonic guards. Loyalty and morale are low among mundane employees."
        ]
      },
      {
        name: "Enchanted Prosthetics",
        category: "Twisted Guards",
        desc: "Guards are all amputees with at least one prosthetic. Each prosthetic tunes to its owner. The prosthetics can stun on contact.",
        questions: [
          "Are the false limbs the work of one genius?",
          "Are they part of a collection?",
          "Were they made for this use?",
          "Is a ghost bound to each?",
          "Are they scientific, with batteries?",
          "Are they powered by the bearer's life force?"
        ],
        modsHarder: [
          "All guards have some adept training and spirit bane charms, alert against supernatural forces.",
          "Veteran guards have learned to tune to their prosthetics to get an additional effect, like life detection or firing energy blasts."
        ],
        modsEasier: [
          "Only one use between recharges.",
          "The guards are mostly old or broken, relying on reputation and supernatural energy to be effective."
        ]
      },
      {
        name: "Feral Pen",
        category: "Twisted Guards",
        desc: "Some areas of the defended site have free-range maniacs. Destitute and wretched beggars are treated as guard dogs, expected to attack intruders and draw attention to anything unusual.",
        questions: [
          "Does the guarded site pretend to be charitable, or a madhouse, or a prison?",
          "What philosophy leads to treating people this way?",
          "How do the city authorities feel about the site?",
          "Religious authorities?",
          "Does the site feed into the Ghost Field in an unusual way?"
        ],
        modsHarder: [
          "Most of the feral guards are killers, possibly haunted, and extremely dangerous.",
          "This pet project is as much art and religion as defense, and has support from a variety of decadent aristocrats in positions of power."
        ],
        modsEasier: [
          "The rest of the site guards hate the feral pen and ignore it as best they can.",
          "It is as much prison hospice as guard dog kennel. Its victims are weak, sick, and starving."
        ]
      },
      {
        name: "Fighting School",
        category: "Twisted Guards",
        desc: "An onsite training school focuses on the lifestyle and skill of a school of fighting. Site defenders are part of a group identity with specialty training.",
        questions: [
          "Is the school's focus on dueling, a martial art, commando training, or something else?",
          "What is their crest, uniform, motto, and lore?",
          "What sort of training space do they have?"
        ],
        modsHarder: [
          "The school itself is an impressive fortress or defense.",
          "The school has an impressive alumni network that visits occasionally and would avenge wrongs to the honor of the school."
        ],
        modsEasier: [
          "This is an off-site shrine or expansion, where they send troublemakers and those they can't eject for political or financial reasons.",
          "Leadership is riddled with rivalries and power struggles. Outsiders know some details."
        ]
      },
      {
        name: "Performance Enhancers",
        category: "Twisted Guards",
        desc: "Guards have ready access to drugs. Some of the drugs enhance performance.",
        questions: [
          "Do the drugs give them a burst of combat effectiveness?",
          "Are the drugs recreational, making them popular with a customer base that pays well and owes favors?",
          "Who provides them with drugs?"
        ],
        modsHarder: [
          "As dealers, the guards are difficult to bribe or intimidate, as they have money and prestige.",
          "Guards can medicate flexibly, with concoctions to enhance perception (even to see the supernatural,) gain combat prowess, or heal."
        ],
        modsEasier: [
          "Their peddling of illegal drugs has made enemies among bluecoats and inspectors.",
          "The guards are junkies. Their employer uses addiction to control them, keeping them near the edge. They are often distractible or unconscious."
        ]
      },
      {
        name: "Zealots",
        category: "Twisted Guards",
        desc: "Guards share a religion that binds them together and makes them resistant to intimidation or corruption.",
        questions: [
          "Do they worship one of the Forgotten Gods? The Church of the Ecstasy of the Flesh? Weeping Lady?",
          "Have they sworn oaths?",
          "What does religion require them to hate, or to love?"
        ],
        modsHarder: [
          "The defended site includes a shrine or temple. Violating the site angers offended worshippers.",
          "Serving as a site guardian is part of a religious duty. Unexpectedly seasoned warriors or important people may serve as lowly guards for a time."
        ],
        modsEasier: [
          "Mandatory prayer times, unclean objects or places left uninspected, and restricted areas may create holes in security.",
          "Enemies of their religion may offer help to embarrass, discredit, or injure the zealots."
        ]
      },
      {
        name: "Ghostport Lock",
        category: "Weird Tech",
        desc: "Keys are tuned to locks that cannot be picked by normal means, or bypassed without whisper expertise. Their access point is in the Ghost Field until the key is present.",
        questions: [
          "Are these locks modem scientific triumphs, or old arcane defenses?",
          "Does he key look like a key, or does it look like a missing decoration, or a gem?",
          "Is the key physical, or energy, like living blood of the right family?"
        ],
        modsHarder: [
          "The locks are hidden and trapped. Messing with the lock could hollow the intruder (tearing the spirit out of the body) or other unpleasantness.",
          "The precise location of the lock must be known, and it is not near what it is locking."
        ],
        modsEasier: [
          "The ghostport lock has been a fad several times in Duskwall. Each time, there was some mass production, and a key to a similar lock might work with a little help.",
          "The owner may have stiffed a whisper locksmith on the fee, or otherwise offended the expert, who is knowledgeable and disgruntled."
        ]
      },
      {
        name: "Lightning Walls",
        category: "Weird Tech",
        desc: "Runic energy twisting technology can make pylons that project a curtain of energy between them. The glowing walls are transparent, but crippling to touch and lethal to pass through. They stop projectiles.",
        questions: [
          "Does the site have the technology legally, or is it stolen?",
          "Maybe cobbled together from leftovers by a mad alchemist?",
          "Is it on all the time (expensive to fuel) or only if the alarm is raised?",
          "Where are the fuel cells kept?"
        ],
        modsHarder: [
          "The equipment is properly installed, its vulnerable parts behind the energy curtain, directly guarding what needs protecting.",
          "The lightning walls attract loose spirits, intruders may also have to contend with confused ghosts."
        ],
        modsEasier: [
          "The walls guard a few key access points, but there are multiple ways around.",
          "The walls are installed poorly, so their machinery is vulnerable from the outside while it is on. If no other guards are present, they can be wrecked."
        ]
      },
      {
        name: "Panopticon",
        category: "Weird Tech",
        desc: "Special crystal lenses transmit their sight through the Ghost Field to mirrors in a central location. From one place, a guardian can monitor views all over the defended site.",
        questions: [
          "Is this new industrial alchemical technology, or an ancient enchanted construction?",
          "Does the current owner know how to get the most functionality out of it?",
          "Who maintains the system?"
        ],
        modsHarder: [
          "The lenses are hidden in mirror frames, statues, and other decor. They are difficult to spot.",
          "The lenses can see into the Ghost Field as well, observing ghosts or occult work, and life force."
        ],
        modsEasier: [
          "The guardians watching the mirrors are somewhat lax.",
          "Over time, many lenses have not been replaced or repaired. Views are limited."
        ]
      },
      {
        name: "Shadow Lanterns",
        category: "Weird Tech",
        desc: "Guards are equipped with lanterns that detect shadows of recent life force as well as shedding light.",
        questions: [
          "Are the lanterns traditional lantern shape, or a glowing ball, or something else?",
          "Does an expert keep the guardians supplied, or is their supply jealously guarded?",
          "Does it cost the guards something to activate the lanterns?",
          "Will the lanterns work if taken off-site?"
        ],
        modsHarder: [
          "Guards are trained to tune into the life force energy to also hear conversations of the life shadows. Guards can tune into the life force energy to know the owner's current location, if in the defended area.",
          "Untended lanterns can be set to transmit detection of a life force to a nearby guardian."
        ],
        modsEasier: [
          "The lanterns can be rendered blind by properly tuning a spiritbane charm while near one.",
          "Every sunrise wipes all traces of past life forces, and they only work at night."
        ]
      },
      {
        name: "Shadow Rooms",
        category: "Weird Tech",
        desc: "The Ghost Field sometimes remembers rooms or entire neighborhoods that no longer exist in the material world. Some defended sites hide treasures in these spaces that can only be accessed if you knowhow.",
        questions: [
          "How are colors different in these shadow rooms?",
          "Is there a smell or sound that lingers?",
          "How does it feel to step out of the material world?",
          "What natural laws work differently here, like fire not flickering?"
        ],
        modsHarder: [
          "The access point to the shadow rooms is an enchanted lock, its location is known and guarded.",
          "The shadow rooms are only connected to the material world a few times a year, or less."
        ],
        modsEasier: [
          "Transitioning from the material world to the shadow rooms involves certain proscribed movements; cross the courtyard three times, then back down stairs with eyes closed (for example.) Too many people know the formula.",
          "The current site owners do not know these rooms exist."
        ]
      }
    ],
    NPCs: [
      {
        name: "Arturo Montastic",
        type: "npc",
        concept: "Addicted Gambler",
        arena: "New Money",
        description: "He is impossibly lucky. He wins enough at games of chance to pay for his addictions, and to treat the consequences (transfusions, transplants, cutting-edge treatments.) His relationships are intense but brief. He often loses everything, but then wins it all back and more. He has owned epic treasures many times.",
        notes: "Risk-averse collectors cannot bear his cavalier attitude on winning and losing priceless art. He does not truly appreciate his treasures, and should not be trusted with them. Losers can take their losses hard."
      },
      {
        name: "Baron Kelyr Strathmill",
        type: "npc",
        concept: "Hardened Industrialist",
        arena: "Old Money",
        description: "His family has controlled the docks for many generations. They quietly destroy competition, and get lucrative city contracts to re-develop blighted areas if the money slows down. Graceful, educated, and pleasant, he is ruthless as barbed steel under a cultured veneer. He is proud of his estate's gardens.",
        notes: "Competition doesn't like being crippled. He often hires outsiders for the dirtiest work, and his victims often hire outsiders to get revenge."
      },
      {
        name: "Baroness Thena Hellyers",
        type: "npc",
        concept: "Hazy Art Patron",
        arena: "Old Money",
        description: "Thena is one of the least emotionally scarred survivors in her weird family. She is a leading light in the art world. She is patron to many artists and her criticism and evaluation drives a significant element of Duskwall's art scene. Whispers have noted she has an unusual connection to the Ghost Field.",
        notes: "Sometimes she hires outsiders to sort out one of her artists' problems. She has a private gallery that she updates with her current trending tastes—those in the art market need to know what's in it."
      },
      {
        name: "Calvin Dannos",
        type: "npc",
        concept: "Eerie Assassin",
        arena: "Underworld",
        description: "The Inkvein was a cabal of seven anonymous assassins, named for their maps of the canals. If one of them was identified as a member, the other six were sworn to kill the outed assassin. Dannos was outed a decade ago, and he killed the other members and their undying founder. Now he IS Inkvein.",
        notes: "Easily bored, he prefers interesting challenges to high paying or easy kills. Of course, many bereaved or power hungry individuals want him dead."
      },
      {
        name: "Commissioner Naria Haig",
        type: "npc",
        concept: "Political Matchmaker",
        arena: "City Law",
        description: "She exudes a plump grandmotherly innocence, but she is one of the sharpest politicians in Duskwall. She supervises over the merging of unexpected allies and the schism of monolithic interests. She cares about one thing—the good of Duskwall as a whole. She is Chair of the Ethics Oversight Committee.",
        notes: "Always playing a bigger game, she uses outsiders to manage errands whose purpose they cannot see. Those she outmaneuvers tend to want to get back at her with violence."
      },
      {
        name: "Doc Sarnin",
        type: "npc",
        concept: "Lecherous Leech",
        arena: "Underworld",
        description: `Doc can keep life in you if you're alive (or recently dead) when you get to him. His extreme methods are often horrifying. Still, his concoctions can crush ghosts, re-attach limbs, and more. The Crows, a tough crew, protect him. They give him victims for his "needs," which are emotional, physical, and scientific.`,
        notes: "Sometimes the Crows hire outsiders to go after rare components or victims for Doc. He has many, many enemies who want to either steal him and force him to serve them, or punish him."
      },
      {
        name: "Doctor Ixit Crichelle",
        type: "npc",
        concept: "Elegant Spook",
        arena: "Old Money",
        description: "Crechelle calls himself an Oneiric Master. He interprets dreams for a fee. He enters them, alters them, and moves through veils to understand truths and secrets the dreamer may not grasp. If he touches a target, or one of their possessions, he may enter their dreams. He appears feeble, but his mind is deadly.",
        notes: "Aristocratic patrons invite him to parties. He needs a person's possession to see into their dreams; he pays for objects to visit some people's dreams. Victims will pay to free themselves ."
      },
      {
        name: "Dr. Hansel Kryvanntic",
        type: "npc",
        concept: "Brilliant Scientist",
        arena: "Foreign",
        description: "He is Severosi, bow-legged and wild-haired. His work on electroplasmic poisoning and mutation in animals and humans is ground-breaking. Fleeing persecution because of his ethically questionable methods back in Severos, he found a more open-minded scientific community in Duskwall.",
        notes: "His research has applications in art, medicine, and war. Those with sufficient resources to further his studies want to control him. He has hurt a lot of people, over time, so he has many enemies."
      },
      {
        name: "Dr. Yerial Crabbskidditch",
        type: "npc",
        concept: "Sleazy Lawyer",
        arena: "New Money",
        description: "He firmly believes those who are wealthy should not be pestered with the law. No matter what you do, if you have means you can arrange for an alternate story that favors you. Deaths, frauds, robberies, and other crimes can be reduced to a few fines. He throws money at problems until they disappear.",
        notes: "He routinely hires outsiders to destroy evidence, intimidate witnesses, compel confessions, and so forth. He has countless enemies, both those seeking justice and former clients who ran out of money."
      },
      {
        name: "Duvrel the Snake",
        type: "npc",
        concept: "Cunning Smuggler",
        arena: "Foreign",
        description: "She is Tycherosian, with the eyes and horns of a goat. Snake tattoos coil around her arms. Exotic drugs from the Dagger Isles flow through her distribution network in Duskwall. She hires outsiders to remove stubborn people while she has an alibi, or to retrieve drugs misplaced at incriminating locations.",
        notes: "Inspectors have orders from the Spirit Wardens to take her alive, to study her uncanny ability to flex with the Ghost Field for supernatural stealth."
      },
      {
        name: "Dylayzia Finchester",
        type: "npc",
        concept: "Fashionable Whisper",
        arena: "New Money",
        description: "Her exotic looks, tattoos, and bright green eyes draw attention. She popularized thigh-high buckled leather boots and spirit bane chokers. Her opinions echo in drawing rooms across the city. People enjoy her feud with the Church of the Ecstasy of the Flesh.",
        notes: "Wealthy figures in the fashion world pay top win for sneak peeks at her clothing designs. Her opinions inflame many enemies­-especially the Church. She hires outsiders to get rare components for her rituals."
      },
      {
        name: "Emeline Coleburn",
        type: "npc",
        concept: "Weary Regulator",
        arena: "City Law",
        description: "She inspects buildings and reports to the Duskwall Council whether they are sound, and whether they serve the purpose listed on the owner's taxation form. She is front-line in the tug-of-war between criminals, politicians, and nobles. She no longer cares about the greater good. Now it's about kickbacks.",
        notes: "She takes the path of least resistance in her evaluations, so people pay to make their preference easier and other roads harder. She hires outsiders for off-the-books communication with pushy customers."
      },
      {
        name: "Eric the White",
        type: "npc",
        concept: "Vigilante Rebel",
        arena: "Foreign",
        description: "The War of Skovlan Unity is over, but this slender maniac with a brushy beard can't let it go. He plans to destroy the government and turn Duskwall into a Skovlan colony to punish them for the destructive war. He wants to discredit and disrupt the government at every turn.",
        notes: "He targets gavernment officials as high up as he can reach, hoping to cause enough trouble to make the government vulnerable to change. He has gathered zealots, and he uses outsiders for disposable work."
      },
      {
        name: "Gi Aniru Ga of Sultha",
        type: "npc",
        concept: "Sacrificing Cultist",
        arena: "Supernatural",
        description: "She worships the Gaping Maw, the Runnel of Life, the Cosmic Thirst. She builds a cult, teaching them to hunt and conduct rituals. Then she moves on. Witnesses uneasily describe her supernatural abilities, including shapeshifting, flight, killing people by attacking their shadows, and so on.",
        notes: "Bereaved relatives, rival cultists, and law enforcers all want her stopped. She hires outsiders to threaten, misdirect, or kill law enforcement. Determined inspectors crush cults she trained, need help to catch her."
      },
      {
        name: "Holtz Clermont",
        type: "npc",
        concept: "Reformed Clerk",
        arena: "City Law",
        description: "He used to be a forger. After he served stint in prison, some respectable family friends got him a position as City Clerk for the whole district. He manages correspondence for permit requests and official notices. When corrupt people inside and outside the system need to adjust evidence, they come to him.",
        notes: "Jilted clients can be threatening, leading him to take steps to adjust their attitude by hiring outside help. He's smarter than he looks, and knows how to back people off. He also might know too much."
      },
      {
        name: "Inspector Lorette Salkha",
        type: "npc",
        concept: "Crusading Inspector",
        arena: "City Law",
        description: 'She needs allies in her hopeless quest to clean up the city. Corruption is everywhere, crime runs rampant, and the bluecoats serve the powerful (on both sides of the law.) Some tragedy in her past propels her into a suicidal effort to restore "rule of law.” Her peers muse it is a shame she will die young.',
        notes: "She could be helpful if she focuses on the right bad guys—your enemies. She can't be bought, so maybe someone needs her killed (or otherwise neutralized.)"
      },
      {
        name: "Jemma Dropkick",
        type: "npc",
        concept: "Feminist Vigilante",
        arena: "Underworld",
        description: "She is a legend in the Seven Shallows neighborhood. She attacks men who abuse women. She survives because she has friends—a few bluecoats, a gang of thugs, and a grateful public. She carefully plans attacks to hurt abusers. Lf her victims abuse again, they are mutilated, packed like luggage, and shipped out of town.",
        notes: "Many powerful men would pay for revenge on Jemma. Sometimes she hires outsiders to help out."
      },
      {
        name: "Kheldaria Whinnich",
        type: "npc",
        concept: "Implacable Developer",
        arena: "New Money",
        description: "She has a vision for developing the Crow's Foot district. It will be divided between businesses, estates, and parks. To realize her vision, she has been selectively buying real estate all around the city, bartering for land in Crow's Foot, and using whatever persuasion is needed to convince owners to sell to her.",
        notes: "She has an estate where she stores induce­ments of all sorts, a variety of treasure designed to persuade owners to sell in exchange for what they want most. They say you could find almost anything there."
      },
      {
        name: "Lady Ashlyn Tyrconnel",
        type: "npc",
        concept: "Decadent Duelist",
        description: "For centuries, aristocrats of Duskwall have learned the Tyrconnel Method of swordplay and self defense. The Tyrconnel family produces countless public servants and warriors—but also a share of scoundrels. Ashlyn's trademark suite of moves is to duel, win, bed someone, and drink to unconsciousness.",
        notes: "You're hired to join the spy game in the Tyrconnel family. Or, someone is targeting her. Either way. Watch your back. Outsiders in the games of nobles are uniformly expendable."
      },
      {
        name: "Lady Candra Dunvil",
        type: "npc",
        concept: "Corrupt Fixer",
        arena: "Old Money",
        description: "Her family built Ironhook Prison. Her wealth is built on generations of shady deals with incarcerated aristocrats and business owners. She sees the world as a rigged game and has contempt for anyone who finds corruption shocking or fixable. She is vain, practical, and ruthless.",
        notes: "She hires outsiders to carry out promises she made to inmates. Her family has casually wrecked reputations and lives over centuries, and that leaves a trail of vengeance seekers."
      },
      {
        name: "Lady Polonia Brogan",
        type: "npc",
        concept: "Desirable Dowry",
        arena: "Old Money",
        description: "She's ugly, smelly, stupid, and rude--and also the key to the Brogan fortune. Her lucky spouse will have access to massive wealth and infrastructure among professional builders and shipwrights of Duskwall. Only her aunt, CECILIA DURWITHE, looks out for her best interests with sharp disapproval.",
        notes: "Brogan hires outsiders to punish those who slight her, or to investigate potential partners. She collects fake wills rogues have planted during assassination attempts, trying to leave her fortune to usurpers ."
      },
      {
        name: "Lord Branon Kinclaith",
        type: "npc",
        concept: "Romantic Horseman",
        arena: "Old Money",
        description: "Branon looks like a hero from a legendary story. He manages the family's stables, the finest horses in Duskwall (where horses are a rare luxury.) His tumultuous trysts with both men and women are common knowledge. Business suffers from his impulsive romantic gestures, but benefits from his charm.",
        notes: "Branon sometimes refuses to sell horses, or breed them, if he dislikes the buyer. Some buyers want access to horseflesh anyway. If his horses are attacked, he hires outsiders to get revenge."
      },
      {
        name: "Lord Bulward Skinnester",
        type: "npc",
        concept: "Greedy Banker",
        arena: "New Money",
        description: "This portly curmudgeon does a brisk trade in real estate titles, both lending and foreclosing. He is acutely aware of the value of properties and how neighbors affect value. He takes particular glee in foreclosing on aristocracy and setting up the newly rich in ancient estates.",
        notes: "Sometimes he hires outsiders to solve problems that his hired bluecoats and bribed councilmen cannot manage. He collects sculpture by Duskwall artists. He has ruined the lives of many formerly influential people."
      },
      {
        name: "Lord Orlan Booker",
        type: "npc",
        concept: "Insulated Mastermind",
        arena: "Old Money",
        description: "Ennui is a danger to the wealthy. Booker fills his days by gathering intelligence and planning heists, then selling the plans to ambitious gangs that lack his patience, experience, resources, and insight. Twice a month he goes to the opera, and meets those who have arranged to purchase a score.",
        notes: "Sometimes things go wrong, and it is natural to blame the planner and want revenge. Sometimes a target wants to punish those who acted against them, even if the act was planning."
      },
      {
        name: "Master Slen Dallicore",
        type: "npc",
        concept: "Protective Guilder",
        arena: "New Money",
        description: "Master Dallicore is the Guildmaster for the Docker's Guild. They move all cargo on and off ships, boats, and gondolas. Their role is protected by law, as are the fees they charge. The guild uses low-level violence to discourage non-guild laborers and smugglers. However, some challenges require proper scoundrels.",
        notes: "Dallicore is not above hiring outsiders to punish powerful patrons of smugglers or illegal dock workers. His position of power also gives him access to rare antiquities, both purchased and acquired."
      },
      {
        name: "Minister Fourteen",
        type: "npc",
        concept: "Grungy Fixer",
        arena: "Underworld",
        description: "The blind Skovlander holds court on the docks, moving from one basement to another. He favors baggy shirts, stained vests, shiny jewelry, and fraying lace. He often acts through his massive bodyguard Severen and his weedy messenger Torok.",
        notes: "He is connected in the Skovlander refugee community, and in Skovlan. For a price (either wealth or an errand) he will share information about Skovlanders. He often hires outsiders to handle sensitive tasks."
      },
      {
        name: "Moonslider the Third",
        type: "npc",
        concept: "Eccentric Artist",
        arena: "New Money",
        description: "She feels moon phases. Her family put her in an asylum for a decade. Later, she won her freedom and inherited the family bootmaking fortune. She makes art. She tries to communicate her moon feelings. She uses oil paint, glass blowing, sculpture, song, and dance in multimedia recitals and art pieces.",
        notes: "Her family bought nice things before they all died and she inherited them; she ignores most of it. She needs expensive equipment and supplies for her bizarre art shows."
      },
      {
        name: "Officer Milos Penderyn",
        type: "npc",
        concept: "Corrupt Bailiff",
        arena: "City Law",
        description: "Milos has access to trial evidence, and to prisoners awaiting trial. He can't get people out, but he can silence them. He has a network of corrupt peers, judges, bluecoats, and others so he can trade favors to accomplish the impossible. Huge and greasy, he is built like a bull and he enjoys the scent of fear.",
        notes: "Controlling Milos could mean protecting or killing someone in bluecoat custody. An endless stream of people want revenge on him, and a more select group would like to control or use him."
      },
      {
        name: "Officer Veleris Walund",
        type: "npc",
        concept: "Heroic Bluecoat",
        description: "There are actually songs about him. He is very popular. Veleris is a skilled orator (though he retreats into modesty) and a canny judge of character and situations. (He insists he just tries to do the right thing.) His opinion is influential in his district. He is trusted to guard valuables. His moustaches are his pride and joy.",
        notes: "He has no family, and he seems to be an idealist. Some try to persuade him, others try to threaten him. Threats don't seem to work. He has been known to quietly hire outsiders to get justice."
      },
      {
        name: "Pebbler",
        type: "npc",
        concept: "Demon Spy",
        arena: "Supernatural",
        description: "This earth demon looks like a fat man built around a boulder gut, leaking sand from joints. It is able to see and hear through sand, earth, and stone within a range of miles. It works with non-cultists voluntarily, selling information in exchange for raids into the rare areas protected from its prying.",
        notes: "Dozens of powerful people want Pebbler banished or robbed. However, the demon is a peerless information exchange, valuable even if it is difficult to control."
      },
      {
        name: "Saithernon",
        type: "npc",
        concept: "Exotic Fence",
        arena: "Underworld",
        description: "He drapes his python, DELGRAAZ, around his neck. He wears a turban with a jewel on it. He is willing to buy almost anything, no matter how strange. He also knows what you need, sometimes before you know you need it. His bazaar unfurls below the Kennington market in an abandoned gondola dock.",
        notes: "He pays people to get things for him, then sells them at tremendously inflated prices to those desperate to have them. This can cause hurt feelings among the desperate."
      },
      {
        name: "Serlevica the Brander",
        type: "npc",
        concept: "Spy Whisper",
        arena: "Underworld",
        description: "Gaunt and frizzed, this foul-smelling Whisper has a secret ritual that allows her to control and see through rats she brands. She sells her services as a spy or site guardian. She has survived by retreating into slums and sewers when threatened, and striking from the shadows until it is safe to emerge again.",
        notes: "She is closely tied to the information marketplace, buying and selling secrets. She often hires outsiders to deal with her enemies through theft or violence, and she is in turn a frequent target."
      },
      {
        name: "Sir Mournseller",
        type: "npc",
        concept: "Anarchist Ghost",
        arena: "Supernatural",
        description: "This ghost possesses old men from the Draymach Asylum, breaking them out to find and hire scoundrels for obscure tasks with no independent purpose. Examples include killing an insignificant chandler or stealing a specific stone from a wall in a noble's estate. Payment is the location of hidden treasure.",
        notes: "A decade ago, an astute inspector began picking out the connection between errands, seeing a very long and very dangerous game to unseat the city's rulers emerging."
      },
      {
        name: "Sir Olen Llanwold",
        type: "npc",
        concept: "Piratical Industrialist",
        arena: "New Money",
        description: "He is thin and nervous, easy to underestimate. He specializes in stripping foes of their assets and taking over their operations. His father was a butler, and he grew up hating aristocrats. He understands power structures and corrupts retainers. His top agent, Ellsfielder, is a beautiful and ruthless woman.",
        notes: "Many ruined aristocrats (and their allies) hate Danwold passionately. He does not hesitate to use his assets, legal and otherwise, to defend himself and cripple his foes. He hires outsiders through proxies."
      },
      {
        name: "Sir Tocker Farros",
        type: "npc",
        concept: "Pragmatic Councilman",
        arena: "City Law",
        description: "Sometimes the law works, and sometimes it doesn't. Regardless, the Council must rule and there must be order. Sir Farros ensures the districts he serves do not get too far out of hand before lawless elements are curbed. One way or another. He looks like an affable grandfather, but he has a dark past.",
        notes: "Sir Farros uses inspectors or scoundrels, politicians or housemaids—anyone who will get the job done. He has an endless list of enemies who feel he wronged them, and want revenge. His agents are disposable."
      },
      {
        name: "SLOPSPATTER",
        type: "npc",
        concept: "Canal Hull",
        arena: "Supernatural",
        description: "This hull learned to consume spirits and bolster its strength with theirs. It cannibalizes machinery and rummages in wrecked boats for parts. It has gondola prow shoulder guards and helm, and strange banded armor made of water-logged wood over intricate mechanical parts. It fears destruction.",
        notes: "It assassinates targets, with its body or by possessing machines near them. It hunts whispers, leeches, and scholars, stealing their knowledge and killing them. Their allies want revenge."
      },
      {
        name: "Syla DuTorrivestria",
        type: "npc",
        concept: "Famous Connoisseur",
        arena: "Foreign",
        description: "This mysterious Iruvian hides behind a veil. For years, she has been the final word on Duskwall delicacies. She specializes in evaluating high-end cuisine (including spore wines and cooking with leviathan blood.) She stays in the public eye with racy politics and a string of scandalous romances.",
        notes: 'She must keep any real competitors for her fame weakened and embarrassed, and she has countless enemies. Everyone "knows" she is an Iruvian spy.'
      },
      {
        name: "The Honorable Telia Cray",
        type: "npc",
        concept: "Stern Prosecutor",
        arena: "City Law",
        description: "She's old, she's sour, and she has a reputation for jailing Duskwall's criminals. As thin and hard as an iron poker, she relentlessly pursues her cases, bending the law with a passionate hatred of scoundrels. She runs a special unit of Inspectors dedicated to investigating her cases, run by INSPECTOR ULEK.",
        notes: "If she is taking a case personally ( as she often does) she may hire outsiders to acquire or create evidence. She also conduds a brutal war of counter-intelligence against rogues looking to free their associates."
      },
      {
        name: "The Wooden Judge",
        type: "npc",
        concept: "Haunted Puppet",
        arena: "Underworld",
        description: "This knee-high ventriloquist dummy looks like a caricature of a grim Judge. It is supernaturally animated. The puppet appears unexpectedly, interrupting a scoundrel's routine by offering jobs in a squeaky voice. He pays by revealing the location of hidden caches of ancient coin.",
        notes: "Many angry victims want to know who pulls the strings of the Wooden Judge. The puppet often hires fresh talent for dubious work."
      },
      {
        name: "Theodore Lysander",
        type: "npc",
        concept: "Bard Pimp",
        arena: "Underworld",
        description: "Elegant and charismatic, this well-dressed man runs the Tenpenny Court Network. He manages prostitutes and their customers, his personal connections and charm monetized. He is also a skilled composer and performer, often seen at the Worldsedge Theater in Crow's Foot.",
        notes: "He is a skilled networker. He takes the safety of his friends seriously, and is protedive of his employees, to the point of using blackmail to force powerful patrons to back off."
      },
      {
        name: "Chief Prichard",
        type: "npc",
        description: "The head Overseer of the Ministry of Provisions in Duskwall. Manages the workers and food allotments for the city districts.",
        district: "Barrowcleft",
        traits: [
          "calculating",
          "confident",
          "calm"
        ]
      },
      {
        name: "Lord Strangford",
        type: "npc",
        description: "Operates one of the largest leviathan hunter fleets, serves on the City Council and is a high-ranking member of the secret order within the Church of Ecstasy.",
        district: "Brightstone",
        traits: [
          "secretive",
          "calculating",
          "arrogant"
        ]
      },
      {
        name: "Hutton",
        type: "npc",
        description: "A Skovlander refugee and former soldier, now the leader of an anarchist revolutionary movement, bent on forcing the government to acknowledge Skovlander rights in the Empire.",
        district: "Charhollow",
        traits: [
          "brave",
          "compassionate",
          "wise"
        ]
      },
      {
        name: "Lady Drake",
        type: "npc",
        description: `A magistrate who is "reasonable" when it comes to street crime, so long as the offender's purse is sufficient.`,
        district: "Charterhall",
        traits: [
          "flexible",
          "shrewd",
          "subtle"
        ]
      },
      {
        name: "Master Slane",
        type: "npc",
        description: "A notorious factory foreman known for excessive and cruel punishments for the smallest infractions. Many attempts have been made on his life, but all have failed. Some say he's a devil.",
        district: "Coalridge",
        traits: [
          "cold",
          "cruel",
          "sadistic"
        ]
      },
      {
        name: "Sergeant Lochlan",
        type: "npc",
        description: "The senior Bluecoat squad leader in the district, reporting to Captain Dunvil. Lochlan is flexible and reasonable, taking bribes and payoffs when she can; enforcing the law and making examples when necessary.",
        district: "Crow's Foot",
        traits: [
          "shrewd",
          "tough",
          "commanding"
        ]
      },
      {
        name: "Chief Helker",
        type: "npc",
        description: "One of the most influential senior Dockers. Helker has a lot of sway at the docks, and if you cross him, you might find your cargo tossed into the drink—and possibly you along with it.",
        district: "The Docks",
        traits: [
          "cautious",
          "greedy",
          "vengeful"
        ]
      },
      {
        name: "Master Krocket",
        type: "npc",
        description: "An unsavory, greasy-haired, scarecrow of a man who runs the snarling pack of vicious dogs used by Ironhook to track down escapees and sniff out contraband and tunnels. His dog-handlers can be found around the labor camp and all about Dunslough, using their status with the prison for favors and bribes.",
        district: "Dunslough",
        traits: [
          "cruel",
          "greedy",
          "ruthless"
        ]
      },
      {
        name: "Jira",
        type: "npc",
        description: 'A dealer of fine weapons from the Dagger Isles. Greatly respected by many street toughs in The Dusk—a "jira blade" is a status symbol that many aspire to.',
        district: "Nightmarket",
        traits: [
          "bold",
          "tough",
          "confident"
        ]
      },
      {
        name: "Levyra",
        type: "npc",
        description: 'A medium who invites clients to bring ghosts in bottles to posses her so they can share a few final words before the ghost is "freed" (Levyra hands it off to the waiting Spirit Wardens nearby).',
        district: "Silkshore",
        traits: [
          "weird",
          "daring",
          "dishonest",
          ""
        ]
      },
      {
        name: "Mother Narya",
        type: "npc",
        description: "Runs the Arms of the Weeping Lady charity house.",
        district: "Six Towers",
        traits: [
          "kind",
          "patient",
          "gracious"
        ]
      },
      {
        name: "Maestro Helleren",
        type: "npc",
        description: "Senior composer and conductor of the Spiregarden Theater, premiere performance venue for the elite of the city.",
        district: "Whitecrown",
        traits: [
          "sincere",
          "dramatic",
          "vain"
        ]
      },
      {
        name: "Hester Vale",
        type: "npc",
        description: 'Matriarch of the oldest farm family. The living embodiment of "tough but fair."',
        district: "Barrowcleft",
        traits: [
          "proud",
          "fierce",
          "suspicious"
        ]
      },
      {
        name: "Commander Bowmore",
        type: "npc",
        description: "Chief Officer of the Watch in Brightstone. Bowmore's family financed Bowmore Bridge centuries ago and now holds many positions of power.",
        district: "Brightstone",
        traits: [
          "proud",
          "principled",
          "connected"
        ]
      },
      {
        name: "Briggs",
        type: "npc",
        description: "The owner of a merchant stall at Charhollow market, cover for a network of gossips, spies, and code-smiths among the working class people of the district, selling their services to those who need them.",
        district: "Charhollow",
        traits: [
          "secretive",
          "sneaky",
          "cautious"
        ]
      },
      {
        name: "Lord Penderyn",
        type: "npc",
        description: "Chief Scholar of the Archive of Echoes, authorized by the Emperor to keep a collection of ancient ghosts trapped in spirit bottles, to be consulted in cases where knowledge from the distant past would benefit the operation of the Imperial government. Lord Penderyn also consults the spirits on his own volition, forming the rebellious Path of Echoes society for other elites and nobles who seek communion with the spectral realm.",
        district: "Charterhall",
        traits: [
          "reckless",
          "strange",
          "obsessive"
        ]
      },
      {
        name: "Belle Brogan",
        type: "npc",
        description: "A Skovlander factory worker who's been gaining popularity as a potential union organizer. It's only a matter of time before a factory boss tries make an example of her.",
        district: "Coalridge",
        traits: [
          "charming",
          "confident",
          "bold"
        ]
      },
      {
        name: "Lewit, Jol, Myra, Reyf",
        type: "npc",
        description: "Bluecoat constables; run an extortion racket.",
        district: "Crow's Foot",
        traits: [
          "arrogant",
          "vain",
          "volatile"
        ]
      },
      {
        name: "Tris",
        type: "npc",
        description: "A legendary tattooist who only inks those that have looked upon a leviathan and lived to tell the tale. Getting a tattoo from Tris is a rite of passage for everyone who hunts the demons of the void sea.",
        district: "The Docks",
        traits: [
          "artistic",
          "popular",
          "insightful"
        ]
      },
      {
        name: "Vandra",
        type: "npc",
        description: "A deathlands scavenger that survived six runs and was pardoned. She knows the landscape beyond the barrier very well—but few can make sense of her haunted mumblings.",
        district: "Dunslough",
        traits: [
          "haunted",
          "wise",
          "daring"
        ]
      },
      {
        name: "Leclure",
        type: "npc",
        description: "A purveyor of personal luxuries (soaps, hair oils, perfume, fine silks) who dabbles in fortune telling. Some say her that drowned lover is a ghost that whispers secrets in her ear.",
        district: "Nightmarket",
        traits: [
          "shrewd",
          "tough",
          "commanding"
        ]
      },
      {
        name: "Helene",
        type: "npc",
        description: "The elegant and mysterious proprietor of the Silver Stag Casino. People say she would have been a queen of Severos had she lived in the old days before the Empire.",
        district: "Silkshore",
        traits: [
          "cultured",
          "charming",
          "secretive"
        ]
      },
      {
        name: "Chef Roselle",
        type: "npc",
        description: "One of the best cooks in the city, still operating the legendary Golden Plum restaurant—worth the trip into the haunted streets of Six Towers.",
        district: "Six Towers",
        traits: [
          "creative",
          "insightful",
          "friendly"
        ]
      },
      {
        name: "Lady Freyla",
        type: "npc",
        description: "Regarded by some as the finest sommelier in the Empire. She serves only the most deserving at the Emperor's Cask.",
        district: "Whitecrown",
        traits: [
          "erudite",
          "cultured",
          "charming"
        ]
      },
      {
        name: "Mara Keel",
        type: "npc",
        description: "A former smuggler who's gone into hiding among the farm laborers of Barrowcleft.",
        district: "Barrowcleft",
        traits: [
          "quiet",
          "secretive",
          "patient"
        ]
      },
      {
        name: "Rolan Wott",
        type: "npc",
        description: "An influential magistrate who handles property, endowments, and financial cases. Famous for his extravagant parties.",
        district: "Brightstone",
        traits: [
          "stylish",
          "elitist",
          "shrewd"
        ]
      },
      {
        name: "Corben",
        type: "npc",
        description: "An ex-military Skovlander on the lam for crimes against the empire.",
        district: "Charhollow",
        traits: [
          "tough",
          "reckless",
          "candid"
        ]
      },
      {
        name: "Hopper",
        type: "npc",
        description: 'A drug addict, whisper, and all-around weirdo who perches on rooftops in the district. Hopper claims to see "ghost rails" and "spirit trains" originating deep beneath Coalridge, stretching beyond the horizon.',
        district: "Coalridge",
        traits: [
          "weird",
          "visionary",
          "enthusiastic"
        ]
      },
      {
        name: "Mardin Gull",
        type: "npc",
        description: "Owner and operator of the Leaky Bucket public house. Mardin was the leader of the Crows many years ago, before Roric and Lyssa, and now enjoys a comfortable retirement out of the scoundrel life.",
        district: "Crow's Foot",
        traits: [
          "charming",
          "experienced",
          "respected"
        ]
      },
      {
        name: "Mordis",
        type: "npc",
        description: "A strange merchant which hides its true appearance beneath many layers of robes and hoods. Also fences occult and arcane stolen goods, no questions asked.",
        district: "Nightmarket",
        traits: [
          "secretive",
          "insightful",
          "arcane"
        ]
      },
      {
        name: "Madame Tesslyn",
        type: "npc",
        description: "Operates the Red Lamp brothel, the oldest and most respected institution of its sort in the city.",
        district: "Silkshore",
        traits: [
          "confident",
          "insightful",
          "enthusiastic"
        ]
      },
      {
        name: "Flint",
        type: "npc",
        description: "A spirit trafficker who trades out of a condemned manor house.",
        district: "Six Towers",
        traits: [
          "weird",
          "calculating",
          "suspicious"
        ]
      }
    ],
    Scores: [
      {
        name: "Accidental Death",
        category: "Secret Dirty Work",
        desc: "Not only must the target die, the target must not know how death came. If by some misfortune the ghost of the victim is interrogated, it must not have any special knowledge. There is a ritual and an amulet for the assassins to ensure secrecy. No one living or dead can know who did this deed.",
        narrative: "By the time the crew knows the job, there is a better than even chance their knowledge is too much risk and their employer plans to kill them. They might want some leverage."
      },
      {
        name: "Bayer's Train Heist",
        category: "Misplaced Fortune",
        desc: "Bayer was a rail jack fired for being drunk. Over years, he built a crew with one mission in mind--robbing a train. When lruvia completed negotiations with Akoros to buy an unprecedented mass of leviathan blood to pour into industrialization, Bayer's crew hit the train carrying the payment, sabotaging a bridge. Rescuers found the train in the canyon, but no gold--an impossible feat. Bayer's crew vanished.",
        narrative: 'An Iruvian ingot stamped with the year "802" will attract attention.'
      },
      {
        name: "Bellweather Architectural Plans",
        category: "Historical Curiosity",
        desc: "The Duskwall Archives have the sanitized blueprints of the Bellweather Crematorium on file. The original plans were drawn by a Spirit Warden driven mad by an internal rift, so he haunted himself. He drew peculiar plans with occult underpinnings, and those original drawings were interpreted by architects.",
        narrative: "Are there coded secrets in the original plans that reveal a repellant secret or ominous threat? Or are the plans the scribbling of a madman? Either way, some people would pay top coin to get a good look."
      },
      {
        name: "Book of Walls",
        category: "Historical Curiosity",
        desc: "Long ago, a nameless rogue cultivated a mass of bloodworms in a wall. He wrote a book with their blood. The words were nonsense, but strangely affecting; if the reader tuned in to them, and held the book, the reader could walk through a wall. Spirit Wardens ruined the book with holy smoke.",
        narrative: "A legend, or is there truth to it? Walking through walls is a neat trick, and the book may hold the key to learning it. It is sought by a wide variety of the curious—scholars, collectors, and scoundrels."
      },
      {
        name: "Censer Mace of Udoch",
        category: "Religious Object",
        desc: "The head of this ornately carved mace opens on hinges so incense can be put inside to wisp as the mace swings. The haft has a recipe carved into it, instructions to make special incense out of bone and rare sap and unguents. If that incense bums in the mace, it can destroy ghosts or demons with a single hit.",
        narrative: "This was a founding artifact of the Church of the Ecstasy of the Flesh. If it were returned, they would gain a fresh following from critics who feel the church cannot protect against supernatural threats."
      },
      {
        name: "Charter of Crows",
        category: "Historical Curiosity",
        desc: "This gauntlet is made out of crow beaks. Each beak is carved with arcane symbols. Consulting Whispers officially report it does not have any power in the Ghost Field. It was made by the Spirit Warden who first tamed the deathseeker crows; he claimed it was a treaty that guaranteed their service.",
        narrative: "Spirit Wardens lost this gauntlet decades ago, but they want it back. The idea it is a treaty with the deathseeker crows is probably nonsense. They can't take that chance."
      },
      {
        name: "Combination Harpsichord",
        category: "Weird Scholarship",
        desc: 'TARNALI was a Whisper composer who built a special harpsichord. When two tones are played, often a third "ghost" tone can be heard. By attaching the tuning pegs to crystals and runes, Tarnali built a harpsichord that could interact with the Ghost Field through calculated progressions of played tones.',
        narrative: "This effort is intensely interesting to those who want to find doors hidden in the Ghost Field, draw or repel what lurks Behind the Mirror, or develop more portable tonal energies for non-Whispers ."
      },
      {
        name: "Dyvik's Chaser Mask",
        category: "Weird Artifact",
        desc: "This silvery face mask has the word “Elekthiaron” etched along its inner edge. When the word is spoken, the personality of the one touching the mask is pulled into it. The personality that was in the mask goes in the body. If the one in the body doesn't touch the mask once a week, madness threatens.",
        narrative: "Has someone been using the mask to pose as someone else? How long has that been going on? Is there someone in the mask that needs rescuing? Was the mask used to cheat biological death?"
      },
      {
        name: "Evardian's Song Folios",
        category: "Weird Scholarship",
        desc: 'Four leather-bound volumes, full of musical notation with heavily annotated margins. The "music" is supposed to be transcribed and translated leviathan song. Legend suggests if the music is played correctly, it can drive humans insane with visions of the demon-haunted deep.',
        narrative: "Aristocrats will collect anything. Scholars go to great lengths for research material. Cultists may find religious significance in the folios. (Owning the folios is against the law.)"
      },
      {
        name: "Falheim's Prod",
        category: "Historical Curiosity",
        desc: "This ragged pole with a spear and a silver-cable loop was the first prototype of what became the lightning hook. It doesn't work very well, but it was the first historically known charged object that could consistently interact with the Ghost Field.",
        narrative: "Apparently this bit of history is an important prestige piece in the turbulent intrigues of a number of underground cults led by Whispers. The city government would also like to display it in a museum."
      },
      {
        name: "Fang of Ibiria",
        category: "Religious Object",
        desc: "This brutal stiletto has a green stone in the pommel, and a runic symbol on the blade. The blade transforms electroplasm into a mutagen. The longer the blade is in a victim, the more monstrous the victim becomes. A cut gives nightmares, minutes give mutations, hours or days create a real monster.",
        narrative: "Cultists want this blade so they can make or become monsters."
      },
      {
        name: "Goblet of Eletrachtian",
        category: "Weird Artifact",
        desc: "The silver and gold cup is big enough to hold with two hands, crusted with obsidian stones. The owner puts a drop of a demon's blood in the goblet with certain other liquids, and conducts a ritual. For days afterwards (maybe longer) the owner can see anything the demon uses remote vision to view, just by watching the surface's illusory reflections.",
        narrative: "There are many legends about the creation of the goblet, and the fate of the Whisper who first energized it. Rumor suggests the Duskwall Council entrusted the goblet to a certain family for safekeeping."
      },
      {
        name: "Hollow Shroud",
        category: "Religious Object",
        desc: "The Church of the Ecstasy of the Flesh clergy wrapped the funeral shroud around a heretic, then conducted a ritual that severed the heretic's connection to the body, cutting the spirit loose as a ghost. The shroud transferred the spirit of a faithful but sickly member into the heretic's body. New life!",
        narrative: "The Shroud was stolen almost twenty years ago, and rumors suggest it has been used in debased rituals to summon demons or enflesh echoes of the Forgotten Gods."
      },
      {
        name: "Idol of the Sleeping Lion",
        category: "Religious Object",
        desc: "The hefty iron statue depicts a devilfish-headed humanoid, cloaked in wings. Its presence influences human dreams, so they drift through the ink-black sea but can perceive their surroundings. Sacrificing to the statue gives a cultist a cosmic infection, involving psychic ability and mutations.",
        narrative: "The statue has been retrieved by officers of the law several times, and destroyed several times more. Again and again, it emerges in the heart of fresh tragedy, baleful and singular."
      },
      {
        name: "Ink Fleece",
        category: "Family Heirloom",
        desc: "Long ago, Captain Manarill claimed he could prove that leviathans had fur, or fleece. He brought back a swatch of curling fur as big as a bedspread. He claimed to have harvested it from a leviathan's skin. The mantle served as a symbol of the Manarill family's heritage of exploration and danger. But it was stolen.",
        narrative: "Does it do more than represent heritage? What dreams might one have while wrapped in it? Might a wealthy Whisper pay more for it than the family that owned it? Who took it?"
      },
      {
        name: "Kasavaraya Tea Set",
        category: "Family Heirloom",
        desc: "When the Immortal Emperor visited Akoros four centuries ago, he used this tea set with the patriarch of the Kasavaraya family. They are still one of the most decorated and entrenched military families in Duskwall. Their tea set is a symbol of Duskwall's prominence. However, a saucer and a cup are missing.",
        narrative: "This stuff is priceless, literally, so negotiating a price for its return is tricky. If you could find the missing pieces, or forge them adequately, they would be great hostages to ajfed the family's behavior."
      },
      {
        name: "Kidnap The Heir",
        category: "Secret Dirty Work",
        desc: "People are keys that fit into estate locks. They can be turned to open the way to lots of money. You might be taking a child to ransom back to the guardian, or you might be getting someone out of the way so a more distant heir can inherit. This is about controlling where the money goes.",
        narrative: "How harsh does the employer want this to be? Kid gloves treatment, or is the plan to kill the heir when it is all over? How much input will the employer accept from the hired help? Is the plan already in place?"
      },
      {
        name: "Krogs Broken Heart",
        category: "Misplaced Fortune",
        desc: "Krog was a savage from the Dagger Isles, pressed into service on a hunting ship. He eventually owned a small fleet. He was old when he fell in love with a young woman who robbed him. Heartbroken, he took the rest of his treasure aboard his last hunting ship, Heartsong, and scuttled her in the harbor.",
        narrative: "Whispers like to brag they found a way under the waves to find the wealth. Gracmaas the Pirate claimed to have recovered it all to his hidden lair—before he was killed."
      },
      {
        name: "Limptwitch's Stash",
        category: "Misplaced Fortune",
        desc: "Limptwitch was a Whisper who interrogated ghosts to find the location of hidden treasure. He was famous for his Grotto, the place where he stored all his salvaged wealth. Many factions tried to get his treasure, but he never gave up the secret. Then he was jailed and hanged. The Grotto was never found.",
        narrative: "Did a cellmate in prison hear muttered hints as to its location? Maybe a Whisper has clues based on where he left his mark in the sewers. Has someone finally found a real lead?"
      },
      {
        name: "Mark of the Void",
        category: "Religious Object",
        desc: "It is an eerie black disk of leviathan bone, about the size of a dinner plate but five times as thick. The bone is carved with a strange circular pattern with rays cutting through it. The primitive artwork was polished, and silver inlaid in the pattern, by a decadent nobleman.",
        narrative: "Impressionable people admit the disk whispers to them, they hear the Back of the Mirror when it the disk is near. Many cults see this disk as a conduit to clearer communication with their supernatural patrons."
      },
      {
        name: "Naladicha's Cartography",
        category: "Historical Curiosity",
        desc: "The famous cartographer Naladicha died, and his ghost was woven into a spirit anchor connected to a pen on a wire. The drooping pen scribbled nonstop, dipping to indicate a page turn. Two books were filled with scribbles before the pen stilled. These lines and shapes may be maps of the Ghost Field.",
        narrative: "One consulting Whisper reported that when she attuned to the books using an expensive and difficult ritual, the maps became luminous and four dimensional, revealing lost secrets in Duskwall."
      },
      {
        name: "Norscye's Lament",
        category: "Famous Jewel",
        desc: "This ruby has been set in a series of weapons for the last three centuries. One estimate was that the gem had participated in upwards of a thousand deaths. Legend suggests that the ruby can hold a single ghost, surviving the destruction of the body, bound to the gem until it chooses another guest.",
        narrative: "While the gemstone is priceless because of its unnatural clarity, it is also possible that an important ghost might be inside, and might choose to speak to a Whisper or a blood relative."
      },
      {
        name: "Orb Of Sellivas",
        category: "Weird Artifact",
        desc: "This fist-sized golden orb tunes to one bearer at a time, though it may respond to others. If commanded, it can release a steady light that radiates in the material world and the Ghost Field, revealing what is hidden. The radiation can also draw or repel ghosts and demons.",
        narrative: 'The Sellivas order of witches wrote their research journals in an ink that can only be read by the light of the Orb. If someone had the Orb and the "blank" book, they could crack ancient secrets.'
      },
      {
        name: "Plant Evidence",
        category: "Secret Dirty Work",
        desc: "Someone needs to be found guilty of doing something. For that to work out, you need evidence, put in the wrong place at the wrong time. To manage that, you need proper scoundrels.",
        narrative: "Do you know what the target will be accused of doing? Are you to lead the authorities to the evidence? Must someone be seduced before a hidden witness? Are the scoundrels making evidence, or using what they're given? What if they could do better? Must the evidence fool a court, or a powerful individual?"
      },
      {
        name: "Plasmic Blade Flail",
        category: "Weird Artifact",
        desc: "This weapon can slay ghosts and demons. It appears to be a gladius stitched with runes. Once the bearer attunes to the weapon, it can disconnect into vertebrate-like wedges connected by a steely central cable. The blade-whip is flexible and simmering with energy. It can reform into a straight blade at will.",
        narrative: "Only five of these flails ever existed. One is carried by the Spirit Warden assigned to the Immortal Emperor's defense. The rest are the stuff of legends."
      },
      {
        name: "Remote Writer",
        category: "Weird Artifact",
        desc: "This little book has a peculiar occult symbol on the cover. If an object is placed between the covers for a full 24 hours, then the book will transcribe any conversation happening in earshot of the object until reset. When the book reaches the end, the writing starts over on the first page, clearing pages as it goes.",
        narrative: "The book provides remote reading, eavesdropping of a sort. A target's favorite pen or lucky coin can become the broadcaster, and determined spies can copy the magic book writing so they don't lose it."
      },
      {
        name: "Rylaria's Shield",
        category: "Family Heirloom",
        desc: "Rylaria Graefwold was a soldier who gained title and wealth. She wrote her life's story on the back of the shield she used to save a general. Later generations added to the family story. The shield represents the family's honor. It was lost at sea when their first leviathan hunting ship was wrecked. Or was it?",
        narrative: "Now the family is wealthy, and this artifact would be important to them. Does it have a secret in code?"
      },
      {
        name: "Skovlan Scrip",
        category: "Misplaced Fortune",
        desc: "A dense lockbox filled with paper money issued by the Akorosian government to pay soldiers quelling the Skovlander Insurrection. The scrip can be exchanged for coins or services in Duskwall. Scrip is basically untraceable.",
        narrative: "Some of the military supply that got lost during the war. Does the stashs location implicate a corrupt official or other thief?"
      },
      {
        name: "Sonurian Ghost Key",
        category: "Family Heirloom",
        desc: "The Sonuria family had mansions in the area that is now the Seven Shallows slum. They created a vault for the protected dead, and for their mundane treasures. The only way in is for a family member to present the Sonurian Ghost Key before the hidden location of the vault in the Ghost Field. The key has been lost for decades.",
        narrative: "That key could be hidden anywhere. If it were found, either a family member could be recruited to open the door, or the key could be sold to the family. What does the key look like? What is inside the vault?"
      },
      {
        name: "Soultrap Carnelian",
        category: "Famous Jewel",
        desc: "This semi-precious stone was carved by the Whisper Ichralia. She suffocated people with hot wax and bound their fresh ghosts in wax seals on scrolls or letters with the Soultrap. When the seal was broken, the insane ghost attacked the opener and anyone nearby.",
        narrative: "The Spirit Wardens destroyed this object decades ago. Didn't they? Maybe someone else made another one, or maybe the original survived."
      },
      {
        name: "Steal Blackmail",
        category: "Secret Dirty Work",
        desc: "Secrets must be protected. If they come out, people can get hurt, ruined, killed, and so on. You are hired to adjust the circle of people who can prove something. Will it be bigger? Or smaller?",
        narrative: "Do you know what information you're after, or is that secret from you? If you have a chance, will you peek at it? Are you targeting a blackmailer to remove their hold, or getting evidence to give a blackmailer? Is the evidence to be destroyed? Do you plan to do as you are told?"
      },
      {
        name: "Terrorize",
        category: "Secret Dirty Work",
        desc: "People can be stubborn, to the point where only fear can unseat their decision. Maybe they feel independent and need to reminded that they need protection. Maybe they feel safe and need to be reminded they are not untouchable.",
        narrative: "Are you supposed to be someone in particular, like a random street thug or rival's employee or bluecoat? How far can the terror go? Do you need to trash a home, or maybe converse with a loved one?"
      },
      {
        name: "The Emerald Well",
        category: "Famous Jewel",
        desc: "This depthless gem is a chilly pinhole between the material world and the Ghost Field. It provides energy to Whispers and attracts ghosts. The Emerald Well was protected by the Church of the Ecstasy of the Flesh, but a thief stole it decades ago. It is a hotspot for supernatural activity. Disaster flows in its wake.",
        narrative: "This is one of the few objects pursued by demons, Whispers, inspectors, clergy, and collectors. Scholars suggest demons may be able to turn it inside out, creating a fresh gate to incarnate more demons."
      },
      {
        name: "The Hellwhisper Ring",
        category: "Weird Scholarship",
        desc: `The ring is made of tiny bits of bone wired together. It must be worn for at least a day per year of the bearer's life before it begins to work. When placed on a source of information, the ring sifts it until the ring speaks the information's "language." The bearer can see through riddles, read arcane texts, and break code with ease.`,
        narrative: "Legend says 32 demons voluntarily gave some of their bone to be part of this ring, and it was released among humans to cause chaos through greater understanding."
      },
      {
        name: "The Helsman Inheritance",
        category: "Misplaced Fortune",
        desc: "The final will and testament of the clan's patriarch included a 24 hour locked-house condition. Survivors would split the inheritance. Darayl Helsman left the house at the end of the time with a small bag. Explorers found nothing but corpses in the house, the inheritance was gone. Darayl was found dead the next day, the bag gone. The city locked the house and guards against trespassers.",
        narrative: "Surely Darayl hid the inheritance in the Ghost Field. Find the ghost key and lock in the house, and get it all! Or, did someone else already get it?"
      },
      {
        name: "The Key Lens",
        category: "Weird Scholarship",
        desc: 'The round frame has forty special lenses hinged on its rim. The lenses can layer over each other, flip out past the frame, rotate to take advantage of the angles inside the ground crystal, and take translucent colored filters. Their inventor, VLAS HALDAK, said he had found "the key." He died of shock, the lens on his work table.',
        narrative: "Legends vary. It can see into the Ghost Field, it can see into people, it allows reading demonic texts, it can see the way into ghost neighborhoods, etc. Needs a Whisper to use properly."
      },
      {
        name: "The Leviathan's Eye",
        category: "Famous Jewel",
        desc: "This sapphire turns impossibly black if dipped in leviathan blood. If the still-bloody stone is pressed against a seer's forehead, the sensitive can see what the ocean sees, looking above the waves or probing the deeps. The gem used to be passed around between leviathan hunter captains, but has since been lost.",
        narrative: "One expert said using the Eye was as close as a human could get to a demon seeing through its elemental affinity, and that it began a slow change in the individual who was exposed to its power."
      },
      {
        name: "The Tabissera Diary",
        category: "Weird Scholarship",
        desc: "Warden Khalana Uress was the Head Confessor of the Spirit Wardens. She recorded secrets that were only for the use of the order using a book code, coordinates that pointed to words in a specific book. Without that book, the code cannot be cracked. Daring thieves took the book, then lost it.",
        narrative: "Fakes come on the market all the time. Only the Spirit Warden leadership know what the book looked like, and they aren't telling. What is the Diary about?"
      },
      {
        name: "The Thousand Facet Diamond",
        category: "Famous Jewel",
        desc: "This gem is the elegant centerpiece on the back of a peculiar clockwork gauntlet. A seer can use the gauntlet to travel into the Ghost Field while retaining physical presence, or possibly even other dimensions. Each use burns out some of the diamond facets. The device is reported to have a mind of its own.",
        narrative: "Ever since its theft from the Adelairde family, the gauntlet has surfaced only in rumors of especially daring heists or mind-shattering experiments."
      },
      {
        name: "Whitecrown Signet Ring",
        category: "Family Heirloom",
        desc: "The Whitecrown family schismed in the wake of the theft of the matriarch's signet ring over two centuries ago. They fell from being players in the intrigues around the throne to bickering over dwindling family holdings. Their wealth and influence is low, but not beyond recall.",
        narrative: "If the ring resurfaced, elements of the feud might put aside their differences and reunite. Besides, legends suggest a ghost matriarch is bound to the ring, and she knows their secrets."
      }
    ]
  }
};
const ClockKey_SVGDATA = {
  1: {
    height: 836,
    width: 230,
    paths: [
      "M217.017,123.52c-1.6-0.8-2.84-1.44-4.1-2.04c-1.12-0.53-2.26-1.04-3.42-1.51 c-1.05-0.43-2.18-0.68-3.18-1.19c-0.89-0.45-1.23-1.23-1.2-2.36c0.09-4.48-0.07-8.97,0.05-13.45c0.08-3.31-0.83-6.47-1.14-9.72 c-0.01-0.14-0.09-0.28-0.14-0.42c-0.57-2.01-1.2-4.01-1.69-6.04c-0.45-1.85-0.75-3.74-1.11-5.61 c-0.012-0.043-0.023-0.085-0.035-0.127c-0.6-1.69-1.348-3.353-1.825-5.083c-0.46-1.66-0.68-3.38-1.03-5.07 c-0.04-0.24-0.16-0.47-0.25-0.7c-0.49-1.32-0.98-2.65-1.47-3.97c-0.55-1.44-0.93-2.97-1.69-4.28c-0.79-1.35-0.65-3.03,0.61-4.19 c0.43-0.39,0.85-0.85,1.08-1.36c0.57-1.3,1.35-2.62,1.44-3.97c0.08-1.11-0.46-3.08-1.14-3.29c-1.58-0.47-3.49-0.42-5.1,0.03 c-1.41,0.4-2.59,1.63-4.07,2.62c-1.15-1.18-2.43-2.41-3.6-3.75c-0.41-0.47-0.43-1.29-0.82-1.78c-0.67-0.84-1.56-1.5-2.23-2.33 c-0.18-0.22-0.08-0.9,0.13-1.16c0.85-1.02,1.78-1.97,2.71-2.92c2.18-2.22,4.37-4.45,6.57-6.65c0.85-0.86,1.78-1.64,2.63-2.5 c1.16-1.17,2.38-2.29,3.37-3.59c0.66-0.88,0.89-2.07,1.42-3.06c0.86-1.63,0.01-3.02-0.68-4.31c-0.23-0.43-1.4-0.4-2.15-0.48 c-0.69-0.08-1.4,0.02-2.09-0.02c-1.71-0.11-3.14,0.17-4.52,1.47c-1.22,1.14-2.96,1.74-4.44,2.62c-0.98,0.59-1.89,1.31-2.88,1.88 c-2.02,1.17-4.2,2.11-6.07,3.47c-1.12,0.81-2.16,1.18-3.49,1.4c-1.28,0.22-2.44,1.1-3.7,1.59c-0.58,0.23-1.72,0.49-1.82,0.3 c-0.91-1.63-2.75-1.79-4.03-2.77c-0.33-0.25-0.58-0.62-0.93-0.82c-1.11-0.64-2.26-1.22-3.38-1.85c-1.48-0.83-2.94-1.7-4.42-2.53 c-0.93-0.53-1.83-1.24-2.84-1.5c-1.37-0.35-2.24-1.96-3.89-1.5c-0.08,0.03-0.19-0.02-0.29-0.04c-1.97-0.58-3.94-1.16-5.91-1.73 c-0.28-0.08-0.76-0.02-0.84-0.18c-0.89-1.7-2.8-1.2-4.1-1.6c-2.83-0.87-5.94-0.87-8.94-1.22c-0.39-0.04-1.05,0.06-1.14-0.13 c-0.79-1.56-2.21-1.01-3.4-1.05c-2.09-0.08-2.68-0.62-2.72-2.65c-0.01-0.84-0.1-1.69-0.24-2.51c-0.16-0.88-0.54-1.72-0.62-2.59 c-0.13-1.24-0.03-2.49-0.11-3.73c-0.06-0.88-0.61-1.45-1.5-1.13c-0.79,0.28-1.59,0.72-2.21,1.28c-1.48,1.36-2.85,2.84-4.29,4.25 c-1.1,1.08-2.08,2.06-3.81,2.55c-1.54,0.44-2.99,1.69-4.63,2.42c-1.79,0.8-3.28,2.25-5.44,2.13c-0.44-0.02-1.16-0.02-1.28,0.22 c-0.7,1.36-1.94,0.82-2.98,0.97c-0.49,0.07-0.99,0.11-1.47,0.24c-1.92,0.49-3.84,0.98-5.75,1.52c-1.74,0.49-3.51,0.95-5.19,1.61 c-1.92,0.74-3.67,1.99-5.63,2.46c-1.64,0.38-3.01,1.13-4.51,1.72c-0.99,0.39-2.52,0.38-3.43-0.13c-1.93-1.09-4.28-1.09-6.03-2.54 c-0.22-0.19-0.67-0.12-1.02-0.13c-0.9-0.02-1.79-0.02-2.69-0.02c-1.37,0.01-2.19,0.72-2.36,2.15c-0.09,0.78-0.06,1.59-0.09,2.38 c-0.01,0.35,0.11,0.87-0.06,1.02c-1.68,1.35-0.89,3.24-1.18,4.9c-0.16,0.88-0.56,1.8-1.1,2.51c-0.75,0.99-1.76,1.79-2.61,2.72 c-1.02,1.1-1.99,2.26-2.99,3.39c-1.49,1.67-2.96,3.37-4.5,5c-1.36,1.45-2.81,2.83-4.2,4.25c-0.16,0.17-0.19,0.46-0.31,0.67 c-0.74,1.29-1.39,2.64-2.25,3.84c-0.89,1.25-2.63,1.86-2.72,3.75c-0.02,0.38-0.57,0.73-0.86,1.11c-0.37,0.49-0.79,0.96-1.07,1.5 c-0.73,1.39-1.26,2.89-2.1,4.21c-1.08,1.71-2.25,3.34-2.65,5.38c-0.07,0.32-0.39,0.6-0.57,0.91c-0.21,0.34-0.45,0.67-0.59,1.05 c-0.43,1.21-0.72,2.48-1.24,3.65c-0.79,1.76-1.75,3.45-2.6,5.19c-1.27,2.6-2.74,5.13-3.69,7.85c-0.5,1.45-0.18,3.23-0.08,4.85 c0.05,0.7,0.68,1.37,0.69,2.06c0.06,6.07,0.06,12.15,0.01,18.23c0,0.71-0.37,1.44-0.63,2.13c-0.35,0.95-1.04,1.85-1.09,2.8 c-0.07,1.31-1.04,1.92-1.62,2.82c-0.91,1.43-2.71,1.9-3.59,3.51c-1.01,1.85-0.94,3.91,0.46,5.41c1.17,1.24,2.59,0.75,3.93,0.97 c1.41,0.22,3.01,0.26,4.12,0.99c1.11,0.74,1.87,2.16,2.5,3.43c0.77,1.56,1.35,3.24,1.8,4.92c0.67,2.5,0.94,5.12,2.32,7.4 c0.56,0.92,1.03,1.9,1.52,2.87c0.51,1.03,0.96,2.09,1.48,3.11c0.56,1.09,1.13,2.18,1.77,3.22c0.29,0.48,0.84,0.8,1.16,1.26 c0.61,0.87,1.11,1.82,1.71,2.69c0.32,0.47,0.83,0.81,1.16,1.27c0.93,1.3,1.79,2.65,2.73,3.95c0.31,0.43,0.83,0.69,1.15,1.11 c0.52,0.69,0.89,1.51,1.44,2.16c0.41,0.48,1.1,0.72,1.54,1.18c1.57,1.66,3,3.46,4.65,5.03c1.3,1.26,2.91,2.18,4.25,3.4 c1.99,1.84,3.82,3.85,5.81,5.7c0.51,0.47,1.42,0.47,1.99,0.9c0.95,0.71,1.78,1.59,2.88,2.59c-0.72,0.66-1.63,1.5-2.55,2.33 c-0.78,0.7-1.61,1.34-2.34,2.07c-1.54,1.55-3.05,3.13-4.54,4.73c-1.24,1.32-2.6,2.56-3.6,4.05c-0.6,0.91-1.1,1.85-1.89,2.63 c-1.23,1.21-1.21,4.03,0.24,4.66c1.03,0.45,2.61,0.53,3.57,0.03c1.41-0.72,2.76-0.5,4.14-0.57c1.93-0.09,3.89,0.02,5.8-0.21 c1.19-0.14,2.33-0.75,3.46-1.2c0.49-0.19,0.89-0.6,1.38-0.76c0.46-0.16,1.13,0.06,1.45-0.21c2.19-1.82,5.18-1.79,7.53-3.48 c1.41-1.01,3.25-2.21,5.36-2.06c0.28,0.02,0.58-0.29,0.88-0.44c0.42-0.22,0.85-0.61,1.29-0.62c3.43-0.04,6.86,0,10.3,0.03 c0.38,0,0.99-0.01,1.11,0.21c0.64,1.13,1.69,0.85,2.63,0.91c1.1,0.06,2.24-0.13,3.27,0.14c2.96,0.79,5.9,1.59,9,1.58 c6.02-0.03,12.05,0.27,18.01-0.93c0.82-0.17,1.69-0.08,2.52-0.24c1.04-0.2,2.05-0.52,3.14-0.81c0.13,0.6,0.21,0.79,0.21,0.98 c0.01,8.226,0.03,16.462,0.01,24.699c-0.001,0.368-0.217,0.882-0.515,1.099c-0.676,0.493-1.572,0.71-2.176,1.273 c-1.37,1.26-2.6,2.68-3.92,4c-0.73,0.73-1.61,1.32-2.31,2.08c-0.98,1.06-0.96,2.42-0.9,3.78c0.07,1.95,0.64,2.62,2.59,2.67 c1.712,0.061,3.434,0.019,5.146,0.03c1.112,0.007,2.014,0.908,2.024,2.02c0.06,6.72,0.08,13.44,0.15,20.16 c0.019,1.205-0.537,1.936-1.437,2.533c-0.23,0.153-0.451,0.318-0.644,0.516c-1.605,1.643-3.165,3.308-4.789,4.931 c-0.63,0.64-1.57,1.05-2.01,1.79c-1.29,2.14-3.22,3.55-5.3,4.69c-2.51,1.38-2.76,1.58-2.61,4.33c0.09,1.65,1.84,3.48,3.41,3.17 c1.82-0.35,3.74-0.85,5.26-1.85c0.77-0.51,1.38-0.68,2.16-0.71c0.95-0.04,1.9-0.01,2.84-0.01c2.59,0.01,3.03,0.46,3.03,3.1 c-0.01,31.18-0.02,62.36-0.04,93.55c0,2.88-0.13,5.78,0.03,8.66c0.16,2.8,0.67,5.58,0.91,8.39c0.15,1.83,0.08,3.68,0.15,5.52 c0.02,0.42,0.14,0.85,0.29,1.25c0.23,0.58,0.66,1.12,0.75,1.72c0.13,0.93-0.34,2.21,0.13,2.78c1.82,2.18-0.35,4.04-0.21,6.04 c0.01,0.2-0.21,0.41-0.31,0.62c-0.53,1.08-1.43,2.14-1.49,3.24c-0.21,4.27-0.19,8.56-0.19,12.84 c-0.01,51.9,0.01,103.81-0.05,155.71c0,4.36-0.54,8.71-0.84,13.06c-0.03,0.34-0.19,0.66-0.31,0.98c-0.25,0.69-0.73,1.36-0.74,2.05 c-0.12,5.68-0.07,11.36-0.23,17.03c-0.11,3.65-0.78,7.31-0.68,10.95c0.12,4.59-0.27,9.16,0.58,13.82 c0.85,4.63,0.19,9.53,0.21,14.31c0.01,1-0.27,2.32,0.24,2.92c1.2,1.39,0.69,2.89,0.79,4.35c0.03,0.33-0.22,0.7-0.37,1.03 c-0.25,0.55-0.55,1.06-0.76,1.62c-0.17,0.44-0.2,0.93-0.36,1.38c-0.47,1.36-0.97,2.72-1.45,4.08c-0.11,0.31-0.11,0.7-0.3,0.94 c-1.58,2-2.33,4.36-2.52,6.8c-0.23,3.07-0.06,6.17-0.08,9.26c-0.02,3.62,0.05,7.24,0.93,10.78c0.07,0.3,0.39,0.56,0.42,0.86 c0.13,1.29,0.2,2.59,0.29,3.88c-0.91,0.05-1.84,0.23-2.72,0.09c-0.66-0.1-1.24-0.71-1.91-0.9c-1.83-0.53-3.81,1.69-3.74,3.17 c0.1,2.16,0.3,4.33,1.59,6.15c1.14,1.6,2.44,3.09,3.73,4.57c1.18,1.36,2.64,2.45,2.25,4.66c-0.47,2.6-0.66,5.25-1.01,8.26 c-4.52,0.25-8.9,0.65-13.3,0.72c-8.65,0.13-17.32,0.08-25.98,0.13c-0.58,0-1.24-0.02-1.74,0.22c-1.03,0.49-1.92,1.28-2.97,1.7 c-1.85,0.75-3.77,1.31-5.65,1.96c-0.22,0.07-0.42,0.22-0.63,0.32c-1.16,0.57-2.28,1.38-3.51,1.64c-1.03,0.21-1.79,0.61-2.49,1.28 c-0.2,0.19-0.4,0.5-0.62,0.51c-1.14,0.08-2.03,0.39-2.85,1.34c-0.63,0.73-1.75,1.04-2.67,1.49c-1.72,0.84-3.48,1.61-5.18,2.49 c-1.48,0.77-3.04,1.49-4.33,2.53c-1.49,1.21-2.68,2.8-4.09,4.14c-0.84,0.79-1.75,1.75-2.79,2.02c-1.46,0.39-2.97,0.34-4.52,0.83 c-2.05,0.64-4.39,0.08-6.57,0.95c-1.38,0.54-3.25-0.48-4.4,1.21c-0.07,0.1-0.38,0.03-0.58,0.05c-2.5,0.25-4.95-0.04-7.53,0.73 c-3.19,0.97-6.74,0.74-10.14,1.08c-0.59,0.06-1.36,0.23-1.7,0.63c-0.83,1.02-0.42,3.75,0.69,4.4c0.91,0.54,2,0.82,3.05,1.07 c0.66,0.15,1.4-0.06,2.08,0.05c1.68,0.29,3.67-0.91,5.01,1.05c0.07,0.1,0.38,0.06,0.58,0.07c4.87,0.2,9.72,0.09,14.61,0.8 c4.38,0.64,8.94-0.01,13.42,0.18c3.03,0.13,5.86-0.88,8.82-1.09c0.14-0.01,0.35-0.06,0.4-0.15c0.61-1.3,1.84-0.85,2.85-1.06 c0.57-0.11,1.2-0.3,1.65-0.65c0.83-0.64,1.45-1.63,2.35-2.1c2.5-1.32,4.56-3.31,7.19-4.45c1-0.43,1.58-0.43,2.51,0.04 c0.62,0.31,1.68,0.25,2.33-0.08c1.06-0.53,1.88-0.64,2.74,0.22c0.76,0.76,1.53,1.51,2.34,2.23c1.14,1.02,2.41,1.91,3.46,3.02 c1.04,1.08,1.85,2.38,2.78,3.56c1.11,1.4,4.49,1.72,5.94,0.58c1.29-1.01,1.57-2.52,1.85-3.97c0.24-1.24,0.03-2.49,0.68-3.78 c0.9-1.75,1.39-2.39,3.41-2.36c2.29,0.02,4.58,0.1,6.87,0.11c1.04,0.01,1.62,0.52,1.84,1.5c0.31,1.31,0.45,2.68,0.96,3.9 c0.36,0.85,1.11,1.71,1.91,2.16c1.23,0.7,4.69-0.66,5.09-2.01c0.53-1.73,1.15-3.6,1-5.35c-0.24-2.82,1.44-4.54,2.89-6.43 c0.3-0.39,1.44-0.68,1.72-0.45c1.45,1.23,3.45,2.17,3.18,4.62c-0.06,0.64,0.09,1.3,0.02,1.94c-0.31,3.01-0.68,6.01-0.98,9.02 c-0.08,0.86-0.01,1.74-0.01,2.77c1.08-0.07,1.88-0.05,2.64-0.18c1.12-0.2,2.2-0.62,3.32-0.73c1.38-0.13,2.78-0.05,4.18-0.04 c1.86,0.01,2.13,0.24,1.82,2.07c-0.17,1-0.42,2.39-1.12,2.8c-1.1,0.65-0.86,1.44-0.87,2.24c-0.05,2.1-0.03,4.19-0.01,6.28 c0.01,0.44,0,1.19,0.2,1.26c1.41,0.53,0.81,1.71,0.98,2.64c0.17,0.9,0.34,1.81,0.64,2.66c0.39,1.08-0.23,3.51-1.19,3.75 c-1.67,0.43-3.39,0.66-5.09,0.99c-1.84,0.36-3.67,0.72-5.5,1.11c-0.22,0.05-0.4,0.28-0.61,0.39c-0.43,0.23-0.85,0.56-1.3,0.63 c-0.594,0.081-1.208,0.05-1.82,0.036c-1.386-0.033-2.643-0.905-3.075-2.222c-0.613-1.87-0.822-3.704-0.936-5.614 c-0.03-0.33-0.6-0.59-0.79-0.96c-0.43-0.85-1.13-1.77-1.07-2.62c0.07-0.98,1.05-1.44,2.19-1.38c0.81,0.04,1.64-0.21,2.44-0.43 c0.59-0.16,1.12-0.55,1.72-0.69c0.52-0.12,1.09-0.06,1.63-0.02c1.25,0.08,1.8-0.43,1.76-1.72c-0.05-1.89,0.01-3.78-0.01-5.68 c-0.01-1.66-0.83-2.55-2.56-2.57c-3.84-0.04-7.67-0.02-11.5,0.02c-1.16,0.01-1.74,0.7-1.85,1.83c-0.05,0.54-0.08,1.09-0.24,1.6 c-0.48,1.6-1.38,3.17-1.45,4.78c-0.08,1.83-0.74,3.01-2.08,4.1c-0.83,0.67-1.56,0.79-2.23,0.04c-1.08-1.22-2.09-2.51-3.04-3.83 c-1.06-1.48-1.88-3.17-3.08-4.51c-0.91-1.03-1.92-2.41-3.7-1.84c-0.51,0.17-0.93,0.69-1.44,0.79c-2.58,0.46-4.33,2.33-6.35,3.7 c-2.13,1.45-4.2,2.53-6.93,2.33c-3.17-0.24-6.37-0.07-9.55-0.09c-0.4,0-0.93,0.1-1.16-0.1c-1.75-1.51-4.32-2.07-5.29-4.5 c-0.06-0.13-0.33-0.24-0.5-0.25c-2.1-0.1-3.95-1.56-6.16-1.07c-0.31,0.07-0.68-0.08-1.02-0.17c-0.9-0.25-1.8-0.73-2.71-0.75 c-4.62-0.08-9.25-0.03-13.88-0.05c-0.46,0-0.94-0.13-1.38-0.29c-0.63-0.24-1.23-0.8-1.85-0.81c-6.97-0.06-13.94-0.01-20.91-0.06 c-1.47-0.01-2.4,0.9-3.11,1.81c-1.58,2.02,0.43,5.8,3.19,6.29c1.71,0.31,3.41,0.64,5.12,0.96c0.19,0.04,0.49,0.05,0.55,0.17 c0.65,1.18,1.78,0.83,2.77,0.94c2.9,0.31,5.78,0.66,8.67,1c0.103,0.019,0.206,0.038,0.308,0.057c2.154,0.545,4.296,1.193,6.481,1.6 c1.241,0.232,2.507,0.15,3.769,0.183c0.284,0.007,0.568,0.119,0.821,0.24c0.62,0.28,1.22,0.6,1.83,0.9 c1.33,0.65,2.68,1.25,3.98,1.96c0.4,0.22,0.6,0.76,0.96,1.06c1.45,1.23,2.93,2.41,4.37,3.64c0.97,0.82,1.92,1.67,2.84,2.54 c1.98,1.86,3.98,3.71,5.89,5.64c1.72,1.72,3.46,3.45,4.97,5.36c1.54,1.93,3.34,2.52,5.79,2.51c18.47-0.08,36.94-0.01,55.4,0.02 c2.17,0,4.19,0.14,5.7-2.14c1.09-1.64,2.99-2.73,4.39-4.2c0.74-0.77,1.1-1.87,1.77-2.73c0.68-0.88,1.47-1.69,2.3-2.45 c1.56-1.45,2.81-3.12,3.91-4.94c0.46-0.76,1.51-1.22,1.86-2.01c0.76-1.74,1.56-3.38,3.08-4.61c0.42-0.34,0.88-0.97,0.86-1.44 c-0.08-1.47,0.99-2.28,1.57-3.39c0.75-1.42,1.61-2.73,1.52-4.59c-0.21-4.42-0.08-8.86-0.05-13.29c0-0.61,0.19-1.23,0.35-1.83 c0.14-0.49,0.55-0.98,0.49-1.43c-0.39-3,0.95-5.77,1.1-8.7c0.01-0.2,0.23-0.39,0.34-0.59c0.26-0.47,0.56-0.92,0.78-1.41 c0.59-1.37,1.1-2.77,1.75-4.11c0.19-0.39,0.85-0.54,1.1-0.93c1.25-1.87,2.56-3.71,3.58-5.7c0.73-1.41,1.8-2.83,1.37-4.6 c-0.1-0.41-0.44-1.03-0.73-1.07c-2.3-0.28-4.43-1.46-6.87-1.09c-1.41,0.21-2.88,0.03-4.32,0.03c-2.22,0-2.56-0.51-2.76-2.74 c-0.2-2.19,1.03-4.66-1.1-6.53c-0.08-0.07-0.02-0.29-0.04-0.44c-0.26-2.65,0.17-5.27-0.75-7.99c-0.82-2.44,0.02-5.23-0.93-7.92 c-0.87-2.51,0.15-5.31-1.06-8.11c-1.14-2.64-0.76-5.92-1.16-8.91c-0.31-2.31,0.38-4.77-0.96-6.94c-0.31-0.5-0.91-0.93-1-1.46 c-0.41-2.24-0.68-4.5-1.01-6.76c-0.32-2.2-0.65-4.4-0.99-6.6c-0.03-0.19-0.09-0.47-0.23-0.53c-1.21-0.55-0.86-1.61-0.88-2.55 c-0.25-12.95,0.26-25.89-0.76-38.84c-0.645-8.159-0.207-16.407-0.21-24.606c0-0.326,0.03-0.655,0.132-0.964 c0.498-1.505,1.628-2.909,1.808-4.439c0.32-2.74,0.57-5.52,0.82-8.26c0.521-5.744,0.168-11.569,0.15-17.363 c-0.001-0.411-0.054-0.823-0.201-1.207c-0.519-1.358-1.356-2.643-1.619-4.039c-0.5-2.67-0.7-5.39-1.02-8.09 c-0.04-0.39-0.08-0.79-0.07-1.19c0.07-3.15-0.3-6.32,0.69-9.42c0.41-1.29-0.17-2.87,1.22-3.88c0.1-0.07,0.06-0.37,0.06-0.57 c0.04-8.32,0.08-16.64,0.08-24.96c0-0.43-0.28-0.88-0.45-1.31c-0.19-0.46-0.56-0.9-0.58-1.36c-0.48-11.05,0.53-22.1-0.75-33.17 c-0.77-6.68-0.15-13.52-0.19-20.29c-0.02-4.13-0.15-8.26-0.15-12.39c-0.01-44.063-0.01-88.115,0-132.178 c0-0.883,0.011-1.77,0.117-2.647c0.323-2.687-0.394-5.417,0.813-8.095c0.54-1.2,0.09-2.85,0.14-4.29c0.01-0.42,0.12-0.86,0.28-1.25 c0.26-0.62,0.63-1.2,0.88-1.82c0.14-0.36,0.1-0.78,0.19-1.16c0.48-2.02,1-4.03,1.44-6.05c0.25-1.17-0.47-2.63,1.09-3.39 c0.11-0.05,0.1-0.36,0.11-0.56c0.28-4.51,0.31-9,0.88-13.53c0.7-5.49,0.44-11.15,0.13-16.71c-0.31-5.55,1.18-10.95,0.94-16.46 c-0.02-0.62,0-1.25,0-1.92c0.98-0.1,1.74-0.1,2.45-0.27c0.7-0.17,1.35-0.53,2.03-0.75c1.92-0.62,2.45-1.33,2.42-3.39 c0-0.43-0.07-0.86-0.12-1.48h-4.97c-1.98-0.01-2.64-0.7-2.65-2.73c-0.01-0.75,0.05-1.5-0.01-2.25c-0.53-6.86,1.3-13.97-2.06-20.55 c0.49-2.24-1.35-4.79,0.96-6.8c1.23-1.08,2.27-2.42,3.62-3.33c1.23-0.83,2.52-1.47,3.3-2.84c0.8-1.42,2.89-2.31,4.31-1.95 c1.05,0.28,2.12,0.53,3.13,0.92c2.26,0.86,4.46,1.89,6.75,2.65c0.94,0.32,2.23,0.47,3.05,0.06c1.77-0.89,2.89-2.77,3.34-4.51 c0.76-2.92,0-5.91-1.12-8.69c-0.5-1.24-0.4-1.92,0.76-2.43c1.71-0.75,3.37-1.59,5.07-2.37c2.07-0.95,3.93-2.43,6.34-2.56 c0.29-0.02,0.55-0.33,0.84-0.5c0.37-0.23,0.78-0.65,1.14-0.63c1.59,0.13,3.06-0.23,4.74,0.92c1.61,1.11,4.13,0.99,6.27,1.19 c1.93,0.17,2.82-0.82,3-2.78c0.04-0.43,0.26-0.88,0.47-1.28c0.39-0.75,1.16-1.46,1.2-2.22c0.07-1.42,0.75-3-1.6-3.85 c-1.72-0.61-2.93-2.52-4.52-3.62c-1.38-0.96-2.98-1.6-4.73-2.51c0.24-0.6,0.46-1.24,0.75-1.85c0.82-1.72,1.67-3.42,2.49-5.13 c0.34-0.73,0.5-1.6,1.01-2.17c1.42-1.63,1.98-3.64,2.79-5.55c0.36-0.87,0.45-1.99,1.06-2.59c1.09-1.06,1.52-2.34,1.98-3.69 c0.29-0.85,0.66-1.68,1.09-2.46c0.51-0.93,1.33-1.73,1.67-2.7c0.81-2.39,2.14-3.18,4.45-2.38c0.31,0.1,0.7,0.11,1.03,0.04 c1.17-0.22,2.36-0.41,3.5-0.76c1.24-0.38,2.44-0.9,3.62-1.43c0.21-0.08,0.37-0.5,0.37-0.77 C217.026,126.28,217.017,124.66,217.017,123.52z M143.507,186.1c-0.82,0.65-1.72,0.95-2.7,1.06c-9.15,3.4-19.04,5.26-29.37,5.26 c-46.57,0-84.32-37.75-84.32-84.32c0-46.56,37.75-84.31,84.32-84.31c46.56,0,84.31,37.75,84.31,84.31 C195.747,143.31,174.167,173.48,143.507,186.1z",
      "M214.327,133.65c-1.07-0.77-2.58-1.24-3.21-2.27c-2.25-3.6-6.31-7.65-5.88-11.05 c1.52-12.04-0.33-23.52-2.8-35.1c-1.17-5.49-2.18-10.99,4.72-14.06c1.08-0.48,1.88-3.13,1.63-4.57c-0.19-1.07-2.16-2.19-3.55-2.64 c-6.7-2.14-12.98-4.88-17.4-10.69c-8.86-11.65-19.24-21.69-32.64-27.85c-6.64-3.05-11.86-6.24-11.09-14.54 c0.07-0.78-0.31-1.64-0.64-2.4c-1.25-2.84-2.56-5.66-3.84-8.48c-2.09,2.6-4.15,5.23-6.27,7.81c-1.41,1.73-2.68,4.5-4.41,4.85 c-5.32,1.1-10.85,1.76-16.28,1.67c-10.63-0.18-20.99,1.14-30.97,4.67c-7.85,2.78-15.14,3.77-22.72-1.31 c-3.42-2.29-8.09-2.69-13.48-4.35c1.1,3.41,1.68,5.25,2.3,7.08c2.66,7.87,2.9,14.94-4.11,21.28c-9.76,8.83-16.78,19.74-21.74,31.96 c-3.43,8.43-7.09,16.77-10.4,25.25c-0.69,1.77-0.76,4.07-0.31,5.93c1.61,6.58,3.4,13.13,5.43,19.59c3.09,9.77,5.6,19.86,9.93,29.08 c3.68,7.83,9.58,14.63,14.68,22.14c-0.79,0.96-2.1,2.1-2.8,3.53c-1.36,2.82-2.37,5.81-3.53,8.72c3.12,0.11,6.55,1.11,9.29,0.15 c8.09-2.86,14.4-0.35,20.54,4.73c2.39,1.98,2.05,3.36,0.46,5.32c-5.83,7.15-10.71,15.15-18.99,20.06 c-0.98,0.57-0.82,3.05-1.18,4.65c1.4,0.24,3.08,1.12,4.16,0.63c10.45-4.67,20.76-9.67,31.2-14.38c6.31-2.84,12.43-5.88,19.84-5.85 c10.42,0.05,20.84-1.07,31.26-1.7c1.76-0.11,3.51-0.28,5.42-0.43c0.16,1.54,0.36,2.51,0.36,3.49 c-0.02,59.51,0.09,119.02-0.28,178.52c-0.04,6.76-2.01,13.66-6.63,19.46c-5.78,7.26-11.13,14.88-16.46,22.49 c-0.72,1.03-0.2,2.93-0.26,4.43c1.3-0.02,2.66,0.24,3.87-0.09c5.76-1.56,11.47-3.28,18.14-5.22c0.62,6.25,1.49,10.98,1.5,15.73 c0.13,47,0.21,94.01,0.09,141.01c-0.02,9.45-0.81,18.9-1.43,28.34c-0.51,7.62-1.87,15.22-1.81,22.82 c0.09,11.27,1.35,22.52,1.59,33.8c0.11,4.87-1.07,9.77-1.69,14.65c-0.95,7.5-2.36,14.98-2.73,22.51c-0.3,6.1,1.55,12.38,0.78,18.37 c-0.97,7.49-5.01,14.53-11.46,18.32c-5.29,3.13-12.04,4.52-18.29,5.09c-7.23,0.66-14.61-0.47-21.92-0.75 c-7.56-0.29-13.36-5.01-15.18-12.31c-0.24-0.97-0.97-2.04-1.79-2.6c-3.54-2.44-7.19-4.7-11.02-7.17 c-6.83,8.88-7.82,11.33-7.65,21.13c0.27,15.78,1.28,31.58,0.87,47.34c-0.19,7.12-0.36,13.84,2.91,20.27 c0.57,1.13,1.4,2.86,2.29,2.97c6.4,0.82,12.69,3.55,19.18-1.16c3.35-2.42,8.23-3.21,12.54-3.72c7.41-0.88,14.92-0.84,22.37-1.43 c4.08-0.32,7.49-1.9,7.64-6.78c0.16-4.95,2.49-7.46,7.41-7.25c1.26,3.22,2.35,6.35,3.73,9.34c0.48,1.05,1.56,2.34,2.55,2.54 c3.24,0.62,6.57,0.74,9.86,1.16c3.38,0.42,5.09-0.92,6.01-4.3c1.78-6.56,3.92-13.02,6.08-19.47c1.92-5.71,2.31-11.28-0.26-16.93 c-0.69-1.51-0.6-3.37-1.02-5.99c2.46,0.64,3.97,1.18,5.52,1.41c2.3,0.33,4.62,0.44,6.93,0.65c-0.07-2.7,0.5-5.64-0.37-8.06 c-1.39-3.88-4.05-7.3-5.6-11.14c-2.34-5.79-5.86-11.75-5.96-17.69c-0.58-35.66-0.34-71.34-0.33-107.01c0-1.81,0.12-3.68,0.57-5.42 c3.38-13.1,3.56-26.5,1.68-39.63c-1.53-10.75-1.54-20.97,1.15-31.44c1.09-4.23,1.29-8.84,1.02-13.23 c-1.21-19.88-3.7-39.73-3.94-59.61c-0.62-50.99-0.29-102-0.34-153.01c0-1.66-0.07-3.35,0.18-4.98c1.91-12.43,4.96-24.78,5.62-37.26 c1.28-24.01,3.36-48.15-1.87-72.06c-0.27-1.25,0.73-3.34,1.8-4.23c9.73-8.05,9.78-8,20.31-1.11c0.7,0.46,1.39,1.05,2.17,1.23 c2.36,0.55,6.51,1.85,6.85,1.21c1.35-2.54,2.6-5.99,1.92-8.6c-2.38-9.22-2.43-17.78,3.82-25.59c2.88-3.6,5.07-8.11,8.66-10.71 c4.75-3.45,10.65-5.28,15.88-8.13c2.41-1.3,5.32-2.92,6.4-5.17C220.707,136.36,216.637,135.31,214.327,133.65z M111.437,192.42 c-46.57,0-84.32-37.75-84.32-84.32c0-46.56,37.75-84.31,84.32-84.31c46.56,0,84.31,37.75,84.31,84.31 C195.747,154.67,157.997,192.42,111.437,192.42z",
      "M216.086,109.69c-0.08-0.48,0.02-1-0.02-1.5c-0.07-0.95,0.16-2.22-0.36-2.76 c-0.73-0.76-2.03-0.97-3.07-1.46c-0.63-0.3-1.24-0.67-1.83-1.05c-0.53-0.33-1.08-0.65-1.53-1.07c-0.8-0.74-1.92-0.81-2.57-2.09 c-1.13-2.22-0.49-4.7-1.75-6.94c-1-1.8,0.07-4.32-0.91-6.51c-0.3-0.67,0.89-2,1.37-3.04c0.65-1.39,2.31-2.03,2.57-3.75 c0.12-0.81,0.64-1.61,1.15-2.28c1.78-2.38,1.16-5.33-1.31-6.02c-1.49-0.42-2.55-1.16-3.72-2.06c-1.21-0.92-2.77-1.49-4.25-1.92 c-1.54-0.44-2.15-1.61-2.84-2.79c-0.59-1.02-1.09-2.11-1.76-3.08c-0.71-1.02-1.59-1.93-2.47-2.98c0.35-0.13,0.74-0.16,0.86-0.35 c1.27-2.02,3.25-2,5.28-1.95c1.15,0.02,2.4,0.21,3.44-0.16c1.28-0.45,2.71-1.16,3.49-2.19c1.24-1.65-0.42-4.48-2.46-4.74 c-1.98-0.25-3.94-0.58-5.91-0.89c-0.18-0.03-0.34-0.15-0.51-0.22c-0.77-0.33-1.52-0.72-2.32-0.95c-0.57-0.16-1.22,0.01-1.79-0.13 c-2.14-0.53-4.24-1.43-6.41-1.61c-1.69-0.14-2.87-0.66-4.02-1.8c-1.28-1.26-2.82-2.26-4.1-3.52c-0.3-0.29-0.23-1.24,0-1.73 c0.44-0.91,1.54-0.97,2.32-1.44c1.74-1.05,3.29-2.45,4.89-3.74c0.52-0.42,1.31-0.9,1.38-1.42c0.19-1.46,0.06-2.96,0.06-4.5 c-2.54-0.33-4.95-0.67-7.38-0.94c-0.89-0.1-1.81-0.01-2.71-0.03c-0.34-0.01-0.68-0.07-1.01-0.16c-0.89-0.23-1.76-0.69-2.64-0.7 c-4.02-0.08-8.04-0.03-12.07-0.05c-0.42,0-1.11,0-1.23-0.23c-1.12-2.09-3.02-1.96-4.92-1.88c-1.14,0.04-1.8-0.46-2.06-1.62 c-0.27-1.22-0.34-2.76-1.12-3.54c-1.17-1.16-0.68-2.45-1.05-3.64c-0.33-1.08-0.81-2.76-1.52-2.93c-2.01-0.5-4.21-0.87-6.23,0.31 c-0.93,0.54-1.88,1.05-2.87,1.44c-1.21,0.48-2.61,0.61-3.7,1.27c-1.77,1.08-3.79,0.89-5.3,0.34c-1.38-0.5-2.66-0.56-4-0.68 c-0.75-0.06-1.5-0.02-2.23-0.16c-0.94-0.18-1.87-0.77-2.76-0.69c-1.9,0.18-3.03-0.91-3.97-2.14c-1.29-1.72-2.14-3.79-3.53-5.41 c-1.31-1.54-1.8-3.71-3.74-4.73c-0.49-0.26-0.96-0.67-1.48-0.73c-0.94-0.12-1.92-0.14-2.85,0c-0.59,0.08-1.26,0.41-1.66,0.85 c-0.55,0.59-0.75,1.49-1.3,2.07c-1.44,1.55-2.99,3-4.48,4.5c-0.13,0.12-0.12,0.38-0.22,0.55c-0.46,0.75-0.9,1.52-1.42,2.22 c-0.5,0.67-1.12,1.24-1.62,1.91c-0.48,0.62-0.79,1.38-1.31,1.96c-1.39,1.54-3.54,0.54-5.35,1.73c-2.13,1.39-5.14,1.6-7.81,1.92 c-2.43,0.29-4.97,0.32-7.37-0.06c-1.44-0.23-2.84-1.32-4.04-2.3c-1.44-1.18-2.57-2.71-4.77-2.47c-0.61,0.06-1.27-0.43-2.23-0.78 c-0.27,0.91-0.79,1.91-0.83,2.92c-0.13,3.22-0.1,6.44-0.1,9.66c0,0.72-0.13,1.16-0.84,1.66c-1.79,1.24-3.39,2.74-5.12,4.08 c-0.33,0.26-0.9,0.26-1.36,0.33c-0.69,0.1-1.75-0.09-2.02,0.28c-0.84,1.21-1.97,0.84-3.05,0.96c-0.53,0.06-1.05,0.27-1.56,0.43 c-1.41,0.44-2.79,0.98-4.23,1.32c-1.4,0.33-3.13-0.6-4.16,1.16c-0.06,0.1-0.38,0.07-0.58,0.08c-1.15,0.07-2.3,0.17-3.45,0.2 c-2.18,0.07-2.94,0.91-2.47,2.97c0.12,0.55,0.55,1.09,0.97,1.51c0.85,0.82,1.83,1.51,2.67,2.35c1.09,1.09,2.1,2.27,2.99,3.24 c-0.99,1.5-1.8,2.84-2.73,4.09c-0.62,0.83-1.51,1.47-2.09,2.32c-1.11,1.6-2.09,3.3-3.12,4.96c-0.31,0.5-0.73,0.96-0.93,1.51 c-0.5,1.33-2.38,2.73-3.8,2.76c-1.15,0.03-2.49-0.24-3.4,0.26c-1.3,0.71-2.55,0.65-3.86,0.66c-2.14,0.01-4.03,0.57-5.36,2.35 c-0.3,0.41-0.32,1.02-0.56,1.48c-0.7,1.31-0.46,3.54,0.67,4.44c0.88,0.71,1.97,1.17,2.86,1.87c0.75,0.58,1.24,1.6,2.06,1.97 c1.26,0.57,1.85,1.38,1.54,2.64c-0.41,1.68,0.4,3.44-0.77,5.14c-0.67,1,0.34,2.85-1.26,3.76c-0.08,0.04-0.05,0.28-0.06,0.43 c-0.07,1.2-0.32,2.3-0.72,3.49c-0.69,2.08-1.06,4.24-2.44,6.06c-1.06,1.41-1.99,2.97-2.99,4.37c-1.47,2.05-3.91,3.38-5.93,5.04 c-0.77,0.63-1.44,1.4-2.26,1.94c-2.24,1.47-2.4,4.44-0.52,6.31c1.02,1.02,2.11,0.63,3.19,0.81c0.52,0.08,1.08,0.08,1.56,0.28 c1.37,0.58,2.71,1.21,4.05,1.87c0.66,0.33,1.54,0.63,1.86,1.2c0.54,0.99,0.73,2.18,1.06,3.29c0.11,0.38,0.15,0.8,0.33,1.14 c0.54,0.96,1.26,1.84,1.67,2.85c1.1,2.69,0.84,5.73,2.18,8.41c0.66,1.31,0.76,2.91,1.15,4.37c0.3,1.13,0.34,2.53,1.05,3.3 c0.9,0.97,0.77,1.95,0.91,3c0.09,0.63,0.37,1.24,0.6,1.95c-0.55,0.45-1.38,0.87-1.82,1.55c-0.96,1.47-1.52,3.18-2.98,4.34 c-1.33,1.06-0.8,2.64-0.82,4.03c-0.02,1.27,1.61,3.18,2.84,3.32c3.02,0.36,6.04,0.64,9.06,0.96c0.33,0.04,0.81,0.04,0.95,0.24 c1,1.45,2.98,2.44,2.17,4.75c-0.11,0.31,0.39,0.78,0.39,1.18c0.02,1.32,0.11,2.68-0.17,3.95c-0.22,1.01-1.1,1.86-1.41,2.87 c-0.54,1.71,0.41,3.02,1.55,4.15c1.28,1.27,1.94,1.24,3.66,0.26c0.96-0.55,1.99-1.12,3.06-1.32c1.94-0.35,3.1,1.4,4.64,2.13 c1.17,0.55,2.17,1.43,3.34,1.98c1.51,0.72,3.1,1.19,4.05,2.8c0.33,0.57,1.26,0.78,1.9,1.19c0.6,0.38,1.4,0.7,1.69,1.26 c0.51,1.03,0.69,2.23,1.05,3.34c0.14,0.4,0.35,0.83,0.65,1.11c0.69,0.66,0.82,3.4,0.13,4.02c-1.03,0.92-1,1.59,0.01,2.49 c0.82,0.73,1.45,1.79,2.39,2.23c0.75,0.36,1.85,0.05,2.78-0.07c0.31-0.04,0.58-0.53,0.9-0.55c3.1-0.24,5.89-1.34,8.58-2.84 c0.3-0.16,0.95-0.17,1.14,0.03c0.76,0.82,2.02,1.28,1.69,2.88c-0.33,1.67,0.2,3.38-1.17,4.99c-1.23,1.45-2.01,3.39-2.64,5.23 c-0.38,1.12-0.54,2.67-0.05,3.67c1.2,2.45,4.7,2.61,6.65,0.57c0.81-0.86,1.69-1.67,2.6-2.42c0.67-0.55,1.47-0.95,2.18-1.46 c0.32-0.22,0.58-0.52,0.85-0.79c0.92-0.91,1.79-1.88,3.23-1.91c0.07-0.01,0.12-0.25,0.21-0.36c0.47-0.55,0.87-1.23,1.45-1.62 c1.52-1.02,3.11-1.93,4.71-2.83c0.26-0.15,0.74-0.13,1.03,0.01c0.92,0.44,2.1,0.77,2.65,1.53c1.27,1.72,2.45,3.58,3.25,5.55 c0.83,2.06,3.35,3.48,5.17,2.57c1.67-0.83,2.63-2.52,4.53-3.18c1.48-0.51,2.62-2,3.93-3.03c0.29-0.22,0.64-0.44,0.98-0.49 c2.46-0.4,4.93-0.75,7.39-1.13c0.2-0.03,0.4-0.06,0.58-0.14c2.21-1.02,3.32-0.31,3.32,2.12c0,14.19-0.05,28.38,0.05,42.57 c0.01,1.86-0.96,2.7-2.18,3.62c-1.74,1.29-3.51,2.55-5.17,3.94c-1.03,0.85-1.73,2.36-2.86,2.77c-2.07,0.74-3.5,2.3-5.3,3.36 c-0.78,0.46-2.38,1.3-1.52,2.46c0.73,0.98,1.51,2.42,3.29,2.29c1.75-0.12,3.52-0.01,5.28,0.04c0.36,0.01,0.79,0.11,1.07,0.32 c0.62,0.47,1.08,1.3,1.76,1.51c2.45,0.76,2.94,2.75,3.4,4.84c0.09,0.38,0.22,0.9,0.49,1.05c1.71,0.98,1.74,2.53,1.65,4.2 c-0.06,1.3,0.03,2.61,0.03,3.92c0,29.84,0.04,59.67-0.06,89.5c-0.01,2.31,0.88,4.73-0.96,7.07c-0.87,1.09-0.54,3.2-0.94,4.86 c-0.58,2.45-0.57,4.95-2.05,7.23c-0.78,1.21-0.76,2.94-1.11,4.44c-0.34,1.49-0.68,2.98-1.03,4.46c-0.03,0.13-0.14,0.34-0.23,0.35 c-1.15,0.18-0.88,1.09-0.84,1.76c0.05,0.94-0.27,1.83,0.87,2.72c0.82,0.63,0.83,2.35,1.12,3.6c0.4,1.74,0.73,3.51,1.09,5.26 c0.03,0.15,0.05,0.32,0.13,0.42c1.29,1.52,1.66,3.35,1.96,5.25c0.2,1.27,0.59,2.51,0.92,3.76c0.03,0.12,0.2,0.2,0.26,0.33 c0.28,0.55,0.77,1.11,0.79,1.68c0.09,3.17,0.09,6.34,0.08,9.51c-0.01,53.22-0.02,106.45-0.08,159.68c0,1.51,0.78,3.34-1.06,4.47 c-0.08,0.05-0.06,0.29-0.07,0.43c-0.29,3.58-0.58,7.16-0.86,10.73c-0.32,4.15-0.63,8.3-0.97,12.45c-0.03,0.37-0.26,0.73-0.4,1.09 c-0.22,0.55-0.64,1.11-0.63,1.66c0.01,2.21,0.17,4.31,0.9,6.56c0.95,2.95,0.48,6.31,0.89,9.51c0.6,4.76,0.19,9.64,0.22,14.47 c0,0.5-0.1,1.11,0.14,1.48c1.42,2.19,0.48,4.57,0.54,6.84c0.04,1.47-0.44,2.98-0.84,4.43c-0.28,0.99-0.67,2.02-1.29,2.82 c-0.83,1.08-1.77,2.01-1.64,3.52c0.05,0.49,0.15,1.21-0.11,1.46c-1.13,1.09-0.65,2.44-0.83,3.69c-0.31,2.06,0.16,4.04-0.82,6.24 c-0.96,2.19-0.26,5.14-0.16,7.75c0.02,0.5,0.87,0.95,0.93,1.47c0.29,2.77-0.03,5.53,0.85,8.32c0.65,2.07,0.26,4.49,0.21,6.75 c-0.04,2.22,0.51,4.38,0.15,6.66c-0.41,2.56-0.2,5.21-0.29,7.83c-0.01,0.43-0.02,1.12-0.27,1.26c-1.4,0.77-2.83,1.57-4.34,2.04 c-1.7,0.53-3.51,0.72-5.26,1.07c-0.15,0.02-0.35,0.06-0.42,0.16c-1.05,1.6-2.96,1.06-4.42,1.69c-1.82,0.79-3.98,0.8-5.99,1.16 c-0.29,0.05-0.67,0.1-0.83,0.3c-1.07,1.37-2.9,1.4-4.18,1.54c-2.35,0.25-4.8-0.49-7.21-0.82c-0.14-0.02-0.32-0.1-0.39-0.21 c-1.13-1.76-2.78-0.72-4.19-0.71c-0.45,0-0.86,0.75-1.36,0.9c-1.49,0.44-3.02,0.74-4.53,1.14c-0.22,0.06-0.35,0.43-0.57,0.58 c-0.67,0.47-1.36,1.26-2.06,1.29c-3.56,0.13-7.14,0.07-10.71,0.04c-0.34,0-0.71-0.21-1.04-0.37c-0.54-0.26-1.05-0.56-1.58-0.84 c-0.82-0.43-1.69-0.79-2.43-1.32c-0.47-0.34-0.64-1.1-1.12-1.39c-1.87-1.14-3.1-2.75-4.11-4.66c-0.29-0.55-1.05-1.17-1.64-1.22 c-2.71-0.22-5.54-0.58-7.69,1.72c-0.83,0.9-1.8,1.06-2.92,1.04c-0.38,0-0.87,0.04-1.14,0.26c-1.57,1.29-3.5,1.51-5.38,1.82 c-2.39,0.39-4.78,0.67-7.17,1.02c-0.22,0.03-0.39,0.29-0.61,0.39c-1.11,0.5-2.2,1.26-3.35,1.41c-2.09,0.25-3.01,0.98-2.64,3.04 c0.19,1.07,0.64,2.49,1.43,2.95c1.21,0.72,2.83,0.7,4.26,1.06c1.65,0.43,3.28,0.93,4.92,1.42c1.01,0.3,2.01,0.63,3.03,0.92 c1.88,0.54,3.74,1.35,5.66,1.53c3.04,0.28,6.13,0.18,9.19,0.18c13.52,0.02,27.05,0,40.57,0.04c1.41,0.01,3.03-0.62,4.13,0.94 c0.1,0.14,0.48,0.07,0.73,0.09c5.48,0.4,11.03-0.61,16.46,0.99c1.95,0.58,4.05,0.68,6.11,1c0.07,1.26,0.61,2.47-0.7,3.3 c-0.85,0.54-1.65,1.22-2.57,1.58c-2.2,0.85-4.44,1.57-6.68,2.32c-0.99,0.34-2.02,0.59-3.01,0.94c-1.67,0.58-3.32,1.21-4.98,1.82 c-0.23,0.09-0.44,0.21-0.66,0.31c-0.53,0.24-1.04,0.64-1.58,0.69c-5.18,0.48-10.35-0.17-15.61,0.68 c-5.76,0.93-11.79-0.18-17.64,1.1c-0.82,0.18-1.73-0.09-2.55,0.08c-1.8,0.37-3.61,0.77-5.32,1.42c-0.58,0.21-1.08,1.13-1.26,1.82 c-0.66,2.45,1.02,5.29,4.03,5.07c1.83-0.13,3.72,0.54,5.59,0.87c0.12,0.02,0.22,0.18,0.34,0.24c0.72,0.31,1.43,0.85,2.17,0.88 c2.51,0.11,5.03,0.09,7.54,0.03c1.18-0.03,2.56,0.41,3.33-1.08c0.07-0.15,0.56-0.11,0.86-0.11c5.22,0.01,10.44,0.02,15.66,0.05 c0.34,0,0.79,0,1,0.19c1.32,1.25,2.86,1.82,4.67,1.79c1.63-0.02,3.26,0.01,4.6,1.25c0.06,0.99-0.12,1.83-1.41,1.95 c-0.23,0.02-0.46,0.31-0.66,0.5c-1.32,1.33-2.56,2.77-3.99,3.98c-1.06,0.89-2.34,2.07-3.56,2.12c-2.5,0.1-4.06,2.03-6.3,2.6 c-1.31,0.34-2.46,1.45-3.98,1.52c-0.29,0.01-0.67,0.07-0.83,0.26c-1.11,1.31-2.62,1.66-4.2,1.76c-1.8,0.12-3.76-0.26-5.37,0.33 c-1.58,0.59-3.07,0.54-4.61,0.59c-1.96,0.05-3.92,0.02-5.88,0c-0.39,0-0.79-0.07-1.16-0.17c-0.83-0.22-1.64-0.59-2.48-0.71 c-2.61-0.36-5.24-0.64-7.85-0.96c-0.15-0.02-0.38-0.06-0.41-0.14c-0.54-1.36-1.74-0.98-2.71-0.99c-4.02-0.06-8.04-0.04-12.07-0.05 c-0.4,0-0.81,0-1.19-0.08c-1.18-0.25-2.34-0.57-3.51-0.81c-0.49-0.09-1.19,0.17-1.47-0.09c-1.49-1.32-3.25-0.64-4.88-0.82 c-0.45-0.05-1.2,0.06-1.3-0.14c-0.68-1.42-1.93-1.03-3.02-1.06c-2.06-0.05-5.27-2.58-6.24-4.39c-0.87-1.64-2.23-3.05-3.48-4.46 c-1.04-1.17-2.36-2.08-3.33-3.29c-0.87-1.07-1.16-2.84-2.21-3.49c-1.93-1.2-2.76-3.77-5.53-3.92c-0.11,0.08-0.58,0.28-0.75,0.63 c-0.28,0.54-0.63,1.29-0.45,1.77c0.48,1.3,1.57,2.45,1.78,3.76c0.36,2.21,2.01,3.73,2.59,5.88c0.45,1.67,1.26,3.48,2.41,5.08 c1.14,1.56,1.41,3.74,2.13,5.63c0.43,1.16,0.89,2.33,1.51,3.4c0.36,0.63,1.01,1.13,1.61,1.59c0.67,0.5,1.52,0.79,2.13,1.35 c0.78,0.7,1.25,1.83,2.11,2.32c1.81,1.02,4.06,1.07,5.77,2.38c0.07,0.06,0.21,0.06,0.3,0.04c2.43-0.53,4.36,1.08,6.06,2.12 c2,1.24,4.52,2.12,5.74,4.61c0.47,0.95,1.67,1.55,3.12,0.54c0.9-0.62,2.18-0.69,3.18-1.48c1.15-0.91,2.59-1.45,3.89-2.16 c0.34-0.18,0.65-0.55,0.97-0.56c2.21-0.07,4.53-0.5,6.59,0.05c1.65,0.44,3.29,0.44,4.91,0.75c3.34,0.63,6.68,1.23,10.11,1.01 c0.19-0.02,0.47-0.04,0.58,0.07c1.69,1.69,4.5-0.27,6.04,1.88c2.64-0.06,5.21,0.33,7.75,1.05c1.35,0.38,2.74,0.65,4.1,0.98 c0.13,0.03,0.21,0.2,0.34,0.27c1.18,0.58,2.33,1.28,3.57,1.7c1.36,0.47,2.81,0.68,4.22,1.01c0.12,0.03,0.22,0.16,0.34,0.24 c0.93,0.58,1.82,1.22,2.8,1.71c1.03,0.51,2.68,0.57,3.1,1.35c1.03,1.92,2.93,2.76,4.5,3.64c1.3,0.73,3.45,0.26,5.09-0.18 c0.46-0.12,0.44-2.05,0.6-3.16c0.06-0.34-0.03-0.71,0.02-1.05c0.29-1.88-1.12-3-1.84-4.46c-0.7-1.42-2.24-1.12-3.03-2.13 c-0.57-0.71-1.11-1.52-1.85-1.99c-1.99-1.26-4.2-2.07-5.98-3.79c-1.42-1.38-3.36-2.21-5.05-3.33c-0.53-0.36-0.97-0.86-1.6-1.43 c1.59-0.28,2.79-0.38,3.91-0.73c1.33-0.42,2.56-1.15,3.88-1.59c1.23-0.41,2.52-0.08,3.86-0.73c1.07-0.51,2.44-1.28,3.54-1.27 c4.9,0.06,9.87-1.42,14.74,0.77c1.85,0.84,4.1,0.89,6.19,1.08c2.2,0.2,4.42,0.08,6.63,0.19c1.39,0.07,2.87-0.36,3.15-1.52 c0.35-1.43-0.11-3.07-0.31-4.61c-0.05-0.35-0.43-0.86-0.75-0.94c-1.89-0.45-3.03-2.61-5.28-2.29c-0.29,0.05-0.76-0.44-0.98-0.79 c-0.55-0.87-1.04-1.78-1.46-2.72c-0.72-1.58-1.07-3.47-2.15-4.72c-1.03-1.21-1.01-2.65-1.64-3.91c-0.95-1.9,1.19-4.82,3.55-5.51 c1.64-0.47,2.56-1.92,3.11-3.23c0.56-1.3,1.48-2.16,2.47-2.65c1.95-1,3.13-2.23,2.85-4.48c-0.15-1.19,0.35-1.95,1.04-2.38 c1,0.29,1.75,0.57,2.54,0.71c0.68,0.12,1.65-0.21,2.05,0.15c1.42,1.25,3.06,0.73,4.59,0.79c1.64,0.07,2.82-1.17,2.72-2.83 c-0.14-2.32,0.71-4.76-1.17-6.9c-1.23-1.41-2.02-3.2-3.05-4.79c-0.22-0.34-0.72-0.52-0.87-0.87c-0.46-1.06-0.77-2.19-1.23-3.25 c-0.29-0.71-0.68-1.39-1.13-2.01c-1.1-1.56-2.04-3.14-1.53-5.37c1.49-0.04,2.78-0.09,3.89-1.32c1.1-1.21,1.2-2.49,1.25-3.92 c0.01-0.23,0.11-0.48,0.24-0.67c1.24-1.84,0.48-3.88,0.58-5.83c0.01-0.15-0.29-0.35-0.49-0.46c-1-0.56-2.03-1.05-3-1.64 c-0.5-0.3-0.84-0.89-1.35-1.13c-1-0.46-2.14-0.66-3.09-1.2c-0.51-0.28-0.94-1-1.07-1.59c-0.43-2.04-0.69-4.12-1.08-6.17 c-0.08-0.39-0.55-0.7-0.63-1.08c-0.19-0.93-0.56-2-0.26-2.78c0.2-0.56,1.73-1.24,2.07-1c1.34,0.91,2.76,0.55,4.13,0.75 c0.3,0.04,0.57,0.28,0.87,0.41c0.5,0.23,0.99,0.58,1.52,0.65c3.46,0.48,6.98-0.42,10.48,0.84c1.88,0.67,4.18,0.23,6.29,0.19 c0.47-0.01,1.28-0.37,1.34-0.69c0.2-1.06,0.29-2.2,0.09-3.25c-0.08-0.41-1.04-0.65-1.59-1c-0.18-0.12-0.3-0.34-0.49-0.47 c-1.59-1.12-3.47-1.86-4.58-3.59c-0.05-0.07-0.2-0.06-0.28-0.11c-0.71-0.43-1.45-0.81-2.11-1.31c-0.61-0.47-1.1-1.11-1.72-1.57 c-0.68-0.5-1.49-0.82-2.16-1.33c-0.65-0.49-1.14-1.21-1.81-1.67c-1.57-1.08-3.21-2.06-4.83-3.08c-0.55-0.35-1.1-0.73-1.69-1.01 c-0.82-0.38-1.8-0.53-2.49-1.06c-0.53-0.41-0.95-1.22-1.04-1.91c-0.29-2.18,0.44-4.47-0.96-6.53c-0.53-0.79-1.11-1.77-1.11-2.66 c-0.06-20.73-0.05-41.46-0.03-62.18c0-0.42,0.15-0.86,0.31-1.25c0.21-0.5,0.64-0.94,0.74-1.45c0.29-1.62,0.18-3.22,0.78-4.9 c0.83-2.34,0.88-4.99,1.09-7.52c0.17-1.95,0.05-3.92,0.11-5.88c0.01-0.47,0.2-0.93,0.37-1.38c0.2-0.51,0.68-0.99,0.69-1.49 c0.05-4.08,0.04-8.15,0.01-12.23c0-0.48-0.04-1.25-0.32-1.39c-0.99-0.49-0.7-1.33-0.78-2.08c-0.35-3.05-0.31-6.21-1.2-9.09 c-0.7-2.29-0.69-4.49-0.62-6.72c0.12-3.64-0.46-7.31,0.67-10.95c0.71-2.26,0.78-4.71,1.14-7.07c0.04-0.24,0.05-0.53,0.19-0.72 c1.27-1.67,1.08-3.79,1.66-5.67c0.44-1.39,0.1-3,0.26-4.5c0.1-0.93,0.2-2.16,0.8-2.68c1.42-1.23,1.05-2.71,1.11-4.18 c0.02-0.75,0.08-1.5,0.08-2.26c0-7.94,0-15.89-0.03-23.84c0-0.4-0.25-0.81-0.42-1.2c-0.21-0.5-0.6-0.97-0.64-1.48 c-0.1-1.3,0.06-2.63-0.09-3.92c-0.13-1.03-0.9-2.06-0.78-3.02c0.31-2.47-0.9-4.62-1.12-6.95c-0.02-0.22-0.23-0.41-0.33-0.63 c-0.25-0.52-0.62-1.03-0.7-1.58c-0.19-1.34,0.04-2.8-0.39-4.03c-0.8-2.24-1.62-4.42-1.62-6.84c0.01-17.65,0.01-35.31,0.01-52.97 c0-0.35,0.01-0.7,0-1.05c-0.02-1.05,0.41-1.5,1.54-1.48c2.96,0.07,5.93,0.14,8.89-0.02c1.36-0.08,2.79-0.5,3.99-1.12 c0.75-0.39,1.46-1.39,1.62-2.23c0.27-1.36,0.17-2.82,0.01-4.2c-0.06-0.53-0.66-1.12-1.16-1.45c-0.95-0.62-2-1.08-3.02-1.6 c-0.99-0.5-1.96-1.06-2.98-1.47c-1.78-0.73-3.61-1.35-5.4-2.06c-0.43-0.18-0.73-0.7-1.16-0.84c-2.24-0.68-2.37-0.81-2.37-3.03 c0.01-25.61,0-51.21,0.02-76.82c0-3.07,0.14-6.13,0.21-9.2c0.01-0.24,0.02-0.5,0.07-0.74c0.27-1.22,0.63-2.42,0.81-3.66 c0.37-2.55,0.64-5.13,0.97-7.69c0.02-0.18,0.12-0.4,0.26-0.51c1.25-1.01,1.6-2.31,1.7-3.89c0.22-3.29,0.67-6.56,1.04-9.84 c0.02-0.18,0.11-0.47,0.23-0.51c1.12-0.39,0.81-1.36,0.9-2.16c0.05-0.55-0.08-1.13,0.06-1.65c0.48-1.75,1.32-3.45,1.53-5.23 c0.29-2.37,0.65-4.96-0.01-7.16c-0.63-2.1-0.45-4.08-0.64-6.11c-0.06-0.75,0.14-1.67-0.22-2.22c-1.07-1.62-0.53-3.36-0.68-5.04 c-0.04-0.45,0-0.91,0-1.36c-0.04-11.77-0.07-23.54-0.12-35.32c0-0.74,0.31-1.64-0.76-2.05c-0.18-0.07-0.26-0.51-0.3-0.79 c-0.28-1.71-0.53-3.42-0.79-5.13c-0.02-0.14-0.04-0.34,0.04-0.43c0.85-1.09,1.42-2.52,3.18-2.48c0.48,0.01,1.01-0.1,1.45-0.3 c1.93-0.87,3.83-1.82,5.76-2.7c0.91-0.41,1.88-0.69,2.8-1.06c0.79-0.32,1.87-0.46,2.28-1.06c1.04-1.51,2.94-0.65,4.08-1.75 c0.2-0.2,0.94-0.09,1.27,0.13c1.02,0.68,1.91,1.57,2.95,2.21c0.97,0.6,2.05,1.01,3.11,1.45c0.77,0.32,1.57,0.54,2.6,0.88 c0.08-0.06,0.43-0.5,0.88-0.68c1.99-0.8,2.28-1.19,2.32-3.33c0.02-0.8-0.16-2.05,0.24-2.3c1.05-0.65,0.8-1.53,0.84-2.37 c0.1-1.85,0.1-3.71,0.2-5.57c0.02-0.46,0.14-1,0.42-1.35c1.19-1.48,2.43-2.92,3.72-4.33c1.85-2.02,3.76-3.98,5.62-5.99 c1.2-1.3,2.41-2.58,3.51-3.96c0.91-1.15,2.34-1.82,2.73-3.48c0.22-0.96,1.04-1.77,1.58-2.66c1.01-1.68,2.08-3.34,2.99-5.07 c0.86-1.63,1.53-3.36,2.33-5.01c0.12-0.24,0.55-0.48,0.82-0.47c0.85,0.06,1.7,0.23,2.56,0.36c1.64-0.37,3.34-0.64,5.04-0.61 c2.2,0.04,4.18-0.16,5.25-2.55c-0.42-0.66-0.75-1.53-1.37-2.07c-1.26-1.13-2.64-2.08-2.54-4.07c0.02-0.43-0.29-0.97-0.6-1.32 c-0.98-1.09-1.88-2.23-2.27-3.68c-0.25-0.92-0.45-1.85-0.7-2.92c0.1-0.16,0.47-0.49,0.53-0.87c0.41-2.81,0.64-5.66,1.19-8.44 c0.36-1.78,1.14-3.48,1.81-5.19c0.13-0.33,0.58-0.58,0.92-0.78c1.21-0.7,2.72-1.11,3.58-2.1c0.87-1,1.89-1.43,2.93-2.05 C215.346,112.2,216.377,111.28,216.086,109.69z M111.437,192.42c-46.57,0-84.32-37.75-84.32-84.32c0-46.56,37.75-84.31,84.32-84.31 c46.56,0,84.31,37.75,84.31,84.31C195.747,154.67,157.997,192.42,111.437,192.42z",
      "M220.041,157.85c-0.55-1.59-1.99-2.91-3.19-4.22c-1.44-1.55-3.06-2.93-4.54-4.44 c-0.94-0.97-2.09-1.91-2.57-3.1c-0.71-1.75-2.03-2.69-3.39-3.77c-0.82-0.65-1.45-1.6-2.05-2.48c-0.5-0.74-0.65-1.96-1.31-2.31 c-1.12-0.62-0.92-1.41-0.84-2.26c0.08-0.9-0.07-2.1,0.44-2.6c0.78-0.78,0.7-1.59,0.82-2.45c0.08-0.56-0.1-1.25,0.16-1.69 c1.35-2.35-0.12-5.35,1.81-7.52c0.27-4.36,0.77-8.72,0.74-13.07c-0.02-4.6-0.55-9.19-0.86-13.78c-0.02-0.23-0.04-0.6-0.18-0.67 c-1.2-0.58-0.74-1.69-0.88-2.62c-0.3-2.03-0.62-4.06-0.94-6.09c-0.03-0.17-0.16-0.32-0.24-0.49c-0.24-0.54-0.6-1.06-0.69-1.62 c-0.13-0.75,0.01-1.54-0.06-2.3c-0.14-1.56,0.39-3.22-0.79-4.65c-0.22-0.28-0.2-1.14,0.05-1.36c1.19-1.08,1.96-2.58,3.68-3.18 c0.9-0.32,1.87-1.42,2.11-2.35c0.36-1.38,0.09-2.92,0.09-4.59c-1.73,0-3.3,0.02-4.87,0c-0.36-0.01-0.98-0.02-1.05-0.2 c-0.46-1.09-1.43-0.72-2.21-0.93c-0.6-0.16-1.47-0.3-1.69-0.73c-0.65-1.26-1.95-1.91-2.51-3.35c-0.54-1.39-1.94-2.48-3.06-3.6 c-1.57-1.58-3.29-3.01-4.82-4.63c-0.9-0.96-1.45-2.23-2.3-3.24c-1.37-1.63-3.13-2.84-3.93-5.04c-0.75-2.04-0.93-2.28,0.91-3.34 c1.13-0.65,2.46-1.26,3.14-2.27c0.61-0.91,1.38-1.33,2.18-1.58c1.22-0.36,1.87-1.27,2.04-2.22c0.26-1.52,0.07-3.12,0.07-4.65 c-0.7-0.18-1.53-0.16-1.73-0.5c-0.54-0.93-1.34-0.88-2.1-0.8c-2.26,0.22-4.43-0.1-6.81,0.91c-2.5,1.06-5.7,0.06-8.58,0.97 c-1.39,0.44-3.04,0.01-4.63-0.49c-1.72-0.54-3.23-1.39-4.81-2.12c-0.53-0.24-0.86-0.92-1.39-1.21c-1.65-0.91-3.34-1.75-5.03-2.58 c-1.13-0.55-2.27-1.12-3.46-1.5c-1.3-0.42-2.67-0.64-4.01-0.96c-0.12-0.03-0.2-0.18-0.32-0.25c-0.49-0.28-0.96-0.69-1.5-0.81 c-1.58-0.38-3.18-0.64-4.78-0.96c-0.14-0.02-0.31-0.04-0.39-0.13c-1.28-1.53-3.33-0.93-4.88-1.77c-0.54-0.3-1.16-0.25-1.76-0.8 c-0.74-0.69-1.95-0.86-2.95-1.27c-0.31-0.13-0.57-0.36-0.88-0.52c-1.82-0.91-2.44-3.41-4.85-3.63c-0.37-0.03-0.84-0.97-0.93-1.54 c-0.16-0.97-0.04-2-0.04-2.77c-1.29-1.4-2.71-1.66-4.31-1.5c-1.04,0.1-3.26,1.89-3.77,2.79c-0.68,1.21-0.49,3.06-2.5,3.4 c-0.54,0.1-1.02,0.85-1.41,1.39c-0.58,0.82-1.24,1.27-2.3,1.24c-2.01-0.06-4.03-0.04-6.04,0.02c-0.52,0.02-1.03,0.31-1.53,0.51 c-0.4,0.16-0.75,0.5-1.15,0.55c-3.09,0.4-6.2,0.74-9.3,1.11c-0.14,0.02-0.31,0.01-0.41,0.1c-1.74,1.46-4.05,1.26-6.01,1.52 c-2.02,0.27-3.57,1.32-5.4,1.82c-1.27,0.35-2.45,1.02-3.69,1.51c-2.06,0.82-4.13,1.61-6.2,2.4c-0.64,0.24-1.35,0.37-1.91,0.73 c-1.46,0.94-2.83,2.01-4.28,2.97c-1.07,0.72-2.2,1.37-3.31,2.04c-0.98,0.59-1.98,1.14-2.94,1.76c-0.49,0.32-0.89,0.79-1.38,1.11 c-0.56,0.35-1.41,0.47-1.71,0.95c-0.49,0.79-1.09,1.06-1.92,1.26c-0.56,0.14-1.09,0.61-1.52,1.04c-0.91,0.91-1.7,1.92-2.6,2.84 c-1.47,1.52-3.01,2.96-4.47,4.49c-1.04,1.1-1.94,2.34-2.99,3.42c-1.05,1.07-2.23,2.02-3.34,3.03c-0.16,0.15-0.42,0.34-0.42,0.49 c0.1,1.74-2.06,1.97-2.29,3.47c-1.95,0.29-1.67,2.42-2.79,3.49c-1.16,1.11-1.61,2.94-2.39,4.45c-0.36,0.68-0.62,1.51-1.17,1.98 c-0.96,0.81-1.45,1.74-1.52,2.96c-0.02,0.38-0.02,0.81-0.2,1.11c-0.84,1.45-1.74,2.87-2.62,4.29c-0.4,0.63-1.03,1.22-1.16,1.9 c-0.25,1.29-0.94,1.6-2.14,1.73c-2.53,0.27-5.17-0.85-7.62,0.97c-0.78,0.57-1.29,0.9-1.28,1.82c0.02,1.15,0.04,2.3,0.09,3.45 c0.01,0.28,0.02,0.64,0.18,0.82c0.91,1.01,1.87,1.99,2.82,2.97c0.3,0.31,0.66,0.56,0.92,0.89c0.54,0.7,0.91,1.58,1.57,2.11 c1.32,1.05,1.76,2.7,0.91,4.16c-0.19,0.32-0.31,0.7-0.37,1.07c-0.33,2.36-0.19,4.68-0.93,7.12c-1.04,3.39-0.76,7.19-0.99,10.82 c-0.084,1.3-0.028,2.609-0.004,3.91c0.006,0.347,0.042,0.913,0.113,1.253c0.215,1.031,0.607,2.038,0.712,3.077 c0.13,1.18,0.02,2.39,0.08,3.59c0.02,0.39,0.24,0.77,0.39,1.15c0.19,0.5,0.5,0.97,0.6,1.49c0.36,1.88,0.66,3.78,0.98,5.67 c0.02,0.14,0.04,0.36,0.12,0.39c1.31,0.58,0.79,1.78,0.95,2.74c0.08,0.47-0.04,1.09,0.21,1.4c1.07,1.27,0.76,2.98,1.64,4.41 c0.92,1.49,0.83,3.53,1.95,5.15c1.07,1.53,1.11,3.52,2.09,5.23c1.14,2,1.76,4.33,3.12,6.29c0.99,1.43,1.86,2.94,2.81,4.39 c0.43,0.64,1.05,1.17,1.38,1.86c0.32,0.66,0.52,1.46,0.46,2.17c-0.02,0.21-1.11,0.37-1.72,0.47c-0.89,0.14-2.03-0.1-2.64,0.37 c-1.27,0.99-2.58,1.6-4.16,1.75c-0.27,0.02-0.66,0.12-0.78,0.31c-0.74,1.2-2.18,0.94-3.19,1.62c-0.9,0.6-1.97,0.95-2.95,1.45 c-0.13,0.06-0.15,0.33-0.22,0.5c-0.29,0.61-0.57,1.22-0.88,1.88c0.22,0.14,0.66,0.26,0.73,0.49c0.44,1.56,1.62,1.71,2.95,1.69 c6-0.1,12,0.28,17.98-0.6c2.02-0.3,2.35-0.04,2.27,1.87c-0.01,0.33,0.33,0.65,0.42,1c0.28,1.08,0.93,2.18-0.3,3.18 c-0.72,0.59-1.28,1.39-1.97,2.04c-0.57,0.55-1.16,1.13-1.84,1.51c-1.53,0.85-3.29,1.33-4.37,2.87c-0.11,0.16-0.38,0.21-0.57,0.32 c-1.53,0.89-3.3,1.54-4.54,2.74c-1.67,1.63-4.03,1.83-5.72,3.3c-0.62,0.53-1.4,0.9-2.1,1.34c-0.35,0.22-0.68,0.57-1.05,0.64 c-1.67,0.33-2.61,1.81-2.12,3.47c0.38,1.29,2.05,1.63,3.29,1.08c1.5-0.67,2.83-2,4.72-1.6c0.23,0.05,0.48-0.03,0.71,0.01 c3.29,0.59,6.38-0.81,9.6-0.9c0.14,0,0.37-0.02,0.4-0.09c0.59-1.47,1.9-0.82,2.92-1.07c1.08-0.27,2.31-0.48,3.12-1.14 c1.34-1.1,3.01-1.42,4.43-1.52c2.07-0.14,3.55-1.64,5.54-1.71c0.53-0.02,1.04-0.3,1.55-0.46c0.45-0.14,0.92-0.22,1.33-0.43 c0.95-0.49,1.87-1.48,2.8-1.47c2.17,0.03,4.33,0.51,6.5,0.83c0.1,0.02,0.16,0.24,0.27,0.29c0.56,0.28,1.11,0.61,1.7,0.78 c1.28,0.37,2.98,0.25,3.8,1.06c1.41,1.37,3.24,0.88,4.73,1.73c0.92,0.53,2.42-0.25,3.25,1.05c0.11,0.17,0.55,0.21,0.82,0.18 c3.28-0.45,5.4,2.03,8.05,3.18c1.02,0.44,1.9,1.2,2.94,1.6c2.28,0.87,4.77,0.75,7.12,1.85c2.1,0.99,4.76,1.09,7.16,1.03 c6.72-0.19,13.49,0.95,20.17-0.71c1.13-0.28,2.39-0.08,3.58-0.17c0.39-0.02,0.78-0.21,1.15-0.37c0.47-0.21,0.91-0.6,1.39-0.67 c1.14-0.15,2.49,0.21,3.39-0.3c1.52-0.84,2.91-0.42,4.47-0.47c0.03,0.81,0.09,1.47,0.09,2.13v170.39c0,1.92,0.01,3.84-0.01,5.76 c0,0.42,0.03,1.13-0.17,1.22c-1.48,0.66-0.88,1.94-0.93,2.97c-0.1,1.67-0.15,3.36-0.02,5.03c0.14,1.95-0.76,4.1,1,5.79 c0.14,0.13,0.07,0.46,0.13,0.69c0.32,1.16,0.64,2.31,1,3.45c0.05,0.18,0.32,0.33,0.52,0.42c1.35,0.57,1.68,1.45,1.02,2.81 c-0.14,0.29-0.42,0.71-0.31,0.88c1.11,1.81,0.69,3.83,0.63,5.73c-0.1,2.98-0.59,5.94-0.76,8.93c-0.14,2.43-0.03,4.89-0.08,7.33 c-0.01,0.6,0.23,1.41-0.8,1.57c-0.12,0.02-0.28,0.37-0.29,0.57c-0.16,3.08-0.36,6.15-0.72,9.24c-0.59,4.97-0.21,10.05-0.21,15.09 c0,44.18,0.01,88.36,0,132.54c0,6.23-0.02,12.47-0.12,18.7c-0.03,1.37,0.13,2.67-0.79,4.12c-0.92,1.43-0.93,3.56-1.02,5.39 c-0.16,3.11-0.07,6.24-0.11,9.36c-0.01,0.51-0.02,1.4-0.24,1.47c-1.21,0.4-0.8,1.35-0.89,2.13c-0.08,0.62-0.03,1.28-0.26,1.84 c-1.03,2.54-0.86,5.31-0.25,7.71c0.44,1.74,0.41,3.39,0.61,5.08c0.09,0.71-0.17,1.75,0.22,2.08c1.12,0.97,0.85,2.16,0.86,3.3 c0.05,10.08,0.08,20.15,0.07,30.22c0,1.21,0.33,2.59-1.03,3.45c-0.18,0.11-0.18,0.53-0.24,0.8c-0.3,1.45-0.59,2.91-0.92,4.36 c-0.04,0.18-0.32,0.29-0.45,0.47c-0.23,0.34-0.53,0.68-0.61,1.06c-0.36,1.69-0.64,3.38-0.96,5.08c-0.02,0.13-0.03,0.36-0.11,0.39 c-1.37,0.57-0.82,1.77-0.87,2.73c-0.07,1.48,0.09,2.98-0.06,4.45c-0.07,0.64-0.56,1.58-1.07,1.74c-1.53,0.48-3.39-0.22-4.66,1.28 c-6.11,0.05-12.2-0.04-18.29,0.83c-3.57,0.51-7.27,0.09-10.91,0.11c-0.52,0-1.34-0.08-1.52,0.2c-0.88,1.4-2.2,0.79-3.34,0.85 c-1.68,0.09-3.36,0.01-5.03,0.03c-2.22,0.03-2.87,0.61-2.88,2.52c-0.01,1.74,1.56,3.66,3.06,3.67c2.44,0.02,4.89-0.03,7.33,0.03 c0.54,0.01,1.1,0.29,1.59,0.56c0.66,0.35,1.23,1.13,1.88,1.17c2.77,0.19,5.5,0.3,8.27,0.8c3.4,0.62,6.97,0.26,10.46,0.39 c1.31,0.04,2.77-0.51,3.81,0.86c0.13,0.16,0.55,0.11,0.83,0.16c1.98,0.31,3.97,0.57,5.93,0.94c1.09,0.21,2.13,0.61,3.19,0.93 c0.13,0.04,0.23,0.15,0.35,0.21c0.62,0.31,1.25,0.59,1.87,0.9c0.71,0.37,1.79,0.59,2.05,1.17c0.56,1.23,0.85,2.64,0.96,4.01 c0.19,2.53,0.15,5.07,0.25,7.61c0.01,0.38,0.22,0.77,0.39,1.12c0.21,0.43,0.67,0.83,0.68,1.24c0.06,2.54,0.03,5.08,0.03,8.02 c-1.66,0.18-3.24,0.45-4.82,0.5c-2.92,0.07-5.85,0-8.77,0.03c-0.79,0-1.59,0.13-2.49,0.22c0.04,1.62-0.73,3.04,0.83,4.49 c1.37,1.26,2.42,2.7,4.52,2.55c0.429-0.031,0.861,0.057,1.262,0.211c2.119,0.81,4.149,1.889,6.518,1.859 c2.647-0.022,3.007,0.673,2.932,3.776c-0.017,0.708,0.025,1.415,0.061,2.122c0.065,1.295-0.44,1.831-1.823,1.812 c-3.69-0.07-7.38-0.03-11.07,0c-0.56,0.01-1.42-0.02-1.62,0.29c-0.74,1.16-1.8,0.84-2.78,0.84c-2.78,0.02-5.56,0.01-8.34,0.01 c-2.64,0-5.27,0.06-7.9-0.01c-1.15-0.03-2.08,0.55-2.33,1.39c-0.7,2.4,0.27,5.56,3.59,5.63c1.2,0.02,2.77-0.38,3.51,0.22 c1.4,1.15,2.84,0.75,4.28,0.95c1.97,0.27,3.93,0.57,5.9,0.89c0.17,0.03,0.3,0.3,0.46,0.45c0.91,0.82,1.76,1.71,3.21,1.47 c0.49-0.09,1.07,0.16,1.57,0.35c0.51,0.19,0.95,0.66,1.45,0.73c3.2,0.43,6.4,0.78,9.69,1.16c0.04,0.17,0.13,0.39,0.14,0.62 c0.03,1.82,0.03,3.65,0.06,5.47c0.01,0.76-0.1,1.57,0.11,2.28c0.5,1.64,0.12,2.28-1.61,2.28c-4.12,0-8.24-0.01-12.36,0.02 c-0.7,0.01-1.77,0-2.02,0.4c-0.59,0.96-1.36,0.7-2.11,0.73c-1.81,0.07-3.64,0.04-5.44,0.19c-1.13,0.1-2.23,0.64-3.35,0.64 c-8.67,0.06-17.35,0.03-26.02,0.05c-0.66,0-1.71-0.04-1.89,0.3c-0.55,1.03-1.38,0.79-2.18,0.88c-1.31,0.17-2.07,1-2.12,2.29 c-0.1,2.71,1.38,4.42,4.05,4.64c0.66,0.06,1.34,0.06,2.01,0.06c11.59,0,23.19-0.04,34.79,0.04c2.11,0.01,4.23,0.53,6.34,0.84 c0.16,0.02,0.3,0.17,0.46,0.26c0.46,0.24,0.9,0.61,1.38,0.7c2.05,0.38,4.12,0.68,6.18,1.02c0.17,0.02,0.32,0.14,0.49,0.22 c0.59,0.27,1.16,0.71,1.77,0.77c1.78,0.18,2.26,0.55,2.18,2.39c-0.13,2.89,0.3,5.79-0.56,8.69c-0.54,1.82,0.44,4.02-1.28,5.61 c-1.07,0.99-1.03,2.72-2.45,3.52c-0.6,0.33-1.11,0.94-1.49,1.53c-0.84,1.31-1.52,2.72-2.37,4.02c-0.39,0.59-1.08,0.97-1.53,1.53 c-0.82,1.05-1.77,2.07-2.29,3.27c-0.73,1.7,0.72,3.6,2.56,3.61c1.2,0,2.39-0.07,3.59-0.14c0.28-0.01,0.76-0.06,0.79-0.18 c0.37-1.48,1.9-1.22,2.79-1.6c1.47-0.63,2.91-1.2,4.18-2.2c0.6-0.47,1.56-0.65,1.91-1.24c0.65-1.1,0.98-2.39,1.44-3.6 c0.17-0.43,0.37-0.84,0.5-1.28c0.4-1.41,0.82-2.81,1.14-4.24c0.15-0.69,0.22-1.46,0.08-2.14c-0.28-1.36,0.93-1.72,1.44-2.55 c0.84-1.38,1.53-1.33,2.36-0.08c0.04,0.06,0.18,0.09,0.27,0.09h5.12c-0.27-2.27,0.54-4.2-0.94-6.39c-1.18-1.72-2.35-3.95-2.25-6.37 c0.02-0.28-0.07-0.57-0.13-0.85c-0.31-1.36-0.62-2.72-0.98-4.33c4.5,0,8.43-0.01,12.35,0.02c0.27,0,0.59,0.24,0.78,0.46 c0.82,0.96,1.75,1.44,3.09,1.4c2.73-0.08,5.46,0.06,8.19,0.06c14.24,0.01,28.47,0,42.7,0c0.67,0,1.35,0.02,2.01-0.07 c0.32-0.05,0.75-0.28,0.88-0.55c0.69-1.38,1.24-2.78,1.07-4.42c-0.22-2-0.91-2.79-2.91-2.81c-2.59-0.03-5.17,0-7.76-0.03 c-0.4,0-0.82-0.09-1.21-0.22c-0.79-0.28-1.56-0.86-2.35-0.87c-4.08-0.1-8.15-0.05-12.22-0.06c-0.39,0-0.91,0.14-1.13-0.05 c-1.49-1.3-3.27-0.63-4.92-0.82c-1.42-0.16-3.03,0.59-4.17-0.93c-0.17-0.22-0.72-0.18-1.1-0.18c-1.29-0.03-2.58-0.02-3.86-0.03 c-0.63,0-1.49,0.23-1.83-0.09c-1.49-1.41-3.58-0.43-5.29-1.62c-1.47-1.03-3.79-0.13-5.71-1.05c-1.26-0.6-2.87,0.1-4.29-1.07 c-1.64-1.35-3.9-1.12-5.98-1.07c-1.17,0.02-1.96-0.78-2.01-1.96c-0.02-0.61,0-1.22,0-1.93c0.7-0.04,1.27-0.05,1.83-0.12 c0.31-0.04,0.62-0.16,0.9-0.3c0.48-0.24,0.93-0.73,1.42-0.78c3.66-0.32,7.33-0.56,10.99-0.82c0.05-0.01,0.1-0.01,0.15-0.01 c1.17-0.12,2.41-1.19,2.51-2.35c0.1-1.23,0.02-2.47,0.02-3.7c-1.73-0.36-3.3-0.9-4.9-0.98c-3.01-0.13-6.03,0-9.05,0.03 c-0.43,0-0.99-0.06-1.25,0.17c-1.07,0.95-2.32,0.59-3.51,0.66c-1.57,0.08-2.62-0.97-2.97-2.16c-0.34-1.18-0.19-2.67,0.24-3.85 c0.41-1.13,3.21-1.2,4.42-0.44c0.97,0.61,2.01,1.16,3.09,1.52c0.79,0.26,1.7,0.21,2.56,0.22c2.42,0.05,3.28-0.79,3.32-3.21 c0.02-1.15,0.11-2.31-0.02-3.45c-0.11-0.94-0.49-1.85-0.77-2.77c-0.35-1.1-0.72-2.18-1.14-3.45c0.69-0.05,0.96-0.09,1.24-0.09 c4.31-0.08,8.62-0.14,12.93-0.23c0.51-0.01,1.03-0.12,1.52-0.26c0.68-0.19,1.33-0.66,1.99-0.67c6.85-0.05,13.71-0.02,20.56-0.04 c0.71,0,1.61,0.13,2.1-0.23c1.18-0.87,2.44-0.56,3.67-0.62c1.29-0.05,2.6,0.05,3.87-0.13c0.76-0.11,1.42-0.83,2.18-0.93 c2.31-0.3,4.64,0.04,6.98-0.78c1.36-0.48,1.89-0.92,1.89-2.21c-0.01-1.05,0-2.09,0-3.07c-1.98-0.4-3.74-0.82-5.52-1.07 c-1.03-0.15-2.1-0.02-3.15-0.04c-0.33,0-0.87,0.04-0.95-0.13c-0.68-1.28-1.88-0.93-2.9-0.94c-4.36-0.05-8.72-0.02-13.08-0.03 c-0.42,0-0.84-0.06-1.25-0.16c-0.85-0.21-1.69-0.65-2.53-0.66c-3.74-0.08-7.48-0.04-11.22-0.07c-0.39,0-0.81-0.11-1.19-0.25 c-0.65-0.26-1.27-0.76-1.93-0.82c-1.661-0.151-3.335-0.019-5.007-0.073c-0.629-0.021-1.638-0.204-2.243-0.375 c-0.66-0.186-1.321-0.376-1.99-0.432c-1.57-0.13-3.16-0.02-4.74-0.05c-0.36,0-0.73-0.1-1.06-0.22c-0.75-0.28-1.46-0.83-2.21-0.87 c-2.29-0.12-4.62,0.13-6.89-0.13c-1-0.11-2.34-0.9-2.73-1.74c-0.4-0.87-0.13-2.37,0.4-3.27c0.641-1.095,1.837-1.878,2.791-2.802 c0.176-0.17,0.314-0.377,0.406-0.604c0.418-1.034,0.692-2.09,1.883-2.644c0.49-0.22,0.73-0.96,1.09-1.46 c0.58-0.8,1.01-1.83,1.79-2.34c1.34-0.86,2.7-1.8,4.39-2.05c0.94-0.14,2.19-0.41,2.65-1.07c0.83-1.21,2.16-0.98,3.16-1.63 c1.45-0.94,3.1-1.57,4.65-2.39c0.2-0.1,0.36-0.48,0.37-0.73c0.03-1.66,0.02-3.32,0.02-5.1c-1.93,0-3.73-0.2-5.46,0.05 c-1.77,0.26-3.54,0.82-5.19,1.53c-0.95,0.41-1.55,0.46-2.52,0.01c-1.67-0.76-3.21-2.09-5.31-1.62c-0.77,0.17-1.62,0.05-2.43,0.02 c-1.31-0.03-2.01-0.77-2.04-2.07c-0.03-1.1,0.24-2.39-0.24-3.26c-0.82-1.47-0.5-2.93-0.57-4.4c-0.07-1.35,0.57-1.94,1.93-1.96 c1.81-0.04,3.65,0.03,5.45-0.16c1.45-0.15,2.85-0.78,4.3-0.91c2.1-0.2,4.21-0.09,6.32-0.19c5.64-0.27,11.27-0.58,16.91-0.89 c0.29-0.01,0.59-0.18,0.87-0.31c0.46-0.22,0.9-0.66,1.36-0.68c2.87-0.12,5.74-0.18,8.61-0.21c1.86-0.01,3.49-0.46,4.72-1.98 c0.73-0.91,0.33-3.4-0.5-3.95c-1.54-1.02-3.21-0.87-4.89-0.91c-0.4-0.01-0.81-0.11-1.19-0.25c-0.76-0.27-1.48-0.83-2.23-0.85 c-3.214-0.102-6.428-0.038-9.642-0.061c-0.354-0.003-0.711-0.029-1.053-0.122c-0.859-0.234-1.683-0.63-2.544-0.697 c-1.48-0.12-2.97-0.01-4.46-0.04c-0.35,0-0.72-0.1-1.05-0.23c-0.7-0.28-1.36-0.79-2.07-0.87c-1.37-0.14-2.78,0.05-4.16-0.06 c-4.36-0.36-8.78,0.74-13.14-0.72c-1.01-0.34-1.88-0.84-2.7-1.35c-0.51-0.31-0.85-1.41-0.73-2.06c0.1-0.55,0.9-1.24,1.51-1.38 c1.69-0.39,3.52,0.23,5.11-1.2c0.68-0.6,1.73-0.79,2.03-1.87c0.46-1.59,0.03-3.2-1.02-4.15c-1.15-1.05-2.8-1.57-4.3-2.17 c-0.95-0.37-1.49-0.84-1.48-1.89c0.03-1.58,0.02-3.17-0.01-4.75c-0.01-0.57,0.08-1.42-0.24-1.65c-1.34-0.97-1.03-2.35-1.03-3.6 c-0.03-12.57-0.2-25.14,0.09-37.7c0.09-4.05-0.94-8.2,0.93-12.27c0.93-2.02,0.71-4.58,1.03-6.89c0.16-1.24-0.47-2.69,1-3.6 c0.14-0.09,0.09-0.54,0.09-0.83c0-4.12,0.01-8.25-0.02-12.37c0-0.41-0.16-0.82-0.29-1.22c-0.19-0.59-0.54-1.16-0.6-1.77 c-0.36-3.45-0.65-6.9-0.98-10.35c-0.03-0.31-0.24-0.6-0.38-0.89c-0.22-0.51-0.58-1-0.66-1.53c-0.24-1.69,0.47-3.51-0.81-5.07 c-0.19-0.23-0.19-0.89,0-1.1c1.13-1.21,0.66-2.69,0.81-4.07c0.03-0.33-0.01-0.85,0.17-0.94c1.18-0.61,0.78-1.71,0.9-2.64 c0.31-2.41,0.6-4.82,0.92-7.23c0.02-0.17,0.16-0.32,0.24-0.48c0.28-0.64,0.56-1.28,0.85-1.91c0.32-0.7,0.59-1.93,1-1.98 c1.63-0.19,2.43-1.42,3.43-2.35c1.11-1.02,1.99-2.29,3.34-3.88c1.88-0.27,4.43-0.62,6.97-0.99c0.244-0.035,0.634-0.127,0.864-0.214 c1.441-0.546,2.865-1.399,4.326-1.486c2.42-0.16,3.88-1.4,5.1-3.21c0.42-0.63,0.74-1.32,1.14-1.95c0.73-1.13,0.46-2.45-0.7-3.13 c-1.06-0.64-2.14-1.26-3.22-1.86c-0.79-0.43-1.66-0.72-2.39-1.23c-1.235-0.87-2.388-1.874-3.593-2.814 c-0.497-0.388-1.371-0.934-1.933-1.221c-0.971-0.497-1.952-0.974-2.934-1.465c-1-0.5-2.02-0.97-3.01-1.5 c-1.6-0.84-3.21-1.67-4.75-2.6c-0.37-0.23-0.71-0.84-0.72-1.29c-0.12-4.45-0.14-8.91-0.24-13.37c-0.01-0.63-0.24-1.27-0.47-1.87 c-0.4-1.04-1.01-2.01-1.27-3.07c-0.41-1.62-0.52-3.32-0.9-4.95c-0.19-0.8-1.03-1.52-1.04-2.28c-0.03-2.59-1.5-4.95-1.05-7.62 c0.23-1.35,0.07-2.78,0.01-4.17c-0.02-0.49-0.22-0.99-0.41-1.46c-0.18-0.47-0.63-0.91-0.64-1.37c-0.1-5.89-0.19-11.79-0.2-17.69 c-0.01-43.36-0.01-86.72,0.01-130.09c0-3.59,0.1-7.19,0.18-10.78c0-0.35,0.13-0.72,0.28-1.04c0.23-0.52,0.69-0.98,0.75-1.51 c0.14-1.13-0.01-2.31,0.15-3.44c0.21-1.41,0.24-3.06,1.01-4.12c1.23-1.69,0.93-3.66,1.6-5.44c0.86-2.26-0.54-4.93,1.14-7.29 c1.15-1.62,1.74-3.65,2.56-5.5c0.27-0.59,0.41-1.24,0.72-1.81c0.54-1.02,1.19-1.98,1.75-2.99c0.58-1.04,1.14-2.09,1.63-3.17 c0.67-1.52,2.22-1.88,3.43-2.66c0.92-0.59,2.03-0.89,3.04-1.36c1.51-0.69,3.02-1.38,4.5-2.12c0.5-0.26,1.18-0.59,1.33-1.04 c0.46-1.4,0.79-2.85,1.02-4.31c0.13-0.82-0.4-1.39-1.27-1.39c-3.26,0-6.51,0.03-9.77,0.06c-0.24,0-0.51,0-0.7,0.11 c-2.29,1.29-4.7,0.26-7.06,0.66c-0.05-0.53-0.1-0.81-0.1-1.1c0-8.53,0.13-17.08-0.04-25.61c-0.18-8.49,0.86-17.02-0.84-25.46 c-0.17-0.87-0.26-1.75-0.48-2.61c-0.13-0.53-0.56-0.99-0.63-1.51c-0.16-1.28,0.11-2.69-0.33-3.83c-0.93-2.37-0.35-3.87,2.08-4.61 c1.47-0.44,2.09-2.42,3.94-2.27c0.03,0,0.06-0.17,0.13-0.23c0.85-0.86,1.58-2.12,2.61-2.47c1.65-0.55,2.44-1.96,3.72-2.84 c0.98-0.67,1.86-1.5,2.82-2.2c0.62-0.46,1.31-0.81,1.96-1.23c0.66-0.42,1.31-0.86,1.95-1.31c0.27-0.2,0.49-0.46,0.76-0.67 c0.8-0.63,1.65-1.2,2.4-1.88c1.08-0.97,2.05-2.05,3.13-3.03c1.21-1.1,2.77-1.94,3.64-3.25c1.25-1.87,2.53-3.64,4.13-5.24 c1.47-1.47,2.88-3.08,3.97-4.84c0.72-1.18,2.37-1.65,2.4-3.29c0-0.06,0.14-0.14,0.22-0.16c1.32-0.35,2.61-0.84,3.95-1 c1.36-0.16,2.93-0.39,3.93,0.85c1.2,1.51,2.76,0.97,4.22,1.05c0.96,0.06,1.93,0.15,2.88,0.04c2.29-0.27,4.18,0.69,6.06,1.78 c0.68,0.4,1.4,0.75,2.09,1.13c0.92,0.51,1.83,1.03,2.85,1.6c0-0.01,0.07-0.17,0.19-0.27c0.97-0.86,2.45-1.54,2.79-2.6 C220.411,161.37,220.561,159.38,220.041,157.85z M111.437,192.42c-43.96,0-80.06-33.63-83.96-76.57c-0.27-0.72-0.3-1.53-0.18-2.4 c-0.12-1.77-0.18-3.55-0.18-5.35c0-46.56,37.75-84.31,84.32-84.31c46.56,0,84.31,37.75,84.31,84.31 C195.747,154.67,157.997,192.42,111.437,192.42z",
      "M230.071,128.64c-0.15-1.08-0.7-2.04-2.08-2.04c-0.28,0-0.57-0.25-0.84-0.39 c-0.47-0.25-0.92-0.61-1.42-0.73c-1.45-0.36-2.93-0.61-4.39-0.92c-0.12-0.03-0.22-0.18-0.34-0.23c-0.69-0.31-1.37-0.67-2.09-0.89 c-0.5-0.15-1.09,0.01-1.58-0.15c-1.59-0.49-3.12-1.21-4.73-1.56c-0.84-0.18-1.56-0.25-1.9-1.1c-0.26-0.64-0.44-1.3-0.58-1.71 c-0.72-0.61-1.66-1-1.81-1.59c-0.47-1.97-0.84-4-0.92-6.01c-0.17-4.38-0.13-8.76-0.19-13.14c0-0.39,0.08-0.98-0.12-1.13 c-1.52-1.11-0.88-2.72-1.05-4.13c-0.09-0.72-0.04-1.47-0.24-2.16c-0.52-1.81-1.24-3.58-1.68-5.41c-0.47-1.99-0.71-4.03-1.05-6.05 c-0.02-0.15-0.03-0.35-0.12-0.41c-1.51-0.98-1.28-2.82-1.53-4.12c-0.44-2.32-1.97-4.02-2.61-6.16c-0.4-1.34-1.17-2.57-1.71-3.87 c-0.68-1.62-1.18-3.32-1.99-4.86c-0.81-1.54-2.08-2.85-2.84-4.42c-0.66-1.35-0.85-2.94-2.05-4.04c-0.1-0.09-0.05-0.51,0.07-0.66 c0.56-0.66,1.05-1.5,1.78-1.88c1.3-0.68,1.3-1.76,1.31-2.91c0.01-1.17-0.04-2.34,0.01-3.51c0.07-1.48-0.62-2.06-2.07-2.04 c-3.26,0.04-6.52,0.06-9.78-0.01c-0.7-0.02-1.46-0.33-2.05-0.72c-1.1-0.72-2.12-1.56-3.13-2.4c-0.54-0.45-0.96-1.03-1.48-1.5 c-0.43-0.39-0.99-0.65-1.4-1.06c-1.1-1.08-2.85-1.27-3.64-2.8c-0.26-0.51-0.8-0.93-1.31-1.26c-1.904-1.241-3.992-2.242-5.711-3.712 c-0.881-0.754-1.89-1.335-2.86-1.97c-0.607-0.397-1.054-1.111-1.699-1.348c-2.2-0.8-3.28-2.91-5.09-4.15 c-1.33-0.92-1.84-2.72-3.74-3.11c-0.83-0.18-1.88-1.09-2.14-1.89c-0.88-2.71-2.14-5.37-1.84-8.36c0.05-0.48,0.01-0.96,0.01-1.34 c-1.25-1.09-2.38-0.97-3.36,0.1c-0.89,0.97-1.57,2.15-2.54,3.02c-1.43,1.29-2.97,2.51-4.61,3.52c-0.69,0.42-1.38,0.67-2.02,1.31 c-0.9,0.89-2.2,1.64-3.43,1.85c-1.8,0.3-3.69,0.07-5.53,0.05c-0.18,0-0.48-0.07-0.53-0.18c-0.47-1.14-1.47-0.93-2.36-0.94 c-6.56-0.01-13.14-0.04-19.7,0.04c-1.54,0.02-3.04-0.25-4.58,0.97c-1.14,0.9-3.14,0.73-4.76,1.02c-2.09,0.36-4.19,0.69-6.29,1.07 c-0.19,0.03-0.33,0.28-0.53,0.39c-0.37,0.22-0.74,0.54-1.14,0.59c-2.19,0.29-4.26,0.71-6.23,1.94c-1.53,0.96-3.44,1.68-5.22,1.77 c-1.75,0.09-2.67,1.41-4.14,1.82c-1.55,0.42-2.99,0.65-4.48-0.1c-0.81-0.405-1.626-0.816-2.452-1.201 c-0.68-0.317-1.835-0.735-2.558-0.934c-1.54-0.425-3.106-0.796-4.66-1.225c-0.36-0.1-0.75-0.28-1-0.54 c-1.13-1.22-3.97-1.95-5.53-1.35c-0.17,0.06-0.44,0.21-0.43,0.31c0.02,1.69-0.44,3.69,0.31,4.96c0.62,1.05,0.67,1.93,0.85,2.94 c0.3,1.71,0.65,3.4,0.99,5.1c0.03,0.13,0.11,0.31,0.22,0.36c1.21,0.52,0.68,1.35,0.48,2.21c-2.65,0-5.23,0-7.8-0.01 c-0.24,0-0.59,0.01-0.69-0.13c-1.25-1.66-3.02-0.97-4.53-0.83c-0.67,0.07-1.56,1.09-1.79,1.86c-0.3,0.97-0.07,2.11,0.02,3.18 c0.03,0.3,0.32,0.68,0.6,0.85c0.79,0.49,1.63,0.88,2.41,1.29c0,1.61-0.25,3.18,0.06,4.61c0.44,1.98-0.79,3.3-1.41,4.84 c-0.37,0.91-1.12,1.68-1.74,2.48c-0.65,0.86-1.47,1.62-1.97,2.56c-1.056,1.961-2.123,3.875-3.665,5.518 c-0.045,0.048-0.085,0.103-0.115,0.162c-0.62,1.2-1.26,2.38-1.81,3.61c-0.52,1.15-0.65,2.41-1.51,3.5c-0.8,1-1.09,2.41-1.63,3.63 c-0.4,0.91-0.89,1.79-1.23,2.73c-0.65,1.77-0.53,3.74-1.91,5.36c-0.96,1.12-1.31,2.75-2.03,4.1c-0.74,1.37-1.69,2.45-3.49,2.5 c-1.86,0.04-3.37,1.92-3.6,3.77c-0.44,3.62,2.49,5.16,4.33,7.38c0.29,0.36,0.73,0.77,0.74,1.17c0.06,1.95,0,3.9-0.04,5.84 c0,0.27-0.16,0.53-0.27,0.79c-0.22,0.58-0.62,1.14-0.66,1.73c-0.1,1.31-0.05,2.63-0.02,3.94c0,0.38,0.07,0.77,0.19,1.13 c0.27,0.77,0.78,1.51,0.84,2.29c0.15,1.79,0.08,3.6,0.11,5.4c0.01,0.78-0.28,1.79,0.1,2.29c1.42,1.91,0.12,4.44,1.72,6.36 c0.72,0.86,0.64,2.41,0.9,3.65c0.5,2.35,1.18,4.66,1.83,6.96c0.68,2.41,2.51,4.36,2.52,7.02c0,0.81,0.91,1.59,1.32,2.43 c0.52,1.07,0.95,2.19,1.43,3.28c0.11,0.24,0.28,0.45,0.41,0.68c0.56,1,1.12,1.99,1.67,2.99c0.32,0.59,0.48,1.5,0.98,1.75 c1.39,0.69,1.07,2.22,1.83,3.18c0.47,0.6,0.82,1.29,1.25,1.92c0.26,0.37,0.56,0.71,0.83,1.08c0.52,0.72,1.09,1.41,1.54,2.17 c0.52,0.89,1.47,2.02,1.24,2.71c-0.31,0.91-1.5,1.63-2.46,2.18c-1.59,0.9-3.29,1.6-4.94,2.38c-0.45,0.21-0.9,0.41-1.35,0.63 c-0.95,0.47-1.92,0.92-2.85,1.45c-0.71,0.42-1.35,0.98-2.05,1.42c-0.99,0.63-2.06,1.14-3,1.82c-0.81,0.58-1.46,1.39-2.27,1.98 c-0.53,0.4-1.41,0.43-1.81,0.9c-0.87,1.04-1.78,2-2.43,3.31c-0.93,1.85-0.62,3.28,0.36,4.67c0.71,1,1.81,1.7,3.22,1.44 c2.79-0.51,5.68,0.59,8.47-0.8c1.08-0.54,2.59-0.18,3.9-0.27c0.42-0.02,1.09-0.02,1.21-0.26c0.52-1.03,1.44-0.76,2.26-0.9 c1.76-0.28,3.52-0.6,5.28-0.92c0.13-0.02,0.33-0.1,0.37-0.21c0.43-1.07,1.39-0.83,2.22-0.9c0.63-0.06,1.27-0.03,1.88-0.15 c2.21-0.43,4.39-1,6.61-1.36c1.77-0.29,3.57-0.02,5.09,0.93c1.33,0.83,2.43,2.06,4.19,1.92c0.07,0,0.14,0.24,0.25,0.32 c0.96,0.71,1.94,1.41,3.11,2.26c-0.03,0.78,0.72,2.01-0.9,2.62c-0.11,0.05-0.12,0.35-0.21,0.52c-0.68,1.31-1.35,2.63-2.06,3.93 c-0.41,0.75-0.86,1.47-1.32,2.17c-0.52,0.79-1.16,1.5-1.6,2.33c-0.46,0.86-0.7,1.84-1.11,2.73c-0.56,1.22-1.46,2.35-1.74,3.63 c-0.31,1.34-0.12,2.81-0.03,4.22c0.08,1.17,0.87,1.95,2,2.03c1.38,0.09,2.83,0.58,4.1-0.64c0.75-0.73,1.82-1.11,2.66-1.76 c0.66-0.5,1.45-1.08,1.73-1.8c0.87-2.3,2.93-3.51,4.48-5.18c0.47-0.51,1.29-0.68,1.83-1.15c1.39-1.22,2.56-2.77,4.1-3.71 c1.46-0.88,3.26-1.31,4.97-1.65c1.24-0.24,2.38,0.18,3.64,0.89c2.31,1.31,5.28,0.57,7.75,2.06c1.12,0.68,2.84,0.67,4.2,0.82 c2.23,0.25,4.29,0.73,6.53,1.79c-0.24,0.43-0.46,0.94-0.77,1.4c-0.4,0.57-0.99,1.05-1.28,1.67c-0.79,1.67-1.35,3.39-1.07,5.31 c0.19,1.25,2.23,3.39,3.42,3.12c1.23-0.27,2.54-0.81,3.48-1.62c1.48-1.28,2.63-2.93,4.01-4.33c1.1-1.12,2.36-2.08,3.53-3.12 c0.71-0.64,1.3-1.64,2.12-1.89c1.76-0.52,3.64-0.61,5.45-0.97c1.79-0.35,3.55,0.17,5.46-0.91c1.89-1.06,4.51-0.98,6.82-1.09 c2.82-0.13,2.63-0.62,2.63,2.59c0,57.42,0.02,114.83-0.06,172.25c0,4.23,0.83,8.54-0.79,12.73c-0.62,1.6-0.25,3.38-1,5.17 c-0.81,1.94-0.89,4.43-1.01,6.62c-0.34,6.56-0.12,13.14-0.11,19.72c0,0.48-0.12,1.18,0.15,1.41c1.43,1.27-0.05,3.62,1.8,4.67 c0.34,3.04,0.98,6.08,0.99,9.12c0.06,52.79,0.04,105.58,0.04,158.37c0,3.16,0,6.33-0.03,9.49c0,0.57-0.12,1.14-0.26,1.69 c-0.19,0.72-0.64,1.41-0.66,2.11c-0.11,3.56-0.11,7.11-0.16,10.67c-0.01,0.42-0.1,0.85-0.21,1.27c-0.2,0.8-0.52,1.58-0.66,2.4 c-0.17,0.95-0.16,1.93-0.31,2.89c-0.16,1.01-0.64,2.01-0.6,2.99c0.16,3.93,0.47,7.84,0.73,11.76c0.01,0.09,0.01,0.19,0.03,0.29 c0.02,0.09,0.03,0.25,0.09,0.26c1.53,0.52,1.01,1.83,1.01,2.84c0.04,8.82,0.12,17.63-0.03,26.45c-0.05,2.65,0.87,5.42-0.97,8.02 c-0.8,1.12-0.72,2.87-1.05,4.32c-0.05,0.23-0.17,0.43-0.26,0.64c-0.55,1.3-1.35,2.55-1.59,3.9c-0.47,2.59-1.33,5.12-1.07,7.86 c0.22,2.37-0.05,4.78,0.08,7.16c0.1,1.83,0.58,3.64,0.72,5.47c0.11,1.56-0.68,2.28-2.23,2.29c-2.87,0.02-5.74-0.01-8.61,0.03 c-0.6,0.01-1.54,0.04-1.74,0.4c-0.54,0.93-1.29,0.71-2.03,0.74c-1.89,0.09-3.92-0.26-5.63,0.33c-1.64,0.56-3.18,0.44-4.77,0.55 c-0.77,0.05-1.56,0-2.33,0.04c-0.39,0.03-0.99,0.03-1.1,0.25c-0.72,1.33-1.93,0.77-2.95,0.89c-0.68,0.07-1.56-0.12-1.99,0.24 c-1.51,1.3-3.91-0.13-5.14,1.79c-2.12-0.02-4.15,0.22-6.23,0.82c-1.96,0.56-2.12,0.32-2.18,2.44c-0.01,0.34-0.01,0.69,0,1.03 c0.06,1.68,2.24,2.98,3.84,2.46c2.01-0.65,4.08-1.5,6.15-1.56c7.1-0.21,14.21-0.12,21.31-0.12c0.47-0.01,0.99,0.07,1.4,0.28 c1.67,0.85,3.32,1.62,5.27,1.47c0.64-0.05,1.32,0.15,1.95,0.35c0.64,0.19,1.22,0.71,1.84,0.75c3.19,0.16,3.22,0.16,3.33,3.45 c0.02,0.47,0.05,1.22,0.31,1.34c2.07,0.98,1.89,2.8,1.64,4.51c-0.1,0.64-0.81,1.33-1.41,1.69c-0.29,0.17-1-0.36-1.53-0.56 c-0.43-0.16-0.87-0.4-1.32-0.42c-1.21-0.07-2.43-0.01-3.65-0.06c-0.4-0.01-0.97-0.03-1.18-0.29c-1.01-1.21-2.46-2.07-2.96-3.72 c-0.12-0.39-0.73-0.77-1.18-0.88c-0.64-0.15-1.36,0-2.03-0.08c-3.01-0.39-4.31,2.14-4.4,4.43c-0.18,4.77-0.13,9.54-0.14,14.31 c-0.01,2.82,2.03,4.69,4.86,4.52c0.33-0.03,0.71,0,1-0.14c0.39-0.2,0.79-0.49,1.05-0.84c0.57-0.81,0.87-2.08,1.62-2.43 c1.73-0.79,3.65-1.22,5.52-1.65c1.12-0.26,2.33-0.11,3.44-0.37c0.5-0.12,0.83-1.12,1.47-0.21c0.36,0.51,0.86,1.02,0.95,1.59 c0.16,0.95,0.03,1.94,0.06,2.91c0.02,0.73-0.3,1.6,0.72,2.02c0.1,0.04,0.07,0.87-0.06,0.92c-0.9,0.37-1.84,0.86-2.77,0.87 c-4.38,0.09-8.76-0.08-13.14,0.08c-4.25,0.15-8.48,0.6-12.73,0.93c-0.14,0.01-0.29,0.04-0.42,0.1c-0.18,0.06-0.46,0.13-0.49,0.24 c-0.27,1.05-1.1,0.74-1.78,0.78c-1.26,0.07-2.71-0.25-3.73,0.27c-1.56,0.79-3.07,0.49-4.61,0.6c-0.83,0.06-1.66-0.02-2.48,0.05 c-0.46,0.04-0.92,0.23-1.36,0.4c-0.57,0.22-1.11,0.68-1.66,0.69c-5.74,0.12-11.48,0.25-17.22,0.19c-2.94-0.03-5.8,0.32-8.66,0.89 c-1.92,0.38-3.87,0.56-5.81,0.84c-0.14,0.02-0.37,0.03-0.41,0.11c-0.64,1.38-1.89,0.79-2.91,0.91c-0.67,0.07-1.58-0.17-1.99,0.19 c-1.16,1-2.45,0.58-3.69,0.69c-0.83,0.07-1.68,0-2.47,0.2c-0.46,0.12-0.79,0.86-1.24,0.91c-2.91,0.37-5.84,0.62-8.76,0.91 c-0.15,0.01-0.35-0.02-0.43,0.06c-0.65,0.68-1.53,1.29-1.85,2.11c-0.31,0.78,0.21,1.51,0.84,2.36c1.3,1.76,2.87,2,4.54,1.69 c2.76-0.49,5.54,0.64,8.38-0.92c1.96-1.08,4.67-0.8,7.06-1.06c1.06-0.12,2.14-0.03,3.21-0.09c0.36-0.02,0.71-0.16,1.05-0.3 c0.57-0.23,1.13-0.71,1.7-0.71c7.2-0.09,14.42,0.25,21.57-0.98c0.95-0.16,1.86-0.79,2.8-0.8c8.27-0.06,16.54-0.03,24.81-0.02 c0.44,0,1.03-0.11,1.28,0.12c1.16,1.09,2.55,0.69,3.86,0.72c2.62,0.06,5.26-0.04,7.88,0.09c3.92,0.2,7.83,0.57,11.75,0.79 c0.98,0.06,1.1,0.61,1.1,1.33c0.03,2.39,0.05,4.78,0.05,7.16c-0.01,2.02-1.87,3.14-3.77,2.39c-0.95-0.37-1.99-0.7-2.98-0.7 c-10.76-0.06-21.51-0.02-32.27-0.07c-1.58-0.01-3.37,0.66-4.65-0.97c-0.08-0.09-0.27-0.11-0.41-0.13 c-2.93-0.32-5.86-0.62-8.79-0.95c-0.4-0.04-0.8-0.18-1.18-0.33c-0.57-0.24-1.13-0.77-1.69-0.77c-7.35-0.03-14.69,0-22.04,0.04 c-0.95,0-2.27,1.35-2.31,2.29c-0.03,0.86-0.1,1.62,1.01,2.08c0.65,0.27,0.96,1.53,1.59,1.68c1.92,0.48,3.91,0.63,5.87,0.93 c1.04,0.15,2.37-0.55,2.94,1.01c0.04,0.1,0.36,0.11,0.55,0.12c3.51,0.33,7.01,0.67,10.52,0.95c1.16,0.1,2.34,0.02,3.5,0.08 c0.4,0.02,0.79,0.25,1.19,0.39c0.5,0.18,1.01,0.52,1.52,0.53c2.43,0.06,4.86,0.01,7.3,0.06c0.65,0.01,1.3,0.23,1.94,0.4 c0.48,0.13,0.93,0.46,1.4,0.46c7.84,0.09,15.67,0.05,23.5,0.23c5.81,0.13,11.61,0.48,17.4,0.86c0.64,0.05,1.54,0.85,1.76,1.49 c0.49,1.43,1.55,2.76,1.15,4.45c-0.06,0.27,0.33,0.63,0.48,0.97c0.55,1.25,1.09,2.51,1.63,3.77c-0.137,0.184-0.17,0.23-0.307,0.414 c-0.944-0.093-1.899-0.132-2.823-0.294c-0.59-0.1-1.13-0.53-1.7-0.54c-6.96-0.1-13.91-0.14-20.87-0.22 c-1.08-0.01-2.29,0.4-3.09-0.88c-0.16-0.27-0.9-0.25-1.38-0.26c-1.6-0.03-3.21-0.01-4.82-0.01c-0.33-0.01-0.83,0.09-0.99-0.09 c-0.91-1.09-2.14-0.72-3.26-0.77c-1.26-0.05-2.53,0.01-3.79-0.02c-0.36-0.01-0.72-0.14-1.05-0.29c-0.58-0.25-1.11-0.75-1.7-0.82 c-2.88-0.32-5.74-0.13-8.66-0.74c-3.27-0.68-6.78-0.21-10.19-0.18c-0.48,0-1.14,0.2-1.4,0.55c-0.9,1.21,0.09,4.17,1.51,4.44 c2.01,0.39,4.05,0.6,6.08,0.87c0.72,0.1,1.84-0.1,2.09,0.29c0.78,1.21,1.85,0.74,2.83,0.84c0.92,0.1,2.04-0.16,2.7,0.29 c1.05,0.71,2.08,0.6,3.16,0.65c1.06,0.05,2.18-0.07,3.19,0.21c1.63,0.45,3.16,1.3,4.8,1.72c1.71,0.45,3.48,0.08,5.27,1.06 c1.43,0.78,3.44,0.32,5.23,0.91c2.13,0.71,4.5-0.02,6.83,0.88c2.46,0.95,5.22,0.01,8.01,1.07c3.13,1.19,6.86,0.81,10.33,1.12 c0.57,0.05,1.18,0.03,1.68,0.26c0.64,0.3,1.17,0.82,1.75,1.24c0.15-0.02,0.31-0.05,0.46-0.08c-0.1,1.18,0.17,2.59-0.39,3.5 c-0.86,1.38-2.53,1.97-4.19,2.02c-3.25,0.08-6.51,0.02-9.76,0.07c-1.86,0.03-2.68,0.94-2.66,2.81c0.01,0.93,1.47,3.14,2.4,3.36 c1.65,0.4,3.33,0.82,5.01,0.9c3.06,0.14,6.13,0.03,9.19,0.05c1.58,0,2.3,0.73,2.31,2.34c0.02,3.12,0.22,6.25-0.07,9.34 c-0.2,2.13,1.22,2.97,2.27,4.19c0.09,0.1,0.56,0.01,0.73-0.14c0.99-0.82,1.37-1.83,1.28-3.18c-0.06-1.03,0.45-2.08,0.6-3.13 c0.26-1.95-0.25-4.06,1.26-5.73c0.28-5.74,0.56-11.48,0.85-17.22c0.04-0.83,0.14-1.66,0.12-2.48c-0.08-3.46,0.65-6.86,0.83-10.28 c0.13-2.46-0.51-4.96-0.75-7.44c-0.12-1.26,0.28-2.76-0.28-3.74c-0.87-1.54-0.47-3.05-0.63-4.58c-0.05-0.53,0.01-1.07-0.06-1.6 c-0.05-0.37-0.12-0.96-0.36-1.06c-0.97-0.44-0.73-1.24-0.75-1.98c-0.04-1.8,0.39-3.78-0.24-5.34c-0.66-1.64-0.54-3.17-0.62-4.76 c-0.07-1.22-0.02-2.44-0.04-3.65c-0.01-0.44,0.04-1.1-0.2-1.26c-1.41-0.94-0.74-2.36-0.95-3.57c-0.24-1.44-0.63-2.87-0.69-4.32 c-0.07-1.59-0.67-3.32,0.58-4.74c0.21-0.24,0.92-0.42,1-0.32c0.42,0.54,0.88,1.15,1.01,1.8c0.31,1.52-0.14,3.06,1.03,4.58 c1.02,1.3,1.22,3.22,1.85,4.85c0.34,0.86,0.86,1.64,1.25,2.49c0.27,0.58,0.43,1.22,0.69,1.82c0.46,1.07,0.96,2.13,1.45,3.19 c0.52,1.12,1.04,2.24,1.56,3.35c0.41,0.87,1.05,1.69,1.2,2.59c0.41,2.58,0.73,5.18,0.87,7.78c0.17,3.21,0.12,6.43,0.19,9.64 c0.01,0.43-0.01,1.08,0.24,1.23c1.04,0.66,0.84,1.66,0.91,2.6c0.27,3.54-0.37,7.08,0.66,10.64c0.5,1.72,1.74,2.57,2.66,3.79 c0.16,0.21,0.75,0.19,1.12,0.12c0.62-0.12,2.42-2.53,2.46-3.18c0.51-8.75-0.35-17.53,0.71-26.29c0.41-3.38-0.31-6.91-0.58-10.36 c-0.09-1.15,0.49-2.57-1.1-3.24c-0.11-0.04-0.11-0.35-0.13-0.54c-0.3-2.81-0.59-5.62-0.9-8.42c-0.05-0.47-0.11-1.21-0.38-1.33 c-1.02-0.43-0.73-1.26-0.78-1.97c-0.08-1.11,0.3-2.53-0.25-3.27c-0.83-1.1-0.52-2.02-0.49-3.05c1.99-0.43,3.75-1.81,5.74-0.95 c0.39,2.88,0.85,5.69,1.14,8.52c0.23,2.29,1.01,4.26,2.89,5.63c0.45,0.33,1.22,0.47,1.77,0.35c0.76-0.15,1.45-0.63,2.3-1.03 c0-2.53-0.02-5.15,0.02-7.78c0.01-0.86-0.14-1.96,0.31-2.53c0.91-1.16,0.53-1.98-0.12-2.77c0.48-1.75,1.76-1.6,3.07-1.64 c6.71-0.25,13.42-0.57,20.13-0.87c0.19,0,0.39-0.03,0.58-0.06c2.915-0.587,5.795-1.362,8.816-1.146 c1.388,0.099,2.779,0.185,4.166,0.067c1.583-0.135,3.2,0.101,4.658-0.921c0.97-0.68,1.69-1.88,1.18-3.28 c-0.25-0.68-1.16-1.55-1.81-1.58c-5.95-0.3-11.92-0.12-17.83-1.11c-0.37-0.06-0.98-0.04-1.06-0.23c-0.47-1.12-1.42-0.85-2.25-0.88 c-1.79-0.07-3.78,0.4-5.34-0.22c-1.54-0.62-2.97-0.51-4.46-0.69c-4.45-0.53-9.09,1.2-13.37-1.14c-0.57-0.31-1.22-0.55-1.66-0.99 c-1.16-1.18-2.18-2.5-3.35-3.68c-1.89-1.9-3.88-3.71-5.77-5.62c-1.11-1.1-1.9-2.74-3.21-3.36c-1.71-0.81-2.94-1.96-4.27-3.2 c-1.45-1.36-3.25-2.35-5.13-3.67v-1.37c2.39,0.23,4.78-0.38,6.81,1.6c0.74,0.73,2.1,1.17,3.17,1.15c2.07-0.06,2.81-1.1,2.83-3.22 c0.012-1.029,0.105-2.072-0.135-3.065c-0.126-0.522-0.594-1.242-0.983-1.612c-0.994-0.944-2.204-1.718-2.982-2.803 c-1.18-1.62-2.71-2.7-4.3-3.8c-0.66-0.45-1.27-1.04-1.77-1.68c-0.62-0.77-1.01-1.75-1.67-2.48c-0.7-0.79-1.07-1.55-1.07-2.66 c0.04-25.52,0.02-51.03,0.09-76.55c0.01-2.45,0.54-4.89,0.86-7.33c0.02-0.2,0.28-0.36,0.38-0.56c0.51-1.02,1.37-2.03,1.42-3.07 c0.2-4.67,0.37-9.36,0.15-14.02c-0.23-4.6,0.89-9.24-0.91-13.86c-0.97-2.5-0.76-5.45-1.08-8.2c-0.06-0.53-0.12-1.06-0.22-1.59 c-0.17-0.92-0.53-1.84-0.54-2.75c0-1.6-0.1-3.16,0.52-4.8c0.54-1.42,0.41-3.2,0.21-4.77c-0.37-2.8,0.82-5.35,0.97-8.05 c0.01-0.14,0.05-0.36,0.14-0.4c1.26-0.61,0.84-1.8,0.99-2.79c0.06-0.43-0.11-1.04,0.12-1.27c1.46-1.45,0.73-3.5,1.61-5.25 c1.1-2.2-0.12-5.19,1.07-7.68c0.04-9.5,0.1-18.99,0.12-28.49c0-1.74,0.34-3.72-0.35-5.18c-0.85-1.83-0.55-3.56-0.74-5.33 c-0.04-0.36-0.16-0.73-0.31-1.07c-0.25-0.56-0.68-1.08-0.79-1.67c-0.37-2.01-0.64-4.05-0.95-6.07 c-0.018-0.064-0.035-0.126-0.053-0.19c-0.547-1.29-1.442-2.513-1.707-3.87c-0.47-2.46-0.88-4.98-0.88-7.47 c-0.04-51.72-0.02-103.44-0.05-155.15c0-2.24,0.68-3.89,2.54-5.13c0.81-0.53,1.5-1.26,2.19-1.96c1.11-1.12,2.13-2.32,3.27-3.39 c0.39-0.36,1.19-0.28,1.57-0.64c1.32-1.26,2.51-2.66,3.81-3.95c1.03-1.02,2.18-1.94,3.2-2.97c1.34-1.36,2.58-2.82,3.92-4.18 c1.21-1.22,2.62-2.26,3.72-3.58c1.17-1.4,2.28-2.77,4.14-3.27c0.14-0.04,0.24-0.28,0.35-0.43c1.26-1.87,1.11-3.98,0.97-6.07 c-0.02-0.38-0.44-0.97-0.78-1.06c-2.42-0.64-4.68,0.12-6.93,0.92c-0.29,1.52-1.89,1.12-2.8,1.7c-1.15,0.74-2.85,0.01-4.3,1.16 c-0.88,0.7-2.61,0.58-3.96,0.92c-1.74,0.44-3.32,1.03-4.92,2.07c-0.1-0.55-0.25-1.01-0.25-1.47c0-2.48-0.03-4.97,0.07-7.45 c0.23-5.62,0.14-11.24,0.73-16.88c0.56-5.39-0.01-10.89-0.04-16.34c-0.03-6.04,0.03-12.08-0.03-18.12 c-0.03-2.15,0.05-4.26-0.48-6.46c-0.76-3.17-0.78-6.51-1.2-9.77c-0.11-0.84-0.54-1.64-0.8-2.46c-0.06-0.22-0.15-0.54-0.04-0.67 c0.72-0.89,1.46-1.75,2.24-2.59c1.82-1.97,3.8-3.81,5.45-5.92c1.33-1.69,2.58-3.28,4.76-3.9c0.76-0.21,1.55-0.62,2.13-1.15 c1.19-1.11,2.12-2.36,3.81-3.06c1.74-0.72,3.12-2.32,4.64-3.56c0.41-0.33,0.73-0.78,1.16-1.07c2.04-1.42,4.11-2.79,6.15-4.21 c0.29-0.2,0.44-0.61,0.73-0.8c1.46-0.91,3.01-1.69,4.41-2.68c1.16-0.81,2.17-1.83,3.2-2.8c0.46-0.44,0.86-0.97,1.18-1.51 c0.4-0.68,0.54-1.55,1.06-2.09c1.159-1.21,1.822-2.544,1.82-4.222c0-0.258,0.046-0.516,0.159-0.747c0.97-1.97,2.06-3.9,2.95-5.92 c1.15-2.6,2.08-5.3,3.24-7.89c1.04-2.33,2.44-4.52,3.34-6.89c0.61-1.59,1.59-2.02,3.03-2.03c3.99-0.03,7.99-0.22,11.96,0.02 c2.25,0.14,3.79-1.49,5.85-1.66c0.717-0.051,1.424-0.522,2.077-0.886c0.846-0.472,1.672-0.976,2.476-1.516 c0.646-0.434,1.381-0.838,1.917-1.398C230.441,131.98,230.311,130.27,230.071,128.64z M111.437,192.42 c-46.57,0-84.32-37.75-84.32-84.32c0-46.56,37.75-84.31,84.32-84.31c46.56,0,84.31,37.75,84.31,84.31 C195.747,154.67,157.997,192.42,111.437,192.42z"
    ],
    clocks: {
      size: 169,
      0: { x: 111.011, y: 108.5 }
    }
  },
  2: {
    height: 625.438,
    width: 197.009,
    path: "M193.86,271.21c-2.234-2.626-5.64-4.792-8.929-5.835c-6.793-2.153-11.841,2.196-17.463,7.369 c-5.009-25.727-17.583-43.987-38.477-54.246l-18.909-21.56v-12l20.773-23.686c19.55-10.446,31.402-28.304,36.229-53.096 c5.622,5.174,10.67,9.523,17.463,7.369c3.289-1.043,6.695-3.208,8.929-5.835c4.877-5.734,3.879-14.302-1.542-19.605 c-6.442-6.301-13.569-5.549-24.852,3.382c-4.816-25.231-17.183-43.587-38.409-54.031h0.158c-1.506-0.732-3.056-1.394-4.625-2.025 c-2.997-1.25-6.144-2.365-9.463-3.327c0,0-0.527-0.089-1.457-0.217c-2.421-0.731-4.757-2.02-7.743-3.273 c2.103-2.282,3.255-3.455,4.321-4.703c5.176-6.057,4.821-14.978-0.792-20.538c-5.647-5.594-14.543-5.829-20.352-0.539 c-6.101,5.556-6.808,14.49-1.648,20.831c4.153,5.103,3.905,5.403-2.49,8.055c-1.793,0.744-3.604,1.465-5.417,2.187 c-10.281,3.032-16.092,6.929-22.875,12.001c-12.415,9.284-19.739,22.385-23.521,37.515c-0.673,2.693-2.08,5.2-3.437,8.492 c-2.262-2.122-3.424-3.284-4.661-4.36c-6.003-5.222-14.845-4.864-20.356,0.799c-5.544,5.698-5.778,14.673-0.534,20.534 c5.507,6.156,14.361,6.869,20.646,1.662c5.058-4.19,5.355-3.94,7.984,2.512c3.394,8.33,6.292,17.054,10.972,24.62 c6.032,9.752,14.303,16.873,24.096,21.915l21.601,23.357v12l-20.223,21.867c-10.232,5.068-18.855,12.348-25.091,22.43 c-4.68,7.566-7.578,16.29-10.972,24.62c-2.629,6.452-2.926,6.702-7.984,2.512c-6.285-5.206-15.139-4.493-20.646,1.662 c-5.243,5.861-5.01,14.837,0.534,20.534c5.511,5.663,14.352,6.021,20.356,0.799c1.237-1.076,2.399-2.238,4.661-4.36 c1.356,3.292,2.764,5.799,3.437,8.492c3.782,15.13,11.106,28.232,23.521,37.515c7.877,5.89,14.425,10.198,28.206,13.404 c1.38,0.321,2.787,0.579,4.201,0.789c0.031,27.796,0.06,69.604,0.085,105.236c0.009,13.829,0.018,26.73,0.026,37.518 c0,0.826-0.08,1.652-0.121,2.436c-3.447,0.597-4.58-0.495-4.682-4.511c-0.072-2.822-0.002-5.649-0.016-8.473 c-0.024-4.802-0.891-5.97-4.609-5.976c-14.432-0.022-28.864-0.01-43.295-0.009c-4.627,0-9.255,0.084-13.881-0.022 c-3.054-0.07-4.428,1.698-4.326,5.623c0.079,3.039,0.085,6.08-0.001,9.119c-0.111,3.933,1.27,5.674,4.317,5.646 c8.372-0.076,16.745-0.038,25.118-0.024c4.14,0.007,4.933,1.055,4.947,6.397c0.024,9.702,0.024,9.702-7.67,9.702 c-7.381-0.001-14.762-0.025-22.143,0.006c-3.558,0.015-4.54,1.209-4.551,5.611c-0.035,13.947-0.943,13.109,10.004,13.035 c6.61-0.045,13.22-0.032,19.83,0.002c3.528,0.018,4.463,1.226,4.534,5.638c0.17,10.455,0.17,10.455-8.056,10.455 c-7.271,0-14.542-0.024-21.813,0.01c-3.492,0.016-4.48,1.263-4.503,5.672c-0.067,12.642-0.701,12.243,9.397,12.129 c6.83-0.077,13.661-0.04,20.491-0.004c3.466,0.018,4.419,1.281,4.484,5.702c0.154,10.39,0.154,10.39-8.106,10.39 c-7.271,0-14.542-0.026-21.813,0.01c-3.447,0.017-4.439,1.296-4.452,5.736c-0.039,13.671-0.908,12.955,9.772,12.916 c17.076-0.063,34.152-0.012,51.227-0.02c4.329-0.002,5.098-1.02,5.1-6.63c0.001-1.977-0.037-3.956,0.007-5.931 c0.094-4.282,1.178-5.371,4.197-4.937c1.031,10.07,1.909,19.99,3.129,29.842c0.425,3.429,1.312,6.98,2.695,9.93 c1.2,2.56,3.388,5.993,5.16,6.013c1.744,0.02,4.469-3.383,5.098-5.954c2.029-8.292,4.037-16.802,4.667-25.395 c0.85-11.612,0.501-23.379,0.517-35.079c0.042-30.977,0.078-68.798,0.115-106.572c0.037-37.246,0.075-74.445,0.121-104.988 c3.105-0.304,5.045-0.635,5.045-0.635c29.872-8.658,46.55-29.062,52.338-59.383c11.283,8.931,18.409,9.683,24.852,3.382 C197.739,285.512,198.737,276.945,193.86,271.21z M44.186,100.381c0-29.823,24.177-54,54-54s54,24.177,54,54 c0,29.823-24.177,54-54,54S44.186,130.205,44.186,100.381z M98.186,334.381c-29.823,0-54-24.177-54-54c0-29.823,24.177-54,54-54 s54,24.177,54,54C152.186,310.205,128.009,334.381,98.186,334.381z",
    clocks: {
      size: 108,
      0: { x: 98.579, y: 280 },
      1: { x: 98.579, y: 100 }
    }
  },
  3: {
    height: 915.936,
    width: 277.634,
    path: "M263.752,257.836c-13.719,1.508,3.345-15.515,3.955-23.109l-0.113,0.113 c8.127-22.574,2.75-46.079-10.802-65.608c14.365-1.735,19.981-6.287,20.122-15.339c0.118-7.617-5.228-14.388-12.762-14.963 c-3.451-0.263-7.412,0.636-10.496,2.245c-6.369,3.324-6.896,10.001-7.248,17.67c-12.146-8.157-24.329-12.988-36.575-14.34 c-2.94-2.54-4.264-6.236-3.879-10.997c0.451-5.587,0.239-11.066-0.572-16.359c0.828-2.872,1.549-5.847,2.156-8.934 c5.672,5.174,10.766,9.523,17.62,7.369c3.319-1.043,6.755-3.208,9.009-5.835c4.921-5.734,3.914-14.302-1.556-19.605 c-6.5-6.301-13.69-5.549-25.075,3.382c-5.055-30.578-25.967-51.62-54.619-60.047c-2.447-0.732-4.807-2.023-7.825-3.278 c2.125-2.286,3.29-3.461,4.367-4.71c11.938-14.551-7.15-33.181-21.367-21.111c-6.165,5.565-6.879,14.513-1.665,20.864 c4.197,5.111,3.946,5.411-2.516,8.068c-1.812,0.745-3.642,1.467-5.474,2.19c-24.645,7.648-40.948,25.21-46.886,49.595 c-0.68,2.698-2.102,5.208-3.473,8.505c-2.286-2.125-3.461-3.29-4.71-4.367c-14.552-11.938-33.18,7.152-21.111,21.367 c5.565,6.165,14.513,6.879,20.864,1.665c4.71-3.867,5.338-3.944,7.487,1.123c-1.309,6.465-1.74,13.174-1.396,20.102 c0.3,6.03-1.497,10.097-5.356,12.617c-8.889,2.044-17.148,6.132-25.567,9.656c-6.448,2.691-6.837,2.656-7.484-3.926 c-0.804-8.178-7.636-14-15.931-13.576c-18.581,1.516-18.918,28.187-0.181,30.036c1.645,0.122,3.299,0.129,6.419,0.243 c-1.366,3.319-2.113,5.992-3.558,8.47c-3.428,5.74-6.123,11.683-7.912,17.811c-4.722,16.154-2.533,34.602,5.996,50.411 c1.801,5.691,8.569,13.392-1.603,12.903c-40,12.971,18.416,54.114,16.704,9.691c34.782,3.225,46.692,41.92,80.447,49.674 c7.963,2.791,11.179,6.671,12.046,13.724c0.012,3.241,0.01,6.503,0,9.829h-0.223c0,2.086,0,5.309,0,5.309s0.065,0.184-0.069,0.268 c-7.211-0.002-14.005-0.041-20.79,0.015c-4.483,0.037-6.154,1.09-6.592,4.667c-0.352,4.638-0.043,9.45-0.131,14.122 c0.062,5.274,1.49,6.69,6.861,6.724c6.999,0.045,13.998,0.011,21.721,0.011v5.671c-7.723,0-14.722-0.034-21.721,0.011 c-5.372,0.035-6.799,1.45-6.861,6.724c0.087,4.671-0.221,9.484,0.131,14.122c0.438,3.577,2.109,4.63,6.592,4.667 c6.785,0.056,13.579,0.017,20.79,0.015c0.134,0.084,0.279,0.175,0.069,0.268v5.406h0.599c0.031,3.784,0.031,7.619,0,12h-0.599 v4.809c0,0,0.065,0.184-0.069,0.268c-7.211-0.002-14.005-0.041-20.79,0.015c-4.483,0.037-6.154,1.09-6.592,4.667 c-0.352,4.638-0.043,9.45-0.131,14.122c0.062,5.274,1.49,6.69,6.861,6.724c6.999,0.045,13.998,0.011,21.721,0.011v5.671 c-7.723,0-14.722-0.034-21.721,0.011c-5.372,0.035-6.799,1.45-6.861,6.724c0.087,4.671-0.221,9.484,0.131,14.122 c0.438,3.577,2.109,4.63,6.592,4.667c6.785,0.056,13.579,0.017,20.79,0.015c0.134,0.084,0.279,0.175,0.069,0.268v4.906h0.599 c0.031,4.284,0.031,8.119,0,12h-0.599v5.309c0.211,0.092,0.065,0.184-0.069,0.268c-7.211-0.002-14.005-0.041-20.79,0.015 c-4.483,0.037-6.154,1.09-6.592,4.667c-0.352,4.638-0.043,9.45-0.131,14.122c0.062,5.274,1.49,6.69,6.861,6.724 c6.999,0.045,21.721,0.011,21.721,0.011v5.671c0,0-14.722-0.034-21.721,0.011c-5.372,0.035-6.799,1.45-6.861,6.724 c0.087,4.671-0.221,9.484,0.131,14.122c0.438,3.577,2.109,4.63,6.592,4.667c6.785,0.056,13.579,0.017,20.79,0.015 c0.134,0.084,0.279,0.175,0.457,0.268c0,1.594,4.559,168.228,4.51,209.286c-0.005,4.1,0.442,9.128,0.442,10.259 c-3.396,0-6.234,0.133-9.054-0.034c-3.499-0.206-5.37,1.456-6.735,4.558c-1.281,2.913-2.803,5.866-4.843,8.27 c-6.58,7.751-16.578,7.84-23.206,0.144c-2.209-2.565-3.736-5.81-5.169-8.932c-1.239-2.699-2.939-4.083-5.916-4.024 c-3.712,0.073-7.428,0.078-11.14-0.009c-3.163-0.074-4.936,1.432-6.143,4.306c-1.141,2.716-2.476,5.469-4.285,7.764 c-8.725,11.281-23.01,6.923-27.966-5.357c-1.496-5.628-5.039-7.274-10.521-6.767c-4.485,0.415-6.285,1.937-6.286,6.612 c-0.001,15.755-0.002,31.511-0.003,47.266c-0.001,16.376-0.012,32.752,0.006,49.127c0.004,3.646,2.039,5.706,5.586,5.765 c4.244-0.151,7.724,1.078,9.747-3.72c1.63-3.566,3.31-7.297,5.811-10.239c5.927-6.969,15.25-7.396,21.596-0.827 c2.91,3.012,4.885,7.078,6.716,10.936c1.245,2.623,2.748,3.896,5.573,3.857c3.96-0.055,7.925-0.102,11.882,0.027 c3.041,0.099,4.629-1.359,5.914-4.011c1.386-2.861,3.016-5.766,5.166-8.063c10.107-10.412,22.254-3.718,27.139,8.037 c1.337,2.907,3.18,4.141,6.281,4.034c3.442-0.119,6.891-0.027,10.523-0.027c1.065,5.652,2.167,11.021,3.856,16.453 c1.228,3.675,2.407,8.536,7.056,8.594c4.923,0.061,6.042-4.987,7.307-8.743c1.456-4.322,2.867-8.847,3.125-13.35 c0.728-12.721,1.152-25.477,1.174-38.219c0.19-111.404,0.292,50.177,0.366-61.227c0.003-5.129,0.201-18.49,0.201-22.46 c0-41.693,4.098-203.286,4.098-209.558c8.112,0,15.82-0.053,23.528,0.021c5.544,0.13,6.64-3.323,6.288-8.201 c0.033-3.547,0.038-7.095-0.007-10.642c-0.066-5.278-1.476-6.669-6.885-6.701c-7.529-0.044-23.121-0.011-23.121-0.011v-5.671 c0,0,15.592,0.033,23.121-0.011c5.408-0.032,6.819-1.423,6.885-6.701c0.044-3.547,0.04-7.095,0.007-10.642 c0.351-4.882-0.742-8.33-6.288-8.201c-7.707,0.073-15.416,0.021-22.724,0.021v-22.76c7.308,0,15.017-0.053,22.724,0.021 c5.544,0.13,6.64-3.323,6.288-8.201c0.033-3.547,0.038-7.095-0.007-10.642c-0.066-5.278-1.476-6.669-6.885-6.701 c-7.529-0.044-15.059-0.011-23.121-0.011v-5.671c8.062,0,15.592,0.033,23.121-0.011c5.408-0.032,6.819-1.423,6.885-6.701 c0.044-3.547,0.04-7.095,0.007-10.642c0.351-4.882-0.742-8.33-6.288-8.201c-7.707,0.073-15.416,0.021-22.724,0.021v-22.76 c7.308,0,15.017-0.053,22.724,0.021c5.544,0.13,6.64-3.323,6.288-8.201c0.033-3.547,0.038-7.095-0.007-10.642 c-0.066-5.278-1.476-6.669-6.885-6.701c-7.529-0.044-15.059-0.011-23.121-0.011v-5.671c8.062,0,15.592,0.033,23.121-0.011 c5.408-0.032,6.819-1.423,6.885-6.701c0.044-3.547,0.04-7.095,0.007-10.642c0.351-4.882-0.742-8.33-6.288-8.201 c-7.707,0.073-15.416,0.021-22.724,0.021v-13.831c0.379-7.638,5.186-13.149,13.162-15.825 c28.456-7.104,41.808-33.352,64.888-48.287c17.492-10.743,9.354,22.937,28.518,19.129 C282.127,286.309,282.455,259.681,263.752,257.836z M105.697,839.074c0.498,2.38,0.15,4.934-3.302,4.884 c-2.295-0.033-3.176,1.042-3.702,3.217c-0.26,1.076-1.713,2.383-2.793,2.559c-0.723,0.118-2.36-1.479-2.505-2.467 c-0.409-2.804-2.004-3.344-4.385-3.299c-3.709,0.07-7.424,0.116-11.131-0.006c-3.83-0.126-3.945,2.278-3.981,5.13 c-0.038,2.976,0.755,4.826,4.142,4.589c1.477-0.103,2.968,0.015,4.451-0.025c2.202-0.059,4.543-0.006,4.579,2.901 c0.039,3.187-2.477,3.119-4.78,3.068c-1.36-0.03-2.728,0.082-4.08-0.025c-3.258-0.257-4.5,1.312-4.272,4.425 c-0.041,4.353,1.027,8.028-4.883,7.506c-7.022,0.039-7.951,0.802-7.543-7.405c0.169-3.39-1.192-4.855-4.554-4.524 c-0.857,0.085-1.922,0.329-2.555-0.056c-1.2-0.729-2.156-1.861-3.213-2.825c1.006-1.017,1.944-2.121,3.057-3.004 c0.38-0.301,1.199-0.042,1.817-0.044c5.007-0.022,7.131-2.986,5.196-7.646c-0.392-0.945-1.974-1.785-3.11-1.944 c-3.651-0.437-7.442,0.158-11.117-0.121c-3.786-0.387-5.894,0.721-5.698,5.061c0.045,0.996-1.78,2.077-2.744,3.119 c-0.848-1.038-2.451-2.105-2.412-3.108c0.153-3.932-1.445-5.27-5.269-5.225c-1.017,0.012-2.491-1.899-2.973-3.215 c-0.52-1.421-0.127-3.18-0.126-4.791c0-5.24-0.002-5.268,5.3-5.954c2.366-0.306,3.023-1.787,2.927-3.889 c-0.098-2.143,0.268-4.425,2.848-4.073c1.034,0.141,2.342,2.528,2.49,3.998c0.282,2.788,1.314,4.039,4.131,3.976 c3.956-0.088,7.919-0.125,11.873,0.011c3.063,0.105,4.168-1.204,4.13-4.212c-0.036-2.816-0.326-5.041-3.916-4.755 c-2.559,0.203-4.468-0.474-4.367-3.527c0.095-2.865,2.016-3.344,4.358-3.173c2.898,0.212,3.849-1.243,3.979-4.019 c0.085-1.821,0.73-5.002,1.563-5.153c3.046-0.553,6.308-0.31,9.408,0.165c0.646,0.099,1.284,2.453,1.345,3.795 c0.224,4.967,0.374,5.207,5.401,5.214c1.361,0.002,2.929-0.422,4.027,0.116c1.271,0.623,2.94,2.09,2.942,3.194 c0.002,1.125-1.621,2.815-2.876,3.241c-1.665,0.565-3.667,0.223-5.518,0.132c-3.18-0.157-3.971,1.57-3.952,4.398 c0.019,2.703,0.495,4.64,3.783,4.569c3.956-0.085,7.916-0.055,11.873-0.012c2.165,0.024,3.322-0.763,3.826-3.068 c0.241-1.105,1.771-1.927,2.718-2.877c0.905,0.971,2.333,1.814,2.605,2.939c0.545,2.256,1.757,2.7,3.843,3.111 C108.401,831.102,105.035,835.914,105.697,839.074z M139.108,46c29.823,0,54,24.177,54,54c0,29.823-24.177,54-54,54 s-54-24.177-54-54C85.108,70.176,109.285,46,139.108,46z M19.108,212c0-29.823,24.177-54,54-54s54,24.177,54,54 c0,29.823-24.177,54-54,54S19.108,241.823,19.108,212z M144.944,857.898c-2.09,2.578-1.865,5.176-1.942,7.953 c-0.024,0.854,0.131,1.914-0.302,2.509c-2.403,3.147-3.159,2.809-5.436-0.185c-0.264-0.306-0.178-0.948-0.184-1.437 c-0.041-3.271,0.536-6.657-2.369-9.253c-0.531-0.475-0.479-1.605-0.957-3.425c1.21-1.271,2.47-3.306,4.294-4.333 c2.379-1.339,5.236-0.58,6.441,1.819C145.405,853.367,145.95,856.658,144.944,857.898z M144.996,807.941 c-2.224,2.677-1.877,5.438-1.992,8.318c-0.086,2.146-0.2,4.578-2.99,4.544c-2.765-0.034-2.874-2.475-2.933-4.614 c-0.08-2.895,0.543-5.919-2.179-8.193c-0.631-0.527-0.645-1.797-1.234-3.633c1.265-1.382,2.48-3.465,4.292-4.5 c2.341-1.338,5.233-0.649,6.476,1.731C145.382,803.404,145.991,806.744,144.996,807.941z M80.062,279.694 c17.171-3.582,56.234-25.446,59.296-50.487c5.518,22.114,30,48.729,61,48.729C162.77,319.773,120.431,321.28,80.062,279.694z M205.108,266c-29.823,0-54-24.177-54-54c0-29.823,24.177-54,54-54s54,24.177,54,54C259.108,241.823,234.932,266,205.108,266z",
    clocks: {
      size: 108,
      0: { x: 138.892, y: 100 },
      1: { x: 72.892, y: 212 },
      2: { x: 204.892, y: 212 }
    }
  },
  4: {
    height: 1041,
    width: 368.697,
    path: "M365.949,178.882c-2.159-2.705-5.464-5.038-8.725-6.201c-7.211-2.57-12.634,1.794-18.155,7.261 c-1.008-3.182-1.811-5.292-2.346-7.468c-7.207-29.311-25.676-46.993-55.052-53.142c-3.565-0.746-4.337-2.365-5.721-5.525 c-10.917-24.928-15.917-32.928-31.863-49.408c-1.625-1.679-3.453-3.192-5.144-4.761c-15.909-14.758-20.909-17.758-43.492-26.71 c-1.882-0.746-3.781-1.782-6.866-3.302c2.349-1.876,3.694-2.659,4.662-3.772c4.695-5.397,4.837-13.436,0.452-19.014 c-5.3-6.742-15-7.806-21.456-2.354c-6.714,5.67-7.304,15.417-1.328,21.919c3.617,3.935,3.297,5.361-1.725,7.153 c-2.044,0.73-4.17,1.226-6.237,1.896c-12.766,4.137-23.255,11.604-31.918,21.798c-2.372,2.791-4.778,5.622-7.539,8.002 c-15.564,13.413-26.166,29.895-31.108,49.904c-0.68,2.752-1.741,4.084-4.825,4.54c-29.053,4.299-51.461,25.809-57.16,54.556 c-0.307,1.549-0.792,3.062-1.25,4.806c-11.35-8.302-18-8.998-24.401-2.862c-5.321,5.101-6.467,13.398-1.935,19.203 c2.036,2.608,5.192,4.836,8.302,6.005c7.137,2.683,12.59-1.579,17.735-6.353c0.583,1.299,1.01,1.874,1.096,2.496 c4.046,29.315,27.997,53.277,57.825,57.393c2.223,0.307,4.062,1.874,4.644,4.041c1.308,4.861,2.891,9.682,4.787,14.345 c9.432,23.198,28.811,38.203,45.823,55.084c5.104,5.065,11.204,9.197,17.156,13.308c5.563,3.842,7.792,8.391,7.788,15.456 c-0.129,188.254-0.004,308.508,0.065,496.762c0,0.102-0.005,0.205-0.006,0.307v41.241c-2.701,0.026-5.102,0.092-7.461-0.047 c-3.499-0.206-5.37,1.456-6.735,4.558c-1.282,2.913-2.803,5.866-4.844,8.27c-6.581,7.751-16.578,7.84-23.206,0.144 c-2.254-2.617-3.797-5.94-5.255-9.119c-1.087-2.369-3.472-3.882-6.078-3.833c-3.63,0.068-7.263,0.071-10.893-0.013 c-3.163-0.074-4.936,1.432-6.143,4.306c-1.141,2.716-2.476,5.469-4.285,7.764c-8.725,11.281-23.01,6.923-27.966-5.357 c-1.496-5.628-5.039-7.274-10.521-6.767c-4.485,0.415-6.285,1.937-6.286,6.612c-0.001,15.755-0.002,31.511-0.003,47.266 c-0.001,16.376-0.012,32.752,0.006,49.127c0.004,3.646,2.039,5.706,5.586,5.765c4.244-0.151,7.724,1.078,9.747-3.72 c1.63-3.566,3.31-7.297,5.811-10.239c5.927-6.969,15.25-7.396,21.596-0.827c2.91,3.012,4.885,7.078,6.716,10.936 c1.457,3.071,3.269,4.292,7.14,3.723c2.897-0.426,5.844-0.506,8.73-0.009c4.108,0.708,6.007-0.762,7.499-3.84 c1.386-2.861,3.016-5.766,5.166-8.063c10.107-10.412,22.254-3.718,27.139,8.037c1.337,2.907,3.181,4.141,6.281,4.034 c2.715-0.094,5.446-0.058,8.257-0.038v2.091c0.319,0.001,0.631,0.004,0.951,0.004c0.362,2.11,0.473,3.786,0.947,5.352 c2.41,7.972,4.19,16.244,7.596,23.773c3.168,7.005,9.289,6.901,12.709-0.011c2.932-5.925,5.134-12.395,6.525-18.868 c4.01-18.662,2.675-37.664,2.696-56.567c0.133-118.853,0.314,0.295,0.392-118.558c0.068-103.934,0.013-377.867,0.064-481.801 c0.001-2.781-0.281-6.125,1.073-8.24c4.886-7.634,8.978-15.851,18.168-20.058c5.139-2.352,9.257-7.045,13.652-10.893 c4.267-3.736,8.16-7.904,12.459-11.599c15.452-13.278,26.023-29.619,30.885-49.451c0.909-3.707,2.926-4.598,6.161-5.73 c8.764-3.067,17.943-5.775,25.742-10.598c14.82-9.164,23.822-23.162,28.263-40.071c0.703-2.678,1.909-5.223,2.991-8.122 c11.076,8.596,18.006,9.328,24.489,3.223C369.187,192.953,370.464,184.538,365.949,178.882z M146.765,952.539 c0.498,2.38,0.15,4.934-3.302,4.884c-2.294-0.033-3.176,1.042-3.702,3.217c-0.26,1.076-1.713,2.383-2.793,2.559 c-0.723,0.118-2.36-1.479-2.504-2.467c-0.409-2.804-2.004-3.344-4.384-3.299c-3.709,0.07-7.424,0.116-11.131-0.006 c-3.83-0.126-3.945,2.278-3.981,5.13c-0.038,2.976,0.755,4.826,4.142,4.589c1.477-0.103,2.968,0.015,4.451-0.025 c2.202-0.059,4.543-0.006,4.579,2.901c0.04,3.187-2.477,3.119-4.78,3.068c-1.36-0.03-2.728,0.082-4.08-0.025 c-3.258-0.257-4.5,1.312-4.272,4.425c-0.041,4.353,1.027,8.028-4.883,7.506c-7.022,0.039-7.951,0.802-7.542-7.405 c0.168-3.39-1.192-4.855-4.555-4.524c-0.857,0.085-1.922,0.329-2.555-0.056c-1.2-0.729-2.156-1.861-3.213-2.825 c1.006-1.017,1.944-2.121,3.057-3.004c0.379-0.301,1.199-0.042,1.817-0.044c5.007-0.022,7.131-2.986,5.197-7.646 c-0.393-0.945-1.975-1.785-3.11-1.944c-3.651-0.437-7.442,0.158-11.117-0.121c-3.786-0.387-5.894,0.721-5.698,5.061 c0.045,0.996-1.78,2.077-2.744,3.119c-0.848-1.038-2.451-2.105-2.412-3.108c0.153-3.932-1.445-5.27-5.269-5.225 c-1.017,0.012-2.491-1.899-2.973-3.215c-0.52-1.422-0.127-3.18-0.126-4.791c0.001-5.24-0.002-5.268,5.3-5.954 c2.366-0.306,3.023-1.787,2.927-3.889c-0.098-2.143,0.268-4.425,2.848-4.073c1.034,0.141,2.342,2.528,2.49,3.998 c0.282,2.788,1.314,4.039,4.131,3.976c3.956-0.088,7.919-0.125,11.872,0.011c3.063,0.105,4.168-1.204,4.13-4.212 c-0.035-2.816-0.326-5.041-3.916-4.755c-2.559,0.203-4.468-0.474-4.367-3.527c0.095-2.865,2.016-3.344,4.358-3.173 c2.898,0.212,3.849-1.243,3.979-4.019c0.085-1.821,0.73-5.002,1.563-5.153c3.046-0.553,6.308-0.31,9.408,0.165 c0.646,0.099,1.284,2.453,1.345,3.795c0.224,4.967,0.375,5.207,5.402,5.214c1.361,0.002,2.928-0.423,4.027,0.116 c1.272,0.623,2.94,2.09,2.943,3.194c0.002,1.125-1.621,2.815-2.876,3.241c-1.666,0.565-3.668,0.223-5.518,0.132 c-3.18-0.157-3.971,1.57-3.952,4.398c0.019,2.703,0.495,4.64,3.783,4.569c3.957-0.085,7.916-0.055,11.874-0.012 c2.166,0.024,3.322-0.763,3.826-3.068c0.242-1.105,1.771-1.927,2.718-2.877c0.905,0.971,2.333,1.814,2.605,2.939 c0.545,2.256,1.757,2.7,3.843,3.111C149.469,944.566,146.104,949.379,146.765,952.539z M252.621,98.898 c0.287-0.167,0.574-0.334,0.861-0.502c2.841,6.521,5.683,13.042,8.739,20.056c-4.719,1.002-8.414,1.787-12.443,2.642 C250.758,113.446,251.689,106.172,252.621,98.898z M184.136,46.188c29.823,0,54,24.177,54,54c0,29.823-24.177,54-54,54 s-54-24.177-54-54C130.136,70.365,154.313,46.188,184.136,46.188z M162.097,165.903c14.218,3.796,27.946,4.565,42.414-0.072 c-3.942,14.414-4.001,28.063,0.302,42.583c-14.189-3.96-27.779-4.487-42.527-0.062C166.547,193.78,166.444,180.286,162.097,165.903 z M114.049,99.643c0.292,0.134,0.583,0.269,0.875,0.403c1.095,7.133,2.19,14.267,3.378,22.01 c-3.852-0.843-7.747-1.695-12.458-2.726C108.69,112.502,111.369,106.072,114.049,99.643z M114.09,275.17 c-2.992-7.299-5.446-13.283-8.044-19.622c4.192-0.951,7.557-1.714,11.303-2.564C116.293,260.174,115.314,266.84,114.09,275.17z  M97.136,240.188c-29.823,0-54-24.177-54-54c0-29.823,24.177-54,54-54s54,24.177,54,54 C151.136,216.012,126.96,240.188,97.136,240.188z M190.317,961.816c-2.889,3.631-2.59,7.316-2.675,11.229 c-0.063,2.929-0.301,6.185-4.102,6.083c-3.718-0.099-3.92-3.373-3.912-6.266c0.01-3.961,0.532-7.956-2.966-11.069 c-0.843-0.75-0.86-2.433-1.653-4.938c1.737-1.842,3.427-4.577,5.876-5.996c3.218-1.864,7.078-0.801,8.743,2.361 C190.908,955.651,191.666,960.12,190.317,961.816z M190.377,894.286c-2.75,3.639-2.754,7.277-2.731,11.231 c0.017,2.954-0.303,6.162-3.967,6.219c-3.722,0.058-4.036-3.156-4.069-6.118c-0.044-3.915,0.729-7.982-2.898-11.07 c-0.855-0.728-0.902-2.408-1.792-5.047c1.877-1.885,3.726-5.163,6.313-5.925c2.41-0.711,6.606,0.411,8.177,2.279 C190.999,887.744,191.681,892.56,190.377,894.286z M190.399,830.196c-3.107,3.329-2.592,6.926-2.795,10.682 c-0.086,1.597-0.323,3.33-1.04,4.717c-1.41,2.725-4.298,2.744-5.822,0.114c-0.63-1.087-1.04-2.453-1.075-3.706 c-0.125-4.43,0.653-9.009-3.304-12.472c-0.62-0.543-0.572-1.852-0.833-2.806c-0.315-0.34-0.629-0.679-0.944-1.019 c2.103-2.244,3.85-5.571,6.413-6.415c2.391-0.788,6.184,0.324,8.392,1.933C192.319,823.355,192.864,827.555,190.399,830.196z  M184.136,328.188c-29.823,0-54-24.177-54-54c0-29.823,24.177-54,54-54s54,24.177,54,54 C238.136,304.012,213.96,328.188,184.136,328.188z M252.789,277.752c-0.265-0.133-0.531-0.265-0.796-0.398 c-1.015-8.257-2.029-16.515-3.086-25.115c4.167,0.862,8.324,1.721,13.585,2.809C259.162,262.841,255.975,270.297,252.789,277.752z  M271.136,240.188c-29.823,0-54-24.177-54-54c0-29.823,24.177-54,54-54c29.823,0,54,24.177,54,54 C325.137,216.012,300.96,240.188,271.136,240.188z",
    clocks: {
      size: 108,
      0: { x: 184.245, y: 100 },
      1: { x: 97.245, y: 186 },
      2: { x: 271.245, y: 186 },
      3: { x: 184.245, y: 274 }
    }
  },
  5: {
    height: 1148.657,
    width: 368.698,
    path: "M364.919,177.185c-5.856-6.593-15.147-6.888-21.897-0.694c-3.717,3.411-4.299,3.242-5.541-1.587 c-0.25-0.972-0.571-1.926-0.803-2.901c-6.223-26.032-22.396-42.736-47.523-51.238c-2.474-0.837-4.808-2.72-6.666-4.641 c-6.618-6.844-12.426-14.598-19.638-20.709c-7.25-6.144-14.426-11.753-15.964-21.863c-0.145-0.952-0.81-1.83-1.262-2.728 c-10.14-20.142-26.293-32.5-48.2-37.503c-2.572-0.587-5.014-1.743-8.025-2.817c1.316-1.702,1.86-2.531,2.526-3.247 c6.502-6.986,6.698-15.783,0.465-21.94c-5.785-5.714-15.027-5.762-20.84-0.11c-6.368,6.191-6.436,15.084,0.239,21.857 c2.991,3.035,1.728,4.561-1.167,5.98c-1.334,0.654-2.844,0.952-4.281,1.387c-24.857,7.514-40.936,23.712-48.399,48.654 c-0.748,2.499-2.69,4.83-4.561,6.77c-8.684,9.004-17.485,17.897-26.377,26.695c-1.782,1.764-3.95,3.591-6.269,4.287 c-27.272,8.186-44.245,25.906-50.386,53.864c-0.306,1.391-0.752,2.75-1.182,4.299c-11.942-8.326-18.43-8.891-24.733-2.424 c-5.16,5.294-6.085,13.716-1.351,19.24c2.253,2.629,5.655,4.841,8.962,5.874c6.77,2.115,12.009-1.8,16.717-6.757 c0.647,1.364,1.068,1.923,1.182,2.539c5.495,29.672,22.939,48.289,51.806,56.504c1.891,0.538,3.666,2.056,5.112,3.503 c8.725,8.731,17.397,17.519,25.942,26.426c1.755,1.83,3.532,4.061,4.227,6.423c5.507,18.702,16.574,32.696,33.076,43.228 c6.667,4.255,11.428,11.52,16.987,17.48c0.5,0.535,0.688,1.544,0.692,2.334c0.044,10.877,0.03,21.753,0.03,32.638 c-1.577,0.516-2.845,0.932-4.113,1.346c-17.135,5.597-30.511,16.033-39.024,31.952c-3.426,6.407-5.333,13.646-7.754,20.57 c-1.76,5.033-3.129,5.54-6.907,2.08c-2.706-2.478-6.172-4.068-9.837-4.235c-8.598-0.392-15.176,6.223-15.67,13.97 c-0.384,6.021,2.865,11.744,8.198,14.44c5.638,2.851,12.01,2.021,16.818-2.189c2.562-2.243,5.668-1.656,6.923,1.51 c1.187,2.993,1.799,6.229,3.124,9.149c2.549,5.62,4.886,11.444,8.247,16.568c9.497,14.478,39.422,28.018,39.422,28.018v28.542 c0,0-0.496,0.466-0.788,0.469c-5.522,0.049-11.045,0.088-16.568,0.095c-9.805,0.013-10.191,0.382-10.188,9.959 c0.001,2.347-0.002,4.695,0,7.042c0.008,7.059,1.061,8.147,7.942,8.157c6.643,0.01,13.286,0.002,20.223,0.002 c-0.115,2.368-0.198,4.098-0.292,6.035c-7.528,0-14.546,0.054-21.562-0.02c-3.56-0.037-6.383,2.854-6.323,6.415 c0.064,3.826-0.011,7.654,0.01,11.481c0.033,5.918,1.364,7.248,7.324,7.269c6.815,0.024,21.22,0.006,21.22,0.006v7.044 c0,0-14.435-0.017-21.108,0.005c-6.069,0.02-7.373,1.289-7.434,7.19c-0.028,2.682,0.18,5.38-0.039,8.044 c-0.443,5.389,0.07,10.039,6.912,10.524c-3.015,31.457-2.572,62.398,2.234,93.196c2.98,19.097,7.19,37.854,16.599,55.063 c1.443,2.639,2.397,5.924,2.406,8.914c0.209,63.543,0.251,127.087,0.325,190.631c0.002,1.795,0,3.59,0,5.442 c-5.238,0.679-7.397-1.369-7.347-5.986c0.035-3.185,0.024-6.371,0.006-9.557c-0.034-5.945-1.325-7.274-7.309-7.285 c-17.074-0.032-34.148-0.022-51.222-0.026c-11.718-0.003-23.435-0.029-35.153,0.013c-5.235,0.019-6.699,1.54-6.756,6.814 c-0.038,3.521-0.04,7.042,0.004,10.563c0.066,5.255,1.516,6.725,6.823,6.744c11.215,0.04,22.431,0.01,33.646,0.013 c11.868,0.003,11.868,0.005,11.75,11.912c-0.059,5.922-1.3,7.16-7.407,7.176c-12.22,0.031-24.439,0.018-36.659,0.029 c-7.054,0.006-8.155,1.08-8.167,7.935c-0.004,2.18-0.006,4.359,0.001,6.539c0.021,6.383,1.222,7.644,7.439,7.655 c11.048,0.02,22.096,0.002,33.144,0.006c11.791,0.005,11.791,0.008,11.648,12.012c-0.067,5.703-1.367,7.062-7.047,7.083 c-10.378,0.04-20.758,0.096-31.135-0.002c-15.122-0.144-14.146-0.478-14.047,14.132c0.038,5.646,1.377,6.992,7.074,7.008 c11.048,0.031,22.096,0.007,33.144,0.01c12.19,0.003,12.19,0.005,12.011,12.153c-0.083,5.597-1.413,6.924-7.187,6.944 c-10.211,0.034-20.423,0.089-30.633-0.001c-15.773-0.139-14.465-0.577-14.406,14.774c0.024,6.173,1.313,7.37,7.73,7.375 c13.726,0.011,27.452,0.005,41.179,0.003c14.898-0.002,29.796,0.018,44.694-0.027c5.339-0.016,6.767-1.487,6.831-6.742 c0.033-2.682-0.046-5.366,0.02-8.047c0.126-5.106,1.839-6.469,8.044-5.697c0,5.722-0.455,11.611,0.097,17.404 c1.078,11.308,2.634,22.631,8.667,32.623c3.709,6.143,9.563,5.816,12.753-0.612c2.984-6.015,5.833-12.625,6.409-19.174 c1.579-17.969,2.543-36.045,2.614-54.083c0.36-91.878,0.35-183.757,0.553-275.636c0.005-2.049,0.733-4.214,1.576-6.124 c3.369-7.639,7.748-14.934,10.257-22.833c11.421-35.946,13.433-72.997,11.755-110.391c-0.269-5.99-0.801-11.968-1.209-17.909 c7.452-1.534,7.775-1.945,7.779-9.588c0.001-2.515,0.011-5.03,0.007-7.545c-0.013-7.75-0.894-8.656-8.46-8.663 c-7.141-0.007-22.406-0.001-22.406-0.001v-7.045c0,0,16.742-0.048,24.561,0.019c4.359,0.038,6.392-2,6.312-6.351 c-0.071-3.855,0.016-7.712-0.019-11.568c-0.053-5.938-1.345-7.219-7.35-7.242c-7.485-0.029-22.504-0.007-22.504-0.007v-6.035 c0,0,15.454,0.033,22.967-0.011c5.362-0.031,6.803-1.454,6.876-6.683c0.049-3.52,0.028-7.042,0.018-10.563 c-0.019-6.708-1.157-7.881-7.7-7.895c-7.319-0.016-21.161-0.004-21.161-0.004v-28.963c0,0,51.319-18.506,51.418-58.803 c13.274,8.8,19.828,9.143,25.982,1.96c4.843-5.653,4.919-13.758,0.181-19.362c-6.121-7.24-12.687-6.904-26.259,1.909 c-5.709-30.27-22.672-50.541-52.587-59.137c0-11.198-0.038-22.249,0.053-33.298c0.01-1.247,0.394-2.826,1.206-3.677 c5.143-5.394,9.736-11.741,15.851-15.695c15.582-10.074,26.618-23.168,32.069-40.997c0.628-2.052,2.154-4.251,3.897-5.472 c12.064-8.448,22.297-18.658,30.858-30.639c1.235-1.728,3.009-3,5.027-3.661c25.276-8.284,41.218-25.241,47.865-51.029 c0.549-2.129,1.536-4.145,2.62-7.008c2.028,1.88,3.182,3.03,4.418,4.083c5.813,4.951,14.202,4.893,19.761-0.107 C369.847,192.788,370.428,183.388,364.919,177.185z M252.394,107.492c4.098,3.415,7.887,6.574,11.677,9.733 c-0.404,0.395-0.807,0.791-1.211,1.186c-4.169,0.785-8.338,1.57-13.15,2.476C250.666,116.112,251.516,111.872,252.394,107.492z  M184.406,46c29.823,0,54,24.177,54,54c0,29.823-24.177,54-54,54s-54-24.177-54-54C130.406,70.177,154.583,46,184.406,46z  M162.373,165.581c14.357,4.18,28.096,4.578,42.513,0.199c-4.092,14.47-3.946,28.113,0.227,42.523 c-14.26-4.037-27.868-4.509-42.273-0.152C166.659,193.831,166.896,180.189,162.373,165.581z M115.827,107.593 c1.197,5.466,2.101,9.598,3.149,14.382c-4.547-0.964-8.521-1.806-13.675-2.899C108.835,115.221,111.958,111.814,115.827,107.593z  M43.406,186c0-29.823,24.177-54,54-54s54,24.177,54,54c0,29.823-24.177,54-54,54S43.406,215.823,43.406,186z M115.278,265.909 c-3.402-3.626-6.248-6.661-9.67-10.309c4.662-1.06,8.192-1.862,12.324-2.801C117.071,257.051,116.27,261.011,115.278,265.909z  M238.406,453c0,29.823-24.177,54-54,54s-54-24.177-54-54s24.177-54,54-54S238.406,423.177,238.406,453z M184.406,328 c-29.823,0-54-24.177-54-54c0-29.823,24.177-54,54-54s54,24.177,54,54C238.406,303.823,214.23,328,184.406,328z M251.958,267.927 c-1.167-5.669-2.154-10.46-3.262-15.84c5.154,0.97,9.935,1.87,14.716,2.77c0.446,0.541,0.892,1.082,1.338,1.623 C260.673,260.129,256.595,263.778,251.958,267.927z M271.406,240c-29.823,0-54-24.177-54-54c0-29.823,24.177-54,54-54 c29.823,0,54,24.177,54,54C325.406,215.823,301.23,240,271.406,240z",
    clocks: {
      size: 108,
      0: { x: 184.245, y: 100 },
      1: { x: 97.245, y: 186 },
      2: { x: 271.245, y: 186 },
      3: { x: 184.245, y: 274 },
      4: { x: 184.245, y: 453 }
    }
  },
  6: {
    height: 1148.98,
    width: 370.141,
    path: "M365.84,176.489c-5.689-5.831-14.774-6.109-20.983-0.642c-4.677,4.118-4.976,4.085-6.414-2.269 c-6.187-27.333-22.732-44.97-49.412-53.347c-1.887-0.593-3.769-2.168-4.983-3.788c-8.33-11.115-18.008-20.785-29.318-28.894 c-1.84-1.32-3.239-3.825-3.948-6.065c-8.013-25.306-24.804-41.278-50.453-47.985c-1.299-0.34-2.628-0.562-3.93-0.89 c-6.029-1.519-6.346-2.456-2.44-7.102c5.378-6.396,4.93-15.201-1.065-20.921c-5.702-5.442-14.806-5.447-20.582-0.013 c-6.006,5.651-6.507,14.545-1.066,20.88c0.962,1.12,2.36,1.865,5.102,3.969c-3.997,1.969-6.466,3.647-9.192,4.455 c-21.058,6.239-37.094,18.816-44.941,39.357c-3.899,10.207-9.562,17.625-17.758,24.394c-6.646,5.489-11.704,12.883-17.615,19.294 c-1.38,1.497-3.203,3.002-5.097,3.546c-28.343,8.127-45.563,26.507-51.567,55.389c-0.195,0.941-0.595,1.84-1.211,3.697 c-4.56-5.357-9.738-8.928-16.367-7.261c-3.226,0.811-6.599,2.778-8.897,5.184c-5.104,5.343-4.779,13.776,0.038,19.336 c6.068,7.004,12.02,6.721,25.619-1.458c0.72,3.007,1.322,5.896,2.106,8.735c7.133,25.831,23.797,42.127,49.404,49.659 c2.498,0.735,4.874,2.61,6.784,4.488c8.593,8.445,17.053,17.028,25.427,25.692c1.767,1.828,3.636,4.007,4.323,6.356 c5.597,19.138,16.997,33.318,33.994,43.913c6.567,4.094,11.118,11.439,16.51,17.374c0.48,0.528,0.534,1.578,0.536,2.386 c0.033,10.743,0.022,21.486,0.022,30.697c-9.552,5.427-18.816,9.569-26.776,15.469c-12.547,9.299-19.949,22.422-23.771,37.578 c-0.68,2.698-2.102,5.208-3.473,8.506c-2.286-2.126-3.461-3.29-4.711-4.367c-6.067-5.231-15.003-4.872-20.573,0.801 c-5.603,5.707-5.839,14.698-0.54,20.569c5.565,6.166,14.515,6.88,20.866,1.665c5.112-4.197,5.412-3.946,8.069,2.516 c3.43,8.344,6.359,17.082,11.089,24.661c8.379,13.426,21.019,21.894,36.078,26.785c1.434,0.466,3.551,2,3.587,3.097 c0.294,8.853,0.165,17.72,0.165,27.124c-7.476,0-14.485-0.043-21.493,0.014c-5.306,0.044-6.687,1.494-6.735,6.878 c-0.033,3.697-0.03,7.394-0.004,11.091c0.042,5.943,1.284,7.157,7.436,7.185c6.702,0.031,13.405,0.007,20.448,0.007 c0,2.034,0,5.598,0,5.598s-13.784-0.034-20.783,0.011c-5.372,0.035-6.799,1.45-6.861,6.724c-0.047,4.026,0.044,8.054-0.023,12.079 c-0.072,4.325,1.898,6.385,6.299,6.345c6.876-0.063,13.753,0.049,20.629,0.113c0.289,0.003,1.739,0.534,1.739,0.534v6.407 c0,0-14.692-0.032-21.682,0.01c-5.652,0.034-7.334,1.395-6.872,7.119c0.694,8.601-1.289,15.249-8.006,21.638 c-8.605,8.185-13.036,19.34-15.463,31.089c-1.309,6.335-2.096,6.555-6.889,2.398c-6.287-5.453-15.195-5.103-20.871,0.819 c-5.657,5.902-5.624,15.003,0.076,20.896c5.702,5.895,14.51,6.153,20.855,0.613c1.117-0.975,2.238-1.945,4.238-3.682 c1.129,2.807,2.274,4.924,2.843,7.186c4.769,18.938,15.137,33.728,31.864,44.051c1.736,1.072,3.27,3.377,3.775,5.392 c3.397,13.548,7.363,26.834,14.685,38.904c0.804,1.325,1.03,3.177,1.033,4.786c0.118,64.926,0.18,129.852,0.239,194.778 c0.001,0.981-0.122,1.963-0.184,2.894c-5.249,0.709-6.974-0.588-7.13-5.358c-0.109-3.352-0.003-6.71-0.024-10.065 c-0.036-5.705-1.357-7.092-7.019-7.099c-21.978-0.026-43.956-0.012-65.933-0.011c-7.046,0-14.094,0.1-21.138-0.026 c-4.635-0.083-6.728,2.003-6.589,6.633c0.109,3.639,0.121,7.278-0.002,10.917c-0.157,4.646,1.947,6.703,6.575,6.67 c12.75-0.09,25.501-0.045,38.251-0.028c6.305,0.008,7.513,1.253,7.533,7.599c0.038,11.525,0.038,11.526-11.68,11.525 c-11.24-0.001-22.481-0.03-33.722,0.007c-5.418,0.018-6.914,1.437-6.931,6.666c-0.053,16.568-1.437,15.572,15.235,15.484 c10.066-0.053,20.132-0.038,30.198,0.002c5.373,0.021,6.796,1.457,6.905,6.697c0.259,12.419,0.259,12.42-12.268,12.419 c-11.073,0-22.146-0.028-33.218,0.011c-5.319,0.019-6.822,1.501-6.857,6.738c-0.102,15.018-1.068,14.544,14.31,14.408 c10.401-0.092,20.803-0.047,31.205-0.005c5.279,0.022,6.729,1.522,6.828,6.773c0.234,12.342,0.234,12.342-12.345,12.342 c-11.073,0-22.146-0.031-33.218,0.012c-5.25,0.02-6.76,1.539-6.779,6.814c-0.06,16.24-1.382,15.39,14.882,15.343 c26.004-0.075,52.009-0.015,78.013-0.024c6.592-0.002,7.763-1.211,7.767-7.876c0.001-2.349-0.056-4.699,0.01-7.046 c0.144-5.087,1.794-6.38,6.391-5.865c1.57,11.962,2.907,23.747,4.765,35.449c0.647,4.073,1.998,8.292,4.104,11.797 c1.828,3.041,5.159,7.119,7.859,7.143c2.656,0.024,6.805-4.019,7.763-7.073c3.09-9.85,6.148-19.959,7.106-30.167 c1.295-13.794,0.763-27.772,0.787-41.671c0.158-91.433,0.238-182.866,0.46-274.299c0.006-2.499,0.844-5.29,2.131-7.444 c7.151-11.972,11.314-25.021,14.283-38.502c0.767-3.483,2.275-5.895,5.318-7.958c14.472-9.809,23.801-23.321,28.184-40.279 c0.711-2.753,1.981-5.361,3.281-8.798c2.096,1.947,3.257,3.114,4.508,4.173c6.274,5.312,15.319,4.747,20.867-1.276 c5.371-5.83,5.28-14.718-0.209-20.541c-5.593-5.933-14.657-6.313-20.861-0.875c-4.91,4.304-5.502,4.183-6.871-2.32 c-2.843-13.501-9.129-25.091-18.636-35.051c-1.059-1.109-1.624-3.064-1.703-4.662c-0.225-4.519-0.177-9.058-0.049-13.584 c0.13-4.584-1.863-6.712-6.52-6.641c-7.688,0.117-23.46,0.032-23.46,0.032v-7.081c0,0,15.513,0.035,23.187-0.012 c5.264-0.032,6.699-1.51,6.757-6.834c0.042-3.858,0.047-7.718-0.001-11.576c-0.066-5.278-1.476-6.669-6.885-6.701 c-7.529-0.044-22.059-0.011-22.059-0.011v-6.073c0,0,14.421,0.036,22.088-0.012c5.373-0.034,6.792-1.451,6.855-6.73 c0.048-4.026-0.055-8.054,0.028-12.079c0.089-4.361-1.944-6.374-6.308-6.332c-7.707,0.073-23.662,0.021-23.662,0.021 s0-18.743,0-28.6c29.397-8.459,46.462-28.621,52.535-59.535c5.681,5.182,10.784,9.539,17.649,7.382 c3.324-1.045,6.767-3.214,9.025-5.845c4.929-5.744,3.921-14.326-1.559-19.637c-6.511-6.312-13.714-5.558-25.117,3.388 c-5.85-30.371-22.706-50.809-52.896-59.482c0-11.328-1.021-22.855,0.356-34.088c0.927-7.564,7.385-13.291,13.943-17.092 c17.546-10.17,29.776-24.263,35.419-43.925c0.495-1.726,2.182-3.403,3.745-4.482c12.023-8.304,22.113-18.494,30.667-30.315 c1.255-1.734,3.402-3.24,5.446-3.923c25.095-8.384,41.101-25.168,47.682-50.873c0.553-2.159,1.517-4.212,2.638-7.26 c1.992,1.814,3.143,2.911,4.345,3.949c6.307,5.446,15.194,5.081,20.928-0.844C371.579,191.607,371.538,182.33,365.84,176.489z M253.55,107.072c4.157,3.613,7.747,6.732,11.337,9.852c-0.326,0.501-0.652,1.003-0.979,1.504 c-4.182,0.798-8.365,1.596-13.163,2.512C251.718,116.132,252.577,111.882,253.55,107.072z M185.289,45.98c29.823,0,54,24.177,54,54 c0,29.823-24.177,54-54,54s-54-24.177-54-54C131.289,70.157,155.466,45.98,185.289,45.98z M164.151,165.773 c13.581,4.334,27.363,4.22,41.777,0.199c-4.474,14.48-3.87,28.139,0.027,42.429c-14.232-4.098-27.748-4.399-41.531-0.444 c0.777-7.312,2.093-14.066,2.044-20.809C166.419,180.244,165.032,173.349,164.151,165.773z M116.538,107.809 c1.209,5.322,2.145,9.436,3.252,14.311c-4.762-1.06-8.731-1.943-13.791-3.07C109.65,115.157,112.775,111.823,116.538,107.809z M98.289,239.98c-29.823,0-54-24.177-54-54c0-29.823,24.177-54,54-54s54,24.177,54,54 C152.289,215.804,128.113,239.98,98.289,239.98z M115.949,265.97c-3.407-3.594-6.205-6.546-9.77-10.308 c5.012-1.059,8.587-1.815,12.604-2.664C117.803,257.484,116.976,261.266,115.949,265.97z M239.289,683.98c0,29.823-24.177,54-54,54 s-54-24.177-54-54s24.177-54,54-54S239.289,654.157,239.289,683.98z M239.289,452.98c0,29.823-24.177,54-54,54s-54-24.177-54-54 s24.177-54,54-54S239.289,423.157,239.289,452.98z M185.289,327.98c-29.823,0-54-24.177-54-54c0-29.823,24.177-54,54-54 s54,24.177,54,54C239.289,303.804,215.113,327.98,185.289,327.98z M253.079,268.69c-1.271-6.405-2.241-11.297-3.279-16.525 c5.356,1.047,10.057,1.966,16.634,3.251C261.644,260.177,257.764,264.034,253.079,268.69z M272.289,239.98 c-29.823,0-54-24.177-54-54c0-29.823,24.177-54,54-54c29.823,0,54,24.177,54,54C326.289,215.804,302.113,239.98,272.289,239.98z",
    clocks: {
      size: 108,
      0: { x: 185.128, y: 100 },
      1: { x: 98.128, y: 186 },
      2: { x: 272.128, y: 186 },
      3: { x: 185.128, y: 274 },
      4: { x: 185.128, y: 453 },
      5: { x: 185.128, y: 684 }
    }
  }
};
const SVGDATA = {
  teeth: {
    tall: {
      viewBox: "0 0 512 1540",
      paths: {
        frame: "M0,0v1540l512-244.2V0H0z M451,1263.5l-390,186V61h390V1263.5z",
        half: "M0,0v748l512-244.2V0H0z",
        full: "M0,0v1540l512-244.2V0H0z"
      }
    },
    med: {
      viewBox: "0 0 512 1540",
      paths: {
        frame: "M0,0v1388l512-395.6V0H0z M458,965.7L54,1278V53h404V965.7z",
        full: "M0,0v1540l512-244.2V0H0z"
      }
    },
    short: {
      viewBox: "0 0 512 1540",
      paths: {
        frame: "M0,0v991l511.4-247L512,0H0z M470.5,715.2L41,922.6V40h430L470.5,715.2z",
        full: "M0,0v991l511.4-247L512,0H0z"
      }
    }
  },
  armor: {
    viewBox: "0 0 512 512",
    paths: {
      heavy: "M157.5,80.7c-20.6,13.7-46,22.5-69.4,26c6.8,48.9,26.1,84.1,46,97.8 c10.5,7.3,20.4,9,30.4,5.6c8.9-3.1,18.6-11,27.8-25.6C165.3,154.3,160.6,113.5,157.5,80.7L157.5,80.7z M354.5,80.8 c-3.1,32.8-7.8,73.6-34.7,103.8c9.1,14.6,18.9,22.5,27.8,25.6c10,3.4,19.8,1.7,30.4-5.6c19.8-13.7,39.1-48.8,45.9-97.7 C399.3,103.7,376,95.5,354.5,80.8L354.5,80.8z M254.4,67.9c-37.1,0-69.8,8.3-89.6,21c1.2,6.5,2.6,13,4.2,19.3 c19.2-8.2,50.3-16.7,85.4-16.7c35.2,0,66.3,8.5,85.4,16.7c1.7-6.3,3.1-12.8,4.2-19.3C324.2,76.2,291.5,67.9,254.4,67.9z M64.9,127.9l-47.7,45.5c29.8,37.2,63,56.8,86.5,58.7c1.1,0.1,2.3,0.1,3.3,0.2c1.8-7.6,4-15.1,6.5-22.3 C91.7,194.9,74.4,166.1,64.9,127.9L64.9,127.9z M447.1,127.9c-9.6,38.3-26.9,67-48.6,82c0,0-0.1,0-0.1,0.1 c2.5,7.3,4.7,14.7,6.5,22.3c1.1,0,2.2-0.1,3.4-0.2c23.4-1.9,56.8-21.5,86.5-58.7L447.1,127.9L447.1,127.9z M176,139.4 c5.7,12.2,13.1,23.3,22.9,32.8l6.4,6.2l-4.3,7.8c-2.3,4.1-4.6,8-7,11.7c40.8,15,85,14,124-0.2c-2.4-3.6-4.6-7.4-6.9-11.4l-4.3-7.8 l6.4-6.2c9.4-9.1,16.7-19.9,22.3-31.5C280.8,153.8,228.5,151.3,176,139.4L176,139.4z M401.7,243.6c0,0-3.7,38.1-22.9,76.1 l-121.7-32.7l-1.8-0.4l-1.8,0.4l-120.3,32.7c-19-38-22.7-76.1-22.7-76.1s12,3.8,19.5-18.7c10.7,3.2,22,3.3,32.8-0.4 c9.2-3.2,17.8-8.8,25.8-16.9c21.6,8.9,44.2,13.1,66.7,13.1c22.7,0,45.6-4.2,67.4-13.1c8,8,16.8,13.7,26.1,16.9 c10.9,3.7,22.3,3.6,33.1,0.4C389.6,247.4,401.7,243.6,401.7,243.6z M486.1,210.7c-25.4,24.2-52.1,38-76.2,40c-0.4,0-0.9,0-1.3,0.1 c1.2,8.1,2,16.2,2.3,24.4c22.8,3.8,54.7,0.1,90-14.3L486.1,210.7L486.1,210.7z M25.9,210.8l-14.8,50.1c35.3,14.4,67.2,18.1,90,14.3 c0.3-8.2,1.1-16.3,2.3-24.4c-0.4,0-0.9,0-1.3-0.1C78,248.7,51.3,234.9,25.9,210.8L25.9,210.8z M256,305.2l-114.8,28.1 c1.9,7.7,10.1,17.6,15.4,23.8c31.8-7.3,59.3-11.4,94.7-11.6c2.6,0,5.3,0,7.9,0c38.2,0.3,64.9,4.3,95.9,11.6 c5.1-6.2,15.2-15.8,16.8-23.6L256,305.2L256,305.2z M254.1,347.8l-79.3,22.1c5.8,4.8,16,8.5,23.2,13.3c18-5,33.5-7.8,53.5-7.9 c1.5,0,3,0,4.5,0c21.6,0.2,36.6,3,54.1,7.9c9.9-1.8,16.8-6.8,25.5-12.3L254.1,347.8L254.1,347.8z M373.3,377.7 c-68.3,55.6-166.9,55.7-235.3,0.3l-1.8,35.9c4.7,7.9,18.3,17,38,23c21,6.4,48,9.9,75.6,10.2c27.6,0.3,55.8-2.6,79.4-8.7 c21.6-5.6,39.3-14.2,48.8-23.9L373.3,377.7L373.3,377.7z",
      light: "M254.9,88c-23.1,0-44.1,2.8-59.8,8.8c-7.9,3-14.5,6.8-19.5,11.9c-5,5.1-8.4,12.1-8.4,19.9 c0,3.2,0.5,6.2,1.5,9.1c2,37.1-20.9,83.9-46,107.5c5.9,35.9,19.4,72.7,39.6,106.3c23.8,23,54.6,35.4,85.9,37.1v-24 c-9.6-0.1-19-0.5-26.5-1.1l0.8-13.2c7.1,0.6,16.2,1,25.7,1.1v-28.3c-9.1,0.4-17.9,1.8-24.4,4.2l-3.3-12.7 c8.1-2.9,17.8-4.6,27.7-5.1v-23.8c-2.9,0.2-5.8,0.5-8.7,1c-17.2,1-31.8,3.6-45.2,7.5l-0.1-0.2c16.7-14.8,38.1-22.2,59.6-22.2 c21.4,0,42.9,7.4,59.6,22.2l-0.1,0.1c-13.4-3.9-28.1-6.5-45.4-7.5c-2.8-0.5-5.7-0.8-8.5-1v23.8c10,0.5,19.7,2.1,27.7,5.1l-3.3,12.7 c-6.6-2.4-15.4-3.8-24.5-4.2v28.3c9.4-0.1,18.6-0.4,25.7-1.1l0.8,13.2c-7.5,0.7-16.9,1-26.5,1.1v24.1c32.4-0.8,64.6-13,89.4-36.5 c21.1-33.6,34.9-69.9,40.8-105.3c-26.2-23.2-50.7-72.5-47.8-110.7c0.7-2.5,1-5,1-7.7c0-7.8-3.4-14.8-8.4-19.9 c-5-5.1-11.7-8.9-19.6-11.9C298.9,90.8,278,88,254.9,88L254.9,88z M254.9,101.3c22.3,0,42.5,2.9,56.4,8.2c7,2.7,12.4,6,15.7,9.3 c3.3,3.4,4.5,6.3,4.5,9.9c0,1.8-0.3,3.6-1.1,5.5c-21.9-11.9-49.3-17.9-76.7-17.9c-26.6,0-53.2,5.6-74.7,16.8 c-0.5-1.5-0.7-2.9-0.7-4.4c0-3.5,1.2-6.5,4.5-9.9c3.3-3.4,8.7-6.7,15.7-9.3C212.4,104.1,232.6,101.3,254.9,101.3L254.9,101.3z M253.7,130c24.6,0,49.2,4.8,68.6,14.3c-3.1,2.6-6.9,5.1-11.4,7.3c-13.9,7-33.9,11.5-56,11.5s-42-4.5-56-11.5 c-4.9-2.4-9-5.2-12.2-8C205.8,134.5,229.7,130,253.7,130z M232.3,174.9c3.7,0.5,7.5,0.9,11.4,1.2c0.5,3.6,1,7.5,1.6,11.8 c1.6,13,3.3,27.9,3.3,37.5c0,10.8-3.5,20.6-9.5,28.1c-6.1,7.5-14.5,13-24.6,16.5c-11.2,3.9-24.5,5.6-39.3,4.8 c-14.2-2.5-25.1-9.3-35.7-19.6c29.1,8.3,54.5,8.2,71.9,2.1c8.7-3.1,15.4-7.6,19.7-13c4.3-5.4,6.5-11.4,6.5-18.9 c0-7.7-1.6-22.8-3.1-35.6C233.6,184.1,232.9,179,232.3,174.9L232.3,174.9z M275,175.2c-0.6,4-1.3,9-2,14.6 c-1.6,12.7-3.1,27.9-3.1,35.6c0,7.5,2.1,13.6,6.5,18.9c4.3,5.4,11,9.9,19.7,13c17.3,6.1,42.6,6.2,71.6-2.1 c-10.6,10.3-21.5,17.1-35.7,19.6c-14.8,0.8-28-0.9-39.1-4.8c-10.1-3.5-18.5-9-24.6-16.5s-9.5-17.3-9.5-28.1 c0-9.7,1.7-24.6,3.3-37.5c0.5-4.3,1.1-8.2,1.5-11.7C267.4,176,271.2,175.7,275,175.2L275,175.2z M347.1,370.2 c-52.9,43.1-129.3,43.2-182.3,0.3l-1.4,27.8c3.6,6.1,14.2,13.2,29.4,17.8c16.3,4.9,37.2,7.7,58.5,7.9c21.4,0.2,43.2-2,61.5-6.7 c16.8-4.3,30.4-11,37.8-18.5L347.1,370.2L347.1,370.2z",
      special: "M256,14.2c-65.6,98.3-131.1,90.2-196.7,106.5c0,262.3,65.6,327.8,196.7,377 c131.1-49.2,196.7-114.7,196.7-377C387.1,104.4,321.6,112.6,256,14.2z M256,47c5.1,0,9.2,4.1,9.2,9.2s-4.1,9.2-9.2,9.2 s-9.2-4.1-9.2-9.2S250.9,47,256,47z M70.6,138.2c0-5.1,4.1-9.2,9.2-9.2s9.2,4.1,9.2,9.2s-4.1,9.2-9.2,9.2S70.6,143.3,70.6,138.2z M92.1,301.1c-5.1,0-9.2-4.1-9.2-9.2c0-5.1,4.1-9.2,9.2-9.2s9.2,4.1,9.2,9.2C101.3,296.9,97.2,301.1,92.1,301.1z M157.7,432.2 c-5.1,0-9.2-4.1-9.2-9.2c0-5.1,4.1-9.2,9.2-9.2s9.2,4.1,9.2,9.2C166.9,428.1,162.7,432.2,157.7,432.2z M256,483.4 c-5.1,0-9.2-4.1-9.2-9.2s4.1-9.2,9.2-9.2s9.2,4.1,9.2,9.2S261.1,483.4,256,483.4z M354.3,432.2c-5.1,0-9.2-4.1-9.2-9.2 c0-5.1,4.1-9.2,9.2-9.2c5.1,0,9.2,4.1,9.2,9.2C363.6,428.1,359.4,432.2,354.3,432.2z M314.4,426.7c-15.8,11.1-33.7,18.7-51.1,26.8 c-6.7,4.7-14-0.5-20.7-2.5c-44.7-18.3-86.5-49.8-107.6-94.5c-29.8-63.5-33.8-135-36.7-204.3c58.8-9,115.3-28.5,156.2-72.1l1.9-2.1 c4.5,5,9.3,9.8,14.2,14.5c35.8,36.3,85,47,133.9,57.8c2.8,1.2,6.8,0.5,9.1,2c-2.7,66.4-5.7,134.9-33.1,196.4 C367.3,380.9,343.2,407.7,314.4,426.7z M419.9,301.1c-5.1,0-9.2-4.1-9.2-9.2c0-5.1,4.1-9.2,9.2-9.2s9.2,4.1,9.2,9.2 C429.1,296.9,425,301.1,419.9,301.1z M432.2,147.4c-5.1,0-9.2-4.1-9.2-9.2s4.1-9.2,9.2-9.2s9.2,4.1,9.2,9.2 S437.3,147.4,432.2,147.4z M301.1,154.9c0.2,23.3,0.3,46.6,0.5,69.9c0,1,0.4,2.2,0.9,3.1c4.9,8.4,9.8,16.9,15,25.1 c1.6,2.6,0.8,5.1,0.6,7.6c-0.7,9.5-1.7,19-2.6,28.5c-1,10.5-2,21-3,31.6c-0.8,9-1.6,17.9-2.4,26.9c-0.8,9-1.7,17.9-2.5,26.9 c-0.7,7.3-1.3,14.6-2,22c-0.1,1.2-0.6,2.7-1.4,3.6c-12,12-24.1,23.9-36.2,35.9c-0.2,0.2-0.5,0.5-1.1,1c0-1.1,0-1.8,0-2.5 c0.1-66.5,0.3-133,0.5-199.5c0-1.5,0.8-3.2,1.7-4.4c2.2-2.9,2.8-6,2.8-9.6c0-28.5,0.1-57.1,0.2-85.6c0-0.7,0-1.5,0-2.5 c0.8,0,1.5-0.1,2.3-0.1c13.9,0.1,27.8,0.1,41.7,0.1c1.2,0,1.9,0.3,2.3,1.5c0.8,2.2,1.7,4.3,2.7,6.6c-6.2,3.9-12.2,7.6-18.2,11.3 C301.6,152.6,301.1,153.4,301.1,154.9z M245.2,433.7c0,0.9,0,1.7,0,2.6c-0.2,0.1-0.4,0.2-0.6,0.3c-1.4-1.5-2.8-3.1-4.3-4.5 c-10.7-10.6-21.5-21.2-32.2-31.9c-0.9-0.9-1.6-2.5-1.7-3.9c-1-9.2-1.8-18.4-2.6-27.5c-0.7-7.2-1.3-14.3-2-21.5 c-0.8-9.2-1.7-18.4-2.6-27.5c-0.7-7.1-1.3-14.2-1.9-21.3c-0.9-9.3-1.7-18.5-2.6-27.8c-0.5-4.9-1-9.9-1.3-14.8 c-0.1-0.7,0.4-1.6,0.8-2.2c5.1-8.6,10.2-17.1,15.2-25.7c0.5-0.9,0.9-2.1,0.9-3.1c0.2-23.2,0.3-46.4,0.5-69.6c0-1.6-0.5-2.5-1.9-3.4 c-6-3.6-11.9-7.3-18-11.2c1-2.5,2-4.9,3.1-7.4c0.2-0.3,0.8-0.6,1.2-0.6c14.6-0.1,29.3-0.1,43.9-0.1c0.1,0,0.3,0.1,0.6,0.3 c0,0.7,0.1,1.5,0.1,2.3c0.1,29.2,0.2,58.4,0.3,87.7c0,2.1,0.3,4,1.7,5.6c2.5,2.9,3,6.2,3,10C244.9,303.4,245.1,368.5,245.2,433.7z",
      specialBg: "M316.9,432.4c-16.5,11.6-35,19.4-53.1,27.8c-7,4.9-14.6-0.5-21.6-2.6 c-46.5-19-90-51.8-111.9-98.3c-31-66.1-35.1-140.5-38.2-212.4c61.2-9.4,119.9-29.6,162.4-75l2-2.1c4.7,5.2,9.6,10.2,14.7,15.1 c37.2,37.7,88.4,48.9,139.2,60.1c2.9,1.3,7.1,0.5,9.4,2.1c-2.9,69.1-5.9,140.3-34.4,204.3C372,384.8,346.8,412.7,316.9,432.4z"
    }
  },
  [
    "ReducedEffect"
    /* ReducedEffect */
  ]: {
    viewBox: "0 0 512 512",
    paths: {
      main: "M260.7,487.55C133,487.55,28.39,382.92,28.39,255.23S133,24.45,260.7,24.45A230.5,230.5,0,0,1,491.49,255.23c0,127.69-103.1,232.32-230.78,232.32Zm-1.06-82L377,287.58l-23.94-25.1-65.41,37.94V128a167.28,167.28,0,0,1,103.6,268.91,193.71,193.71,0,0,0,61.22-141.63A191.18,191.18,0,0,0,260.7,63.45c-106.39,0-193.31,85.39-193.31,191.78A192.9,192.9,0,0,0,128,395.55,167.3,167.3,0,0,1,231,128.2V296.92l-62.5-35.62-25.09,26.28Z"
    },
    classes: {
      main: "fill-linear"
    }
  },
  [
    "ComplicationMinor"
    /* ComplicationMinor */
  ]: {
    viewBox: "0 0 512 512",
    paths: {
      main: "M345.58,263.18l39.74-8.31,73.29-15.3,22.83-4.79,2.81-.58,9.56-2V213.1l-6.33,1.33-79.55,16.62-26.49,5.54-55.93,11.69c-13-11.18-20-24.73-27.16-39.89l-1.67-3.53,34.18-46.76,57.87-79.18,3-4.1,41.19-56.33H409.77L375.26,65.7l-4.09,5.59-60.51,82.78-32.91,45c-15.06-6.36-26.14-17.76-38.57-30.33l-2.34-2.37-4.59-30.28L216.72,33.5l-1-6.47-1.29-8.54h-18.9l2.84,18.75-.11-4.41,15.2,104.1,5.59,37c-11.18,7.5-24.44,12.15-39,15.49l-22.9-28.89L93.8,80.58,44.58,18.49H20.74l53,66.83,4.18,5.26,66.54,84,19.15,24.16-.08.7c-1.93,17.37-8.88,29.63-16.65,43.07L115.3,234.2,25.49,210.61,23.08,210l-4.31-1.14v19.32l2.56.67L112,252.65l27.61,7.25.56,1.4c6.1,15.15,5.39,31.77,2.9,49.71l-30.31,14.2L23.15,367.14l-4.38,2.06v20.62l9.18-4.3,67.92-31.77,17.13-8,28.92-13.54,1.52,1.53c5.85,5.86,10,10.29,11.22,20.75l-31.14,31.3L56.27,453.39l-37.5,37.69v2.43h24l20.91-21h0l77.94-78.36,24.11-24.24,1-.23c23.75-5.79,59.86-6.75,80.11-6.78,4,0,6.81,0,9.35.08l10.4,32.29L293,477.73l1.54,4.78,3.54,11h19.63l-5.19-16.14-2.24-6.95-25.77-80.06-11-34.32c3.55-3.17,8.73-7.63,15-12.42,11.42-8.73,26.21-17.7,35.68-19.62l4.24-.87,25.37,10L442,368.08l4.18,1.66,47.6,18.83V368.48l-37.78-15-5.21-2-82.75-32.74-36.59-14.48c0-13.16,1.4-22.85,9.12-33.93Zm-61.35-41.29c5.12,10.41,11.11,21.1,19.66,30.91l-31.15,6.52a39.69,39.69,0,0,0-6.93-12.22Zm-62.13-28,6,39.74a39.25,39.25,0,0,0-10.25,3.48l-25.18-31.77A132,132,0,0,0,222.1,193.9Zm-43.39,23.92,24.91,31.43a38.6,38.6,0,0,0-4.08,7.07l-33.92-8.92C170.58,238.65,175.45,229.15,178.71,217.82Zm17.49,56.93a39.32,39.32,0,0,0,2.08,10.45L163,301.7c1.05-11.91.92-24.05-2-36.2ZM160,324.27l.09-.55,47.15-22.07h0L169.55,339.5A54.79,54.79,0,0,0,160,324.27Zm28.37,22.85,36.61-36.8a39.43,39.43,0,0,0,10.6,1.45,35.54,35.54,0,0,0,4-.2L250,344.11C236.7,344,212.41,344.2,188.33,347.12ZM250.78,236a35.39,35.39,0,0,0-3.61-1.32L241.46,197a109.45,109.45,0,0,0,25.15,17.38Zm26.37,92.76c-3.9,3-7.1,5.61-9.88,8l-10.1-31.4a39.81,39.81,0,0,0,8.16-7.16l36.5,14.44A169,169,0,0,0,277.15,328.76Zm36-31.76L273.9,281.47c.26-1.14.47-2.29.64-3.44l45.58-9.53C315.5,277.93,313.74,287.39,313.17,297Z"
    },
    classes: {
      main: "fill-radial"
    }
  },
  [
    "ComplicationMajor"
    /* ComplicationMajor */
  ]: {
    viewBox: "0 0 512 512",
    paths: {
      main: "M458.26,239.57l22.83-4.78,2.81-.59,9.56-2v-19.1l-6.33,1.33-79.55,16.62-26.49,5.54-55.93,11.69c-13-11.18-20-24.73-27.16-39.89l-1.67-3.53,34.18-46.76.58-.79c9.76,28.37,24.84,58.48,51.36,78.35l24.6-5,1.83-.54L407.07,229c-37.27-19.15-50.45-51.64-61.94-88.83l-.44-1.43,43.69-59.78,3-4.1,41.19-56.34H409.42L374.91,65.7l-4.09,5.6-46.71,63.9c-34.73.23-70.42-3-95.76-22.5l-12-79.19-1-6.47-1.29-8.55H195.2L198,37.24l-.11-4.4,12.18,83.44c-17,16.89-39.15,28.73-67.39,26.48L93.45,80.59,44.23,18.49H20.39l53,66.83,4.18,5.27L129,155.51c-3.16,27.24-16.63,53.33-32.88,73.74l-71-18.63L22.73,210l-4.31-1.13v19.32l2.56.67,71.38,18.74c8.29,26.73,6.3,57.28,2.12,86L22.8,367.15l-4.38,2.05v20.63l9.18-4.3,67.92-31.78,1.09-.51A190.52,190.52,0,0,1,104.47,382c1.33,7.25,2.58,14.68,3.19,19.36l-51.74,52-37.5,37.69v2.43H42.37l20.91-21h0l58.27-58.57c10.1-.83,33.7-2.28,59.06-3.17,7.9-.28,16.15-.45,24.46-.47,23.47-.05,49.4,1.12,67.34,4.45l20.27,63,1.54,4.79,3.54,11h19.63l-5.19-16.14L310,470.43,291.2,412.17c23.43-27.05,48.62-54.87,86-69.58l64.45,25.5,4.18,1.65,47.6,18.84v-20.1l-37.78-15-5.21-2.06-62.74-24.82c-3.11-24.21,8.64-50.64,20.2-76.57ZM266.92,336.72l-10.1-31.4a39.76,39.76,0,0,0,8.16-7.15l36.5,14.44a169,169,0,0,0-24.68,16.16C272.9,331.76,269.7,334.38,266.92,336.72Zm-71.07-62a39.17,39.17,0,0,0,2.08,10.44l-35.27,16.5c1.05-11.9.92-24-2-36.19Zm-30.58-27.35c5-8.75,9.83-18.25,13.09-29.59l24.91,31.43a39.28,39.28,0,0,0-4.08,7.07Zm41.58,54.25h0L169.2,339.51a54.79,54.79,0,0,0-9.59-15.23l.09-.56Zm17.74,8.67a39.43,39.43,0,0,0,10.6,1.45,38,38,0,0,0,4-.2l10.47,32.54c-13.32-.16-37.61.08-61.69,3Zm22.23-75.64L241.11,197a109.17,109.17,0,0,0,25.15,17.39L250.43,236A37.88,37.88,0,0,0,246.82,234.69Zm26.73,46.78c.26-1.13.47-2.28.64-3.43l45.58-9.53c-4.62,9.43-6.38,18.89-6.95,28.5Zm30-28.66-31.15,6.51a39.53,39.53,0,0,0-6.93-12.21l18.42-25.21C289,232.31,295,243,303.54,252.81ZM232.78,136.13c23.18,13.26,50.47,17.92,77,18.68l-32.37,44.3c-15.06-6.37-26.14-17.76-38.57-30.33l-2.34-2.37-4.59-30.28,0-.12Zm-5,97.52a39.25,39.25,0,0,0-10.25,3.48l-25.18-31.77a132,132,0,0,0,29.42-11.45Zm-14.52-96,5.48,36.25c-11.18,7.5-24.44,12.15-39.05,15.49l-22.46-28.34C178.25,159.21,198.58,149.44,213.24,137.65Zm-69.67,36.28.5.63,19.15,24.15-.08.71c-1.93,17.37-8.88,29.63-16.65,43.06L115,234.2l-.07,0C127,217.56,138.38,195.1,143.57,173.93ZM123.4,385.56c-.42-2.17-1.06-4.9-1.43-6.92-1.84-10-4.7-23.39-8.85-33.12l28.45-13.32,1.52,1.53c5.85,5.87,10,10.3,11.22,20.75Zm15.89-125.65.56,1.4c6.1,15.14,5.39,31.77,2.9,49.71l-29,13.58c2.87-22.76,3.42-48.28-2.06-71.93h0Zm72.18,131.64h-6.55c-8.5.05-16.9.25-25,.53-15.57.55-28,1.33-37.85,2.07l.07-.07a7.94,7.94,0,0,1-.82-.06l24-24.11,1-.23c23.75-5.79,59.86-6.75,80.11-6.78,4,0,6.81,0,9.35.07l10.29,32C249.77,392.55,229.58,391.66,211.47,391.55Zm73.59-1.18-.71.53-.17-.53-11-34.32c3.55-3.17,8.73-7.63,15-12.42,11.42-8.73,26.21-17.7,35.68-19.63l4.24-.86,25.37,10C324.89,348,303.58,369.47,285.06,390.37ZM368.49,319l-.77-.31-36.59-14.48c0-13.15,1.4-22.84,9.12-33.92l5-7.14L385,254.88l.12,0C376.44,274.07,368.18,297,368.49,319Z"
    },
    classes: {
      main: "fill-radial"
    }
  },
  [
    "ComplicationSerious"
    /* ComplicationSerious */
  ]: {
    viewBox: "0 0 512 512",
    paths: {
      main: "M21.42,17.34,78.56,89.45c-2.73,48.59-23.75,85.79-52.39,120l-6.72-1.76V227l2.56.67C37.36,272.78,31.1,318.54,23.83,366l-4.38,2.05v20.63l9.18-4.29c6.52,10.7,13.66,27,19.06,41.33,4.29,11.33,7.48,21,9.26,26.53l-37.5,37.69v2.43h24L72,463.67c9.27-.36,41.77-1.47,82.7-.75,46.74.83,102.61,4.3,139,13.67l5.08,15.78h19.63L311,469.28c35.94-41.51,71.91-80.52,131.73-102.34l51.78,20.49v-20.1l-43-17c-6.37-39.21,12.76-76.67,30.62-116.68l12.37-2.59V212l-6.33,1.32-5.45-2.8c-56.09-28.83-76.33-78-93.3-132.7L433.6,17.34H410.45l-38.6,52.81c-58.28,1.26-112.48-2.46-154.45-37.79l-2.27-15h-18.9l2.83,18.75c-27.13,29-57.56,48-104.58,43.36L45.26,17.34Zm199.92,41c40.6,26.3,88.49,30.89,136.75,30.63L325,134.32c-36.59.39-69.86-3-95.85-24.64l-7.76-51.33Zm-18.84.44,8.29,54.77c-17.81,18.62-37.29,30.18-68,26.86L109.72,98.68c38.59-.74,68.36-17.15,92.78-39.89ZM375.83,96.38c15.53,47,37.05,92.69,84.55,122.72l-51.77,10.82-.82-.42c-37.27-19.14-50.44-51.64-61.93-88.83l-.72-2.31,30.68-42ZM95.09,110.3l34.39,43.39c-2.52,29.59-15.41,52.66-33.14,74.21L45.93,214.67c23.72-29.78,42.64-63.39,49.16-104.37ZM232.93,135c23.94,13.69,51.05,17.4,78.41,17.94l-32.91,45c-15.06-6.36-26.14-17.75-38.57-30.32l-2.35-2.37L232.93,135Zm-18.77.81,5.59,36.95c-11.18,7.5-24.44,12.15-39.05,15.49l-22.9-28.89c22.71-1.4,41.09-10.68,56.36-23.55ZM331.54,157c9.74,29.15,23.14,58,50.58,78.49l-55.93,11.69c-13-11.18-20-24.74-27.16-39.89l-1.67-3.53ZM145.1,173.41l19.15,24.16-.08.71c-1.93,17.36-8.88,29.63-16.65,43.06L116,233.06c13.21-17.36,23.94-36.83,29.12-59.65Zm77.68,19.35,6,39.75A38.88,38.88,0,0,0,218.54,236l-25.18-31.77a132.49,132.49,0,0,0,29.42-11.45Zm19.36,3.05a109.17,109.17,0,0,0,25.15,17.39l-15.83,21.66c-1.18-.49-2.38-.94-3.61-1.32l-5.71-37.73Zm-62.75,20.86L204.3,248.1a39.37,39.37,0,0,0-4.08,7.07l-33.92-8.9c5-8.76,9.83-18.25,13.09-29.6Zm105.52,4.08c5.12,10.42,11.11,21.1,19.66,30.92l-31.15,6.5A39.64,39.64,0,0,0,266.49,246l18.42-25.21ZM43.14,233.26,92,246.09c9.23,28.21,5.8,57.08,1.2,87.45l-49.07,23c6-40.15,10.29-81.42-1-123.24Zm416.14,5.16c-14.93,32.63-30.11,66.73-27.43,104.13l-43.74-17.31c-3.6-25,8.78-49.44,20.72-76.28l50.45-10.54Zm-346.57,13.1,27.61,7.25.56,1.4c6.1,15.13,5.39,31.77,2.9,49.71l-30.32,14.18c3.22-23.51,5-47.81-.75-72.54ZM386,253.74c-9,19.81-17.8,40.8-17.25,63.84l-36.59-14.47c0-13.15,1.4-22.84,9.12-33.92l5-7.15,39.74-8.3ZM161.64,264.36l35.24,9.26A39.33,39.33,0,0,0,199,284.06l-35.27,16.5c1.05-11.9.92-24.05-2.05-36.2Zm159.16,3c-4.62,9.44-6.38,18.89-6.95,28.5l-39.27-15.54c.26-1.12.47-2.27.64-3.43l45.58-9.53ZM266,297l36.5,14.44a169,169,0,0,0-24.68,16.16c-3.9,3-7.1,5.6-9.88,7.94l-10.11-31.4A39.76,39.76,0,0,0,266,297Zm-58.12,3.48-37.66,37.86a54.85,54.85,0,0,0-9.59-15.24l.09-.55,47.15-22.07Zm17.73,8.67a39.43,39.43,0,0,0,10.6,1.46c1.35,0,2.69-.07,4-.2L250.7,343c-13.32-.16-37.62.07-61.7,3l36.61-36.81ZM329.1,322l25.36,10c-29.4,14.92-50.37,35.89-69.25,57.2l-11-34.32c3.55-3.18,8.73-7.63,15-12.43,11.42-8.73,26.21-17.7,35.68-19.63l4.24-.86Zm-186.5,9.07,1.52,1.52c5.85,5.88,10,10.31,11.22,20.75L124.2,384.64c-.35-2.27-.74-4.63-1.2-7.14-2-10.95-4.45-22.94-9.32-32.9l28.92-13.54Zm235.93,10.49,39.22,15.52c-49.42,22.5-82.92,56.68-113.45,91.47l-12.44-38.65c24.11-27.84,47.68-53.61,86.67-68.34Zm-282,11.06c3,6.84,6.22,18.17,8.07,28.26,1.58,8.61,2.5,16.08,3,20.45L71.72,437.4c-1.68-5-3.78-11-6.55-18.29-5.37-14.22-12-30-19.61-42.64l51-23.86Zm150.86,9.15c4,0,6.81,0,9.35.06l10.39,32.3c-26.25-4.15-58.63-4.19-87-3.18-15.58.55-28,1.32-37.86,2.06l24.11-24.24,1-.23C191,362.74,227.16,361.79,247.41,361.76Zm-42.19,47.39c24.92-.06,50.36,1.26,68.41,5.1L287.06,456c-38.71-8.23-89-11-132.09-11.74-27.22-.48-49.23-.19-63.87.17l30.8-31c7.77-.76,30.71-2.84,58.86-3.84,7.9-.28,16.15-.45,24.46-.47Z"
    },
    classes: {
      main: "fill-radial"
    }
  },
  [
    "LostOpportunity"
    /* LostOpportunity */
  ]: {
    viewBox: "0 0 512 512",
    paths: {
      main: "M373.33,52.76A234.57,234.57,0,0,0,52.77,138.67C-12,250.93,26.41,394.41,138.67,459.23s255.75,26.36,320.56-85.91S485.59,117.58,373.33,52.76Zm-211.87,367A189.1,189.1,0,0,1,81,184.37L327.62,431A188.73,188.73,0,0,1,161.46,419.76Zm211.18-14.87L107.14,139.38a187.3,187.3,0,0,1,32.24-32.29L404.89,372.6A187.71,187.71,0,0,1,372.64,404.89ZM431,327.6,184.41,81A189.12,189.12,0,0,1,431,327.6Z"
    },
    classes: {
      main: "fill-linear"
    }
  },
  [
    "WorsePosition"
    /* WorsePosition */
  ]: {
    viewBox: "0 0 512 512",
    paths: {
      horizon: "M18.36,227.8v18.68h86.37a98.45,98.45,0,0,0-4.43-18.68Zm379.4,0a110.51,110.51,0,0,1,9.44,18.68h86.44V227.8H397.76Z",
      boot: "M218.67,18.73a162.14,162.14,0,0,0-20,1.32C164,24.39,123.5,39.4,91.23,67.36L124.7,257.55l.35,10.12c42.26,15.79,100.82,24.55,152.87,24.25,27.19-.15,52.64-2.74,73-7.78s35.2-12.82,41.81-20.94l.44.35a113,113,0,0,0-6.53-17.06h.19a95.88,95.88,0,0,0-4.85-8.66c-.09-.14-.16-.3-.25-.44l-.31-.47c-21.46-34.89-63.5-55.87-124.28-29.37l-.16.06a215.37,215.37,0,0,0-34,20.19h-.81c11-15.72,23.26-28.12,35.91-37.28l1.12-11.16c-14.68-4-38.08-4.06-53.53-.09L201,161.14a130.33,130.33,0,0,1,30.34-3.84c1.5,0,3,0,4.5,0a117.66,117.66,0,0,1,25.25,3.12l3.19-32c-21.06-8.07-42.12-6.6-64.57-1.59l-4.06-18.25A170.07,170.07,0,0,1,231,104.17c1.72,0,3.44,0,5.16.07a107,107,0,0,1,30.06,5.12l3.16-31.47c-25.6-7.69-51-8.1-76.91-2.78l-3.78-18.28A188.53,188.53,0,0,1,221.52,53c1.14,0,2.29-.05,3.43-.06A167.36,167.36,0,0,1,271.23,59l.47-4.6c5-23.31-18.75-35.71-53-35.65ZM397.26,284.45c-10.84,8.13-25.26,13.7-41.87,17.82-22.37,5.54-49.07,8.18-77.38,8.34a526.46,526.46,0,0,1-65.09-3.75L225.36,329c80.16,9.44,141.5-1.19,172-21.78a113.13,113.13,0,0,0-.13-22.75ZM125.7,287.77l1,30.47,58.6,8.43,9.59-22.31c-24.55-3.82-48.21-9.37-69.19-16.59Z",
      ice: "M92.61,309.3C82.3,312.37,74,315.76,68,319.36l-.21.12L37.58,334.2,18.36,322v22.16L32,352.8l4.41,2.81,4.72-2.31,22-10.72c11.71,9.8,40.46,18.23,79.4,23.87l-60,28.25,26.63,21L18.36,454.23v39H145.14L188.86,447l51,46.28h27.84L159.11,394.8l35.06-23c20,1.37,41.34,2.15,63.56,2.15,20.7,0,40.66-.67,59.44-1.87l39.06,24.69-66.9,35.71,62.28,60.75H475.52L385,440.64l51.32-39.78-71.5-33.28c45.88-6,79.18-15.67,89.81-27l18,6.43,21.06,22.57V342.17l-8.94-9.56L483.17,331l-2.15-.78L439.8,315.42a141.57,141.57,0,0,0-16.66-6c5.37,3.24,8.28,6.7,8.28,10.28,0,18.59-77.73,33.66-173.62,33.66S84.14,338.29,84.14,319.7c0-3.63,3-7.13,8.47-10.4Z"
    },
    classes: {
      horizon: "fill-dark",
      boot: "fill-bright",
      ice: "fill-radial"
    }
  },
  [
    "InsightHarm1"
    /* InsightHarm1 */
  ]: {
    viewBox: "0 0 512 512",
    paths: {
      eye: "M406.09,282.69V352.6c4.19,8.54,8.53,16.73,8.53,27.56,0,13.24-8.75,22.78-18.09,22.78-9.13,0-18.69-10-18.69-23.94,0-12.22,5.1-20.64,9.56-29.59V289.63c-6.51-19.32-16.22-25.45-26.54-21.72V226.24A401.64,401.64,0,0,0,409.07,204h45.2C435.64,222.23,417,244.72,406.09,282.69ZM494.83,158.8c-33,49.83-80.77,87.12-134,108.82a291.28,291.28,0,0,1-90,21.07q-7.2.51-14.42.62a256.33,256.33,0,0,1-89-14,239,239,0,0,1-25.35-10.52A239.65,239.65,0,0,1,82.64,223.9C74.76,216.85,66,208.81,57.89,200c-11.54-12.52-21.66-26.51-25.72-41.23,20.19-37.74,48.7-69.38,84.66-92.29C241.41-14.68,416.3,37.68,494.83,158.8Zm-29.17-.36C373.78,11.86,140.41,12.08,57.19,160.28l.46.39-.46.39a353,353,0,0,0,54.67,42.55c45.21,28.32,92.77,42.1,140.82,42.29h.22C324.81,246.14,397.81,215.94,465.66,158.44Z",
      iris: "M303.7,99.51a65,65,0,0,0-45-18h0a65.26,65.26,0,1,0,45,18Zm-45.4,68.13a23.4,23.4,0,1,1,23.39-23.41A23.42,23.42,0,0,1,258.3,167.64Zm45.4-68.13a65,65,0,0,0-45-18h0a65.26,65.26,0,1,0,45,18Zm-45.4,68.13a23.4,23.4,0,1,1,23.39-23.41A23.42,23.42,0,0,1,258.3,167.64Zm45.4-68.13a65,65,0,0,0-45-18h0a65.26,65.26,0,1,0,45,18Zm-45.4,68.13a23.4,23.4,0,1,1,23.39-23.41A23.42,23.42,0,0,1,258.3,167.64Z"
    },
    classes: {
      eye: "fill-dark",
      iris: "fill-med"
    }
  },
  [
    "InsightHarm2"
    /* InsightHarm2 */
  ]: {
    viewBox: "0 0 512 512",
    paths: {
      eye: "M305.51,89.71A78.5,78.5,0,0,0,251.22,68h0a78.81,78.81,0,1,0,54.29,21.71ZM250.71,172a28.25,28.25,0,1,1,28.23-28.27A28.28,28.28,0,0,1,250.71,172Zm54.8-82.26A78.5,78.5,0,0,0,251.22,68h0a78.81,78.81,0,1,0,54.29,21.71ZM250.71,172a28.25,28.25,0,1,1,28.23-28.27A28.28,28.28,0,0,1,250.71,172Zm54.8-82.26A78.5,78.5,0,0,0,251.22,68h0a78.81,78.81,0,1,0,54.29,21.71ZM250.71,172a28.25,28.25,0,1,1,28.23-28.27A28.28,28.28,0,0,1,250.71,172Z",
      iris: "M398.59,282.69V352.6c4.19,8.54,8.53,16.73,8.53,27.56,0,13.24-8.75,22.78-18.09,22.78-9.13,0-18.69-10-18.69-23.94,0-12.22,5.1-20.64,9.56-29.59V289.63c-6.51-19.32-16.22-25.45-26.54-21.72V226.24A401.64,401.64,0,0,0,401.57,204h45.2C428.14,222.23,409.46,244.72,398.59,282.69Zm-264-17.94A239.65,239.65,0,0,1,75.14,223.9c-7.88-7.05-16.67-15.09-24.75-23.86,11.79,18.34,22,39.48,27.42,60.27v50c-4.76,10.14-12.06,17.21-12.06,28.41,0,9.09,11.63,18.09,21,18.09,9.2,0,21.6-9.67,21.59-19.25,0-11.36-7.31-17.81-11.87-27V278.22C103,265.1,117.78,261.12,134.61,264.75ZM487.33,158.8c-33,49.83-80.77,87.12-134,108.82a291.28,291.28,0,0,1-90,21.07q-7.2.51-14.42.62a256.33,256.33,0,0,1-88.95-14,239,239,0,0,1-25.35-10.52A239.65,239.65,0,0,1,75.14,223.9c-7.88-7.05-16.67-15.09-24.75-23.86-11.54-12.52-21.66-26.51-25.72-41.23,20.19-37.74,48.7-69.38,84.66-92.29C233.91-14.68,408.8,37.68,487.33,158.8Zm-29.17-.36C366.28,11.86,132.91,12.08,49.69,160.28l.46.39-.46.39a353,353,0,0,0,54.67,42.55c45.21,28.32,92.77,42.1,140.82,42.29h.22C317.31,246.14,390.31,215.94,458.16,158.44Z"
    },
    classes: {
      eye: "fill-med",
      iris: "fill-med"
    }
  },
  [
    "InsightHarm3"
    /* InsightHarm3 */
  ]: {
    viewBox: "0 0 512 512",
    paths: {
      eye: "M398.31,282.69V352.6c4.19,8.54,8.53,16.73,8.53,27.56,0,13.24-8.75,22.78-18.09,22.78-9.13,0-18.69-10-18.69-23.94,0-12.22,5.1-20.64,9.56-29.59V289.63c-6.51-19.32-16.22-25.45-26.54-21.72V226.24A401.64,401.64,0,0,0,401.29,204h45.2C427.86,222.23,409.18,244.72,398.31,282.69Zm-264-17.94A239.65,239.65,0,0,1,74.86,223.9C67,216.85,58.19,208.81,50.11,200c11.79,18.34,22,39.48,27.42,60.27v50c-4.76,10.14-12.06,17.21-12.06,28.41,0,9.09,11.63,18.09,21,18.09,9.2,0,21.6-9.67,21.59-19.25,0-11.36-7.31-17.81-11.87-27V278.22C102.75,265.1,117.5,261.12,134.33,264.75Zm114.3,24.56a256.33,256.33,0,0,1-88.95-14,109.79,109.79,0,0,1,42.38,48.58v80.59c-6.36,10.47-13.62,16.95-13.62,28.87,0,17.89,11.76,24.5,23.93,24.5,11.91,0,21.6-5.66,21.6-24.5,0-9.3-7.44-16.63-13.22-31.06V324.1C227.16,309.18,237.5,294.45,248.63,289.31ZM487.05,158.8c-33,49.83-80.77,87.12-134,108.82a291.28,291.28,0,0,1-90,21.07q-7.2.51-14.42.62a256.33,256.33,0,0,1-88.95-14,239,239,0,0,1-25.35-10.52A239.65,239.65,0,0,1,74.86,223.9C67,216.85,58.19,208.81,50.11,200c-11.54-12.52-21.66-26.51-25.72-41.23,20.19-37.74,48.7-69.38,84.66-92.29C233.63-14.68,408.52,37.68,487.05,158.8Zm-29.17-.36C366,11.86,132.63,12.08,49.41,160.28l.46.39-.46.39a353,353,0,0,0,54.67,42.55c45.21,28.32,92.77,42.1,140.82,42.29h.22C317,246.14,390,215.94,457.88,158.44Z",
      iris: "M314.46,80a91.84,91.84,0,0,0-63.52-25.39h0A92.2,92.2,0,1,0,314.46,80Zm-64.12,96.24a33.05,33.05,0,1,1,33-33.07A33.08,33.08,0,0,1,250.34,176.25ZM314.46,80a91.84,91.84,0,0,0-63.52-25.39h0A92.2,92.2,0,1,0,314.46,80Zm-64.12,96.24a33.05,33.05,0,1,1,33-33.07A33.08,33.08,0,0,1,250.34,176.25ZM314.46,80a91.84,91.84,0,0,0-63.52-25.39h0A92.2,92.2,0,1,0,314.46,80Zm-64.12,96.24a33.05,33.05,0,1,1,33-33.07A33.08,33.08,0,0,1,250.34,176.25Z"
    },
    classes: {
      eye: "fill-med",
      iris: "fill-bright"
    }
  },
  [
    "InsightHarm4"
    /* InsightHarm4 */
  ]: {
    viewBox: "0 0 512 512",
    paths: {
      eye: "M244,27.44c-46.86,0-93.53,12.25-134.7,39.08-36,22.91-64.47,54.55-84.66,92.29,4.06,14.72,14.18,28.71,25.72,41.23,8.08,8.77,16.87,16.81,24.75,23.86a239.65,239.65,0,0,0,59.47,40.85A239,239,0,0,0,160,275.27a256.33,256.33,0,0,0,88.95,14q7.22-.1,14.42-.62a291.28,291.28,0,0,0,90-21.07A299.94,299.94,0,0,0,430.12,222a286.46,286.46,0,0,0,57.21-63.16C434.75,77.71,339,27.44,244,27.44ZM245.4,245.9h-.22c-48.05-.19-95.61-14-140.82-42.29a353,353,0,0,1-54.67-42.55l.46-.39-.46-.39c83.22-148.2,316.59-148.42,408.47-1.84C390.31,215.94,317.31,246.14,245.4,245.9Zm17.93,42.79c7.16,3,14.11,11.57,20,28.08,3.54,9.85,6.71,22.54,9.33,38.58v74.84C287.27,440.69,281,449.64,281,462.5s10,22.19,21,22.19c10.74,0,22.18-9.73,22.18-23.34,0-14.45-7.09-23.42-12.81-34.57V342.22h-.22a223.26,223.26,0,0,1,7.48-25.45c9.57-26.37,22.57-44.47,34.73-48.86v-.29A291.28,291.28,0,0,1,263.33,288.69Zm-38.82,28.08c6.37-12.19,15.11-23.17,24.4-27.46a256.33,256.33,0,0,1-88.95-14,109.62,109.62,0,0,1,38.91,41.5q1.84,3.45,3.47,7.08v80.59c-6.36,10.47-13.62,16.95-13.62,28.87,0,17.89,11.76,24.5,23.93,24.5,11.91,0,21.6-5.66,21.6-24.5,0-9.3-7.44-16.63-13.22-31.06V324.1C222.09,321.64,223.26,319.18,224.51,316.77Zm-89.9-52A239.65,239.65,0,0,1,75.14,223.9c-7.88-7.05-16.67-15.09-24.75-23.86,11.79,18.34,22,39.48,27.42,60.27v50c-1.08,2.29-2.28,4.43-3.51,6.49-4.18,7.06-8.55,13.25-8.55,21.92,0,9.09,11.63,18.09,21,18.09,9.2,0,21.6-9.67,21.59-19.25,0-8.63-4.22-14.43-8.25-20.76a67,67,0,0,1-3.62-6.27V278.22C103,265.1,117.78,261.12,134.61,264.75Zm267-60.78a401.64,401.64,0,0,1-48.21,22.27v41.67c10.32-3.73,20,2.4,26.54,21.72v59.78c-4.46,8.95-9.56,17.37-9.56,29.59,0,13.94,9.56,23.94,18.69,23.94,9.34,0,18.09-9.54,18.09-22.78,0-10.83-4.34-19-8.53-27.56V282.69c7.59-26.52,19-45.48,31.53-60.73a225.7,225.7,0,0,1,16.65-18Z",
      iris: "M326.5,67.65a108.84,108.84,0,0,0-75.28-30.08h0A109.22,109.22,0,1,0,326.5,67.65Zm-76,114.06a39.17,39.17,0,1,1,39.15-39.19A39.2,39.2,0,0,1,250.51,181.71Zm76-114.06a108.84,108.84,0,0,0-75.28-30.08h0A109.22,109.22,0,1,0,326.5,67.65Zm-76,114.06a39.17,39.17,0,1,1,39.15-39.19A39.2,39.2,0,0,1,250.51,181.71Zm76-114.06a108.84,108.84,0,0,0-75.28-30.08h0A109.22,109.22,0,1,0,326.5,67.65Zm-76,114.06a39.17,39.17,0,1,1,39.15-39.19A39.2,39.2,0,0,1,250.51,181.71Z"
    },
    classes: {
      eye: "fill-bright",
      iris: "fill-med"
    }
  },
  [
    "ProwessHarm1"
    /* ProwessHarm1 */
  ]: {
    viewBox: "0 0 512 512",
    paths: {
      scar: "M443.44,434.53Q408.7,409.87,376,383.64c-20-11.91-31.49.3-44.26,16.86,8.8-18.17,13.38-36.95,3.24-50.86l-4.46-3.84-44.85-35.35L237.9,336.93l17.19-25.34c7.31-12.4,3.43-27.17-5.65-41.14q-16.37-16.32-32.22-33c-1.66-1.23-3.31-2.38-4.95-3.5l-66.44,18.87L167.59,227c10.57-17.62,0-41.59-9.84-55.7q-8.4-9.81-16.62-19.75l-43.67,7.29c18.43-7.3,31.37-22.38,16.85-40l2.06,2.33Q91.79,90.29,68.44,58.49q43,32.32,83.86,67.06L188.92,116l-22.11,22q23.38,20.3,46.09,41.39l71.86-30.46L266,178l.3-.24c-21.55,27.54,18.77,86,46,78.42l31.91-17.7L319.4,275l36.88,52.71c.26.3.53.59.79.9,13.64,12.5,31.23,1.71,43.05-14.53l-19.59,42Q412.66,394.28,443.44,434.53Z"
    },
    classes: {
      scar: "fill-dark"
    }
  },
  [
    "ProwessHarm2"
    /* ProwessHarm2 */
  ]: {
    viewBox: "0 0 512 512",
    paths: {
      scarTissue: "M399,355.08c-15-32.31-18.67-65.87-6.23-94.7-47.19,58.41-76.14,4.41-4.09-70.72-101.67,62.7-147.78,31.47-14-88.26-103,54.66-182.49,69.22-130.93,15.19-37.19,10.63-58.21,5.21-76-2.43A643.42,643.42,0,0,0,55.28,58.49a789.14,789.14,0,0,0,47,77.56c7,18.27,3,38.71-31.46,63.44,124.85-33.45,88.52,47-9.36,104.92,166.21-61.68,207.52-47.41,100.64,78,84-61.07,150.14-44.57,122.89,31.29,31.63-24.51,57.9-29.74,78-20.87q43.39,30.7,90.32,59C436.25,418.27,418.25,386,399,355.08ZM352.11,362c-16.61-9.9-26.17.25-36.79,14,7.32-15.11,11.12-30.72,2.69-42.28l-3.7-3.19L277,301.11l-39.68,22,14.29-21.06c6.08-10.31,2.85-22.58-4.7-34.2q-13.6-13.56-26.78-27.46c-1.38-1-2.75-2-4.11-2.91l-55.23,15.68,18.09-21.41c8.78-14.64,0-34.57-8.18-46.3q-7-8.15-13.82-16.42l-36.3,6.06c15.32-6.06,26.08-18.6,14-33.28l-1.89-2.13c.69.72,1.31,1.42,1.89,2.13l1.71,1.94q-20.43-25.65-39.84-52.09,35.76,26.88,69.71,55.75l30.44-7.93-18.38,18.27q19.44,16.88,38.31,34.41l59.73-25.32L260.68,191l.25-.2c-17.91,22.9,15.6,71.52,38.24,65.19l26.52-14.71-20.6,30.37,30.65,43.82.66.74c11.34,10.39,26,1.42,35.79-12.07L355.9,339q26.72,31.78,52.3,65.24Q379.31,383.76,352.11,362Z"
    },
    classes: {
      scarTissue: "fill-med"
    }
  },
  [
    "ProwessHarm3"
    /* ProwessHarm3 */
  ]: {
    viewBox: "0 0 512 512",
    paths: {
      scar: "M447.44,434.53Q412.7,409.87,380,383.64c-20-11.91-31.49.3-44.26,16.86,8.8-18.17,13.38-36.95,3.24-50.86l-4.46-3.84-44.85-35.35L241.9,336.93l17.19-25.34c7.31-12.4,3.43-27.17-5.65-41.14q-16.37-16.32-32.22-33c-1.66-1.23-3.31-2.38-4.95-3.5l-66.44,18.87L171.59,227c10.57-17.62,0-41.59-9.84-55.7q-8.4-9.81-16.62-19.75l-43.67,7.29c18.43-7.3,31.37-22.38,16.85-40l2.06,2.33Q95.79,90.29,72.44,58.49q43,32.32,83.86,67.06L192.92,116l-22.11,22q23.38,20.3,46.09,41.39l71.86-30.46L270,178l.3-.24c-21.55,27.54,18.77,86,46,78.42l31.91-17.7L323.4,275l36.88,52.71c.26.3.53.59.79.9,13.64,12.5,31.23,1.71,43.05-14.53l-19.59,42Q416.66,394.28,447.44,434.53Z",
      scarTissue: "M436.33,375.37c-18.07-38.87-22.46-79.24-7.49-113.92-56.77,70.27-91.6,5.3-4.93-85.08C301.61,251.8,246.13,214.23,407,70.19,283.18,136,187.5,153.46,249.53,88.47c-44.75,12.79-70,6.27-91.47-2.93a773.7,773.7,0,0,0-135.18-67,949.58,949.58,0,0,0,56.49,93.31c8.39,22,3.6,46.57-37.84,76.32C191.72,148,148,244.71,30.26,314.42c200-74.2,249.65-57,121.08,93.78C252.42,334.73,332,354.59,299.17,445.84c38.06-29.48,69.66-35.77,93.87-25.1q52.21,36.94,108.66,70.93C481.19,451.39,459.54,412.52,436.33,375.37ZM380,383.64c-20-11.91-31.49.3-44.26,16.86,8.8-18.17,13.38-36.95,3.24-50.86l-4.46-3.84-44.85-35.35L241.9,336.93l17.19-25.34c7.31-12.4,3.43-27.17-5.65-41.14q-16.37-16.32-32.22-33c-1.66-1.23-3.31-2.38-4.95-3.5l-66.44,18.87L171.59,227c10.57-17.62,0-41.59-9.84-55.7q-8.4-9.81-16.62-19.75l-43.67,7.29c18.43-7.3,31.37-22.38,16.85-40L116,116.26c.83.86,1.57,1.71,2.27,2.56l2.06,2.33Q95.79,90.29,72.44,58.49q43,32.32,83.86,67.06L192.92,116l-22.11,22q23.38,20.3,46.09,41.39l71.86-30.46L270,178l.3-.24c-21.55,27.54,18.77,86,46,78.42l31.91-17.7L323.4,275l36.88,52.71c.26.3.53.59.79.9,13.64,12.5,31.23,1.71,43.05-14.53l-19.59,42q32.13,38.23,62.91,78.49Q412.7,409.87,380,383.64Z"
    },
    classes: {
      scar: "fill-dark",
      scarTissue: "fill-med"
    }
  },
  [
    "ProwessHarm4"
    /* ProwessHarm4 */
  ]: {
    viewBox: "0 0 512 512",
    paths: {
      scar: "M441.44,434.53Q406.7,409.87,374,383.64c-20-11.91-31.49.3-44.26,16.86,8.8-18.17,13.38-36.95,3.24-50.86l-4.46-3.84-44.85-35.35L235.9,336.93l17.19-25.34c7.31-12.4,3.43-27.17-5.65-41.14q-16.37-16.32-32.22-33c-1.66-1.23-3.31-2.38-4.95-3.5l-66.44,18.87L165.59,227c10.57-17.62,0-41.59-9.84-55.7q-8.4-9.81-16.62-19.75l-43.67,7.29c18.43-7.3,31.37-22.38,16.85-40l2.06,2.33Q89.79,90.29,66.44,58.49q43,32.32,83.86,67.06L186.92,116l-22.11,22q23.38,20.3,46.09,41.39l71.86-30.46L264,178l.3-.24c-21.55,27.54,18.77,86,46,78.42l31.91-17.7L317.4,275l36.88,52.71c.26.3.53.59.79.9,13.64,12.5,31.23,1.71,43.05-14.53l-19.59,42Q410.66,394.28,441.44,434.53Z",
      scarTissue: "M430.33,375.37c-18.07-38.87-22.46-79.24-7.49-113.92-56.77,70.27-91.6,5.3-4.93-85.08C295.61,251.8,240.13,214.23,401,70.19,277.18,136,181.5,153.46,243.53,88.47c-44.75,12.79-70,6.27-91.47-2.93a773.7,773.7,0,0,0-135.18-67,949.58,949.58,0,0,0,56.49,93.31c8.39,22,3.6,46.57-37.84,76.32C185.72,148,142,244.71,24.26,314.42c200-74.2,249.65-57,121.08,93.78C246.42,334.73,326,354.59,293.17,445.84c38.06-29.48,69.66-35.77,93.87-25.1q52.21,36.94,108.66,70.93C475.19,451.39,453.54,412.52,430.33,375.37ZM374,383.64c-20-11.91-31.49.3-44.26,16.86,8.8-18.17,13.38-36.95,3.24-50.86l-4.46-3.84-44.85-35.35L235.9,336.93l17.19-25.34c7.31-12.4,3.43-27.17-5.65-41.14q-16.37-16.32-32.22-33c-1.66-1.23-3.31-2.38-4.95-3.5l-66.44,18.87L165.59,227c10.57-17.62,0-41.59-9.84-55.7q-8.4-9.81-16.62-19.75l-43.67,7.29c18.43-7.3,31.37-22.38,16.85-40L110,116.26c.83.86,1.57,1.71,2.27,2.56l2.06,2.33Q89.79,90.29,66.44,58.49q43,32.32,83.86,67.06L186.92,116l-22.11,22q23.38,20.3,46.09,41.39l71.86-30.46L264,178l.3-.24c-21.55,27.54,18.77,86,46,78.42l31.91-17.7L317.4,275l36.88,52.71c.26.3.53.59.79.9,13.64,12.5,31.23,1.71,43.05-14.53l-19.59,42q32.13,38.23,62.91,78.49Q406.7,409.87,374,383.64Z",
      welts: "M414.13,84.19a39.5,39.5,0,1,0,39.57,39.5,39.2,39.2,0,0,0-39.57-39.5ZM308.33,29.83A28.66,28.66,0,1,0,337,58.51a28.51,28.51,0,0,0-28.67-28.68ZM90.17,322.56a49.51,49.51,0,1,0,49.53,49.52A49.36,49.36,0,0,0,90.17,322.56Zm258-171.24A22.79,22.79,0,1,0,371,174.11a22.61,22.61,0,0,0-22.83-22.79ZM261.49,89.88a16.72,16.72,0,1,0,16.73,16.73,16.63,16.63,0,0,0-16.73-16.73ZM91.15,187.65a21.18,21.18,0,1,0,21.18,21.18,21,21,0,0,0-21.18-21.18Zm77.51,94.54a32.09,32.09,0,1,0,32.07,32.1,32,32,0,0,0-32.07-32.1ZM391.6,243.05a16.51,16.51,0,1,0,16.49,16.52,16.41,16.41,0,0,0-16.49-16.52ZM238.11,374.85a48.43,48.43,0,1,0,48.44,48.45A48.29,48.29,0,0,0,238.11,374.85Zm137,59.88A22.86,22.86,0,1,0,398,457.59a22.69,22.69,0,0,0-22.86-22.86Z"
    },
    classes: {
      scar: "fill-bright",
      scarTissue: "fill-dark",
      welts: "fill-bright"
    }
  },
  [
    "ResolveHarm1"
    /* ResolveHarm1 */
  ]: {
    viewBox: "0 0 512 512",
    paths: {
      spikes: "M256.09,19.1A237.5,237.5,0,0,0,197,27.22C70.63,61.08-4.36,191,29.5,317.31,62.59,440.8,187.39,515.21,311,486.92A132.35,132.35,0,0,1,279.74,475,207,207,0,0,1,122,417.49l-13.48-14.55L94.89,385.42a205.62,205.62,0,0,1-24-47.36l-7.2-17.33L60.71,296.5a205.83,205.83,0,0,1-.18-54.37l3-24.36,7.67-19.51a208.28,208.28,0,0,1,29.16-53.84l105,60.61-68.63-98a205.85,205.85,0,0,1,63.68-34.49l27.24-8.18,23.18-1.89q6.46-.48,12.89-.54a205.54,205.54,0,0,1,61.66,8.84l23.65,11,22,9.09A207.05,207.05,0,0,1,428.2,140.9l13.1,14.44L448.93,173a208,208,0,0,1,16.41,42.22,205.89,205.89,0,0,1,2.52,96.73,133,133,0,0,1,7.74,38.31,235.8,235.8,0,0,0,11.48-155.53C458.51,88.09,361.59,18.05,256.09,19.1Z",
      eyeball: "M344.58,242.53a45.61,45.61,0,0,1,8.95,6.95c12.22,12.21,16.07,29.9,13.26,47.35S354.74,332,340,346.82s-32.54,24-50,26.83-35.13-1-47.35-13.26a48,48,0,0,1-13-24.74,114.74,114.74,0,1,0,114.92-93.12Z",
      iris: "M316.24,254a50.56,50.56,0,0,0-7.08.66c-13,2.09-27.56,9.39-39.76,21.59S249.91,303,247.81,316s.75,23.89,8,31.16S274,357.3,287,355.2s27.56-9.39,39.76-21.59,19.5-26.76,21.59-39.76-.75-23.89-8-31.16c-5.45-5.45-12.94-8.42-21.83-8.68-.74,0-1.49,0-2.25,0Zm-13.81,20.35a16,16,0,0,1,11.86,4.38c7.49,7.5,5.16,22-5.22,32.37s-24.88,12.72-32.38,5.23-5.16-22,5.22-32.38c6.17-6.16,13.78-9.49,20.52-9.6Z"
    },
    classes: {
      spikes: "fill-dark",
      eyeball: "fill-dark",
      iris: "fill-med"
    }
  },
  [
    "ResolveHarm2"
    /* ResolveHarm2 */
  ]: {
    viewBox: "0 0 512 512",
    paths: {
      spikes: "M261.25,19.1a237.64,237.64,0,0,0-59.11,8.12C75.79,61.08.8,191,34.66,317.31,67.75,440.8,192.55,515.21,316.15,486.92A132.59,132.59,0,0,1,284.89,475a207,207,0,0,1-157.72-57.52l-11.44-12.15-15.68-19.92a205.62,205.62,0,0,1-24-47.36l-7.32-17.33L65.87,296.5a205.41,205.41,0,0,1-.18-54.37l91.84,19.32L76.38,198.26a208,208,0,0,1,29.16-53.84L259.93,252.78,141.87,107a205.79,205.79,0,0,1,63.67-34.49L263.45,141,256,62.45q6.46-.48,12.89-.54a205.54,205.54,0,0,1,61.66,8.84l22.84,8.32,22.83,11.78a207,207,0,0,1,57.17,50.05l13.41,16.85L454.08,173a207.52,207.52,0,0,1,18.93,139,132.67,132.67,0,0,1,7.75,38.31,235.92,235.92,0,0,0,11.48-155.53C463.67,88.09,366.74,18.05,261.25,19.1Z",
      eyeball: "M349.74,242.53a45.61,45.61,0,0,1,8.95,6.95c12.21,12.21,16.07,29.9,13.26,47.35s-12.05,35.21-26.83,50-32.54,24-50,26.83-35.14-1-47.35-13.26a48,48,0,0,1-13-24.74,116.19,116.19,0,0,0-2,21.58,114.73,114.73,0,1,0,117-114.7Z",
      iris: "M321.4,254a50.42,50.42,0,0,0-7.08.66c-13,2.09-27.56,9.39-39.76,21.59S255.06,303,253,316s.75,23.89,8,31.16,18.16,10.12,31.16,8,27.56-9.39,39.76-21.59,19.49-26.76,21.59-39.76-.75-23.89-8-31.16c-5.46-5.45-13-8.42-21.83-8.68-.74,0-1.49,0-2.25,0Zm-13.81,20.35a16,16,0,0,1,11.85,4.38c7.5,7.5,5.16,22-5.22,32.37s-24.87,12.72-32.37,5.23-5.16-22,5.22-32.38c6.16-6.16,13.78-9.49,20.52-9.6Z"
    },
    classes: {
      spikes: "fill-med",
      eyeball: "fill-dark",
      iris: "fill-bright"
    }
  },
  [
    "ResolveHarm3"
    /* ResolveHarm3 */
  ]: {
    viewBox: "0 0 512 512",
    paths: {
      spikes: "M261.31,19.1a237.51,237.51,0,0,0-59.11,8.12C75.84,61.08.86,191,34.71,317.31,67.8,440.8,192.61,515.21,316.2,486.92A132.35,132.35,0,0,1,285,475a207,207,0,0,1-157.72-57.52l-13.81-16.37-13.31-15.7a206,206,0,0,1-24.06-47.36l83.63-17.33L65.93,296.5a205.41,205.41,0,0,1-.18-54.37l164.66,47.21-154-91.08a208,208,0,0,1,29.15-53.84L260,252.78,141.92,107A205.85,205.85,0,0,1,205.6,72.52l95.49,158.21L256,62.45q6.47-.48,12.9-.54a205.43,205.43,0,0,1,61.65,8.84L353.08,169l23.17-78.14a206.76,206.76,0,0,1,57.16,50.05l13.08,22.41,7.65,9.67a207.52,207.52,0,0,1,18.93,139,132.33,132.33,0,0,1,7.74,38.31,235.8,235.8,0,0,0,11.48-155.53C463.73,88.09,366.8,18.05,261.31,19.1Z",
      eyeball: "M349.79,242.53a45.38,45.38,0,0,1,9,6.95c12.21,12.21,16.07,29.9,13.25,47.35s-12,35.21-26.82,50-32.54,24-50,26.83-35.13-1-47.34-13.26a48,48,0,0,1-13-24.74,116.19,116.19,0,0,0-2,21.58,114.73,114.73,0,1,0,117-114.7Z",
      iris: "M321.45,254a50.56,50.56,0,0,0-7.08.66c-13,2.09-27.55,9.39-39.75,21.59S255.12,303,253,316s.75,23.89,8,31.16,18.16,10.12,31.16,8,27.56-9.39,39.76-21.59,19.49-26.76,21.59-39.76-.75-23.89-8-31.16c-5.45-5.45-12.94-8.42-21.83-8.68-.74,0-1.49,0-2.25,0Zm-13.81,20.35a16,16,0,0,1,11.86,4.38c7.5,7.5,5.16,22-5.22,32.37s-24.88,12.72-32.37,5.23-5.16-22,5.22-32.38c6.16-6.16,13.78-9.49,20.51-9.6Z"
    },
    classes: {
      spikes: "fill-bright",
      eyeball: "fill-med",
      iris: "fill-bright"
    }
  },
  [
    "ResolveHarm4"
    /* ResolveHarm4 */
  ]: {
    viewBox: "0 0 512 512",
    paths: {
      spikes: "M261.14,19.1A237.51,237.51,0,0,0,202,27.22C75.67,61.08.69,191,34.54,317.31,67.63,440.8,192.44,515.21,316,486.92A132.35,132.35,0,0,1,284.78,475a207,207,0,0,1-157.72-57.52l89.22-30-116.34-2a206,206,0,0,1-24.06-47.36L214,333.21,65.76,296.5a205.41,205.41,0,0,1-.18-54.37l164.66,47.21-154-91.08a208,208,0,0,1,29.15-53.84l154.4,108.36L141.75,107a205.85,205.85,0,0,1,63.68-34.49l95.49,158.21L255.85,62.45q6.47-.48,12.9-.54a205.43,205.43,0,0,1,61.65,8.84L359.77,223.5,376.08,90.85a206.76,206.76,0,0,1,57.16,50.05L415.61,243.13,454,173a207.52,207.52,0,0,1,18.93,139,132.33,132.33,0,0,1,7.74,38.31,235.8,235.8,0,0,0,11.48-155.53C463.55,88.09,366.63,18.05,261.14,19.1Z",
      eyeball: "M349.62,242.53a45.38,45.38,0,0,1,9,6.95c12.21,12.21,16.07,29.9,13.25,47.35s-12,35.21-26.82,50-32.55,24-50,26.83-35.13-1-47.34-13.26a48,48,0,0,1-13-24.74,116.19,116.19,0,0,0-2,21.58,114.73,114.73,0,1,0,117-114.7Z",
      iris: "M321.28,254a50.56,50.56,0,0,0-7.08.66c-13,2.09-27.55,9.39-39.75,21.59S255,303,252.86,316s.75,23.89,8,31.16S279,357.3,292,355.2s27.55-9.39,39.76-21.59,19.49-26.76,21.59-39.76-.75-23.89-8-31.16c-5.45-5.45-12.94-8.42-21.83-8.68-.74,0-1.49,0-2.25,0Zm-13.81,20.35a16,16,0,0,1,11.86,4.38c7.5,7.5,5.16,22-5.22,32.37s-24.88,12.72-32.37,5.23-5.16-22,5.22-32.38c6.16-6.16,13.78-9.49,20.51-9.6Z"
    },
    classes: {
      spikes: "fill-bright",
      eyeball: "fill-bright",
      iris: "fill-bright"
    }
  }
};
gsap.registerPlugin(MotionPathPlugin);
const _noCapWords = "a|above|after|an|and|at|below|but|by|down|for|for|from|in|nor|of|off|on|onto|or|out|so|the|to|under|up|with|yet".split("|").map((word) => new RegExp(`\\b${word}\\b`, "gui"));
const _capWords = [
  "I",
  /[^a-z]{3,}|[.0-9]/gu
].map((word) => /RegExp/.test(Object.prototype.toString.call(word)) ? word : new RegExp(`\\b${word}\\b`, "gui"));
const _loremIpsumText = `Lorem ipsum dolor sit amet, consectetur adipiscing elit. Suspendisse ultricies
nibh sed massa euismod lacinia. Aliquam nec est ac nunc ultricies scelerisque porta vulputate odio.
Integer gravida mattis odio, semper volutpat tellus. Ut elit leo, auctor eget fermentum hendrerit,
aliquet ac nunc. Suspendisse porta turpis vitae mi posuere molestie. Cras lectus lacus, vulputate a
vestibulum in, mattis vel mi. Mauris quis semper mauris. Praesent blandit nec diam eget tincidunt. Nunc
aliquet consequat massa ac lacinia. Ut posuere velit sagittis, vehicula nisl eget, fringilla nibh. Duis
volutpat mattis libero, a porttitor sapien viverra ut. Phasellus vulputate imperdiet ligula, eget
eleifend metus tempor nec. Nam eget sapien risus. Praesent id suscipit elit. Sed pellentesque ligula
diam, non aliquet magna feugiat vitae. Pellentesque ut tortor id erat placerat dignissim. Pellentesque
ut dui vel leo laoreet sodales nec ac tellus. In hac habitasse platea dictumst. Proin sed ex sed augue
sollicitudin interdum. Sed id lacus porttitor nisi vestibulum tincidunt. Nulla facilisi. Vestibulum
feugiat finibus magna in pretium. Proin consectetur lectus nisi, non commodo lectus tempor et. Cras
viverra, mi in consequat aliquet, justo mauris fringilla tellus, at accumsan magna metus in eros. Sed
vehicula, diam ut sagittis semper, purus massa mattis dolor, in posuere.`;
const _randomWords = `
aboveboard|account|achiever|acoustics|act|action|activity|actor|addition|adjustment|advertisement|advice|afterglow|afterimage|afterlife|aftermath|afternoon|afterthought|agreement
air|aircraft|airfield|airlift|airline|airmen|airplane|airport|airtime|alarm|allover|allspice|alongside|also|amount|amusement|anger|angle|animal|another|ants|anyhow|anymore
anyone|anyplace|anytime|anywhere|apparatus|apparel|appliance|approval|arch|argument|arithmetic|arm|army|around|art|ashtray|attack|attraction|aunt|authority|babies|baby|babysitter
back|backache|backbone|backbreaker|backdrop|backfire|background|backhand|backlash|backlog|backpack|backside|backslap|backslide|backspace|backspin|backstroke|backtrack|backward
badge|bag|bait|balance|ball|ballroom|bankbook|bankroll|base|baseball|basin|basket|basketball|bat|bath|battle|beachcomb|bead|bear|because|become|bed|bedrock|bedroll|bedroom
beds|bee|beef|beginner|behavior|belief|believe|bell|bellboy|bellhop|bells|below|berry|bike|bikes|bird|birds|birth|birthday|bit|bite|blackball|blackberries|blackbird|blackboard
blackjack|blacklist|blackmail|blackout|blacksmith|blacktop|blade|blood|blow|blowgun|bluebell|blueberry|bluebird|bluefish|bluegrass|blueprint|board|boardwalk|boat|bodyguard
bomb|bone|book|bookcase|bookend|bookkeeper|bookmark|bookmobile|books|bookseller|bookshelf|bookworm|boot|border|bottle|boundary|bowlegs|bowtie|box|boy|brainchild|brake|branch
brass|breath|brick|bridge|brother|bubble|bucket|bugspray|building|bulb|burst|bushes|business|butter|butterball|buttercup|butterfingers|buttermilk|butternut|butterscotch|button
bypass|cabbage|cabdriver|cable|cactus|cake|cakes|calculator|calendar|camera|camp|can|cancan|candlelight|candlestick|cannon|cannot|canvas|cap|caption|car|card|cardsharp|care
carefree|careworn|carfare|carload|carpenter|carpool|carport|carriage|cars|carsick|cart|cartwheel|cast|cat|cats|cattle|catwalk|cause|cave|caveman|celery|cellar|cemetery|cent
centercut|chalk|chance|change|channel|cheese|cheeseburger|cherries|cherry|chess|chicken|chickens|children|chin|church|circle|clam|class|clockwise|cloth|clover|club|coach|coal
coast|coat|cobweb|coffeemaker|coil|collar|color|comeback|committee|commonplace|commonwealth|company|comparison|competition|condition|connection|control|cook|copper|corn|cornmeal
cough|country|courthouse|cover|cow|cows|crack|cracker|crate|crayon|cream|creator|creature|credit|crewcut|crib|crime|crook|crossbow|crossbreed|crosscut|crossover|crosswalk
crow|crowd|crown|cub|cup|current|curtain|curve|cushion|dad|dairymaid|daisywheel|daughter|day|daybed|daybook|daybreak|daydream|daylight|daytime|deadend|deadline|death|debt
decision|deer|degree|design|desire|desk|destruction|detail|development|digestion|dime|dinner|dinosaurs|direction|dirt|discovery|discussion|dishcloth|dishpan|dishwasher|dishwater
diskdrive|distance|distribution|division|dock|doctor|dog|dogs|doll|dolls|donkey|door|doorstop|downtown|downunder|drain|drawbridge|drawer|dress|drink|driveway|driving|drop
duck|duckbill|duckpin|ducks|dust|ear|earache|earring|earth|earthquake|earthward|earthworm|edge|education|effect|egg|egghead|eggnog|eggs|eggshell|elbow|end|engine|error|event
everything|example|exchange|existence|expansion|experience|expert|eye|eyeballs|eyecatching|eyeglasses|eyelash|eyelid|eyes|eyesight|eyewitness|face|fact|fairies|fall|fang|farm
fatherland|fear|feeling|field|finger|fire|fireball|fireboat|firebomb|firebreak|firecracker|firefighter|firehouse|fireman|fireproof|fireworks|fish|fishbowl|fisherman|fisheye
fishhook|fishmonger|fishnet|fishpond|fishtail|flag|flame|flavor|flesh|flight|flock|floor|flower|flowers|fly|fog|fold|food|foot|football|foothill|footlights|footlocker|footprints
forbearer|force|forearm|forebear|forebrain|forecast|foreclose|foreclosure|foredoom|forefather|forefeet|forefinger|forefoot|forego|foregone|forehand|forehead|foreknowledge
foreleg|foreman|forepaws|foresee|foreshadow|forestall|forethought|foretold|forever|forewarn|foreword|forget|fork|forklift|form|fowl|frame|friction|friend|friends|frog|frogs
front|fruit|fruitcup|fuel|furniture|gate|gearshift|geese|ghost|giants|giraffe|girl|girls|glass|glassmaking|glove|gold|goodbye|goodnight|government|governor|grade|grain|grandaunt
granddaughter|grandfather|grandmaster|grandmother|grandnephew|grandparent|grandson|grandstand|granduncle|grape|grass|grassland|graveyard|grip|ground|group|growth|guide|guitar
gumball|gun|hair|haircut|hall|hamburger|hammer|hand|handbook|handgun|handmade|handout|hands|harbor|harmony|hat|hate|head|headache|headlight|headline|headquarters|health|heat
hereafter|hereby|herein|hereupon|highchair|highland|highway|hill|himself|history|hobbies|hole|holiday|home|homemade|hometown|honey|honeybee|honeydew|honeysuckle|hook|hookup
hope|horn|horse|horseback|horsefly|horsehair|horseman|horseplay|horsepower|horseradish|horses|hose|hospital|hot|hour|house|houseboat|household|housekeeper|houses|housetop
however|humor|hydrant|ice|icicle|idea|impulse|income|increase|industry|ink|insect|inside|instrument|insurance|intake|interest|invention|iron|island|itself|jail|jailbait|jam
jar|jeans|jelly|jellybean|jellyfish|jetliner|jetport|jewel|join|judge|juice|jump|jumpshot|kettle|key|keyboard|keyhole|keynote|keypad|keypunch|keystone|keystroke|keyword|kick
kiss|kittens|kitty|knee|knife|knot|knowledge|laborer|lace|ladybug|lake|lamp|land|language|laugh|leather|leg|legs|letter|letters|lettuce|level|library|lifeblood|lifeguard|lifelike
lifeline|lifelong|lifetime|lifework|limelight|limestone|limit|line|linen|lip|liquid|loaf|lock|locket|longhand|look|loss|love|low|lukewarm|lumber|lunch|lunchroom|machine|magic
maid|mailbox|mainline|man|marble|mark|market|mask|mass|match|matchbox|meal|meantime|meanwhile|measure|meat|meeting|memory|men|metal|mice|middle|milk|mind|mine|minister|mint
minute|mist|mitten|mom|money|monkey|month|moon|moonbeam|moonlight|moonlit|moonscape|moonshine|moonstruck|moonwalk|moreover|morning|mother|motion|motorcycle|mountain|mouth
move|muscle|name|nation|nearby|neck|need|needle|nerve|nest|nevermore|newsboy|newsbreak|newscaster|newsdealer|newsletter|newsman|newspaper|newsprint|newsreel|newsroom|night
nightfall|nobody|noise|noisemaker|north|northeast|nose|note|notebook|nowhere|number|nursemaid|nut|nutcracker|oatmeal|observation|ocean|offer|office|oil|oneself|onetime|orange
oranges|order|oven|overboard|overcoat|overflow|overland|pacemaker|page|pail|pan|pancake|paper|parcel|part|partner|party|passbook|passenger|passkey|Passover|passport|payment
peace|pear|pen|pencil|peppermint|person|pest|pet|pets|pickle|pickup|picture|pie|pies|pig|pigs|pin|pinhole|pinstripe|pinup|pinwheel|pipe|pizzas|place|plane|planes|plant|plantation
plants|plastic|plate|play|playback|playground|playhouse|playthings|pleasure|plot|plough|pocket|point|poison|pollution|ponytail|popcorn|porter|position|postcard|pot|potato
powder|power|price|produce|profit|property|prose|protest|pull|pump|punishment|purpose|push|quarter|quartz|queen|question|quicksand|quiet|quill|quilt|quince|quiver|rabbit|rabbits
racquetball|rail|railroad|railway|rain|raincheck|raincoat|rainstorm|rainwater|rake|range|rat|rate|rattlesnake|rattletrap|ray|reaction|reading|reason|receipt|recess|record
regret|relation|religion|repairman|representative|request|respect|rest|reward|rhythm|rice|riddle|rifle|ring|rings|river|riverbanks|road|robin|rock|rod|roll|roof|room|root
rose|route|rub|rubberband|rule|run|sack|sail|sailboat|salesclerk|salt|sand|sandlot|sandstone|saucepan|scale|scapegoat|scarecrow|scarf|scene|scent|school|schoolbook|schoolboy
schoolbus|schoolhouse|science|scissors|screw|sea|seashore|seat|secretary|seed|selection|self|sense|servant|shade|shadyside|shake|shame|shape|sharecropper|sharpshooter|sheep
sheepskin|sheet|shelf|ship|shirt|shock|shoe|shoelace|shoemaker|shoes|shop|shortbread|show|showoff|showplace|side|sidekick|sidewalk|sign|silk|silver|silversmith|sink|sister
sisterhood|sisters|sixfold|size|skate|skateboard|skin|skintight|skirt|sky|skylark|skylight|slave|sleep|sleet|slip|slope|slowdown|slumlord|smash|smell|smile|smoke|snail|snails
snake|snakes|snakeskin|sneeze|snow|snowball|snowbank|snowbird|snowdrift|snowshovel|soap|society|sock|soda|sofa|softball|somebody|someday|somehow|someone|someplace|something
sometimes|somewhat|somewhere|son|song|songs|sort|sound|soundproof|soup|southeast|southwest|soybean|space|spacewalk|spade|spark|spearmint|spiders|spillway|spokesperson|sponge
spoon|spot|spring|spy|square|squirrel|stage|stagehand|stamp|standby|standoff|standout|standpoint|star|starfish|start|statement|station|steam|steamship|steel|stem|step|stepson
stew|stick|sticks|stitch|stocking|stockroom|stomach|stone|stop|stoplight|stopwatch|store|story|stove|stranger|straw|stream|street|stretch|string|stronghold|structure|substance
subway|sugar|suggestion|suit|summer|sun|sunbaked|sunbathe|sundial|sundown|sunfish|sunflower|sunglasses|sunlit|sunray|sunroof|sunup|supercargo|supercharge|supercool|superego
superfine|supergiant|superhero|superhighways|superhuman|superimpose|supermarket|supermen|supernatural|superpower|superscript|supersensitive|supersonic|superstar|superstrong
superstructure|supertanker|superweapon|superwoman|support|surprise|sweater|sweetheart|sweetmeat|swim|swing|system|table|tablecloth|tablespoon|tabletop|tableware|tail|tailcoat
tailgate|taillight|taillike|tailpiece|tailspin|takeoff|takeout|takeover|talebearer|taleteller|talk|tank|tapeworm|taproom|taproot|target|taskmaster|taste|tax|taxicab|taxpayer
teaching|teacup|team|teammate|teamwork|teapot|teaspoon|teenager|teeth|telltale|temper|tendency|tenderfoot|tenfold|tent|territory|test|textbook|texture|theory|therefore|thing
things|thought|thread|thrill|throat|throne|throwaway|throwback|thumb|thunder|thunderbird|thunderstorm|ticket|tiger|time|timekeeper|timesaving|timeshare|timetable|tin|title
toad|toe|toes|together|tomatoes|tongue|toolbox|tooth|toothbrush|toothpaste|toothpick|top|touch|touchdown|town|township|toy|toys|trade|trail|train|trains|tramp|transport|tray
treatment|tree|trees|trick|trip|trouble|trousers|truck|trucks|tub|turkey|turn|turnabout|turnaround|turnbuckle|turndown|turnkey|turnoff|turntable|twig|twist|typewriter|umbrella
uncle|underachieve|underage|underarm|underbelly|underbid|undercharge|underclothes|undercover|undercut|underdevelop|underestimate|underexpose|underfoot|underground|underwear
unit|upbeat|upbringing|upcoming|update|upend|upgrade|upheaval|uphill|uphold|upkeep|upland|uplift|upload|upmarket|upon|uppercase|upperclassman|uppercut|uproar|uproot|upset
upshot|upside|upstage|upstairs|upstanding|upstart|upstate|upstream|uptake|upthrust|uptight|uptime|uptown|upward|upwind|use|vacation|value|van|vase|vegetable|veil|vein|verse
vessel|vest|view|visitor|voice|volcano|volleyball|voyage|waistline|walk|walkways|wall|walleyed|wallpaper|war|wardroom|warfare|warmblooded|warpath|wash|washbowl|washcloth|washhouse
washout|washrag|washroom|washstand|washtub|waste|wastebasket|wasteland|wastepaper|wastewater|watch|watchband|watchdog|watchmaker|watchman|watchtower|watchword|water|watercolor
watercooler|watercraft|waterfall|waterfront|waterline|waterlog|watermelon|waterpower|waterproof|waterscape|watershed|waterside|waterspout|watertight|wave|wavelike|waves|wax
waxwork|way|waybill|wayfarer|waylaid|wayside|wayward|wealth|weather|weathercock|weatherman|weatherproof|week|weekday|weekend|weeknight|weight|whatever|whatsoever|wheel|wheelchair
wheelhouse|whip|whistle|whitecap|whitefish|whitewall|whitewash|widespread|wilderness|wind|window|wine|wing|winter|wipeout|wire|wish|without|woman|women|wood|woodshop|wool
word|work|worm|wound|wren|wrench|wrist|writer|writing|yak|yam|yard|yarn|year|yoke|zebra|zephyr|zinc|zipper|zoo
`.split("|");
const _numberWords = {
  ones: [
    "zero",
    "one",
    "two",
    "three",
    "four",
    "five",
    "six",
    "seven",
    "eight",
    "nine",
    "ten",
    "eleven",
    "twelve",
    "thirteen",
    "fourteen",
    "fifteen",
    "sixteen",
    "seventeen",
    "eighteen",
    "nineteen",
    "twenty"
  ],
  tens: ["", "", "twenty", "thirty", "forty", "fifty", "sixty", "seventy", "eighty", "ninety"],
  tiers: ["", "thousand", "million", "billion", "trillion", "quadrillion", "quintillion", "sextillion", "septillion", "octillion", "nonillion"],
  bigPrefixes: ["", "un", "duo", "tre", "quattuor", "quin", "sex", "octo", "novem"],
  bigSuffixes: ["", "decillion", "vigintillion", "trigintillion", "quadragintillion", "quinquagintillion", "sexagintillion", "septuagintillion", "octogintillion", "nonagintillion", "centillion"]
};
const _ordinals = {
  zero: "zeroeth",
  one: "first",
  two: "second",
  three: "third",
  four: "fourth",
  five: "fifth",
  eight: "eighth",
  nine: "ninth",
  twelve: "twelfth",
  twenty: "twentieth",
  thirty: "thirtieth",
  forty: "fortieth",
  fifty: "fiftieth",
  sixty: "sixtieth",
  seventy: "seventieth",
  eighty: "eightieth",
  ninety: "ninetieth"
};
const _romanNumerals = {
  grouped: [
    ["", "Ⅰ", "Ⅱ", "Ⅲ", "Ⅳ", "Ⅴ", "Ⅵ", "Ⅶ", "Ⅷ", "Ⅸ"],
    ["", "Ⅹ", "ⅩⅩ", "ⅩⅩⅩ", "ⅩⅬ", "Ⅼ", "ⅬⅩ", "ⅬⅩⅩ", "ⅬⅩⅩⅩ", "ⅩⅭ"],
    ["", "Ⅽ", "ⅭⅭ", "ⅭⅭⅭ", "ⅭⅮ", "Ⅾ", "ⅮⅭ", "ⅮⅭⅭ", "ⅮⅭⅭⅭ", "ⅭⅯ"],
    ["", "Ⅿ", "ⅯⅯ", "ⅯⅯⅯ", "Ⅿↁ", "ↁ", "ↁⅯ", "ↁⅯⅯ", "ↁⅯⅯⅯ", "ↁↂ"],
    ["", "ↂ", "ↂↂ", "ↂↂↂ", "ↂↇ", "ↇ", "ↇↂ", "ↇↂↂ", "ↇↂↂↂ", "ↇↈ"],
    ["", "ↈ", "ↈↈ", "ↈↈↈ"]
  ],
  ungrouped: [
    ["", "Ⅰ", "ⅠⅠ", "ⅠⅠⅠ", "ⅠⅤ", "Ⅴ", "ⅤⅠ", "ⅤⅠⅠ", "ⅤⅠⅠⅠ", "ⅠⅩ"],
    ["", "Ⅹ", "ⅩⅩ", "ⅩⅩⅩ", "ⅩⅬ", "Ⅼ", "ⅬⅩ", "ⅬⅩⅩ", "ⅬⅩⅩⅩ", "ⅩⅭ"],
    ["", "Ⅽ", "ⅭⅭ", "ⅭⅭⅭ", "ⅭⅮ", "Ⅾ", "ⅮⅭ", "ⅮⅭⅭ", "ⅮⅭⅭⅭ", "ⅭⅯ"],
    ["", "Ⅿ", "ⅯⅯ", "ⅯⅯⅯ", "Ⅿↁ", "ↁ", "ↁⅯ", "ↁⅯⅯ", "ↁⅯⅯⅯ", "ↁↂ"],
    ["", "ↂ", "ↂↂ", "ↂↂↂ", "ↂↇ", "ↇ", "ↇↂ", "ↇↂↂ", "ↇↂↂↂ", "ↇↈ"],
    ["", "ↈ", "ↈↈ", "ↈↈↈ"]
  ]
};
const UUIDLOG = [];
const GMID = () => {
  var _a, _b;
  return ((_b = (_a = game == null ? void 0 : game.user) == null ? void 0 : _a.find((user) => user.isGM)) == null ? void 0 : _b.id) ?? false;
};
const isNumber = (ref) => typeof ref === "number" && !isNaN(ref);
const isNumString = (ref) => typeof ref === "string" && !isNaN(parseFloat(ref)) && isFinite(parseFloat(ref));
const isBooleanString = (ref) => typeof ref === "string" && (ref === "true" || ref === "false");
const isArray = (ref) => Array.isArray(ref);
const isSimpleObj = (ref) => ref === Object(ref) && !isArray(ref);
const isList = (ref) => ref === Object(ref) && !isArray(ref);
const isFunc = (ref) => typeof ref === "function";
const isInt = (ref) => isNumber(ref) && Math.round(ref) === ref;
const isFloat = (ref) => isNumber(ref) && /\./.test(`${ref}`);
const isPosInt = (ref) => isInt(ref) && ref >= 0;
const isIndex = (ref) => isList(ref) || isArray(ref);
const isIterable = (ref) => typeof ref === "object" && ref !== null && Symbol.iterator in ref;
const isHTMLCode = (ref) => typeof ref === "string" && /^<.*>$/u.test(ref);
const isHexColor = (ref) => typeof ref === "string" && /^#(([0-9a-fA-F]{2}){3,4}|[0-9a-fA-F]{3,4})$/.test(ref);
const isRGBColor = (ref) => typeof ref === "string" && /^rgba?\((\d{1,3},\s*){1,2}?\d{1,3},\s*\d{1,3}(\.\d+)?\)$/.test(ref);
const isUndefined = (ref) => ref === void 0;
const isDefined = (ref) => !isUndefined(ref);
const isEmpty = (ref) => Object.keys(ref).length === 0;
const hasItems = (ref) => !isEmpty(ref);
const isInstance = (classRef, ref) => ref instanceof classRef;
const isNullish = (ref) => isUndefined(ref) || ref === null;
function assertNonNullType(val, type) {
  let valStr;
  try {
    valStr = JSON.stringify(val);
  } catch {
    valStr = String(val);
  }
  if (val === void 0) {
    throw new Error(`Value ${valStr} is undefined!`);
  }
  if (typeof type === "string") {
    if (typeof val !== type) {
      throw new Error(`Value ${valStr} is not a ${type}!`);
    }
  } else if (!(val instanceof type)) {
    throw new Error(`Value ${valStr} is not a ${type.name}!`);
  }
}
const areFuzzyEqual = (val1, val2) => {
  if ([null, void 0].includes(val1) && [null, void 0].includes(val2)) {
    return true;
  }
  if ([null, void 0].includes(val1) || [null, void 0].includes(val2)) {
    return false;
  }
  if (typeof val1 === "number" && typeof val2 === "number") {
    return val1 === val2;
  }
  if (typeof val1 === "boolean" && typeof val2 === "boolean") {
    return val1 === val2;
  }
  if (typeof val1 === "string" && typeof val2 === "string") {
    return val1 === val2;
  }
  if (typeof val1 === "number" && typeof val2 === "string") {
    return val1 === Number(val2);
  }
  if (typeof val1 === "string" && typeof val2 === "number") {
    return Number(val1) === val2;
  }
  if (typeof val1 === "boolean" && typeof val2 === "object") {
    return false;
  }
  if (typeof val1 === "object" && typeof val2 === "boolean") {
    return false;
  }
  if (typeof val1 === "boolean" && typeof val2 === "string") {
    return val1 && val2 !== "" || !val1 && val2 === "";
  }
  if (typeof val1 === "string" && typeof val2 === "boolean") {
    return val2 && val1 !== "" || !val2 && val1 === "";
  }
  if ((typeof val1 === "number" || typeof val1 === "string") && typeof val2 === "object") {
    return false;
  }
  if (typeof val1 === "object" && (typeof val2 === "number" || typeof val2 === "string")) {
    return false;
  }
  if (typeof val1 === "object" && typeof val2 === "object") {
    return val1 === val2;
  }
  return false;
};
const areEqual = (...refs) => {
  do {
    const ref = refs.pop();
    if (refs.length && !areFuzzyEqual(ref, refs[0])) {
      return false;
    }
  } while (refs.length);
  return true;
};
const pFloat = (ref, sigDigits, isStrict = false) => {
  if (typeof ref === "string") {
    ref = parseFloat(ref);
  }
  if (typeof ref === "number") {
    if (isNaN(ref)) {
      return isStrict ? NaN : 0;
    }
    if (isUndefined(sigDigits)) {
      return ref;
    }
    return Math.round(ref * 10 ** sigDigits) / 10 ** sigDigits;
  }
  return isStrict ? NaN : 0;
};
const pInt = (ref, isStrictOrIndex, _arr) => {
  let isStrict = false;
  if (typeof isStrictOrIndex === "boolean") {
    isStrict = isStrictOrIndex;
  }
  return isNaN(pFloat(ref, 0, isStrict)) ? NaN : Math.round(pFloat(ref, 0, isStrict));
};
const pBool = (ref) => {
  if (typeof ref === "boolean") {
    return ref;
  }
  if ([0, null, void 0, ""].includes(ref)) {
    return false;
  }
  if (typeof ref === "string") {
    return !["0", "false", "null", "undefined", ""].includes(ref);
  }
  if (isArray(ref) && ref.length === 0) {
    return false;
  }
  if (isList(ref) && isEmpty(ref)) {
    return false;
  }
  return true;
};
const radToDeg = (rad, isConstrained = true) => {
  rad = isConstrained ? rad % (2 * Math.PI) : rad;
  rad *= 180 / Math.PI;
  return rad;
};
const degToRad = (deg, isConstrained = true) => {
  deg = isConstrained ? deg % 360 : deg;
  deg *= Math.PI / 180;
  return deg;
};
const getKey = (key, obj) => {
  if (key in obj) {
    return obj[key];
  }
  return null;
};
const FILTERS = {
  IsInstance: (classRef) => (item) => typeof classRef === "function" && item instanceof classRef
};
const uCase = (str) => String(str).toUpperCase();
const lCase = (str) => String(str).toLowerCase();
const sCase = (str) => {
  let [first, ...rest] = `${str ?? ""}`.split(/\s+/);
  first = testRegExp(first, _capWords) ? first : `${uCase(first.charAt(0))}${lCase(first.slice(1))}`;
  if (hasItems(rest)) {
    rest = rest.map((word) => testRegExp(word, _capWords) ? word : lCase(word));
  }
  return [first, ...rest].join(" ").trim();
};
const tCase = (str) => String(str).split(/\s/).map((word, i) => i && testRegExp(word, _noCapWords) ? lCase(word) : sCase(word)).join(" ").trim();
const testRegExp = (str, patterns = [], flags = "gui", isTestingAll = false) => patterns.map((pattern) => pattern instanceof RegExp ? pattern : new RegExp(`\\b${pattern}\\b`, flags))[isTestingAll ? "every" : "some"]((pattern) => pattern.test(`${str}`));
const regExtract = (ref, pattern, flags) => {
  const splitFlags = [];
  [...(flags ?? "").replace(/g/g, ""), "u"].forEach((flag) => {
    if (flag && !splitFlags.includes(flag)) {
      splitFlags.push(flag);
    }
  });
  const isGrouping = /[)(]/.test(pattern.toString().replace(/\\\)|\\\(/g, ""));
  if (isGrouping) {
    splitFlags.push("g");
  }
  flags = splitFlags.join("");
  pattern = new RegExp(pattern, flags);
  const matches = `${ref}`.match(pattern) || [];
  return isGrouping ? Array.from(matches) : matches.pop();
};
const unhyphenate = (str) => `${str}`.replace(/[\u00AD\u200B]/gu, "");
const parseArticles = (str) => `${str}`.replace(/\b([aA])\s([aeiouAEIOU])/gu, "$1n $2");
const pluralize = (singular, num = 2, plural) => {
  if (pFloat(num) === 1) {
    return singular;
  }
  return plural ?? `${singular.replace(/y$/, "ie").replace(/s$/, "se")}s`;
};
const oxfordize = (items, useOxfordComma = true, andString = "and") => {
  if (items.length === 0) {
    return "";
  }
  if (items.length === 1) {
    return `${items[0]}`;
  }
  const lastItem = items.pop();
  return [
    items.join(", "),
    useOxfordComma ? "," : "",
    ` ${andString} `,
    lastItem
  ].join("");
};
const ellipsize = (text, maxLength) => {
  const str = String(text);
  return str.length > maxLength ? `${str.slice(0, maxLength - 3)}…` : str;
};
const pad = (text, minLength, delim = " ") => {
  const str = `${text}`;
  if (str.length < minLength) {
    return `${delim.repeat(minLength - str.length)}${str}`;
  }
  return str;
};
const toKey = (text) => (text ?? "").toLowerCase().replace(/ /g, "-").replace(/default/, "DEFAULT");
const signNum = (num, delim = "", zeroSign = "+") => {
  let sign;
  const parsedNum = pFloat(num);
  if (parsedNum < 0) {
    sign = "-";
  } else if (parsedNum === 0) {
    sign = zeroSign;
  } else {
    sign = "+";
  }
  return `${sign}${delim}${Math.abs(parsedNum)}`;
};
const padNum = (num, numDecDigits, includePlus = false) => {
  const prefix = includePlus && num >= 0 ? "+" : "";
  const [leftDigits, rightDigits] = `${pFloat(num)}`.split(/\./);
  if (getType(rightDigits) === "int") {
    if (rightDigits.length > numDecDigits) {
      return `${prefix}${pFloat(num, numDecDigits)}`;
    } else if (rightDigits.length < numDecDigits) {
      return `${prefix}${leftDigits}.${rightDigits}${"0".repeat(numDecDigits - rightDigits.length)}`;
    } else {
      return `${prefix}${pFloat(num)}`;
    }
  }
  return `${prefix}${leftDigits}.${"0".repeat(numDecDigits)}`;
};
const stringifyNum = (num) => {
  var _a;
  if (pFloat(num) === 0) {
    return "0";
  }
  const stringyNum = lCase(num).replace(/[^\d.e+-]/g, "");
  const base = regExtract(stringyNum, /^-?[\d.]+/);
  const exp = pInt(regExtract(stringyNum, /e([+-]?\d+)$/));
  if (typeof base === "string" && typeof exp === "string") {
    let baseInts = regExtract(base, /^-?(\d+)/);
    let baseDecs = regExtract(base, /\.(\d+)/);
    if (isArray(baseInts) && isArray(baseDecs)) {
      baseInts = (_a = baseInts.pop()) == null ? void 0 : _a.replace(/^0+/, "");
      baseDecs = lCase(baseDecs == null ? void 0 : baseDecs.pop()).replace(/0+$/, "");
      if (!isUndefined(baseInts) && !isUndefined(baseDecs)) {
        const numFinalInts = Math.max(0, baseInts.length + exp);
        const numFinalDecs = Math.max(0, baseDecs.length - exp);
        const finalInts = [
          baseInts.slice(0, numFinalInts),
          baseDecs.slice(0, Math.max(0, exp))
        ].join("") || "0";
        const finalDecs = [
          baseInts.length - numFinalInts > 0 ? baseInts.slice(baseInts.length - numFinalInts - 1) : "",
          baseDecs.slice(baseDecs.length - numFinalDecs)
        ].join("");
        return [
          stringyNum.charAt(0) === "-" ? "-" : "",
          finalInts,
          "0".repeat(Math.max(0, numFinalInts - finalInts.length)),
          finalDecs.length ? "." : "",
          "0".repeat(Math.max(0, numFinalDecs - finalDecs.length)),
          finalDecs
        ].join("");
      }
    }
  }
  return `${num}`;
};
const verbalizeNum = (num) => {
  var _a;
  num = stringifyNum(num);
  const getTier = (trioNum) => {
    if (trioNum < _numberWords.tiers.length) {
      return _numberWords.tiers[trioNum];
    }
    return [
      _numberWords.bigPrefixes[trioNum % 10 - 1],
      _numberWords.bigSuffixes[Math.floor(trioNum / 10)]
    ].join("");
  };
  const parseThreeDigits = (trio) => {
    if (pInt(trio) === 0) {
      return "";
    }
    const digits = `${trio}`.split("").map((digit) => pInt(digit));
    let result = "";
    if (digits.length === 3) {
      const hundreds = digits.shift();
      if (isUndefined(hundreds)) {
        throw new Error(`[U.verbalizeNum] Undefined digit in trio '${digits.join("")}'.`);
      }
      result += hundreds > 0 ? `${_numberWords.ones[hundreds]} hundred` : "";
      if (hundreds && (digits[0] || digits[1])) {
        result += " and ";
      }
    }
    if (pInt(digits.join("")) <= _numberWords.ones.length) {
      result += _numberWords.ones[pInt(digits.join(""))];
    } else {
      const tens = _numberWords.tens[pInt(digits.shift())];
      const ones = pInt(digits[0]) > 0 ? `-${_numberWords.ones[pInt(digits[0])]}` : "";
      result += `${tens}${ones}`;
    }
    return result;
  };
  const numWords = [];
  if (num.charAt(0) === "-") {
    numWords.push("negative");
  }
  const [integers, decimals] = num.replace(/[,\s-]/g, "").split(".");
  const intArray = ((_a = [...integers.split("")].reverse().join("").match(/.{1,3}/g)) == null ? void 0 : _a.map((v) => [...v.split("")].reverse().join(""))) ?? [];
  const intStrings = [];
  while (intArray.length) {
    const thisTrio = intArray.pop();
    if (thisTrio) {
      const theseWords = parseThreeDigits(thisTrio);
      if (theseWords) {
        intStrings.push(`${theseWords} ${getTier(intArray.length)}`);
      }
    }
  }
  numWords.push(intStrings.join(", ").trim());
  if (getType(decimals) === "int") {
    if (integers === "0") {
      numWords.push("zero");
    }
    numWords.push("point");
    for (const digit of decimals.split("")) {
      numWords.push(_numberWords.ones[pInt(digit)]);
    }
  }
  return numWords.join(" ");
};
const ordinalizeNum = (num, isReturningWords = false) => {
  if (isReturningWords) {
    const [numText, suffix] = lCase(verbalizeNum(num)).match(/.*?[-\s]?(\w*)$/i) ?? ["", ""];
    return numText.replace(
      new RegExp(`${suffix}$`),
      suffix in _ordinals ? _ordinals[suffix] : `${suffix}th`
    );
  }
  if (/(\.)|(1[1-3]$)/.test(`${num}`)) {
    return `${num}th`;
  }
  return `${num}${["th", "st", "nd", "rd", "th", "th", "th", "th", "th", "th"][pInt(`${num}`.charAt(`${num}`.length - 1))]}`;
};
const romanizeNum = (num, isUsingGroupedChars = true) => {
  if (isFloat(num)) {
    throw new Error(`Error: Can't Romanize Floats (${num})`);
  }
  if (num >= 4e5) {
    throw new Error(`Error: Can't Romanize >= 400,000 (${num})`);
  }
  if (num < 0) {
    throw new Error(`Error: Can't Romanize Negative Numbers (${num})`);
  }
  if (num === 0) {
    return "0";
  }
  const romanRef = _romanNumerals[isUsingGroupedChars ? "grouped" : "ungrouped"];
  const romanNum = [...stringifyNum(num).split("")].reverse().map((digit, i) => romanRef[i][pInt(digit)]).reverse().join("");
  return isUsingGroupedChars ? romanNum.replace(/ⅩⅠ/gu, "Ⅺ").replace(/ⅩⅡ/gu, "Ⅻ") : romanNum;
};
const loremIpsum = (numWords = 200) => {
  const lrWordList = _loremIpsumText.split(/\n?\s+/g);
  const words = [...lrWordList[randNum(0, lrWordList.length - 1)]];
  while (words.length < numWords) {
    words.push(...lrWordList);
  }
  words.length = numWords;
  return `${sCase(words.join(" ")).trim().replace(/[^a-z\s]*$/ui, "")}.`;
};
const randString = (length = 5) => Array.from({ length }).map(() => String.fromCharCode(randInt(...["a", "z"].map((char) => char.charCodeAt(0))))).join("");
const randWord = (numWords = 1, wordList = _randomWords) => Array.from({ length: numWords }).map(() => randElem([...wordList])).join(" ");
const getUID$1 = (id) => {
  const indexNum = Math.max(
    0,
    ...UUIDLOG.filter(([genericID]) => genericID.startsWith(id)).map(([, , num]) => num)
  ) + 1;
  const uuid = indexNum === 1 ? id : `${id}_${indexNum}`;
  UUIDLOG.push([id, uuid, indexNum]);
  eLog.log(`UUIDify(${id}) --> [${uuid}, ${indexNum}]`);
  Object.assign(globalThis, { UUIDLOG });
  return uuid;
};
const fuzzyMatch = (val1, val2) => {
  const [str1, str2] = [val1, val2].map((val) => lCase(String(val).replace(/[^a-zA-Z0-9.+-]/g, "").trim()));
  return str1.length > 0 && str1 === str2;
};
const isIn = (needle, haystack = [], fuzziness = 0) => {
  const SearchTests = [
    (ndl, item) => new RegExp(`^${ndl}$`, "gu").test(`${item}`),
    (ndl, item) => new RegExp(`^${ndl}$`, "gui").test(`${item}`)
  ];
  if (fuzziness >= 1) {
    const fuzzyTests = [
      (ndl, item) => new RegExp(`^${ndl}`, "gui").test(`${item}`),
      (ndl, item) => new RegExp(`${ndl}$`, "gui").test(`${item}`),
      (ndl, item) => new RegExp(`${ndl}`, "gui").test(`${item}`),
      (ndl, item) => new RegExp(`${item}`, "gui").test(`${ndl}`)
    ];
    SearchTests.push(...fuzzyTests);
    if (fuzziness >= 2) {
      SearchTests.push(...fuzzyTests.map((func) => (ndl, item) => func(`${ndl}`.replace(/\W/g, ""), `${item}`.replace(/\W/gu, ""))));
      if (fuzziness >= 3) {
        SearchTests.push(() => false);
      }
    }
  }
  const searchNeedle = `${needle}`;
  const searchStack = (() => {
    if (isArray(haystack)) {
      return [...haystack];
    }
    if (isList(haystack)) {
      return Object.keys(haystack);
    }
    try {
      return Array.from(haystack);
    } catch {
      throw new Error(`Haystack type must be [list, array], not ${typeof haystack}: ${JSON.stringify(haystack)}`);
    }
  })();
  if (!isArray(searchStack)) {
    return false;
  }
  let matchIndex = -1;
  while (!isPosInt(matchIndex)) {
    const testFunc = SearchTests.shift();
    if (!testFunc) {
      return false;
    }
    matchIndex = searchStack.findIndex((item) => testFunc(searchNeedle, `${item}`));
  }
  if (isPosInt(matchIndex)) {
    return isList(haystack) ? Object.values(haystack)[matchIndex] : haystack[matchIndex];
  }
  return false;
};
const isInExact = (needle, haystack) => isIn(needle, haystack, 0);
const randNum = (min, max, snap = 0) => gsap.utils.random(min, max, snap);
const randInt = (min, max) => randNum(min, max, 1);
const coinFlip = () => randNum(0, 1, 1) === 1;
const cycleNum = (num, [min = 0, max = Infinity] = []) => gsap.utils.wrap(min, max, num);
const clampNum = (num, [min = 0, max = Infinity] = []) => gsap.utils.clamp(min, max, num);
const cycleAngle = (angle, range = [0, 360]) => cycleNum(angle, range);
const roundNum = (num, sigDigits = 0) => sigDigits === 0 ? pInt(num) : pFloat(num, sigDigits);
const sum = (...nums) => Object.values(nums.flat()).reduce((num, tot) => tot + num, 0);
const average = (...nums) => sum(...nums) / nums.flat().length;
const getDistance = ({ x: x1, y: y1 }, { x: x2, y: y2 }) => ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5;
const getAngle = ({ x: x1, y: y1 }, { x: x2, y: y2 }, { x: xO, y: yO } = { x: 0, y: 0 }, range = [0, 360]) => {
  x1 -= xO;
  y1 -= yO;
  x2 -= xO;
  y2 -= yO;
  return cycleAngle(radToDeg(Math.atan2(y2 - y1, x2 - x1)), range);
};
const getAngleDelta = (angleStart, angleEnd, range = [0, 360]) => cycleAngle(angleEnd - angleStart, range);
const getBoundingRectangle = (arrayOfShapes) => {
  let minX = Infinity;
  let minY = Infinity;
  let maxX = -Infinity;
  let maxY = -Infinity;
  for (const shape of arrayOfShapes) {
    let shapeMinX;
    let shapeMinY;
    let shapeMaxX;
    let shapeMaxY;
    if (shape.radius !== void 0) {
      shapeMinX = shape.x - shape.radius;
      shapeMinY = shape.y - shape.radius;
      shapeMaxX = shape.x + shape.radius;
      shapeMaxY = shape.y + shape.radius;
    } else if (shape.size !== void 0) {
      shapeMinX = (shape.x - shape.size) / 2;
      shapeMinY = (shape.y - shape.size) / 2;
      shapeMaxX = (shape.x + shape.size) / 2;
      shapeMaxY = (shape.y + shape.size) / 2;
    } else if (shape.width !== void 0 || shape.height !== void 0) {
      shape.width ?? (shape.width = shape.height);
      shape.height ?? (shape.height = shape.width);
      shapeMinX = (shape.x - shape.width) / 2;
      shapeMinY = (shape.y - shape.height) / 2;
      shapeMaxX = (shape.x + shape.width) / 2;
      shapeMaxY = (shape.y + shape.height) / 2;
    } else {
      throw new Error(`[getBoundingRectangle] Error: shape must be a circle, square, or rectangle, not ${JSON.stringify(shape)}`);
    }
    minX = Math.min(minX, shapeMinX);
    minY = Math.min(minY, shapeMinY);
    maxX = Math.max(maxX, shapeMaxX);
    maxY = Math.max(maxY, shapeMaxY);
  }
  const width = maxX - minX;
  const height = maxY - minY;
  const x = (minX + width) / 2;
  const y = (minY + height) / 2;
  return { x, y, width, height };
};
const randElem = (array) => gsap.utils.random(array);
const randIndex = (array) => randInt(0, array.length - 1);
const makeIntRange = (min, max) => {
  const intRange = [];
  for (let i = min; i <= max; i++) {
    intRange.push(i);
  }
  return intRange;
};
const makeCycler = (array, index = 0) => {
  const wrapper = gsap.utils.wrap(array);
  index--;
  return function* () {
    while (true) {
      index++;
      yield wrapper(index);
    }
  }();
};
function getLast(array) {
  array = Object.values(array);
  if (array.length === 0) {
    throw new Error("Cannot get last element of an empty array.");
  }
  return array[array.length - 1];
}
const unique = (array) => {
  const returnArray = [];
  array.forEach((item) => {
    if (!returnArray.includes(item)) {
      returnArray.push(item);
    }
  });
  return returnArray;
};
const group = (array, key) => {
  const returnObj = {};
  array.forEach((item) => {
    const returnKey = item[key];
    let returnVal = returnObj[returnKey];
    if (!returnVal) {
      returnVal = [];
      returnObj[returnKey] = returnVal;
    }
    returnVal.push(item);
  });
  return returnObj;
};
const sample = (array, numElems = 1, isUniqueOnly = true, uniqueTestFunc = (e, a) => !a.includes(e)) => {
  const elems = [];
  let overloadCounter = 0;
  while (elems.length < numElems && overloadCounter < 1e6) {
    const randomElem = randElem(array);
    if (isUniqueOnly && uniqueTestFunc(randomElem, elems)) {
      elems.push(randomElem);
    }
    overloadCounter++;
  }
  return elems;
};
const removeFirst = (array, element) => array.splice(array.findIndex((v) => v === element));
function pullElement(array, checkFunc) {
  let testFunction;
  if (typeof checkFunc !== "function") {
    testFunction = (_v) => _v === checkFunc;
  } else {
    testFunction = checkFunc;
  }
  const index = array.findIndex((v, i, a) => testFunction(v, i, a));
  if (index === -1) {
    return void 0;
  }
  return array.splice(index, 1).pop();
}
const pullIndex = (array, index) => pullElement(array, (_, i) => i === index);
const subGroup = (array, groupSize) => {
  const subArrays = [];
  while (array.length > groupSize) {
    const subArray = [];
    while (subArray.length < groupSize) {
      subArray.push(array.shift());
    }
    subArrays.push(subArray);
  }
  subArrays.push(array);
  return subArrays;
};
const shuffle = (array) => {
  let currentIndex = array.length;
  let randomIndex;
  while (currentIndex !== 0) {
    randomIndex = Math.floor(Math.random() * currentIndex);
    currentIndex--;
    [array[currentIndex], array[randomIndex]] = [
      array[randomIndex],
      array[currentIndex]
    ];
  }
  return array;
};
const toArray = (target) => {
  return gsap.utils.toArray(target);
};
const checkVal = ({ k, v }, checkTest) => {
  if (typeof checkTest === "function") {
    if (isDefined(v)) {
      return checkTest(v, k);
    }
    return checkTest(k);
  }
  if (typeof checkTest === "number") {
    checkTest = `${checkTest}`;
  }
  return new RegExp(checkTest).test(`${v}`);
};
const remove = (obj, checkTest) => {
  if (isArray(obj)) {
    const index = obj.findIndex((v) => checkVal({ v }, checkTest));
    if (index >= 0) {
      return removeElementFromArray(obj, index);
    }
  } else if (isList(obj)) {
    const [remKey] = Object.entries(obj).find(([k, v]) => checkVal({ k, v }, checkTest)) ?? [];
    if (remKey) {
      return removeElementFromList(obj, remKey);
    }
  }
  return false;
};
const removeElementFromArray = (array, index) => {
  let remVal;
  for (let i = 0; i <= array.length; i++) {
    if (i === index) {
      remVal = array.shift();
    } else {
      array.push(array.shift());
    }
  }
  return remVal;
};
const removeElementFromList = (list, key) => {
  const remVal = list[key];
  delete list[key];
  return remVal;
};
const replace = (obj, checkTest, repVal) => {
  let repKey;
  if (isList(obj)) {
    [repKey] = Object.entries(obj).find((v) => checkVal({ v }, checkTest)) || [false];
    if (repKey === false) {
      return false;
    }
  } else if (isArray(obj)) {
    repKey = obj.findIndex((v) => checkVal({ v }, checkTest));
    if (repKey === -1) {
      return false;
    }
  }
  if (typeof repKey !== "number") {
    repKey = `${repKey}`;
  }
  if (typeof repVal === "function") {
    obj[repKey] = repVal(obj[repKey], repKey);
  } else {
    obj[repKey] = repVal;
  }
  return true;
};
const objClean = (data, remVals = [void 0, null, "", {}, []]) => {
  const remStrings = remVals.map((rVal) => JSON.stringify(rVal));
  if (remStrings.includes(JSON.stringify(data)) || remVals.includes(data)) {
    return "KILL";
  }
  if (Array.isArray(data)) {
    const newData = data.map((elem) => objClean(elem, remVals)).filter((elem) => elem !== "KILL");
    return Array.isArray(newData) && newData.length ? newData : "KILL";
  }
  if (data && typeof data === "object" && JSON.stringify(data).startsWith("{")) {
    const newData = Object.entries(data).map(([key, val]) => [key, objClean(val, remVals)]).filter(([, val]) => val !== "KILL");
    return newData.length ? Object.fromEntries(newData) : "KILL";
  }
  return data;
};
const partition = (obj, predicate = () => true) => [
  objFilter(obj, predicate),
  objFilter(obj, (v, k) => !predicate(v, k))
];
const zip = (keys, values) => {
  if (keys.length !== values.length) {
    throw new Error("The arrays must be of equal length.");
  }
  if (new Set(keys).size !== keys.length) {
    throw new Error("The keys must be unique.");
  }
  const result = {};
  keys.forEach((key, i) => {
    result[key] = values[i];
  });
  return result;
};
function objMap(obj, keyFunc, valFunc) {
  let valFuncTyped = valFunc;
  let keyFuncTyped = keyFunc;
  if (!valFuncTyped) {
    valFuncTyped = keyFunc;
    keyFuncTyped = false;
  }
  if (!keyFuncTyped) {
    keyFuncTyped = (k) => k;
  }
  if (Array.isArray(obj)) {
    return obj.map(valFuncTyped);
  }
  return Object.fromEntries(Object.entries(obj).map(([key, val]) => {
    assertNonNullType(valFuncTyped, "function");
    return [keyFuncTyped(key, val), valFuncTyped(val, key)];
  }));
}
const objSize = (obj) => {
  if (isSimpleObj(obj)) {
    return Object.keys(obj).length;
  }
  if (isArray(obj)) {
    return obj.length;
  }
  if (obj === false || obj === null || obj === void 0) {
    return 0;
  }
  return 1;
};
function objFindKey(obj, keyFunc, valFunc) {
  if (!valFunc) {
    valFunc = keyFunc;
    keyFunc = false;
  }
  if (!keyFunc) {
    keyFunc = (k) => k;
  }
  if (isArray(obj)) {
    return obj.findIndex(valFunc);
  }
  const kFunc = keyFunc || (() => true);
  const vFunc = valFunc || (() => true);
  const validEntry = Object.entries(obj).find(([k, v]) => kFunc(k, v) && vFunc(v, k));
  if (validEntry) {
    return validEntry[0];
  }
  return false;
}
const objFilter = (obj, keyFunc, valFunc, isMutating = false) => {
  if (!valFunc) {
    valFunc = keyFunc;
    keyFunc = false;
  }
  if (!keyFunc) {
    keyFunc = (k) => k;
  }
  if (isArray(obj)) {
    const keptValues = obj.filter(valFunc);
    if (isMutating) {
      obj.splice(0, obj.length, ...keptValues);
      return obj;
    }
    return keptValues;
  }
  const kFunc = keyFunc || (() => true);
  const vFunc = valFunc || (() => true);
  if (isMutating) {
    const entriesToRemove = Object.entries(obj).filter(([key, val]) => !(kFunc(key, val) && vFunc(val, key)));
    for (const [key] of entriesToRemove) {
      delete obj[key];
    }
    return obj;
  }
  return Object.fromEntries(
    Object.entries(obj).filter(([key, val]) => kFunc(key, val) && vFunc(val, key))
  );
};
const objForEach = (obj, func) => {
  if (isArray(obj)) {
    obj.forEach(func);
  } else {
    Object.entries(obj).forEach(([key, val]) => func(val, key));
  }
};
const objCompact = (obj, removeWhiteList = [void 0, null], isMutating = false) => objFilter(obj, (val) => !removeWhiteList.includes(val), void 0, isMutating);
const objClone = (obj, isStrictlySafe = false) => {
  const cloneArray = (arr) => [...arr];
  const cloneObject = (o) => ({ ...o });
  try {
    return JSON.parse(JSON.stringify(obj));
  } catch (err) {
    if (isStrictlySafe) {
      throw err;
    }
    if (Array.isArray(obj)) {
      return cloneArray(obj);
    }
    if (typeof obj === "object") {
      return cloneObject(obj);
    }
  }
  return obj;
};
function objMerge(target, source, {
  isMutatingOk = false,
  isStrictlySafe = false,
  isConcatenatingArrays = true,
  isReplacingArrays = false
} = {}) {
  target = isMutatingOk ? target : objClone(target, isStrictlySafe);
  if (source && typeof source === "object" && "id" in source && isDocID(source.id) || isUndefined(target)) {
    return source;
  }
  if (isUndefined(source)) {
    return target;
  }
  if (!isIndex(source)) {
    return target;
  }
  for (const [key, val] of Object.entries(source)) {
    const targetVal = target[key];
    if (isReplacingArrays && isArray(targetVal) && isArray(val)) {
      target[key] = val;
    } else if (isConcatenatingArrays && isArray(targetVal) && isArray(val)) {
      target[key].push(...val);
    } else if (val !== null && typeof val === "object") {
      if (isUndefined(targetVal) && !(val instanceof Application)) {
        target[key] = new (Object.getPrototypeOf(val)).constructor();
      }
      target[key] = objMerge(
        target[key],
        val,
        { isMutatingOk: true, isStrictlySafe }
      );
    } else {
      target[key] = val;
    }
  }
  return target;
}
function objDiff(obj1, obj2) {
  const diff = {};
  const bothObj1AndObj2Keys = Object.keys(obj2).filter((key) => Object.hasOwn(obj2, key) && Object.hasOwn(obj1, key));
  const onlyObj2Keys = Object.keys(obj2).filter((key) => Object.hasOwn(obj2, key) && !Object.hasOwn(obj1, key));
  for (const key of bothObj1AndObj2Keys) {
    if (typeof obj1[key] === "object" && typeof obj2[key] === "object" && !Array.isArray(obj1[key]) && !Array.isArray(obj2[key])) {
      const nestedDiff = objDiff(obj1[key], obj2[key]);
      if (Object.keys(nestedDiff).length > 0) {
        diff[key] = nestedDiff;
      }
    } else if (Array.isArray(obj1[key]) && Array.isArray(obj2[key])) {
      const array1 = obj1[key];
      const array2 = obj2[key];
      if (array1.toString() !== array2.toString()) {
        diff[key] = obj2[key];
      }
    } else if (obj1[key] !== obj2[key]) {
      diff[key] = obj2[key];
    }
  }
  for (const key of onlyObj2Keys) {
    diff[`-=${key}`] = obj2[key];
  }
  return diff;
}
const objExpand = (obj) => {
  const expObj = {};
  for (const [key, val] of Object.entries(obj)) {
    if (isList(val)) {
      const expandedVal = objExpand(val);
      setProperty(expObj, key, expandedVal);
    } else {
      setProperty(expObj, key, val);
    }
  }
  function arrayify(o) {
    if (isList(o)) {
      if (/^\d+$/.test(Object.keys(o).join(""))) {
        return Object.values(o).map(arrayify);
      }
      return objMap(o, (v) => arrayify(v));
    }
    if (isArray(o)) {
      return o.map(arrayify);
    }
    return o;
  }
  return arrayify(expObj);
};
const objFlatten = (obj) => {
  const flatObj = {};
  for (const [key, val] of Object.entries(obj)) {
    if ((isArray(val) || isList(val)) && hasItems(val)) {
      for (const [subKey, subVal] of Object.entries(objFlatten(val))) {
        flatObj[`${key}.${subKey}`] = subVal;
      }
    } else {
      flatObj[key] = val;
    }
  }
  return flatObj;
};
function objNullify(obj) {
  if (!isIndex(obj)) {
    return obj;
  }
  if (Array.isArray(obj)) {
    obj.forEach((_, i) => {
      obj[i] = null;
    });
    return obj;
  }
  Object.keys(obj).forEach((objKey) => {
    obj[objKey] = null;
  });
  return obj;
}
function objFreezeProps(data, ...keysOrSchema) {
  const firstArg = keysOrSchema[0];
  if (firstArg instanceof Object && !Array.isArray(firstArg)) {
    const schema = firstArg;
    for (const key in schema) {
      if (data[key] === void 0) {
        throw new Error(`Missing value for ${key}`);
      }
    }
  } else {
    for (const key of keysOrSchema) {
      if (data[key] === void 0) {
        throw new Error(`Missing value for ${String(key)}`);
      }
    }
  }
  return data;
}
const getDynamicFunc = (funcName, func, context) => {
  if (typeof func === "function") {
    const dFunc = { [funcName](...args) {
      return func(...args);
    } }[funcName];
    return context ? dFunc.bind(context) : dFunc;
  }
  return false;
};
const withLog = (fn) => {
  return (...args) => {
    console.log(`calling ${fn.name}`);
    return fn(...args);
  };
};
const changeContainer = (elem, container, isCloning = false) => {
  elem = $(elem)[0];
  container = $(container)[0];
  const curContainer = $(elem).parent()[0];
  const curPosition = {
    x: gsap.getProperty(elem, "x"),
    y: gsap.getProperty(elem, "y")
  };
  const relPos = MotionPathPlugin.convertCoordinates(
    curContainer,
    container,
    curPosition
  );
  eLog.checkLog3("changeContainer", "Target Element", { elem, container, curContainer, curPosition, relPos });
  if (isCloning) {
    elem = $(elem).clone()[0];
  }
  $(elem).appendTo($(container));
  gsap.set(elem, relPos);
  return elem;
};
const adjustTextContainerAspectRatio = (textContainer, targetRatio, maxHeight, maxWidth, minFontSize = 8) => {
  textContainer = $(textContainer)[0];
  if (!maxWidth) {
    textContainer.style.setProperty("width", "max-content", "important");
  } else {
    textContainer.style.setProperty("width", `${maxWidth}px`, "important");
  }
  function recurAdjustment() {
    textContainer = $(textContainer)[0];
    const newFontSize = parseFloat(style.fontSize) * 0.8;
    const newLineHeight = parseFloat(style.lineHeight) * 0.8;
    if (newFontSize < minFontSize) {
      return false;
    }
    textContainer.style.fontSize = `${newFontSize}px`;
    textContainer.style.lineHeight = `${newLineHeight}px`;
    return adjustTextContainerAspectRatio(textContainer, targetRatio, lineCount ?? maxHeight, maxWidth, minFontSize);
  }
  const style = window.getComputedStyle(textContainer);
  const lineHeight = parseFloat(style.lineHeight);
  let lineCount = void 0;
  if (isInt(maxHeight) && maxHeight < lineHeight) {
    lineCount = maxHeight;
  }
  const initialWidth = parseFloat(style.width);
  let bestWidth = initialWidth;
  let isAtMaxLineCount = false;
  for (let lines = 1; ; lines++) {
    const expectedHeight = lineHeight * lines;
    const expectedWidth = initialWidth / lines;
    const expectedRatio = expectedWidth / expectedHeight;
    if (expectedRatio < targetRatio) {
      break;
    }
    if (isInt(lineCount)) {
      if (lines > lineCount) {
        if (recurAdjustment()) {
          return;
        }
        break;
      }
    } else if (maxHeight && expectedHeight > maxHeight) {
      if (recurAdjustment()) {
        return;
      }
      break;
    }
    bestWidth = expectedWidth;
    if (isInt(lineCount) && lines === lineCount) {
      isAtMaxLineCount = true;
      break;
    }
  }
  if (!isAtMaxLineCount && maxWidth && bestWidth > maxWidth) {
    if (recurAdjustment()) {
      return;
    }
  }
  textContainer.style.setProperty("width", `${bestWidth}px`, "important");
};
const getSvgCode = (svgDotKey, svgPathKeys) => {
  const svgData = getProperty(SVGDATA, svgDotKey);
  if (!svgData) {
    return "";
  }
  const { viewBox, paths, classes } = svgData;
  svgPathKeys ?? (svgPathKeys = Object.keys(paths).join("|"));
  if (typeof svgPathKeys === "string") {
    svgPathKeys = svgPathKeys.split("|");
  }
  return [
    `<svg viewBox="${viewBox}">`,
    ...svgPathKeys.map((path) => `<path class="${path} ${(classes == null ? void 0 : classes[path]) ?? ""}" d="${paths[path] ?? ""}" />`),
    "</svg>"
  ].join("\n");
};
const getRawCirclePath = (r, { x: xO, y: yO } = { x: 0, y: 0 }) => {
  [r, xO, yO] = [r, xO, yO].map((val) => roundNum(val, 2));
  const [b1, b2] = [0.4475 * r, (1 - 0.4475) * r];
  const [xT, yT] = [xO, yO - r];
  return [[
    ...[xT, yT],
    ...[b2, 0, r, b1, r, r],
    ...[0, b2, -b1, r, -r, r],
    ...[-b2, 0, -r, -b1, -r, -r],
    ...[0, -b2, b1, -r, r, -r]
  ]];
};
const drawCirclePath = (radius, origin) => {
  const [[xT, yT, ...segments]] = getRawCirclePath(radius, origin);
  const path = [`m ${xT} ${yT}`];
  segments.forEach((coord, i) => {
    if (i % 6 === 0) {
      path.push("c");
    }
    path.push(coord);
  });
  path.push("z");
  return path.join(" ");
};
const getColorVals = (red, green, blue, alpha) => {
  var _a;
  if (isRGBColor(red)) {
    [red, green, blue, alpha] = red.replace(/[^\d.,]/g, "").split(/,/).map((color) => isUndefined(color) ? void 0 : parseFloat(color));
  }
  if (isHexColor(red)) {
    if ([4, 5].includes(red.length)) {
      red = red.replace(/([^#])/g, "$1$1");
    }
    [red, green, blue, alpha] = ((_a = red.match(/[^#]{2}/g)) == null ? void 0 : _a.map((val) => parseInt(val, 16))) ?? [];
  }
  if ([red, green, blue].every((color) => /^\d+$/.test(`${color}`))) {
    return [red, green, blue, alpha].filter((color) => /^[\d.]+$/.test(`${color}`));
  }
  return null;
};
const getRGBString = (red, green, blue, alpha) => {
  if (isRGBColor(red) || isHexColor(red)) {
    [red, green, blue, alpha] = getColorVals(red) ?? [];
  }
  if ([red, green, blue].every((color) => /^[.\d]+$/.test(`${color}`))) {
    let colorString = "rgb";
    const colors = [red, green, blue];
    if (/^[.\d]+$/.test(`${alpha}`)) {
      colors.push(alpha >= 1 ? pInt(alpha) : pFloat(alpha, 2));
      colorString += "a";
    }
    return `${colorString}(${colors.join(", ")})`;
  }
  return null;
};
const getHEXString = (red, green, blue) => {
  function componentToHex(c) {
    const hex = c.toString(16);
    return hex.length === 1 ? `0${hex}` : hex;
  }
  if (isHexColor(red)) {
    return red;
  }
  if (isRGBColor(red)) {
    [red, green, blue] = getColorVals(red) ?? [];
  }
  if (isDefined(red) && isDefined(green) && isDefined(blue) && [red, green, blue].every((color) => /^[.\d]+$/.test(`${color}`))) {
    return `#${componentToHex(red ?? 0)}${componentToHex(green ?? 0)}${componentToHex(blue ?? 0)}`;
  }
  return null;
};
const getContrastingColor = (...colorVals) => {
  const [red, green, blue] = getColorVals(...colorVals) ?? [];
  if ([red, green, blue].every(isNumber)) {
    const YIQ = (red * 299 + green * 587 + blue * 114) / 1e3;
    return YIQ >= 128 ? "rgba(0, 0, 0, 1)" : "rgba(255, 255, 255, 0.8)";
  }
  return null;
};
const getRandomColor = () => getRGBString(
  gsap.utils.random(0, 255, 1),
  gsap.utils.random(0, 255, 1),
  gsap.utils.random(0, 255, 1)
);
const getSiblings = (elem) => {
  const siblings = [];
  if (!elem.parentNode) {
    return siblings;
  }
  Array.from(elem.parentNode.children).forEach((sibling) => {
    if (sibling !== elem) {
      siblings.push(sibling);
    }
  });
  return siblings;
};
const escapeHTML$1 = (str) => typeof str === "string" ? str.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/[`']/g, "&#039;") : str;
const testFuncPerformance = (func, ...params) => {
  const start = performance.now();
  let tally = 0;
  const handleResult = () => {
    if (performance.now() - start < 1e4) {
      runFunc();
      tally++;
    } else {
      const elapsedTime = performance.now() - start;
      const timePerCall = roundNum(elapsedTime / tally / 4e3, 4);
      eLog.checkLog3("performance", `[TestPerformance] Function Ran ${tally} Times in ${roundNum(elapsedTime / 1e3, 4)}s, Averaging ${timePerCall}s per Call`);
    }
  };
  const runFunc = () => {
    const result = func(...params);
    if (result instanceof Promise) {
      result.then(handleResult);
    } else {
      handleResult();
    }
  };
  runFunc();
};
const set = (targets, vars) => gsap.set(targets, vars);
function get(target, property, unit) {
  if (unit) {
    const propVal = regExtract(gsap.getProperty(target, property, unit), /[\d.]+/);
    if (typeof propVal === "string") {
      return pFloat(propVal);
    }
    throw new Error(`Unable to extract property '${property}' in '${unit}' units from ${target}`);
  }
  return gsap.getProperty(target, property);
}
const getGSAngleDelta = (startAngle, endAngle) => signNum(roundNum(getAngleDelta(startAngle, endAngle), 2)).replace(/^(.)/, "$1=");
const getNearestLabel = (tl, matchTest) => {
  if (!tl) {
    return void 0;
  }
  if (!objSize(tl.labels)) {
    return void 0;
  }
  if (typeof matchTest === "string") {
    matchTest = new RegExp(matchTest);
  }
  const labelTimes = Object.entries(tl.labels).filter(([label]) => {
    return matchTest instanceof RegExp ? matchTest.test(label) : true;
  }).sort((a, b) => a[1] - b[1]);
  const nearestTime = gsap.utils.snap(labelTimes.map(([_label, time]) => time), tl.time());
  const [nearestLabel] = labelTimes.find(([_label, time]) => time === nearestTime);
  return nearestLabel;
};
const reverseRepeatingTimeline = (tl) => {
  if (tl.repeat() === -1) {
    tl.totalTime(tl.time());
  } else {
    const [tw] = tl.getChildren(false, true, true, tl.time());
    if (tw && tw.repeat() === -1) {
      tw.totalTime(tw.time());
    }
    tl.reverse();
  }
  return tl;
};
const sleep = (duration) => new Promise(
  (resolve) => {
    setTimeout(resolve, duration >= 100 ? duration : duration * 1e3);
  }
);
function waitFor(waitForTarget) {
  return new Promise(
    (resolve, reject) => {
      if (waitForTarget instanceof Promise || waitForTarget instanceof gsap.core.Animation) {
        waitForTarget.then(() => resolve()).catch(reject);
      } else if (Array.isArray(waitForTarget)) {
        Promise.all(waitForTarget.map((target) => waitFor(target))).then(() => resolve()).catch(reject);
      } else {
        resolve();
      }
    }
  );
}
const EventHandlers = {
  onTextInputBlur: async (inst, event) => {
    const elem = event.target;
    const { action, target, flagTarget } = elem.dataset;
    if (!action) {
      throw new Error("Input text elements require a data-action attribute.");
    }
    if (!target && !flagTarget) {
      throw new Error("Input text elements require a 'data-target' or 'data-flag-target' attribute.");
    }
    if (target) {
      await inst.document.update({ [target]: elem.value });
    } else if (flagTarget) {
      if (elem.value === "") {
        await inst.document.unsetFlag(C.SYSTEM_ID, flagTarget);
      } else {
        await inst.document.setFlag(C.SYSTEM_ID, flagTarget, elem.value);
      }
    }
  },
  onSelectChange: async (inst, event) => {
    const elem = event.currentTarget;
    const { action, dtype, target, flagTarget } = elem.dataset;
    if (!action) {
      throw new Error("Select elements require a data-action attribute.");
    }
    if (!target && !flagTarget) {
      throw new Error("Select elements require a 'data-target' or 'data-flag-target' attribute.");
    }
    const dataType = lCase(dtype);
    let value;
    switch (dataType) {
      case "number":
        value = pFloat(elem.value);
        break;
      case "boolean":
        value = lCase(`${elem.value}`) === "true";
        break;
      case "string":
        value = `${elem.value}`;
        break;
      default: {
        if (isNumString(value)) {
          throw new Error(`You must set 'data-dtype="Number"' for <select> elements with number values.`);
        }
        if (isBooleanString(value)) {
          throw new Error(`You must set 'data-dtype="Boolean"' for <select> elements with boolean values.`);
        }
        value = `${elem.value}`;
        break;
      }
    }
    if (target) {
      await inst.document.update({ [target]: value });
    } else if (flagTarget) {
      if (elem.value === "") {
        await inst.document.unsetFlag(C.SYSTEM_ID, flagTarget);
      } else {
        await inst.document.setFlag(C.SYSTEM_ID, flagTarget, value);
      }
    }
  }
};
const isDocID = (ref) => {
  return typeof ref === "string" && /^[A-Za-z0-9]{16}$/.test(ref);
};
const isDocUUID = (ref) => {
  if (typeof ref !== "string") {
    return false;
  }
  const [docName, docID] = ref.split(/\./);
  if (!isDocID(docID)) {
    return false;
  }
  return game.collections.has(docName);
};
const isDotKey = (ref) => {
  return typeof ref === "string";
};
const isTargetKey = (ref) => {
  if (!isDotKey(ref)) {
    return false;
  }
  if (["name", "img", "id", "_id"].includes(ref)) {
    return true;
  }
  if (ref.startsWith("system")) {
    return true;
  }
  if (ref.startsWith("flag")) {
    return true;
  }
  return false;
};
const isTargetFlagKey = (ref) => {
  if (!isDotKey(ref)) {
    return false;
  }
  if (isTargetKey(ref)) {
    return false;
  }
  return true;
};
const parseDocRefToUUID = (ref) => {
  var _a;
  if (isDocUUID(ref)) {
    return ref;
  } else if (isDocID(ref)) {
    const doc = (_a = game.collections.find((collection) => collection.has(ref))) == null ? void 0 : _a.get(ref);
    if (doc && "uuid" in doc) {
      return doc.uuid;
    }
    throw new Error(`[U.parseDocRefToUUID] Unable to find document with id '${ref}'`);
  } else if (ref && typeof ref === "object" && "uuid" in ref && typeof ref.uuid === "string") {
    return ref.uuid;
  }
  throw new Error(`[U.parseDocRefToUUID] Unrecognized reference: '${ref}'`);
};
const loc = (locRef, formatDict = {}) => {
  if (/[a-z]/.test(locRef)) {
    locRef = locRef.replace(new RegExp(`^(${C.SYSTEM_ID}.)*`), `${C.SYSTEM_ID}.`);
  }
  if (typeof game.i18n.localize(locRef) === "string") {
    for (const [key, val] of Object.entries(formatDict)) {
      formatDict[key] = loc(val);
    }
    return game.i18n.format(locRef, formatDict) || game.i18n.localize(locRef) || locRef;
  }
  return locRef;
};
const getSetting = (setting) => {
  if (game.settings.settings.has(`${C.SYSTEM_ID}.${setting}`)) {
    return game.settings.get(C.SYSTEM_ID, setting);
  }
  return void 0;
};
function getTemplatePath(subFolder, fileName) {
  if (typeof fileName === "string") {
    return `${C.TEMPLATE_ROOT}/${subFolder}/${fileName.replace(/\..*$/, "")}.hbs`;
  }
  return fileName.map((fName) => getTemplatePath(subFolder, fName));
}
function displayImageSelector(callback, pathRoot = `systems/${C.SYSTEM_ID}/assets`, position = { top: 200, left: 200 }) {
  const fp = new FilePicker({
    type: "image",
    activeSource: "public",
    displayMode: "tiles",
    callback,
    top: position.top ?? 200 + 40,
    left: position.left ?? 200 + 10
  });
  return fp.browse(pathRoot);
}
const U = {
  // ████████ GETTERS: Basic Data Lookup & Retrieval ████████
  GMID,
  getUID: getUID$1,
  // ████████ TYPES: Type Checking, Validation, Conversion, Casting ████████
  isNumber,
  isNumString,
  isBooleanString,
  isSimpleObj,
  isList,
  isArray,
  isFunc,
  isInt,
  isFloat,
  isPosInt,
  isIterable,
  isHTMLCode,
  isRGBColor,
  isHexColor,
  isUndefined,
  isDefined,
  isEmpty,
  hasItems,
  isInstance,
  isNullish,
  areEqual,
  areFuzzyEqual,
  pFloat,
  pInt,
  pBool,
  radToDeg,
  degToRad,
  getKey,
  assertNonNullType,
  FILTERS,
  // ████████ REGEXP: Regular Expressions, Replacing, Matching ████████
  testRegExp,
  regExtract,
  // ████████ STRINGS: String Parsing, Manipulation, Conversion ████████
  // ░░░░░░░ Case Conversion ░░░░░░░
  uCase,
  lCase,
  sCase,
  tCase,
  // ░░░░░░░ Formatting ░░░░░░░
  /* hyphenate, */
  unhyphenate,
  pluralize,
  oxfordize,
  ellipsize,
  pad,
  toKey,
  parseArticles,
  signNum,
  padNum,
  stringifyNum,
  verbalizeNum,
  ordinalizeNum,
  romanizeNum,
  // ░░░░░░░ Content ░░░░░░░
  loremIpsum,
  randString,
  randWord,
  // ████████ SEARCHING: Searching Various Data Types w/ Fuzzy Matching ████████
  fuzzyMatch,
  isIn,
  isInExact,
  // ████████ NUMBERS: Number Casting, Mathematics, Conversion ████████
  randNum,
  randInt,
  coinFlip,
  cycleNum,
  cycleAngle,
  roundNum,
  clampNum,
  sum,
  average,
  // ░░░░░░░ Positioning ░░░░░░░
  getDistance,
  getAngle,
  getAngleDelta,
  getBoundingRectangle,
  // ████████ ARRAYS: Array Manipulation ████████
  randElem,
  randIndex,
  makeIntRange,
  makeCycler,
  unique,
  group,
  sample,
  getLast,
  removeFirst,
  pullElement,
  pullIndex,
  subGroup,
  shuffle,
  toArray,
  // ████████ OBJECTS: Manipulation of Simple Key/Val Objects ████████
  remove,
  replace,
  partition,
  zip,
  objClean,
  objSize,
  objMap,
  objFindKey,
  objFilter,
  objForEach,
  objCompact,
  objClone,
  objMerge,
  objDiff,
  objExpand,
  objFlatten,
  objNullify,
  objFreezeProps,
  // ████████ FUNCTIONS: Function Wrapping, Queuing, Manipulation ████████
  getDynamicFunc,
  withLog,
  // ████████ HTML: Parsing HTML Code, Manipulating DOM Objects ████████
  getSvgCode,
  changeContainer,
  adjustTextContainerAspectRatio,
  getRawCirclePath,
  drawCirclePath,
  getColorVals,
  getRGBString,
  getHEXString,
  getContrastingColor,
  getRandomColor,
  getSiblings,
  escapeHTML: escapeHTML$1,
  // ████████ PERFORMANCE: Performance Testing & Metrics ████████
  testFuncPerformance,
  // ░░░░░░░ GreenSock ░░░░░░░
  gsap,
  get,
  set,
  getGSAngleDelta,
  getNearestLabel,
  reverseRepeatingTimeline,
  /* to, from, fromTo, */
  TextPlugin,
  Flip,
  MotionPathPlugin,
  // ████████ ASYNC: Async Functions, Asynchronous Flow Control ████████
  sleep,
  waitFor,
  // EVENT HANDLERS
  EventHandlers,
  // ░░░░░░░ SYSTEM: System-Specific Functions (Requires Configuration of System ID in constants.js) ░░░░░░░
  isDocID,
  isDocUUID,
  isDotKey,
  isTargetKey,
  isTargetFlagKey,
  parseDocRefToUUID,
  loc,
  getSetting,
  getTemplatePath,
  displayImageSelector
};
const registerSettings = function() {
  game.settings.register("eunos-blades", "debug", {
    name: "Debug Level",
    hint: "The verbosity of the debug messages to console.",
    scope: "client",
    // This specifies a world-level setting
    config: true,
    // This specifies that the setting appears in the configuration view
    type: Number,
    range: {
      // If range is specified, the resulting setting will be a range slider
      min: 0,
      max: 5,
      step: 1
    },
    default: 3
    // The default value for the setting
  });
  game.settings.register("eunos-blades", "debugHooks", {
    name: "Debug HOOKS",
    hint: "Whether all Hooks are logged to the console.",
    scope: "client",
    config: true,
    type: Boolean,
    default: false
  });
  game.settings.register("eunos-blades", "openAPIModelLevel", {
    name: "AI Base Quality",
    hint: "Lower values are cheaper to run, at the cost of quality.",
    scope: "client",
    // This specifies a world-level setting
    config: true,
    // This specifies that the setting appears in the configuration view
    type: Number,
    range: {
      // If range is specified, the resulting setting will be a range slider
      min: 0,
      max: 2,
      step: 1
    }
  });
  game.settings.register("eunos-blades", "blacklist", {
    name: "Debug Blacklist",
    hint: "Comma-delimited list of categories of debug messages to silence.",
    scope: "client",
    // This specifies a world-level setting
    config: true,
    // This specifies that the setting appears in the configuration view
    type: String,
    default: ""
    // The default value for the setting
  });
  game.settings.register("eunos-blades", "openAPIKey", {
    name: "OpenAI API Key",
    hint: "Your personal OpenAI API Key (necessary to enable AI functionality)",
    scope: "client",
    // This specifies a world-level setting
    config: true,
    // This specifies that the setting appears in the configuration view
    type: String,
    default: ""
    // The default value for the setting
  });
  game.settings.register("eunos-blades", "whitelist", {
    name: "Debug Whitelist",
    hint: "Comma-delimited list of categories of debug messages to promote.",
    scope: "client",
    // This specifies a world-level setting
    config: true,
    // This specifies that the setting appears in the configuration view
    type: String,
    default: ""
    // The default value for the setting
  });
  game.settings.register("eunos-blades", "systemMigrationVersion", {
    name: "System Migration Version",
    scope: "world",
    config: false,
    type: Number,
    default: 0
  });
};
function initTinyMCEStyles() {
  CONFIG.TinyMCE = {
    ...CONFIG.TinyMCE,
    ...{
      skin: "skin",
      skin_url: "systems/eunos-blades/tinymce/skin",
      content_css: `systems/eunos-blades/tinymce/content.css?${(/* @__PURE__ */ new Date()).getTime()}`,
      font_css: "systems/eunos-blades/fonts.css",
      max_height: 500,
      min_height: 40,
      autoresize_overflow_padding: 0,
      autoresize_bottom_margin: 0,
      // 25,
      menubar: false,
      statusbar: false,
      // True,
      elementPath: true,
      branding: false,
      resize: false,
      plugins: "lists image table code save autoresize searchreplace quickbars template",
      save_enablewhendirty: false,
      // Table_default_styles: {},
      style_formats: [
        {
          title: "Headings",
          items: [
            { title: "Heading 1", block: "h1", wrapper: false },
            { title: "Heading 2", block: "h2", wrapper: false },
            { title: "Heading 3", block: "h3", wrapper: false },
            { title: "Heading 4", block: "h4", wrapper: false }
          ]
        },
        {
          title: "Blocks",
          items: [
            { title: "Paragraph", block: "p", wrapper: false },
            { title: "Block Quote", block: "blockquote", wrapper: true }
            // {title: "Secret", block: "span", classes: "text-secret", attributes: {"data-is-secret": "true"}, wrapper: false}
          ]
        },
        {
          title: "Inline",
          items: [
            { title: "Bold", inline: "b", wrapper: false },
            { title: "Italics", inline: "i", wrapper: false },
            { title: "Underline", inline: "u", wrapper: false },
            { title: "Secret", inline: "span", classes: "text-secret", attributes: { "data-is-secret": "true" }, wrapper: false }
          ]
        }
      ],
      style_formats_merge: false,
      toolbar: "styles | searchreplace | formatting alignment lists elements | removeformat | code | save",
      toolbar_groups: {
        formatting: {
          icon: "color-picker",
          tooltip: "Formatting",
          items: "bold italic underline"
        },
        alignment: {
          icon: "align-left",
          tooltip: "Alignment",
          items: "alignleft aligncenter alignright alignjustify | outdent indent"
        },
        lists: {
          icon: "unordered-list",
          tooltip: "Lists",
          items: "bullist numlist"
        },
        elements: {
          icon: "duplicate",
          tooltip: "Insert Element",
          items: "tableinsertdialog image hr | template"
        }
      },
      toolbar_mode: "floating",
      quickbars_link_toolbar: false,
      quickbars_selection_toolbar: "styles | bold italic underline",
      quickbars_insert_toolbar: "hr image table",
      quickbars_table_toolbar: "tableprops tabledelete | tableinsertrowbefore tableinsertrowafter tabledeleterow | tableinsertcolbefore tableinsertcolafter tabledeletecol"
    }
  };
}
function initCanvasStyles() {
  CONFIG.canvasTextStyle = new PIXI.TextStyle({
    align: "center",
    dropShadow: true,
    dropShadowAngle: U.degToRad(45),
    dropShadowBlur: 8,
    dropShadowColor: C.Colors.BLACK,
    dropShadowDistance: 4,
    fill: [
      C.Colors.bWHITE,
      C.Colors.bGREY
    ],
    fillGradientType: 1,
    fillGradientStops: [
      0,
      0.3
    ],
    fontFamily: "Kirsty",
    fontSize: 32,
    letterSpacing: 2,
    lineHeight: 32,
    lineJoin: "round",
    padding: 4,
    stroke: C.Colors.dBLACK,
    strokeThickness: 3,
    trim: true,
    whiteSpace: "normal",
    wordWrap: true,
    wordWrapWidth: 0.1
  });
}
function initDOMStyles() {
  $("body.vtt.game.system-eunos-blades").append(`<div id="backsplash" style="height: 100%; width: 100%; position: absolute; z-index: -1; background: linear-gradient(35deg, ${C.Colors.GREY}, ${C.Colors.BLACK});"></div>`);
  $("#interface").append(`<div class="lightning-border-container">
    </div>`);
}
async function preloadHandlebarsTemplates() {
  const templatePaths = [
    // General Components
    "systems/eunos-blades/templates/components/toggle-icon.hbs",
    "systems/eunos-blades/templates/components/button-icon.hbs",
    "systems/eunos-blades/templates/components/dotline.hbs",
    "systems/eunos-blades/templates/components/armor.hbs",
    "systems/eunos-blades/templates/components/comp.hbs",
    "systems/eunos-blades/templates/components/select.hbs",
    "systems/eunos-blades/templates/components/portrait.hbs",
    "systems/eunos-blades/templates/components/clock.hbs",
    "systems/eunos-blades/templates/components/roll-collab-mod.hbs",
    "systems/eunos-blades/templates/components/slide-out-controls.hbs",
    "systems/eunos-blades/templates/components/consequence.hbs",
    "systems/eunos-blades/templates/components/consequence-accepted.hbs",
    // Partials
    "systems/eunos-blades/templates/parts/tier-block.hbs",
    "systems/eunos-blades/templates/parts/turf-list.hbs",
    "systems/eunos-blades/templates/parts/cohort-block.hbs",
    "systems/eunos-blades/templates/parts/roll-opposition-creator.hbs",
    "systems/eunos-blades/templates/parts/active-effects.hbs",
    "systems/eunos-blades/templates/parts/gm-pc-summary.hbs",
    "systems/eunos-blades/templates/components/clock-key.hbs"
  ];
  return loadTemplates(templatePaths);
}
const handlebarHelpers = {
  randString(param1 = 10) {
    return U.randString(param1);
  },
  test(param1, operator, param2) {
    const stringMap = {
      true: true,
      false: false,
      null: null,
      undefined: void 0
    };
    if (["!", "not", "=??"].includes(String(param1))) {
      [operator, param1] = [String(param1), operator];
    }
    if (typeof param1 === "string" && param1 in stringMap) {
      param1 = stringMap[param1];
    }
    if (typeof param2 === "string" && param2 in stringMap) {
      param2 = stringMap[param2];
    }
    switch (operator) {
      case "!":
      case "not": {
        return !param1;
      }
      case "=??": {
        return [void 0, null].includes(param1);
      }
      case "&&": {
        return param1 && param2;
      }
      case "||": {
        return param1 || param2;
      }
      case "==": {
        return U.areFuzzyEqual(param1, param2);
      }
      case "===": {
        return param1 === param2;
      }
      case "!=":
      case "!==": {
        return param1 !== param2;
      }
      case ">": {
        return typeof param1 === "number" && typeof param2 === "number" && param1 > param2;
      }
      case "<": {
        return typeof param1 === "number" && typeof param2 === "number" && param1 < param2;
      }
      case ">=": {
        return typeof param1 === "number" && typeof param2 === "number" && param1 >= param2;
      }
      case "<=": {
        return typeof param1 === "number" && typeof param2 === "number" && param1 <= param2;
      }
      case "??": {
        return param1 ?? param2;
      }
      case "includes": {
        return Array.isArray(param1) && param1.includes(param2);
      }
      case "in": {
        if (Array.isArray(param2)) {
          return param2.includes(param1);
        }
        if (U.isList(param2) && (typeof param1 === "number" || typeof param1 === "string")) {
          return param1 in param2;
        }
        if (typeof param2 === "string") {
          return new RegExp(String(param1), "gu").test(String(param2));
        }
        return false;
      }
      default: {
        return false;
      }
    }
  },
  calc(...params) {
    const calcs = {
      "+": (p1, p2) => U.pInt(p1) + U.pInt(p2),
      "-": (p1, p2) => U.pInt(p1) - U.pInt(p2),
      "*": (p1, p2) => U.pInt(p1) * U.pInt(p2),
      "/": (p1, p2) => U.pInt(p1) / U.pInt(p2),
      "%": (p1, p2) => U.pInt(p1) % U.pInt(p2),
      max: (p1, p2) => Math.max(U.pInt(p1), U.pInt(p2)),
      min: (p1, p2) => Math.min(U.pInt(p1), U.pInt(p2)),
      ceil: (p1) => Math.ceil(U.pFloat(p1)),
      floor: (p1) => Math.floor(U.pFloat(p1))
    };
    const [param1, operator, param2] = typeof params[0] === "string" && params[0] in calcs ? [params[1], params[0]] : params;
    return calcs[operator](param1, param2);
  },
  isIn(...args) {
    const [testStr, ...contents] = args;
    return contents.includes(testStr);
  },
  case(mode, str) {
    switch (mode) {
      case "upper":
        return U.uCase(str);
      case "lower":
        return U.lCase(str);
      case "sentence":
        return U.sCase(str);
      case "title":
        return U.tCase(str);
      default:
        return str;
    }
  },
  romanize(val) {
    return U.romanizeNum(U.pInt(val));
  },
  count(param) {
    if (Array.isArray(param) || U.isList(param)) {
      return Object.values(param).filter((val) => val !== null && val !== void 0).length;
    } else if (typeof param === "string") {
      return param.length;
    }
    return param ? 1 : 0;
  },
  // Concat helper
  // Usage: (concat 'first 'second')
  concat(...args) {
    let outStr = "";
    for (const arg of args) {
      if (typeof arg === "string" || typeof arg === "number") {
        outStr += arg;
      }
    }
    return outStr;
  },
  // Merge helper - To merge additional properties into a template's context
  merge(context, ...args) {
    args.pop();
    return args.reduce((acc, val) => Object.assign(acc, val), context);
  },
  // For loop: {{#for [from = 0, to, stepSize = 1]}}<html content, this = index>{{/for}}
  for: (...args) => {
    const options = args.pop();
    let [from, to, stepSize] = args;
    from = U.pInt(from);
    to = U.pInt(to);
    stepSize = U.pInt(stepSize) || 1;
    if (from > to) {
      return "";
    }
    let html = "";
    for (let i = parseInt(from || 0, 10); i <= parseInt(to || 0, 10); i += stepSize) {
      html += options.fn(i);
    }
    return html;
  },
  signNum(num) {
    return U.signNum(num);
  },
  compileSvg(...args) {
    const [svgDotKey, svgPaths] = args;
    return U.getSvgCode(svgDotKey, svgPaths);
  },
  eLog(...args) {
    args.pop();
    let dbLevel = 3;
    if ([0, 1, 2, 3, 4, 5].includes(args[0])) {
      dbLevel = args.shift();
    }
    eLog.hbsLog(...args, dbLevel);
  },
  // Does the name of this turf block represent a standard 'Turf' claim?
  isTurfBlock: (name) => U.fuzzyMatch(name, "Turf"),
  // Which other connection does this connector overlap with?
  getConnectorPartner: (index, direction) => {
    index = parseInt(`${index}`, 10);
    const partners = {
      1: { right: 2, bottom: 6 },
      2: { left: 1, right: 3, bottom: 7 },
      3: { left: 2, right: 4, bottom: 8 },
      4: { left: 3, right: 5, bottom: 9 },
      5: { left: 4, bottom: 10 },
      6: { top: 1, right: 7, bottom: 11 },
      7: { top: 2, left: 6, right: 8, bottom: 12 },
      8: { top: 3, left: 7, right: 9, bottom: 13 },
      9: { top: 4, left: 8, right: 10, bottom: 14 },
      10: { top: 5, left: 9, bottom: 15 },
      11: { top: 6, right: 12 },
      12: { top: 7, left: 11, right: 13 },
      13: { top: 8, left: 12, right: 14 },
      14: { top: 9, left: 13, right: 15 },
      15: { top: 10, left: 14 }
    };
    const partnerDir = { left: "right", right: "left", top: "bottom", bottom: "top" }[direction];
    const partnerNum = partners[index][direction] ?? 0;
    if (partnerNum) {
      return `${partnerNum}-${partnerDir}`;
    }
    return null;
  },
  // Is the value Turf side.
  isTurfOnEdge: (index, direction) => {
    index = parseInt(`${index}`, 10);
    const edges = {
      1: ["top", "left"],
      2: ["top"],
      3: ["top"],
      4: ["top"],
      5: ["top", "right"],
      6: ["left"],
      7: [],
      8: [],
      9: [],
      10: ["right"],
      11: ["left", "bottom"],
      12: ["bottom"],
      13: ["bottom"],
      14: ["bottom"],
      15: ["right", "bottom"]
    };
    if (!(index in edges)) {
      return true;
    }
    return edges[index].includes(direction);
  },
  // Multiboxes
  multiboxes(selected, options) {
    let html = options.fn(this);
    selected = [selected].flat(1);
    selected.forEach((selectedVal) => {
      if (selectedVal !== false) {
        const escapedValue = RegExp.escape(Handlebars.escapeExpression(String(selectedVal)));
        const rgx = new RegExp(` value="${escapedValue}"`);
        html = html.replace(rgx, '$& checked="checked"');
      }
    });
    return html;
  },
  repturf: (turfsAmount, options) => {
    let html = options.fn(void 0);
    let turfsAmountInt = parseInt(turfsAmount, 10);
    if (turfsAmountInt > 6) {
      turfsAmountInt = 6;
    }
    for (let i = 13 - turfsAmountInt; i <= 12; i++) {
      const rgx = new RegExp(` value="${i}"`);
      html = html.replace(rgx, '$& disabled="disabled"');
    }
    return html;
  }
};
handlebarHelpers.eLog1 = function(...args) {
  handlebarHelpers.eLog(...[1, ...args.slice(0, 7)]);
};
handlebarHelpers.eLog2 = function(...args) {
  handlebarHelpers.eLog(...[2, ...args.slice(0, 7)]);
};
handlebarHelpers.eLog3 = function(...args) {
  handlebarHelpers.eLog(...[3, ...args.slice(0, 7)]);
};
handlebarHelpers.eLog4 = function(...args) {
  handlebarHelpers.eLog(...[4, ...args.slice(0, 7)]);
};
handlebarHelpers.eLog5 = function(...args) {
  handlebarHelpers.eLog(...[5, ...args.slice(0, 7)]);
};
Object.assign(handlebarHelpers);
function registerHandlebarHelpers() {
  Object.entries(handlebarHelpers).forEach(([name, func]) => Handlebars.registerHelper(name, func));
}
const gsapPlugins = [
  TextPlugin,
  Flip,
  MotionPathPlugin,
  Draggable,
  SplitText,
  Observer$1,
  CustomEase,
  CustomWiggle,
  CustomBounce,
  EasePack
];
const gsapEffects = {
  // #region CLOCK KEYS
  keyDrop: {
    effect: (clockKey, config) => {
      const [keyContainer] = $(clockKey).closest(".clock-key-container");
      return U.gsap.timeline({
        onComplete() {
          if (config.callback) {
            config.callback();
          }
        }
      }).fromTo(keyContainer, {
        y: config.yShift
      }, {
        y: 0,
        autoAlpha: 1,
        ease: "bounce",
        duration: config.duration
      });
    },
    defaults: {
      duration: 1,
      yShift: -800
    },
    extendTimeline: true
  },
  keyPull: {
    effect: (clockKey, config) => {
      const [keyContainer] = $(clockKey).closest(".clock-key-container");
      return U.gsap.timeline({
        onComplete() {
          if (config.callback) {
            config.callback();
          }
        }
      }).to(keyContainer, {
        y: config.yDelta,
        ease: config.ease,
        duration: 0.75 * config.duration
      }).to(keyContainer, {
        opacity: 0,
        ease: "power2.out",
        duration: 0.25 * config.duration
      }, 0.75 * config.duration);
    },
    defaults: {
      yDelta: -800,
      duration: 1,
      ease: "back.in(1)"
    },
    extendTimeline: true
  },
  keyControlPanelFlip: {
    effect: (target, config) => {
      return U.gsap.timeline({
        delay: config.delay,
        onStart() {
          if (target) {
            const target$ = $(target);
            const nextSibling$ = target$.next(".clock-control-flipper");
            if (nextSibling$.length) {
              U.gsap.effects.keyControlPanelFlip(nextSibling$[0], {
                ...config,
                delay: 0.15
              });
            }
          }
        }
      }).to(target, {
        rotateX: config.angle,
        duration: 0.5,
        ease: "back.inOut(2)"
      });
    },
    defaults: {
      angle: 180,
      delay: 0
    },
    extendTimeline: true
  },
  // #endregion
  // #region CHAT CONSEQUENCE EFFECTS
  csqEnter: {
    effect: (csqContainer, config) => {
      const csqRoot = U.gsap.utils.selector(csqContainer);
      const csqIconCircle = csqRoot(".consequence-icon-circle.base-consequence");
      const csqBaseTypeElem = csqRoot(".consequence-type.base-consequence");
      const csqAcceptTypeElem = csqRoot(".consequence-type.accept-consequence");
      const csqBaseNameElem = csqRoot(".consequence-name.base-consequence");
      const csqAcceptNameElem = csqRoot(".consequence-name.accept-consequence");
      const tl = U.gsap.timeline({ paused: true, defaults: {} });
      if (csqAcceptTypeElem.length > 0) {
        tl.set(csqAcceptTypeElem, { opacity: 0 }, 0);
      }
      if (csqAcceptNameElem.length > 0) {
        tl.set(csqAcceptNameElem, { opacity: 0 }, 0);
      }
      if (csqBaseTypeElem.length > 0) {
        tl.fromTo(csqBaseTypeElem, {
          opacity: 1
        }, {
          opacity: 0,
          duration: 0.25,
          ease: "sine"
        }, 0);
      }
      if (csqAcceptTypeElem.length > 0) {
        tl.fromTo(csqAcceptTypeElem, {
          opacity: 0
        }, {
          opacity: 1,
          duration: 0.25,
          ease: "sine"
        }, 0);
      }
      if (csqBaseNameElem.length > 0) {
        tl.fromTo(csqBaseNameElem, {
          opacity: 1
        }, {
          opacity: 0,
          duration: 0.25,
          ease: "sine"
        }, 0);
      }
      if (csqAcceptNameElem.length > 0) {
        tl.fromTo(csqAcceptNameElem, {
          opacity: 0
        }, {
          opacity: 1,
          duration: 0.25,
          ease: "sine"
        }, 0);
      }
      if (csqContainer) {
        tl.fromTo(csqContainer, {
          filter: "brightness(1)"
        }, {
          filter: `brightness(${config.brightness})`,
          duration: config.duration / 3,
          ease: "none"
        }, 0);
      }
      if (csqIconCircle.length > 0) {
        tl.fromTo(csqIconCircle, {
          scale: 0.75,
          outlineColor: C.Colors.dBLACK,
          outlineWidth: 0
        }, {
          scale: 0.85,
          outlineColor: C.Colors.GREY,
          outlineWidth: 1,
          duration: 0.55,
          ease: "sine.out"
        }, 0);
      }
      return tl;
    },
    defaults: {
      brightness: 1.5,
      duration: 0.5,
      scale: 1.5,
      stagger: 0.05,
      ease: "sine",
      easeStrength: 1.5
    }
  },
  csqClickIcon: {
    effect: (csqIconContainer, config) => {
      const csqContainer = $(csqIconContainer).closest(".comp.consequence-display-container");
      const csqRoot = U.gsap.utils.selector(csqContainer[0]);
      const iconRoot = U.gsap.utils.selector(csqIconContainer);
      const csqBackgroundImg = csqRoot(".consequence-bg-image");
      const csqInteractionPads = csqRoot(".consequence-interaction-pad");
      const csqIconCircleBase = iconRoot(".consequence-icon-circle.base-consequence");
      const csqIconCircleAccept = iconRoot(".consequence-icon-circle.accept-consequence");
      const csqButtonContainers = iconRoot(".consequence-button-container");
      const tl = U.gsap.timeline({
        paused: true,
        onComplete: function() {
          $(csqInteractionPads).css("pointerEvents", "auto");
        },
        onReverseComplete: function() {
          $(csqInteractionPads).css("pointerEvents", "none");
        }
      });
      if (csqBackgroundImg.length) {
        tl.fromTo(csqBackgroundImg, {
          xPercent: 110,
          yPercent: -50
        }, {
          xPercent: -60,
          yPercent: -50,
          duration: 0.5,
          ease: "back"
        }, 0);
      }
      if (csqIconCircleBase.length > 0) {
        tl.fromTo(csqIconCircleBase, {
          opacity: 1
        }, {
          opacity: 0,
          duration: 0.25,
          ease: "sine.out"
        }, 0);
      }
      if (csqIconCircleAccept.length > 0) {
        tl.fromTo(csqIconCircleAccept, {
          opacity: 0
        }, {
          opacity: 1,
          duration: 0.15,
          ease: "sine"
        }, 0).fromTo(csqIconCircleAccept, {
          outlineWidth: 1,
          scale: 0.85
        }, {
          outlineWidth: 2,
          scale: 1,
          duration: 0.25,
          ease: "sine"
        }, 0.175);
      }
      if (csqButtonContainers.length > 0) {
        tl.fromTo(csqButtonContainers, {
          scale: config.scale,
          opacity: 0,
          filter: "blur(25px)"
        }, {
          scale: 1,
          opacity: 1,
          filter: "blur(0px)",
          stagger: config.stagger,
          duration: config.duration,
          ease: `${config.ease}.inOut(${config.easeStrength})`
        }, 0);
      }
      return tl;
    },
    defaults: {
      duration: 0.5,
      scale: 1.5,
      stagger: 0.05,
      ease: "sine",
      easeStrength: 1.5
    }
  },
  csqEnterRight: {
    effect: (csqContainer) => {
      const csqRoot = U.gsap.utils.selector(csqContainer);
      const typeLine = csqRoot(".consequence-type-container .consequence-type.accept-consequence");
      const typeLineBg = csqRoot(".consequence-type-container .consequence-type-bg.accept-consequence");
      const buttonRoot = U.gsap.utils.selector(csqRoot(".consequence-button-container.consequence-accept-button-container"));
      const buttonBg = buttonRoot(".consequence-button-bg");
      const buttonIcon = buttonRoot(".button-icon i");
      const buttonLabel = buttonRoot(".consequence-button-label");
      const tl = U.gsap.timeline({ paused: true, defaults: {} });
      if (typeLine.length > 0) {
        tl.fromTo(
          typeLine,
          {
            color: C.Colors.RED
          },
          {
            color: C.Colors.WHITE,
            duration: 0.5,
            ease: "sine.inOut"
          },
          0
        );
      }
      if (typeLineBg.length > 0) {
        tl.fromTo(typeLineBg, {
          x: 5,
          scaleX: 0,
          color: C.Colors.RED,
          skewX: 0
        }, {
          scaleX: 1,
          skewX: -45,
          color: C.Colors.RED,
          duration: 0.5,
          ease: "back.out"
        }, 0);
      }
      if (buttonBg.length > 0) {
        tl.fromTo(buttonBg, {
          scaleX: 0,
          color: C.Colors.RED,
          skewX: 0
        }, {
          x: 0,
          scaleX: 1,
          skewX: -45,
          color: C.Colors.RED,
          duration: 0.25,
          ease: "back.out"
        }, 0);
      }
      if (buttonIcon.length > 0) {
        tl.fromTo(
          buttonIcon,
          {
            color: C.Colors.GREY,
            opacity: 0.75,
            scale: 1
          },
          {
            color: C.Colors.dBLACK,
            scale: 1.25,
            opacity: 1,
            duration: 0.5,
            ease: "sine"
          },
          0
        );
      }
      if (buttonLabel.length > 0) {
        tl.fromTo(
          buttonLabel,
          {
            color: C.Colors.GREY,
            fontWeight: 400,
            scale: 1
          },
          {
            color: C.Colors.dBLACK,
            fontWeight: 800,
            duration: 0.75,
            ease: "sine"
          },
          0
        );
      }
      return tl;
    },
    defaults: {}
  },
  csqEnterLeft: {
    effect: (csqContainer) => {
      const csqRoot = U.gsap.utils.selector(csqContainer);
      const typeLine = csqRoot(".consequence-type-container .consequence-type.accept-consequence");
      const nameLine = csqRoot(".consequence-name-container .consequence-name.accept-consequence");
      const acceptIconCircle = csqRoot(".consequence-icon-circle.accept-consequence");
      const acceptButton = csqRoot(".consequence-button-container.consequence-accept-button-container");
      const tl = U.gsap.timeline({ paused: true, defaults: {} });
      if (typeLine.length > 0) {
        tl.to(
          typeLine,
          {
            opacity: 0,
            duration: 0.15,
            ease: "sine.inOut"
          },
          0
        );
      }
      if (nameLine.length > 0) {
        tl.to(nameLine, {
          opacity: 0,
          duration: 0.15,
          ease: "sine.inOut"
        }, 0);
      }
      if (acceptIconCircle.length > 0) {
        tl.to(
          acceptIconCircle,
          {
            opacity: 0,
            duration: 0.15,
            ease: "sine.inOut"
          },
          0
        );
      }
      if (acceptButton.length > 0) {
        tl.fromTo(
          acceptButton,
          {
            opacity: 1
          },
          {
            opacity: 0,
            duration: 0.25,
            ease: "sine.inOut"
          },
          0
        );
      }
      return tl;
    },
    defaults: {}
  },
  csqEnterSubLeft: {
    effect: (csqContainer, config) => {
      const csqRoot = U.gsap.utils.selector(csqContainer);
      const iconCircle = csqRoot(`.consequence-icon-circle.${config.type}-consequence`);
      const typeLine = csqRoot(`.consequence-type-container .consequence-type.${config.type}-consequence`);
      const nameLine = csqRoot(`.consequence-name.${config.type}-consequence`);
      const footerBg = csqRoot(`.consequence-footer-container .consequence-footer-bg.${config.type}-consequence`);
      const specialFooterMsg = csqRoot(`.consequence-footer-container .consequence-footer-message.${config.type}-consequence`);
      const tl = U.gsap.timeline({ paused: true, defaults: {} });
      if (iconCircle.length > 0) {
        tl.fromTo(iconCircle, {
          opacity: 0
        }, {
          opacity: 1,
          duration: 0.5,
          ease: "back.out"
        }, 0);
      }
      if (typeLine.length > 0) {
        tl.fromTo(typeLine, {
          opacity: 0
        }, {
          opacity: 1,
          duration: 0.5,
          ease: "back.out"
        }, 0);
      }
      if (nameLine.length > 0) {
        tl.fromTo(nameLine, {
          scaleX: 0
        }, {
          scaleX: 1,
          duration: 0.5,
          ease: "back.inOut"
        }, 0);
      }
      if (footerBg.length > 0) {
        tl.fromTo(footerBg, {
          scaleX: 0,
          skewX: 0,
          opacity: 1
        }, {
          scaleX: 1,
          skewX: -45,
          opacity: 1,
          duration: 0.5,
          ease: "back.inOut"
        }, 0);
      }
      if (specialFooterMsg.length > 0) {
        tl.fromTo(specialFooterMsg, {
          scaleX: 0,
          opacity: 1
        }, {
          scaleX: 1,
          opacity: 1,
          duration: 0.5,
          ease: "back.inOut"
        }, 0);
      }
      if (csqRoot(`.consequence-button-container.consequence-${config.type}-button-container`).length > 0) {
        const buttonRoot = U.gsap.utils.selector(csqRoot(`.consequence-button-container.consequence-${config.type}-button-container`));
        const buttonBg = buttonRoot(".consequence-button-bg");
        const buttonIcon = buttonRoot(".button-icon i");
        const buttonLabel = buttonRoot(".consequence-button-label");
        if (buttonBg.length > 0) {
          tl.fromTo(buttonBg, {
            scaleX: 0,
            skewX: 0,
            opacity: 1
          }, {
            scaleX: 1,
            skewX: -45,
            opacity: 1,
            duration: 0.5,
            ease: "back.inOut"
          }, 0);
        }
        if (buttonIcon.length > 0) {
          tl.fromTo(
            buttonIcon,
            {
              color: C.Colors.GREY,
              opacity: 0.75,
              scale: 1
            },
            {
              color: C.Colors.dBLACK,
              scale: 1.25,
              opacity: 1,
              duration: 0.5,
              ease: "sine"
            },
            0
          );
        }
        if (buttonLabel.length > 0) {
          tl.fromTo(
            buttonLabel,
            {
              color: C.Colors.GREY,
              fontWeight: 400,
              scale: 1
            },
            {
              color: C.Colors.dBLACK,
              fontWeight: 800,
              duration: 0.75,
              ease: "sine"
            },
            0
          );
        }
      }
      return tl;
    },
    defaults: {}
  },
  // #endregion
  // #region CHARACTER SHEET EFFECTS
  fillCoins: {
    effect: (targets, config) => {
      return U.gsap.to(
        targets,
        {
          duration: config.duration / 2,
          scale: config.scale,
          filter: config.filter,
          ease: config.ease,
          stagger: {
            amount: 0.25,
            from: "start",
            repeat: 1,
            yoyo: true
          }
        }
      );
    },
    defaults: {
      duration: 1,
      scale: 1,
      filter: "saturate(1) brightness(2)",
      ease: "power2.in"
    },
    extendTimeline: true
  },
  // #endregion
  // #region GENERAL: 'blurRemove', 'hoverTooltip', 'textJitter'
  blurRemove: {
    effect: (targets, config) => U.gsap.timeline({ stagger: config.stagger }).to(
      targets,
      {
        skewX: config.skewX,
        duration: config.duration / 2,
        ease: "power4.out"
      }
    ).to(
      targets,
      {
        x: config.x,
        marginBottom: config.ignoreMargin ? void 0 : function(i, target) {
          return U.get(target, "height") * -1;
        },
        marginRight: config.ignoreMargin ? void 0 : function(i, target) {
          return U.get(target, "width") * -1;
        },
        scale: config.scale,
        filter: `blur(${config.blur}px)`,
        duration: 3 / 4 * config.duration
      },
      config.duration / 4
    ).to(
      targets,
      {
        autoAlpha: 0,
        duration: config.duration / 2,
        ease: "power3.in"
      },
      config.duration / 2
    ),
    defaults: {
      ignoreMargin: false,
      skewX: -20,
      duration: 0.5,
      x: "+=300",
      scale: 1.5,
      blur: 10,
      stagger: 0
    },
    extendTimeline: true
  },
  blurReveal: {
    effect: (targets, config) => U.gsap.timeline().fromTo(
      targets,
      {
        x: config.x,
        marginBottom: config.ignoreMargin ? void 0 : function(i, target) {
          return U.get(target, "height") * -1;
        },
        marginRight: config.ignoreMargin ? void 0 : function(i, target) {
          return U.get(target, "width") * -1;
        },
        scale: config.scale,
        filter: `blur(${config.blur}px)`
      },
      {
        x: 0,
        marginBottom: 0,
        marginRight: 0,
        scale: 1,
        filter: "blur(0px)",
        duration: 3 / 4 * config.duration
      },
      0
    ).fromTo(
      targets,
      {
        autoAlpha: 0
      },
      {
        autoAlpha: 1,
        duration: config.duration / 2,
        ease: "power3.in"
      },
      0
    ).fromTo(
      targets,
      {
        skewX: config.skewX
      },
      {
        skewX: 0,
        duration: config.duration / 2,
        ease: "power4.out"
      },
      config.duration / 2
    ),
    defaults: {
      ignoreMargin: false,
      skewX: -20,
      duration: 0.5,
      x: "+=300",
      scale: 1.5,
      blur: 10
    },
    extendTimeline: true
  },
  scaleUpReveal: {
    effect: (target, config) => {
      const tl = U.gsap.timeline().fromTo(target, {
        autoAlpha: 0,
        scale: 0.5 * config.scale
      }, {
        autoAlpha: 1,
        scale: config.scale,
        duration: config.duration,
        ease: config.ease
      });
      return tl;
    },
    defaults: {
      scale: 1,
      duration: 0.5,
      ease: "power2"
    },
    extendTimeline: true
  },
  scaleDownRemove: {
    effect: (target, config) => {
      const tl = U.gsap.timeline().to(target, {
        autoAlpha: 0,
        scale: 0.5 * config.scale,
        duration: config.duration,
        ease: config.ease
      });
      return tl;
    },
    defaults: {
      scale: 1,
      duration: 0.5,
      ease: "power2"
    },
    extendTimeline: true
  },
  blurRevealTooltip: {
    effect: (target, config) => {
      if (!target) {
        throw new Error(`blurRevealTooltip effect: tooltip element is ${target === null ? "null" : typeof target}`);
      }
      const tooltip$ = $(target);
      return U.gsap.timeline({
        paused: true,
        onReverseComplete: config.onReverseComplete
      }).fromTo(
        tooltip$,
        {
          filter: `blur(${config.blurStrength}px)`,
          autoAlpha: 0,
          xPercent: 50,
          yPercent: -200,
          scale: config.scale
        },
        {
          filter: "blur(0px)",
          autoAlpha: 1,
          xPercent: -50,
          yPercent: -100,
          scale: 1,
          ease: config.ease,
          duration: config.duration
        }
      );
    },
    defaults: {
      scale: 1.5,
      blurStrength: 15,
      ease: "back.out",
      duration: 0.25,
      onReverseComplete: void 0
    },
    extendTimeline: true
  },
  textJitter: {
    effect: (target, config) => {
      const [targetElem] = $(target);
      if (!targetElem) {
        throw new Error("textJitter effect: target not found");
      }
      const split = new SplitText(targetElem, { type: "chars" });
      return U.gsap.timeline().to(targetElem, {
        autoAlpha: 1,
        duration: config.duration,
        ease: "none"
      }).fromTo(split.chars, {
        y: -config.yAmp
      }, {
        y: config.yAmp,
        duration: config.duration,
        ease: "sine.inOut",
        stagger: {
          repeat: -1,
          yoyo: true,
          from: "random",
          each: config.stagger
        }
      }, 0).fromTo(split.chars, {
        rotateZ: -config.rotateAmp
      }, {
        rotateZ: config.rotateAmp,
        duration: config.duration,
        ease: CustomWiggle.create("myWiggle", { wiggles: 10, type: "random" }),
        stagger: {
          repeat: -1,
          from: "random",
          yoyo: true,
          each: config.stagger
        }
      }, 0);
    },
    defaults: {
      yAmp: 2,
      rotateAmp: 2,
      duration: 1,
      stagger: 0.05
    },
    extendTimeline: true
  }
  // #endregion
};
function Initialize() {
  if (gsapPlugins.length) {
    U.gsap.config({
      nullTargetWarn: true
    });
    U.gsap.registerPlugin(...gsapPlugins);
    Object.assign(
      globalThis,
      {
        TextPlugin,
        Flip,
        MotionPathPlugin,
        Dragger: Draggable,
        SplitText,
        Observer: Observer$1,
        CustomEase,
        CustomWiggle,
        CustomBounce,
        EasePack
      }
    );
  }
  Object.entries(gsapEffects).forEach(([name, effect]) => {
    U.gsap.registerEffect(Object.assign(effect, { name }));
  });
}
function ApplyTooltipAnimations(html) {
  html.find(".tooltip-trigger").each((_, el) => {
    const tooltipElem = $(el).find(".tooltip")[0] ?? $(el).next(".tooltip")[0];
    if (!tooltipElem) {
      return;
    }
    const tooltip$ = $(tooltipElem);
    const tooltipContainer$ = tooltip$.parent();
    if (tooltipContainer$.css("position") !== "relative" && tooltipContainer$.css("position") !== "absolute") {
      tooltipContainer$.css("position", "relative");
    }
    tooltip$.css("position", "absolute");
    const tooltipID = `tooltip-${randomID()}`;
    tooltip$.attr("id", tooltipID);
    if (tooltip$.hasClass("tooltip-wide")) {
      U.adjustTextContainerAspectRatio(tooltipElem, 6);
    }
    $(el).on({
      mouseenter: function() {
        game.eunoblades.Director.displayTooltip(tooltipElem);
      },
      mouseleave: function() {
        game.eunoblades.Director.clearTooltip(tooltipID);
      }
    });
  });
}
const G = U.gsap;
const _BladesTargetLink = class _BladesTargetLink {
  constructor(dataOrConfig, parentLinkData) {
    __privateAdd(this, _updateTargetViaMerge);
    __privateAdd(this, _updateTargetPropVal);
    __publicField(this, "_id");
    __publicField(this, "_targetID");
    __publicField(this, "_targetKey");
    __publicField(this, "_targetFlagKey");
    __publicField(this, "_isScopingById", true);
    __publicField(this, "_initialSchema");
    __publicField(this, "_target");
    __publicField(this, "initPromise");
    __publicField(this, "isInitPromiseResolved", false);
    var _a;
    let linkData;
    let schema;
    const subclassConstructor = this.constructor;
    if (subclassConstructor.IsValidData(dataOrConfig)) {
      ({ linkData } = subclassConstructor.PartitionSchemaData(dataOrConfig));
      const target2 = fromUuidSync(linkData.targetID);
      if (!target2) {
        throw new Error(`[new BladesTargetLink()] Unable to resolve target from uuid '${linkData.targetID}'`);
      }
      if ("targetKey" in linkData) {
        schema = getProperty(target2, `${linkData.targetKey}.${linkData.id}`);
      } else {
        schema = target2.getFlag(C.SYSTEM_ID, `${linkData.targetFlagKey}.${linkData.id}`);
      }
      this.isInitPromiseResolved = true;
    } else {
      const parsedData = __privateMethod(_a = _BladesTargetLink, _ParseConfigToData, ParseConfigToData_fn).call(_a, dataOrConfig, parentLinkData);
      let partialSchema;
      ({ linkData, partialSchema } = subclassConstructor.PartitionSchemaData(parsedData));
      schema = subclassConstructor._ApplySchemaDefaults(partialSchema);
    }
    this._id = linkData.id;
    this._targetID = linkData.targetID;
    if ("targetKey" in linkData) {
      this._targetKey = linkData.targetKey;
    } else {
      this._targetFlagKey = linkData.targetFlagKey;
    }
    const target = fromUuidSync(this.targetID);
    if (!target) {
      throw new Error(`[new BladesTargetLink()] Unable to resolve target from uuid '${this._targetID}'`);
    }
    this._target = target;
    this._initialSchema = schema;
  }
  // #region STATIC METHODS ~
  static get ValidTargetClasses() {
    return [
      BladesActor$1,
      BladesItem$1,
      BladesChat$1,
      User
    ];
  }
  static IsValidConfig(ref) {
    return U.isSimpleObj(ref) && (U.isDocID(ref.target) || U.isDocUUID(ref.target) || U.isDocID(ref.targetID) || U.isDocUUID(ref.targetID) || this.ValidTargetClasses.some((cls) => ref.target instanceof cls)) && (U.isTargetKey(ref.targetKey) || U.isTargetFlagKey(ref.targetFlagKey)) && !(U.isTargetKey(ref.targetKey) && U.isTargetFlagKey(ref.targetFlagKey));
  }
  static IsValidData(ref) {
    return U.isSimpleObj(ref) && U.isDocID(ref.id) && U.isDocUUID(ref.targetID) && (U.isTargetKey(ref.targetKey) || U.isTargetFlagKey(ref.targetFlagKey)) && !(U.isTargetKey(ref.targetKey) && U.isTargetFlagKey(ref.targetFlagKey));
  }
  static BuildLinkConfig(partialConfig) {
    if ("target" in partialConfig) {
      if ("targetKey" in partialConfig) {
        return {
          target: partialConfig.target,
          targetKey: partialConfig.targetKey,
          isScopingById: partialConfig.isScopingById
        };
      } else if ("targetFlagKey" in partialConfig) {
        return {
          target: partialConfig.target,
          targetFlagKey: partialConfig.targetFlagKey,
          isScopingById: partialConfig.isScopingById
        };
      }
      throw new Error("[BladesTargetLink.BuildConfig] Must provide a targetKey or targetFlagKey.");
    } else if ("targetID" in partialConfig) {
      if ("targetKey" in partialConfig) {
        return {
          targetID: partialConfig.targetID,
          targetKey: partialConfig.targetKey,
          isScopingById: partialConfig.isScopingById
        };
      } else if ("targetFlagKey" in partialConfig) {
        return {
          targetID: partialConfig.targetID,
          targetFlagKey: partialConfig.targetFlagKey,
          isScopingById: partialConfig.isScopingById
        };
      }
      throw new Error("[BladesTargetLink.BuildConfig] Must provide a targetKey or targetFlagKey.");
    }
    throw new Error("[BladesTargetLink.BuildConfig] Must provide a target or targetID.");
  }
  /**
   * This static method parses the provided data into a format suitable for BladesTargetLink.
   * Subclasses can override this method to include their own parse logic.
   * If the provided data is already valid, it is returned as is.
   * Otherwise, the data is passed to the private #ParseConfig method for further processing.
   * Note: The 'id' property is defined at the return step, within #ParseConfig: Subclass
   * functionality that depends on the id property should be placed after the super call to this method.
   *
   * @template Schema - The data schema required by the subclass.
   * @param {(BladesTargetLink.Config | BladesTargetLink.Data) & Partial<Schema>} data - The data to be parsed.
   * @returns {BladesTargetLink.Data & Partial<Schema>} - The parsed data, suitable for BladesTargetLink.
   */
  static ParseConfigToData(data, parentLinkData) {
    if (this.IsValidData(data)) {
      return __privateMethod(this, _ParseChildLinkData, ParseChildLinkData_fn).call(this, data, parentLinkData);
    }
    return __privateMethod(this, _ParseConfigToData, ParseConfigToData_fn).call(this, data, parentLinkData);
  }
  static PartitionSchemaData(dataOrConfig) {
    const {
      id,
      target,
      targetID,
      targetKey,
      targetFlagKey,
      isScopingById,
      ...schemaData
    } = dataOrConfig;
    const partialSchema = schemaData;
    if (U.isDocID(id)) {
      if (!this.IsValidData({ id, targetID, targetKey, targetFlagKey, isScopingById })) {
        eLog.error("BladesTargetLink", "Bad Constructor DATA", { dataOrConfig });
        throw new Error("[new BladesTargetLink()] Bad Constructor DATA (see log)");
      }
      let linkData;
      if (targetKey) {
        linkData = { id, targetID, targetKey, isScopingById: isScopingById ?? true };
      } else if (targetFlagKey) {
        linkData = { id, targetID, targetFlagKey, isScopingById: isScopingById ?? true };
      } else {
        eLog.error("BladesTargetLink", "Bad Constructor DATA", { dataOrConfig });
        throw new Error("[BladesTargetLink.PartitionSchemaData] Bad Constructor DATA (see log)");
      }
      return {
        linkData,
        partialSchema
      };
    }
    return {
      linkConfig: this.BuildLinkConfig({
        ...{ isScopingById: isScopingById ?? true },
        ..."targetID" in dataOrConfig ? { targetID: dataOrConfig.targetID } : { target: dataOrConfig.target },
        ..."targetKey" in dataOrConfig ? { targetKey: dataOrConfig.targetKey } : { targetFlagKey: dataOrConfig.targetFlagKey }
      }),
      partialSchema
    };
  }
  static _ApplySchemaDefaults(schemaData) {
    return this.ApplySchemaDefaults(schemaData);
  }
  /**
  * This static method applies defaults to any values missing from the class' data Schema.
  * 'Schema' is defined by subclasses to BladesTargetLink.
  * Subclasses must override this method to apply their own defaults.
  *
  * @template Schema - The data schema required by the subclass.
  * @param {Partial<Schema>} schemaData - Schema data overriding the defaults.
  * @returns {Schema} - The schema data with defaults applied.
  * @throws {Error} - Throws an error if this method is not overridden in a subclass.
  */
  static ApplySchemaDefaults(schemaData) {
    throw new Error("[BladesTargetLink.ApplySchemaDefaults] Static Method ApplySchemaDefaults must be overridden in subclass");
  }
  /**
   * Creates a new instance of BladesTargetLink and initializes it with the provided configuration.
   * The configuration is parsed into a data object which is then used to initialize the target link.
   * The function logs the parsed data for debugging purposes.
   *
   * @template Schema - The schema type parameter that extends the data structure.
   * @param {BladesTargetLink.Config & Partial<Schema>} config - The configuration object containing both the target link configuration and the schema configuration.
   *
   * @returns {Promise<BladesTargetLink<Schema> & BladesTargetLink.Subclass<Schema>>} - A promise that resolves to a new instance of BladesTargetLink, initialized with the provided data.
   *
   * @throws {Error} - Throws an error if the initialization of the target link fails.
   */
  static async Create(config, parentLinkData) {
    const tLink = new this(config, parentLinkData);
    await tLink.initTargetLink();
    return tLink;
  }
  // #endregion
  // #region GETTERS ~
  get isGM() {
    return game.user.isGM;
  }
  get id() {
    return this._id;
  }
  get targetID() {
    return this._targetID;
  }
  get targetKey() {
    return this._targetKey;
  }
  get targetFlagKey() {
    return this._targetFlagKey;
  }
  get isScopingById() {
    return this._isScopingById;
  }
  get initialSchema() {
    return this._initialSchema;
  }
  get targetKeyPrefix() {
    if (!this.targetKey) {
      return void 0;
    }
    if (!this.isScopingById) {
      return this.targetKey;
    }
    return this.targetKey ? `${this.targetKey}.${this.id}` : void 0;
  }
  get targetKeyNullPrefix() {
    if (!this.targetKey) {
      return void 0;
    }
    if (this.isScopingById) {
      return `${this.targetKey}.-=${this.id}`;
    }
    if (/^.+\..+$/g.test(this.targetKey)) {
      return this.targetKey.replace(/\.([^.]+)$/, ".-=$1");
    }
    throw new Error(`[BladesTargetLink.targetKeyNullPrefix] Can't Nullify TargetKey '${this.targetKey}'`);
  }
  get targetFlagKeyPrefix() {
    if (!this.targetFlagKey) {
      return void 0;
    }
    if (!this.isScopingById) {
      return this.targetFlagKey;
    }
    return this.targetFlagKey ? `${this.targetFlagKey}.${this.id}` : void 0;
  }
  get isLinkInitialized() {
    return this.isInitPromiseResolved;
  }
  get linkData() {
    if (this.targetKey) {
      return {
        id: this.id,
        targetID: this.targetID,
        targetKey: this.targetKey,
        isScopingById: this.isScopingById
      };
    }
    if (this.targetFlagKey) {
      return {
        id: this.id,
        targetID: this.targetID,
        targetFlagKey: this.targetFlagKey,
        isScopingById: this.isScopingById
      };
    }
    throw new Error(`[BladesTargetLink.linkData] Missing targetKey and targetFlagKey for '${this.id}'`);
  }
  get target() {
    return this._target;
  }
  get localData() {
    return {
      ...this.initialSchema,
      ...this.linkData
    };
  }
  get data() {
    if (this.isLinkInitialized) {
      let data;
      if (this.targetFlagKeyPrefix) {
        data = this.target.getFlag(C.SYSTEM_ID, this.targetFlagKeyPrefix);
      } else if (this.targetKeyPrefix) {
        data = getProperty(this.target, this.targetKeyPrefix);
      }
      if (!data) {
        throw new Error("[BladesTargetLink.data] Error retrieving data.");
      }
      return data;
    } else {
      eLog.warn("BladesTargetLink", "Attempt to access data of uninitiated BladesTargetLink: Returning local data only.", { bladesTargetLink: this, localData: this.localData });
      return this.localData;
    }
  }
  // #endregion
  // #region ASYNC UPDATE & DELETE METHODS ~
  getDotKeyToProp(prop, isNullifying = false) {
    if (this.targetKeyPrefix) {
      if (prop === void 0) {
        return isNullifying ? this.targetKeyNullPrefix : this.targetKeyPrefix;
      }
      return `${this.targetKeyPrefix}.${isNullifying ? "-=" : ""}${prop}`;
    }
    if (this.targetFlagKeyPrefix) {
      if (prop === void 0) {
        return this.targetFlagKeyPrefix;
      }
      return `${this.targetFlagKeyPrefix}.${prop}`;
    }
    throw new Error("[BladesTargetLink.getDotKeyToProp()] Missing 'targetKeyPrefix' and 'targetFlagKeyPrefix'");
  }
  getFlagParamsToProp(prop) {
    return [C.SYSTEM_ID, this.getDotKeyToProp(prop)];
  }
  async updateTargetFlag(prop, val) {
    if (!this.targetFlagKeyPrefix) {
      return;
    }
    if (val === null) {
      await this.target.unsetFlag(...this.getFlagParamsToProp(prop));
    } else if (this.target instanceof BladesActor$1) {
      await this.target.setFlag(...this.getFlagParamsToProp(prop), val);
    } else if (this.target instanceof BladesItem$1) {
      await this.target.setFlag(...this.getFlagParamsToProp(prop), val);
    } else if (this.target instanceof User) {
      await this.target.setFlag(...this.getFlagParamsToProp(prop), val);
    } else if (this.target instanceof BladesChat$1) {
      await this.target.setFlag(...this.getFlagParamsToProp(prop), val);
    }
  }
  async updateTargetKey(prop, val) {
    if (!this.targetKeyPrefix) {
      return;
    }
    await this.target.update({ [this.getDotKeyToProp(prop, val === null)]: val }, { render: false });
  }
  /**
   * Initializes a target link by updating the target's data with the provided data object.
   * If a targetKey is provided, the data is updated directly on the target.
   * If a targetFlagKey is provided, the data is set as a flag on the target.
   *
   * This method need only be run once, when the document is first created and its data must be written to server storage.
   * External functions can synchronously check the status of initialization via the isInitPromiseResolved property, while
   * asynchronous functions can await the initPromise property.
   *
   * TargetLink documents whose data already exists in server storage can be constructed directly (i.e. new BladesTargetLink(data))
   * without needing to call this method.
   *
   * @param {BladesTargetLink.Data & Schema} data - The combined data object containing both the target link data and the schema data.
   * @returns {Promise<void>} - A promise that resolves when the server update is complete.
   */
  async initTargetLink() {
    this.isInitPromiseResolved = false;
    const data = {
      ...this.linkData,
      ...this.initialSchema
    };
    this.initPromise = new Promise((resolve, reject) => {
      if (this.targetKeyPrefix) {
        const updateData = mergeObject(
          getProperty(this.target, this.targetKeyPrefix) ?? {},
          data
        );
        this.target.update({ [this.targetKeyPrefix]: updateData }, { render: false }).then(() => {
          this.isInitPromiseResolved = true;
          resolve();
        }).catch(reject);
      } else if (this.targetFlagKeyPrefix) {
        const updateData = mergeObject(
          this.target.getFlag(C.SYSTEM_ID, this.targetFlagKeyPrefix) ?? {},
          data
        );
        this.target.setFlag(C.SYSTEM_ID, this.targetFlagKeyPrefix, updateData).then(() => {
          this.isInitPromiseResolved = true;
          resolve();
        }).catch(reject);
      } else {
        reject();
      }
    });
    return this.initPromise;
  }
  async updateTarget(propOrData, valOrWaitFor, waitFor2) {
    if (typeof propOrData === "string") {
      if (getProperty(this.data, propOrData) === valOrWaitFor) {
        return;
      }
      return __privateMethod(this, _updateTargetPropVal, updateTargetPropVal_fn).call(this, propOrData, valOrWaitFor, waitFor2);
    }
    if (typeof propOrData === "object") {
      return __privateMethod(this, _updateTargetViaMerge, updateTargetViaMerge_fn).call(this, propOrData, valOrWaitFor);
    } else {
      throw new Error(`[BladesTargetLink.updateTarget()] Bad updateData for id '${this.id}': ${propOrData}`);
    }
  }
  async updateTargetData(val, waitFor2) {
    if (val) {
      val = {
        ...val,
        ...this.linkData
      };
    }
    await U.waitFor([this.initPromise, waitFor2]);
    if (this.targetFlagKeyPrefix) {
      await this.updateTargetFlag(void 0, val);
    } else {
      await this.updateTargetKey(void 0, val);
    }
  }
  async delete(collection, waitFor2) {
    if (collection) {
      collection.delete(this.id);
    }
    await U.waitFor([this.initPromise, waitFor2]);
    await this.updateTargetData(null);
  }
  // #endregion
};
_ParseChildLinkData = new WeakSet();
ParseChildLinkData_fn = function(childData, parentLinkData) {
  if (!parentLinkData) {
    return childData;
  }
  const keyPrefixParts = "targetKey" in parentLinkData ? [parentLinkData.targetKey] : [parentLinkData.targetFlagKey];
  if (parentLinkData.isScopingById) {
    keyPrefixParts.push(parentLinkData.id);
  }
  const keyPrefix = keyPrefixParts.join(".");
  if ("targetKey" in childData && "targetKey" in parentLinkData) {
    if (childData.targetKey.startsWith(`${keyPrefix}.`)) {
      childData.targetKey = childData.targetKey.slice(keyPrefix.length + 1);
    }
    childData.targetKey = [
      parentLinkData.targetKey,
      parentLinkData.isScopingById ? parentLinkData.id : void 0,
      childData.targetKey
    ].filter(Boolean).join(".");
  } else if ("targetFlagKey" in childData && "targetFlagKey" in parentLinkData) {
    if (childData.targetFlagKey.startsWith(`${keyPrefix}.`)) {
      childData.targetFlagKey = childData.targetFlagKey.slice(keyPrefix.length + 1);
    }
    childData.targetFlagKey = [
      parentLinkData.targetFlagKey,
      parentLinkData.isScopingById ? parentLinkData.id : void 0,
      childData.targetFlagKey
    ].filter(Boolean).join(".");
  } else {
    throw new Error("[BladesTargetLink.ParseChildLinkData] targetKey/targetFlagKey mismatch between provided partialConfig and parentLinkData.");
  }
  return childData;
};
_ParseConfigToData = new WeakSet();
ParseConfigToData_fn = function(config, parentLinkData) {
  if (this.IsValidData(config)) {
    return this.ParseConfigToData(config, parentLinkData);
  }
  const { linkConfig, partialSchema } = this.PartitionSchemaData(config);
  const fullConfig = this.BuildLinkConfig(linkConfig);
  if ("targetKey" in fullConfig) {
    return this.ParseConfigToData({
      id: randomID(),
      ...partialSchema,
      targetID: U.parseDocRefToUUID("target" in fullConfig ? fullConfig.target : fullConfig.targetID),
      targetKey: fullConfig.targetKey
    }, parentLinkData);
  }
  return this.ParseConfigToData({
    id: randomID(),
    ...partialSchema,
    targetID: U.parseDocRefToUUID("target" in fullConfig ? fullConfig.target : fullConfig.targetID),
    targetFlagKey: fullConfig.targetFlagKey
  }, parentLinkData);
};
_updateTargetViaMerge = new WeakSet();
updateTargetViaMerge_fn = async function(updateData, waitFor2) {
  await U.waitFor(waitFor2);
  if (this.targetKeyPrefix) {
    updateData = U.objMap(updateData, false, (key) => `${this.targetKeyPrefix || this.targetFlagKeyPrefix}.${key}`);
    return this.target.update(updateData, { render: false });
  } else if (this.targetFlagKeyPrefix) {
    const existingFlagData = this.target.getFlag(C.SYSTEM_ID, this.targetFlagKeyPrefix) ?? {};
    const flattenedFlagData = flattenObject(existingFlagData);
    const mergedFlagData = mergeObject(flattenedFlagData, updateData);
    return this.target.setFlag(C.SYSTEM_ID, this.targetFlagKeyPrefix, mergedFlagData);
  } else {
    throw new Error(`[BladesTargetLink.#updateTargetViaMerge] Unable to update target data for BladesTargetLink id '${this.id}': Missing both 'targetKeyPrefix' and 'targetFlagKeyPrefix'`);
  }
};
_updateTargetPropVal = new WeakSet();
updateTargetPropVal_fn = async function(prop, val, waitFor2) {
  await U.waitFor(waitFor2);
  if (this.targetKeyPrefix) {
    return this.target.update({ [`${this.targetKeyPrefix}.${prop}`]: val });
  } else if (this.targetFlagKeyPrefix) {
    return this.updateTargetFlag(prop, val);
  }
};
__privateAdd(_BladesTargetLink, _ParseChildLinkData);
/**
 * This private static method is used to transform a configuration object into a data object for BladesTargetLink.
 * It checks if the provided configuration object is already valid data, and if so, returns it directly.
 * Otherwise, it partitions the configuration object into link-specific configuration and additional schema data,
 * constructs a full link configuration, and then creates a data object with a new random ID and the target UUID.
 * The method ensures that either 'targetKey' or 'targetFlagKey' is present and throws an error if the configuration is invalid.
 *
 * @template Schema - The additional schema data required by the subclass.
 * @param {BladesTargetLink.Config | BladesTargetLink.Data & Partial<Schema>} config - The configuration object that may contain BladesTargetLink properties and any subclass-specific schema data.
 * @returns {BladesTargetLink.Data & Partial<Schema>} - The fully constructed data object with necessary properties for BladesTargetLink.
 * @throws {Error} - Throws an error if the configuration object is invalid, lacks a target reference, or if both 'targetKey' and 'targetFlagKey' are provided.
 */
__privateAdd(_BladesTargetLink, _ParseConfigToData);
let BladesTargetLink = _BladesTargetLink;
function isElemPosData(obj) {
  return U.isList(obj) && typeof obj.x === "number" && typeof obj.y === "number" && typeof obj.width === "number" && typeof obj.height === "number";
}
class BladesClockKey extends BladesTargetLink {
  constructor(dataOrConfig) {
    super(dataOrConfig);
    __publicField(this, "positionDragger");
    game.eunoblades.ClockKeys.set(this.id, this);
    Object.values(dataOrConfig.clocksData ?? {}).forEach((clockData) => new BladesClock(clockData));
  }
  // #region STATIC METHODS ~
  static Initialize() {
    function registerClockKeys(doc) {
      if ("clocksData" in doc.system) {
        Object.values(doc.system.clocksData ?? {}).forEach((keyData) => {
          try {
            new BladesClockKey(keyData);
          } catch (err) {
            eLog.error("BladesClockKey", "[BladesClockKey.Initialize] Error initializing clock key.", err, keyData);
          }
        });
      }
    }
    game.items.contents.filter(
      (item) => BladesItem$1.IsType(
        item,
        BladesItemType.clock_keeper,
        BladesItemType.project,
        BladesItemType.cohort_gang,
        BladesItemType.cohort_expert,
        BladesItemType.ritual,
        BladesItemType.design,
        BladesItemType.location,
        BladesItemType.score
      )
    ).forEach(registerClockKeys);
    game.actors.contents.filter(
      (actor) => BladesActor$1.IsType(
        actor,
        BladesActorType.pc,
        BladesActorType.faction
      )
    ).forEach(registerClockKeys);
    return loadTemplates([
      "systems/eunos-blades/templates/components/clock-key.hbs",
      "systems/eunos-blades/templates/components/clock.hbs"
    ]);
  }
  static ApplySchemaDefaults(schemaData) {
    return {
      name: "",
      isVisible: false,
      isNameVisible: false,
      isSpotlit: false,
      clocksData: {},
      sceneIDs: [],
      displayMode: ClockKeyDisplayMode.full,
      oneKeyIndex: U.gsap.utils.random(0, 4, 1),
      ...schemaData
    };
  }
  static async Create(config, _parentLinkData, clocksInitialData = []) {
    if (clocksInitialData.length > 6) {
      eLog.error("BladesClockKey", "[BladesClockKey.Create] Too many clock configs! (Max 6.) Eliminating extras.", clocksInitialData);
      clocksInitialData = clocksInitialData.slice(0, 6);
    } else if (clocksInitialData.length === 0) {
      clocksInitialData.push({});
    }
    const tempLink = new BladesTargetLink(config);
    if (tempLink.targetKeyPrefix) {
      config.clocksData = Object.fromEntries(
        clocksInitialData.map((cSchema, i) => {
          const cData = BladesClock.ParseConfigToData({
            ...BladesClock.ApplySchemaDefaults(cSchema),
            index: i,
            targetID: tempLink.targetID,
            targetKey: `${tempLink.targetKeyPrefix}.clocksData`,
            isScopingById: true
          });
          return [
            cData.id,
            cData
          ];
        })
      );
    } else if (tempLink.targetFlagKeyPrefix) {
      config.clocksData = Object.fromEntries(
        clocksInitialData.map((cSchema, i) => {
          const cData = BladesClock.ParseConfigToData({
            ...BladesClock.ApplySchemaDefaults(cSchema),
            targetID: tempLink.targetID,
            targetFlagKey: `${tempLink.targetFlagKeyPrefix}.clocksData`,
            isScopingById: true
          });
          return [
            cData.id,
            cData
          ];
        })
      );
    } else {
      throw new Error("BladesClockKey.Create: No targetKey or targetFlagKey provided.");
    }
    const clockKeyLink = await super.Create(tempLink.data);
    const clockKey = new BladesClockKey(clockKeyLink.data);
    clockKey.renderTargetAndKeeper();
    return clockKey;
  }
  static GetFromElement(elem) {
    const keyElem$ = $(elem).closest(".clock-key-container").find(".clock-key");
    if (keyElem$.length === 0) {
      return void 0;
    }
    const clockKeyID = keyElem$.attr("id");
    if (!clockKeyID) {
      return void 0;
    }
    return game.eunoblades.ClockKeys.get(clockKeyID);
  }
  // #endregion
  // #region GETTERS & SETTERS ~
  // #region -- Shortcut Schema Getters ~
  get data() {
    return this.linkData;
  }
  get name() {
    return this.data.name;
  }
  set name(val) {
    this.updateTarget("name", val).then(() => {
      this.renderTargetAndKeeper();
    });
  }
  get isVisible() {
    return this.data.isVisible;
  }
  set isVisible(val) {
    this.updateTarget("isVisible", U.pBool(val)).then(() => {
      this.renderTargetAndKeeper();
    });
  }
  get isNameVisible() {
    return this.data.isNameVisible;
  }
  set isNameVisible(val) {
    this.updateTarget("isNameVisible", U.pBool(val)).then(() => {
      this.renderTargetAndKeeper();
    });
  }
  get isSpotlit() {
    return this.data.isSpotlit;
  }
  set isSpotlit(val) {
    this.updateTarget("isSpotlit", val).then(() => {
      this.renderTargetAndKeeper();
    });
  }
  get clocksData() {
    return this.data.clocksData;
  }
  get displayMode() {
    return this.data.displayMode;
  }
  get oneKeyIndex() {
    let { oneKeyIndex } = this.data;
    if (!oneKeyIndex) {
      oneKeyIndex = U.gsap.utils.random(0, 4, 1);
      this.updateTarget("oneKeyIndex", oneKeyIndex).then(() => {
        this.renderTargetAndKeeper();
      });
    }
    return oneKeyIndex;
  }
  get sceneIDs() {
    return this.data.sceneIDs ?? [];
  }
  get overlayPosition() {
    var _a;
    return (_a = this.data.overlayPosition) == null ? void 0 : _a[game.scenes.current.id];
  }
  set overlayPosition(val) {
    if (val) {
      this.updateTarget(`overlayPosition.${game.scenes.current.id}`, val).then(() => {
        this.renderTargetAndKeeper();
      });
    } else {
      this.updateTarget(`overlayPosition.-=${game.scenes.current.id}`, null).then(() => {
        this.renderTargetAndKeeper();
      });
    }
  }
  // #endregion
  get clocks() {
    return new Collection(
      Object.entries(this.clocksData).sort((a, b) => a[1].index - b[1].index).map(([id, data]) => {
        return [id, new BladesClock(data)];
      })
    );
  }
  getClockByID(clockID) {
    return this.clocks.get(clockID);
  }
  getClockByIndex(index) {
    return this.clocks.find((clock) => clock.index === index);
  }
  get size() {
    return this.clocks.size;
  }
  get isComplete() {
    return Array.from(this.clocks).every((clock) => clock.isComplete);
  }
  get isClockKeeperKey() {
    return this.target instanceof BladesClockKeeper$1;
  }
  get isFactionKey() {
    return this.target instanceof BladesFaction$1;
  }
  get isProjectKey() {
    return this.target instanceof BladesProject$1;
  }
  get isScoreKey() {
    return this.target instanceof BladesScore$1;
  }
  get visibleClocks() {
    return this.clocks.filter((clock) => clock.isVisible);
  }
  get activeClocks() {
    return this.visibleClocks.filter((clock) => clock.isActive);
  }
  get inProgressClocks() {
    return this.visibleClocks.filter((clock) => !clock.isComplete && clock.value > 0);
  }
  get unstartedClocks() {
    return this.visibleClocks.filter((clock) => clock.value === 0);
  }
  get completedClocks() {
    return this.visibleClocks.filter((clock) => clock.isComplete);
  }
  get currentClock() {
    if (this.activeClocks.length > 0) {
      return this.getEarliestClock(this.activeClocks);
    }
    if (this.completedClocks.length > 0) {
      return this.getLatestClock(this.completedClocks);
    }
    if (this.visibleClocks.length > 0) {
      return this.getEarliestClock(this.visibleClocks);
    }
    return this.getEarliestClock(Array.from(this.clocks));
  }
  get fullDisplayPosData() {
    const x = this.svgData.width / 2;
    const y = this.svgData.height / 2;
    return {
      x,
      y,
      width: this.svgData.width,
      height: this.svgData.height
    };
  }
  get clocksDisplayPosData() {
    return this.getClocksBoundingBox(Array.from(this.clocks));
  }
  get visibleClocksDisplayPosData() {
    return this.getClocksBoundingBox(this.visibleClocks);
  }
  get activeClocksDisplayPosData() {
    return this.getClocksBoundingBox(this.activeClocks);
  }
  getClocksBoundingBox(clocks) {
    const { size, ...allClocksPosData } = this.svgData.clocks;
    const clocksPosData = Object.fromEntries(
      Object.entries(allClocksPosData).filter(([index]) => clocks.map((clock) => clock.index).includes(U.pInt(index))).map(([index, posData]) => [U.pInt(index), posData])
    );
    const clockWidthPosData = Object.values(clocksPosData).sort((a, b) => a.x - b.x);
    const clockHeightPosData = Object.values(clocksPosData).sort((a, b) => a.y - b.y);
    const xLowest = clockWidthPosData[0].x;
    const xHighest = clockWidthPosData[clockWidthPosData.length - 1].x;
    const yLowest = clockHeightPosData[0].y;
    const yHighest = clockHeightPosData[clockHeightPosData.length - 1].y;
    return {
      // Determine the center point in both x and y axes
      x: (xLowest + xHighest) / 2,
      y: (yLowest + yHighest) / 2,
      // Determine height and width of bounding box, accounting for clock size
      width: xHighest - xLowest + size,
      height: yHighest - yLowest + size
    };
  }
  /** This function accepts any number of arrays of BladesClock, then returns an array
   * containing those BladesClock instances that appear in ALL provided arrays.
   */
  getClocksIn(...clockArrays) {
    if (clockArrays.length === 0)
      return [];
    return clockArrays.reduce((acc, currentArray) => {
      return acc.filter((clock) => currentArray.includes(clock));
    });
  }
  /** This function accepts an array of BladesClock, and returns the BladesClock
   * instance with the lowest index property.
   */
  getEarliestClock(clockArray) {
    if (clockArray.length) {
      return clockArray.sort((a, b) => a.index - b.index)[0];
    }
    return void 0;
  }
  /** This function accepts an array of BladesClock, and returns the BladesClock
   * instance with the highest index property.
   */
  getLatestClock(clockArray) {
    if (clockArray.length) {
      return clockArray.sort((a, b) => b.index - a.index)[0];
    }
    return void 0;
  }
  isInScene(sceneID = game.scenes.current.id) {
    return this.sceneIDs.includes(sceneID);
  }
  get isInCurrentScene() {
    return this.isInScene(game.scenes.current.id);
  }
  get displaySelectOptions() {
    const options = [
      { value: ClockKeyDisplayMode.full, display: "Full Key" },
      { value: ClockKeyDisplayMode.clocks, display: "Clocks" },
      { value: ClockKeyDisplayMode.activeClocks, display: "Active Clocks" }
    ];
    for (let i = 0; i < this.size; i++) {
      options.push(...[
        { value: i, display: `Clock #${i}` },
        { value: `present${i}`, display: `Present Clock #${i}` }
      ]);
    }
    return options;
  }
  // parseClockConfig(config: BladesClock.Config, indexOverride?: ClockIndex): BladesClock.Data {
  //   if (this.size === 6) {throw new Error("Cannot add a clock to a clock key with 6 clocks.");}
  //   if (indexOverride !== undefined && indexOverride < 0) {throw new Error("Cannot add a clock with a negative index.");}
  //   // Remove target so it doesn't conflict with key's targetID
  //   // delete config.target;
  //   const {target, targetID, targetKey, targetFlagKey, ...partialSchema} = config;
  //   const linkData: BladesTargetLink.LinkData = this.targetKey
  //     ? {
  //       targetID: this.targetID,
  //       targetKey: `${this.targetKeyPrefix}.clocksData` as TargetKey
  //     }
  //     : {
  //       targetID: this.targetID,
  //       targetFlagKey: `${this.targetFlagKeyPrefix}.clocksData` as TargetFlagKey
  //     };
  //   // Derive clock's targetID and targetKey/targetFlagKey from key's values
  //   data.targetID = this.targetID;
  //   if (this.targetKey) {
  //     data.targetKey = `${this.targetKeyPrefix}.clocksData` as TargetKey;
  //   } else if (this.targetFlagKey) {
  //     data.targetFlagKey = `${this.targetFlagKeyPrefix}.clocksData` as TargetFlagKey;
  //   }
  //   // Assign 'parentKeyID' and 'index'
  //   config.parentKeyID = this.id;
  //   config.index = indexOverride ?? this.size;
  //   // Parse config to full data object
  //   return BladesClock.ApplySchemaDefaults(
  //     BladesClock.ParseConfigToData(config as BladesClock.Config)
  //   );
  // }
  // #endregion
  // #region HTML INTERACTION ~
  // #region Get Elements$ ~
  getElemFromDisplayContext(displayContext) {
    let elem$;
    const DOM$ = $(".vtt.game.system-eunos-blades");
    switch (displayContext) {
      case ClockDisplayContext.overlay: {
        elem$ = DOM$.find(`#blades-overlay #${this.id}`);
        break;
      }
      case ClockDisplayContext.pcSheet: {
        elem$ = DOM$.find(`.actor.sheet .pc #${this.id}`);
        break;
      }
      case ClockDisplayContext.factionSheet: {
        elem$ = DOM$.find(`.actor.sheet .faction #${this.id}`);
        break;
      }
      case ClockDisplayContext.projectSheet: {
        elem$ = DOM$.find(`.item.sheet .project #${this.id}`);
        break;
      }
      case ClockDisplayContext.scoreSheet: {
        elem$ = DOM$.find(`.item.sheet .score #${this.id}`);
        break;
      }
      case ClockDisplayContext.rollCollab: {
        elem$ = DOM$.find(`.roll-collab-sheet #${this.id}`);
        break;
      }
      case ClockDisplayContext.chatMessage: {
        elem$ = DOM$.find(`#chat #${this.id}`);
        break;
      }
    }
    if (!elem$.length) {
      throw new Error(`[BladesClockKey.getElemFromDisplayContext] Error elem$ not found for key '${this.id}' for display context '${displayContext}'.`);
    }
    return elem$;
  }
  getElements$(displayContext) {
    let elem$;
    if (typeof displayContext === "string") {
      displayContext = this.getElemFromDisplayContext(displayContext);
    }
    elem$ = $(displayContext).find(`#${this.id}`);
    if (!elem$.length) {
      elem$ = $(displayContext).closest(`#${this.id}`);
    }
    if (!(elem$ == null ? void 0 : elem$.length)) {
      throw new Error(`[BladesClockKey.getElements$] Cannot find elements for display context '${displayContext}' of clockKey '${this.id}'.`);
    }
    const keyElems$ = {
      elem$
    };
    if (!elem$.length) {
      throw new Error(`[BladesClockKey.renderClockKey] Error '.clock-key-container' not found for key '${this.id}'.`);
    }
    keyElems$.container$ = elem$.closest(".clock-key-container");
    const imgContainer$ = elem$.find(".key-image-container");
    if (!imgContainer$.length) {
      throw new Error(`[BladesClockKey.renderClockKey] Error '.key-image-container' not found for key '${this.id}'.`);
    }
    keyElems$.imgContainer$ = imgContainer$;
    const label$ = elem$.find(".key-label");
    if (!label$.length) {
      throw new Error(`[BladesClockKey.renderClockKey] Error label$ not found for key '${this.id}'.`);
    }
    keyElems$.label$ = label$;
    const factionLabel$ = elem$.find(".faction-label");
    if (factionLabel$.length) {
      keyElems$.factionLabel$ = factionLabel$;
    }
    const projectLabel$ = elem$.find(".project-label");
    if (projectLabel$.length) {
      keyElems$.projectLabel$ = projectLabel$;
    }
    const scoreLabel$ = elem$.find(".score-label");
    if (scoreLabel$.length) {
      keyElems$.scoreLabel$ = scoreLabel$;
    }
    this.clocks.forEach((clock) => {
      keyElems$.clocks ?? (keyElems$.clocks = {});
      keyElems$.clocks[clock.id] = clock.getElements$(displayContext);
    });
    eLog.checkLog3("BladesClockKey", "Clock Key Elements", keyElems$);
    return keyElems$;
  }
  // #endregion
  // #region Initial Rendering ~
  async renderTo(parentElem) {
    const parent$ = $(parentElem);
    if (!parent$.length) {
      throw new Error(`[BladesClockKey.renderClockKeyTo] Error parent element not provided for key '${this.id}'.`);
    }
    const clockKeyHTML = await renderTemplate(
      "systems/eunos-blades/templates/components/clock-key.hbs",
      this
    );
    $(clockKeyHTML).appendTo(parent$);
  }
  /**
   * This function generates a partial GSAP.TweenVars object that will display the key in a given mode within the bounds of a provided container.
   *
   * @param {ClockKeyDisplayMode | number} [displayMode="full"] - The display mode. Options include:
   * - "full" - displays the entire clock key
   * - "clocks" - zooms in to display only the clocks
   * - "activeClocks" - zooms in to the active clocks
   * - "presentN" (where N is a clock index number) - zooms in to the clock at index N, and presents whichever side has the next available segment towards the camera.
   * - A clock index number - zooms in to the clock at index N
   *
   * @param {HTMLElement | JQuery<HTMLElement> | {x: number, y: number, width: number, height: number}} [container$] - The container within which the key will be displayed.
   * This can be:
   * - An HTMLElement
   * - A JQuery<HTMLElement>
   * - A {x, y, width, height} position definition
   * If not provided, it defaults to the clock key's container element (only if the key is already rendered in the DOM).
   *
   * @returns {gsap.TweenVars} - A partial GSAP.TweenVars object that describes how to display the key in the given mode within the bounds of the provided container. The returned object may include the following properties:
   * - 'scale' (number): A multiple to be applied to scale at "full" display mode.
   * - 'top' (number): A delta vertical shift from "full" display mode position.
   * - 'left' (number): A delta horizontal shift from "full" display mode position.
   * - 'transformOrigin': An absolute value.
   * - 'rotationZ': An absolute value for the keySwing axis.
   * - 'rotationY': An absolute value for rotation in/out of the screen.
   * Any variables left undefined default to "full" display mode.
   */
  getVarsForDisplayMode(keyElems$, displayMode = ClockKeyDisplayMode.full, container$) {
    const keyTweenVars = {};
    const keyImgContTweenVars = {};
    container$ ?? (container$ = keyElems$.container$);
    let targetPosData;
    if (container$ instanceof HTMLElement || container$ instanceof jQuery) {
      const containerPosData = U.gsap.getProperty($(container$)[0]);
      targetPosData = {
        x: containerPosData("x"),
        y: containerPosData("y"),
        width: containerPosData("width"),
        height: containerPosData("height")
      };
    } else if (isElemPosData(container$)) {
      targetPosData = container$;
    } else {
      throw new Error(`[BladesClockKey.getVarsForDisplayMode] Error container$ '${container$}' is not a valid type.`);
    }
    let presentingClock;
    let focusPosData;
    switch (displayMode) {
      case ClockKeyDisplayMode.full: {
        focusPosData = {
          x: this.svgData.width / 2,
          y: this.svgData.height / 2,
          width: this.svgData.width,
          height: this.svgData.height
        };
        break;
      }
      case ClockKeyDisplayMode.clocks: {
        focusPosData = this.getClocksBoundingBox(Array.from(this.clocks));
        break;
      }
      case ClockKeyDisplayMode.activeClocks: {
        focusPosData = this.getClocksBoundingBox(this.getClocksIn(this.activeClocks, this.visibleClocks));
        break;
      }
      case ClockKeyDisplayMode.presentCurrentClock: {
        presentingClock = this.currentClock;
        displayMode = presentingClock.index;
      }
      default: {
        if (typeof displayMode === "string" && displayMode.startsWith("present")) {
          displayMode = U.pInt(displayMode.toString().slice(7));
          presentingClock = this.getClockByIndex(displayMode);
        }
        if (!U.isInt(displayMode) || displayMode < 0 || displayMode >= this.size) {
          throw new Error(`[BladesClockKey.getVarsForDisplayMode] Error display mode '${displayMode}' is not a valid clock index for key '${this.id}'.`);
        }
        const focusClockData = this.svgData.clocks[displayMode];
        focusPosData = {
          x: focusClockData.x,
          y: focusClockData.y,
          width: this.svgData.clocks.size,
          height: this.svgData.clocks.size
        };
        break;
      }
    }
    keyTweenVars.scale = Math.min(
      targetPosData.height / focusPosData.height,
      targetPosData.width / focusPosData.width
    );
    keyImgContTweenVars.top = 0.5 * C.ClockKeySquareSize - focusPosData.y;
    keyImgContTweenVars.left = 0.5 * C.ClockKeySquareSize - focusPosData.x;
    keyImgContTweenVars.transformOrigin = `${focusPosData.x}px ${focusPosData.y}px`;
    keyImgContTweenVars.rotateY = 0;
    if (presentingClock) {
      keyTweenVars.scale *= 2;
      if (presentingClock.getActiveSide() === "left") {
        keyImgContTweenVars.rotateY = 30;
        keyImgContTweenVars.left += this.size === 1 ? 45 : 25;
      } else if (presentingClock.getActiveSide() === "right") {
        keyImgContTweenVars.rotateY = -30;
        keyImgContTweenVars.left -= this.size === 1 ? 45 : 25;
      }
    }
    return { keyTweenVars, keyImgContTweenVars };
  }
  // public fitKeyToContainer(
  //   keyElems$: ClockKeyElems$,
  //   posOverrides?: Partial<ElemPosData & {
  //     xShift: number,
  //     yShift: number,
  //     scaleMult: number
  //   }>
  // ) {
  //   const {container$, elem$, imgContainer$} = keyElems$;
  //   // Get position data for the container$ element (x, y, width, height)
  //   const keyPosition: ElemPosData = {
  //     x: U.gsap.getProperty(container$[0], "x") as number,
  //     y: U.gsap.getProperty(container$[0], "y") as number,
  //     width: U.gsap.getProperty(container$[0], "width") as number,
  //     height: U.gsap.getProperty(container$[0], "height") as number
  //   };
  //   const {xShift, yShift, scaleMult, ...focusPosOverrides} = posOverrides ?? {};
  //   const focusPosition: ElemPosData = {
  //     ...this.fullDisplayPosData,
  //     ...focusPosOverrides
  //   };
  //   eLog.checkLog3("BladesClockKey", "[BladesClockKey] Key Positions", {
  //     keyPosition,
  //     focusPosition,
  //     widthScale: keyPosition.width / focusPosition.width,
  //     heightScale: keyPosition.height / focusPosition.height
  //   });
  //   // Apply scale factor to elem$ to fit default key position inside container$
  //   U.gsap.set(elem$, {
  //     scale: Math.min(
  //       keyPosition.width / focusPosition.width,
  //       keyPosition.height / focusPosition.height
  //     ) * (scaleMult ?? 1)
  //   });
  //   // Apply top, left and transformOrigin value to keyImgContainer, accounting for x/yPercent -50
  //   U.gsap.set(imgContainer$, {
  //     top: (0.5 * C.ClockKeySquareSize) - focusPosition.y + (yShift ?? 0),
  //     left: (0.5 * C.ClockKeySquareSize) - focusPosition.x + (xShift ?? 0),
  //     transformOrigin: `${focusPosition.x + (xShift ?? 0)}px ${focusPosition.y + (yShift ?? 0)}px`
  //   });
  // }
  formatLabels(keyElems$) {
    const { label$, clocks, factionLabel$, projectLabel$, scoreLabel$ } = keyElems$;
    [
      [label$, 2, 4],
      factionLabel$ ? [factionLabel$, 2, 2] : void 0,
      projectLabel$ ? [projectLabel$, 2, 2] : void 0,
      scoreLabel$ ? [scoreLabel$, 2, 2] : void 0,
      ...this.clocks.map((clock) => [clocks[clock.id].clockLabel$, 2.5, 3])
    ].filter(Boolean).forEach(([labelElem$, aspectRatio, maxLines]) => {
      U.adjustTextContainerAspectRatio(labelElem$, aspectRatio, maxLines);
    });
  }
  setToDisplayMode(keyElems$, displayMode, isUpdatingTarget = true) {
    const { keyTweenVars, keyImgContTweenVars } = this.getVarsForDisplayMode(keyElems$, displayMode);
    U.gsap.set(keyElems$.elem$, keyTweenVars);
    U.gsap.set(keyElems$.imgContainer$, keyImgContTweenVars);
    if (isUpdatingTarget && displayMode !== this.displayMode) {
      this.updateTarget("displayMode", displayMode);
    }
  }
  initElementsInContext(html, displayMode, isUpdatingTarget = true) {
    const keyElems$ = this.getElements$(html);
    displayMode ?? (displayMode = this.displayMode);
    this.setToDisplayMode(keyElems$, displayMode, isUpdatingTarget);
    this.formatLabels(keyElems$);
    if (displayMode.toString().startsWith("present") || Number.isInteger(displayMode)) {
      U.gsap.to(keyElems$.container$.find(".clock-label, .clock-key-label"), { autoAlpha: 0, duration: 0 });
    }
    return keyElems$;
  }
  // #endregion
  async addToScene(sceneID = game.scenes.current.id) {
    if (this.isInScene(sceneID)) {
      return;
    }
    const { sceneIDs } = this;
    sceneIDs.push(sceneID);
    await this.updateTarget({
      isVisible: false,
      sceneIDs
    });
    this.renderTargetAndKeeper();
  }
  async removeFromScene(sceneID = game.scenes.current.id) {
    if (!this.isInScene(sceneID)) {
      return;
    }
    const { sceneIDs } = this;
    U.remove(sceneIDs, sceneID);
    await this.updateTarget("sceneIDs", sceneIDs);
    this.renderTargetAndKeeper();
  }
  closeClockKey({ container$ }) {
    container$.remove();
  }
  get svgData() {
    if (this.size === 0) {
      throw new Error("[BladesClockKey.svgData] Error size is 0.");
    }
    const keyData = ClockKey_SVGDATA[this.size];
    let path;
    if (this.size === 1 && keyData.paths) {
      path = keyData.paths[this.oneKeyIndex];
    } else if (keyData.path) {
      path = keyData.path;
    } else {
      throw new Error("[BladesClockKey.svgData] Error path is not defined.");
    }
    return {
      width: keyData.width,
      height: keyData.height,
      path,
      clocks: keyData.clocks
    };
  }
  isInOverlay(elem) {
    return $(elem).hasClass(".overlay-section") || $(elem).closest(".overlay-section").length > 0;
  }
  get keyHeight() {
    return this.svgData.height;
  }
  get keyWidth() {
    return this.svgData.width;
  }
  get keyViewbox() {
    return `0 0 ${this.svgData.width} ${this.svgData.height}`;
  }
  get keyPath() {
    return this.svgData.path;
  }
  get clockSize() {
    return this.svgData.clocks.size;
  }
  getClockPosition(clockIndex = 0) {
    if (clockIndex > this.size) {
      throw new Error(`[BladesClockKey.getClockPosition] Error clockIndex '${clockIndex}' is greater than key size '${this.size}'.`);
    }
    if (clockIndex < 0) {
      throw new Error(`[BladesClockKey.getClockPosition] Error clockIndex '${clockIndex}' is less than 0.`);
    }
    return this.svgData.clocks[clockIndex];
  }
  removePositionDragger() {
    var _a, _b;
    (_a = this.positionDragger) == null ? void 0 : _a.target.remove();
    (_b = this.positionDragger) == null ? void 0 : _b.kill();
    delete this.positionDragger;
  }
  spawnPositionDragger(containerElem$ = game.eunoblades.Director.clockKeySection$) {
    const self = this;
    if (this.positionDragger) {
      this.removePositionDragger();
    }
    const dragElem$ = $(`<div id="Dragger-${this.id}" class="clock-key-container clock-key-dragger" data-size="${this.size}"></div>`).appendTo(containerElem$);
    if (this.overlayPosition) {
      dragElem$.css({
        left: this.overlayPosition.x,
        top: this.overlayPosition.y
      });
    }
    this.positionDragger = new Draggable(dragElem$, {
      type: "top,left",
      onDragStart() {
        $(this.target).css("background", "rgba(255, 255, 0, 0.25)");
        $(this.target).css("outlineColor", "rgba(255, 255, 0, 1)");
      },
      onDragEnd() {
        $(this.target).css("background", "rgba(255, 0, 255, 0.25)");
        $(this.target).css("outlineColor", "rgba(255, 0, 255, 1)");
        self.overlayPosition = { x: this.endX, y: this.endY };
      }
    });
  }
  switchToMode(keyElems$, displayMode, extendKeyVars = {}, extendKeyContainerVars = {}, isUpdatingTarget = true, callback) {
    const { elem$, imgContainer$ } = keyElems$;
    const { keyTweenVars, keyImgContTweenVars } = this.getVarsForDisplayMode(keyElems$, displayMode);
    const currentDisplayMode = this.displayMode;
    const randomID2 = U.gsap.utils.random(1, 1e3, 1);
    return U.gsap.timeline({
      callbackScope: this,
      paused: true,
      onStart() {
        eLog.checkLog2("BladesClockKey", `switchToMode #${randomID2} - START`, { key: this, keyElems$, displayMode });
      },
      onComplete() {
        eLog.checkLog3("BladesClockKey", `switchToMode #${randomID2} - COMPLETE`, { key: this, keyElems$, displayMode });
        if (isUpdatingTarget && displayMode !== this.currentDisplayMode) {
          this.updateTarget("displayMode", displayMode).then(() => callback == null ? void 0 : callback());
        } else {
          callback == null ? void 0 : callback();
        }
      },
      onReverseComplete() {
        eLog.checkLog3("BladesClockKey", `switchToMode #${randomID2} - REVERSE COMPLETE`, { key: this, keyElems$, displayMode });
        if (isUpdatingTarget) {
          this.updateTarget("displayMode", currentDisplayMode);
        }
      }
    }).to(elem$, { ...keyTweenVars, ...extendKeyVars }, 0).to(imgContainer$, { ...keyImgContTweenVars, ...extendKeyContainerVars }, 0);
  }
  // #endregion
  // #region ANIMATED UPDATES (Both GM-Only AND Socket Calls)
  //    #region   > SOCKET CALLS: _SocketCall / static _SocketResponse / _Animation
  fadeInName_Animation(keyElems$) {
    if (!this.name) {
      return void 0;
    }
    return U.gsap.effects.blurReveal(keyElems$.label$, {
      ignoreMargin: true,
      duration: 0.75
    });
  }
  async fadeInName_SocketCall(displayContext) {
    if (!game.user.isGM) {
      return;
    }
    socketlib.system.executeForEveryone("fadeInName_SocketCall", displayContext, this.id);
  }
  static fadeInName_SocketResponse(displayContext, keyID) {
    const key = game.eunoblades.ClockKeys.get(keyID);
    if (!key) {
      return;
    }
    key.fadeInName_Animation(key.getElements$(displayContext));
  }
  fadeOutName_Animation(keyElems$) {
    if (!this.name) {
      return void 0;
    }
    return U.gsap.effects.blurRemove(keyElems$.label$, {
      ignoreMargin: true,
      duration: 0.75
    });
  }
  async fadeOutName_SocketCall(displayContext) {
    if (!game.user.isGM) {
      return;
    }
    this.fadeOutName_Animation(this.getElements$(displayContext));
    socketlib.system.executeForOthers("fadeOutName_SocketCall", displayContext, this.id);
  }
  static fadeOutName_SocketResponse(displayContext, keyID) {
    const key = game.eunoblades.ClockKeys.get(keyID);
    if (!key) {
      return;
    }
    key.fadeOutName_Animation(key.getElements$(displayContext));
  }
  //    #endregion
  // #endregion
  // #region Adding & Removing Clocks ~
  async updateClockIndices() {
    await this.updateTarget("clocksData", Object.fromEntries(
      Object.entries(this.clocksData).map(([id, data], index) => [id, { ...data, index }])
    ));
    return this.clocks;
  }
  async addClock(clockSchema = {}) {
    const cData = BladesClock.ParseConfigToData({
      ...BladesClock.ApplySchemaDefaults(clockSchema),
      index: this.size,
      targetID: this.targetID,
      targetKey: `${this.targetKeyPrefix}.clocksData`,
      isScopingById: true
    });
    await this.updateTarget(`clocksData.${cData.id}`, cData);
    void this.clocks;
    this.renderTargetAndKeeper();
  }
  async deleteClock(clockID) {
    var _a, _b;
    if (this.size <= 1) {
      throw new Error("[BladesClockKey.deleteClock()] Cannot reduce number of clocks below 1!");
    }
    clockID ?? (clockID = (_a = Array.from(this.clocks).pop()) == null ? void 0 : _a.id);
    if (!clockID) {
      return;
    }
    await ((_b = this.getClockByID(clockID)) == null ? void 0 : _b.delete());
    await this.updateClockIndices();
    void this.clocks;
  }
  // #endregion
  // #region OVERRIDES: Async Update Methods
  renderTargetAndKeeper() {
    var _a;
    this.renderTarget();
    (_a = game.eunoblades.ClockKeeper.sheet) == null ? void 0 : _a.render();
  }
  renderTarget() {
    var _a;
    (_a = this.target.sheet) == null ? void 0 : _a.render();
  }
  // #endregion
}
class BladesClock extends BladesTargetLink {
  // #region STATIC METHODS ~
  static ApplySchemaDefaults(schemaData) {
    const namedValueMax = {
      name: schemaData.name ?? "",
      value: schemaData.value ?? 0,
      max: schemaData.max ?? 8
    };
    return {
      index: 0,
      color: ClockColor.white,
      isVisible: !U.isInt(schemaData.index) || schemaData.index === 0,
      isNameVisible: false,
      isHighlighted: false,
      isActive: !U.isInt(schemaData.index) || schemaData.index === 0,
      ...schemaData,
      ...namedValueMax
    };
  }
  // #endregion
  // #region GETTERS & SETTERS ~
  get canEdit() {
    console.log("NOTE: All Clocks currently Editable; see line 71 of BladesClock.ts");
    return this.isVisible && this.isActive;
  }
  get data() {
    return this.linkData;
  }
  get name() {
    return this.data.name;
  }
  set name(val) {
    this.updateTarget("name", val).then(() => {
      this.parentKey.renderTargetAndKeeper();
    });
  }
  get value() {
    return U.pInt(this.data.value);
  }
  set value(val) {
    this.updateTarget("value", U.pInt(val)).then(() => {
      this.parentKey.renderTargetAndKeeper();
    });
  }
  get max() {
    return U.pInt(this.data.max);
  }
  set max(val) {
    this.updateTarget("max", U.pInt(val)).then(() => {
      this.parentKey.renderTargetAndKeeper();
    });
  }
  get color() {
    return this.data.color ?? ClockColor.white;
  }
  set color(val) {
    this.updateTarget("color", val).then(() => {
      this.parentKey.renderTargetAndKeeper();
    });
  }
  get isActive() {
    return U.pBool(this.data.isActive);
  }
  set isActive(val) {
    this.updateTarget("isActive", U.pBool(val)).then(() => {
      this.parentKey.renderTargetAndKeeper();
    });
  }
  get parentKey() {
    const pKey = game.eunoblades.ClockKeys.get(this.data.parentKeyID);
    if (!pKey) {
      throw new Error(`[BladesClockKey.parentKey] No parent key found for clock ${this.id}`);
    }
    return pKey;
  }
  get isNameVisible() {
    return U.pBool(this.data.isNameVisible);
  }
  set isNameVisible(val) {
    this.updateTarget("isNameVisible", U.pBool(val)).then(() => {
      this.parentKey.renderTargetAndKeeper();
    });
  }
  get isVisible() {
    return U.pBool(this.data.isVisible);
  }
  set isVisible(val) {
    this.updateTarget("isVisible", U.pBool(val)).then(() => {
      this.parentKey.renderTargetAndKeeper();
    });
  }
  get isHighlighted() {
    return U.pBool(this.data.isHighlighted);
  }
  set isHighlighted(val) {
    this.updateTarget("isHighlighted", U.pBool(val)).then(() => {
      this.parentKey.renderTargetAndKeeper();
    });
  }
  get index() {
    return U.pInt(this.data.index);
  }
  set index(val) {
    this.updateTarget("index", U.pInt(val)).then(() => {
      this.parentKey.renderTargetAndKeeper();
    });
  }
  get isEmpty() {
    return this.value === 0;
  }
  get isComplete() {
    return this.value >= this.max;
  }
  get rollOppClock() {
    return this;
  }
  get rollOppName() {
    return this.name;
  }
  get rollOppType() {
    return "clock";
  }
  get colorSelectOptions() {
    return [
      { value: ClockColor.white, display: "🔘" },
      { value: ClockColor.yellow, display: "📀" },
      { value: ClockColor.cyan, display: "🔵" },
      { value: ClockColor.red, display: "🔴" }
    ];
  }
  get maxSelectOptions() {
    return [
      { value: 2, display: 2 },
      { value: 3, display: 3 },
      { value: 4, display: 4 },
      { value: 5, display: 5 },
      { value: 6, display: 6 },
      { value: 8, display: 8 },
      { value: 10, display: 10 },
      { value: 12, display: 12 }
    ];
  }
  get valueSelectOptions() {
    const returnVals = [];
    for (let i = 0; i <= this.max; i++) {
      returnVals.push({ value: i, display: i });
    }
    return returnVals;
  }
  // Returns which hemisphere of the clock will show the final change if segmentDelta segments are added/removed.
  getActiveSide(segmentDelta = 0) {
    const finalClockValue = Math.min(this.max, Math.max(0, this.value + segmentDelta));
    const halfClockValue = this.max / 2;
    if (segmentDelta === 0) {
      return finalClockValue >= halfClockValue ? "left" : "right";
    }
    return finalClockValue > halfClockValue ? "left" : "right";
  }
  // #endregion
  // #region HTML INTERACTION ~
  getElemFromDisplayContext(displayContext) {
    let elem$;
    const DOM$ = $(".vtt.game.system-eunos-blades");
    switch (displayContext) {
      case ClockDisplayContext.overlay: {
        elem$ = DOM$.find(`#blades-overlay #${this.id}`);
        break;
      }
      case ClockDisplayContext.pcSheet: {
        elem$ = DOM$.find(`.actor.sheet .pc #${this.id}`);
        break;
      }
      case ClockDisplayContext.factionSheet: {
        elem$ = DOM$.find(`.actor.sheet .faction #${this.id}`);
        break;
      }
      case ClockDisplayContext.projectSheet: {
        elem$ = DOM$.find(`.item.sheet .project #${this.id}`);
        break;
      }
      case ClockDisplayContext.scoreSheet: {
        elem$ = DOM$.find(`.item.sheet .score #${this.id}`);
        break;
      }
      case ClockDisplayContext.rollCollab: {
        elem$ = DOM$.find(`.roll-collab-sheet #${this.id}`);
        break;
      }
      case ClockDisplayContext.chatMessage: {
        elem$ = DOM$.find(`#chat #${this.id}`);
        break;
      }
    }
    if (!elem$.length) {
      throw new Error(`[BladesClockKey.getElemFromDisplayContext] Error elem$ not found for key '${this.id}' for display context '${displayContext}'.`);
    }
    return elem$;
  }
  getElements$(displayContext) {
    let elem$;
    if (typeof displayContext === "string") {
      displayContext = this.getElemFromDisplayContext(displayContext);
    }
    elem$ = $(displayContext).find(`#${this.id}`);
    if (!elem$.length) {
      elem$ = $(displayContext).closest(`#${this.id}`);
    }
    if (!(elem$ == null ? void 0 : elem$.length)) {
      throw new Error(`[BladesClock.getElements$] Cannot find elements for display context '${displayContext}' of clock '${this.id}' of key '${this.parentKey.id}'.`);
    }
    const clockElems$ = {
      clockElem$: elem$
    };
    const container$ = elem$.closest(".clock-container");
    if (!container$.length) {
      throw new Error(`[BladesClock.getElements$] Error '.clock-container' not found for clock '${this.id}' of key '${this.parentKey.id}'.`);
    }
    clockElems$.clockContainer$ = container$;
    const label$ = elem$.find(".clock-label");
    if (!label$.length) {
      throw new Error(`[BladesClock.getElements$] Error '.clock-label' not found for clock '${this.id}' of key '${this.parentKey.id}'.`);
    }
    clockElems$.clockLabel$ = label$;
    const bg$ = elem$.find(".clock-bg");
    if (!bg$.length) {
      throw new Error(`[BladesClock.getElements$] Error '.clock-bg' not found for clock '${this.id}' of key '${this.parentKey.id}'.`);
    }
    clockElems$.bg$ = bg$;
    const frame$ = elem$.find(".clock-frame");
    if (!frame$.length) {
      throw new Error(`[BladesClock.getElements$] Error '.clock-frame' not found for clock '${this.id}' of key '${this.parentKey.id}'.`);
    }
    clockElems$.frame$ = frame$;
    const fill$ = elem$.find(".clock-fill");
    if (!fill$.length) {
      throw new Error(`[BladesClock.getElements$] Error '.clock-fill' not found for clock '${this.id}' of key '${this.parentKey.id}'.`);
    }
    clockElems$.fill$ = fill$;
    const glow$ = elem$.find(".clock-glow");
    if (!glow$.length) {
      throw new Error(`[BladesClock.getElements$] Error '.clock-glow' not found for clock '${this.id}' of key '${this.parentKey.id}'.`);
    }
    clockElems$.glow$ = glow$;
    const cover$ = elem$.find(".clock-cover");
    if (!cover$.length) {
      throw new Error(`[BladesClock.getElements$] Error '.clock-cover' not found for clock '${this.id}' of key '${this.parentKey.id}'.`);
    }
    clockElems$.cover$ = cover$;
    const oneSegments$ = elem$.find(".clock-one-segment");
    if (oneSegments$.length !== 3) {
      throw new Error(`[BladesClock.getElements$] Error '.clock-one-segment' elements not found for clock '${this.id}' of key '${this.parentKey.id}'.`);
    }
    clockElems$.oneSegments$ = oneSegments$;
    return clockElems$;
  }
  // #endregion
  // #region ANIMATED UPDATES (Both GM-Only AND Socket Calls)
  reveal_Animation(clockElems$, callback) {
    const fadeInElements = [
      clockElems$.frame$,
      clockElems$.fill$
    ].filter((el$) => el$ !== void 0);
    const tl = U.gsap.timeline({
      callbackScope: this,
      onComplete() {
        callback == null ? void 0 : callback();
      }
    });
    tl.to(clockElems$.cover$, { scale: 2, autoAlpha: 0, duration: 0.5, ease: "power2" });
    tl.fromTo(fadeInElements, {
      autoAlpha: 0,
      scale: 2
    }, {
      autoAlpha: 1,
      scale: 1,
      duration: 0.5,
      stagger: 0.2,
      ease: "power2"
    });
    if (this.name && this.isNameVisible) {
      tl.blurReveal(clockElems$.clockLabel$, {
        ignoreMargin: true,
        duration: 0.75
      }, "<+0.05");
    }
    if (this.isHighlighted) {
      tl.scaleUpReveal(clockElems$.glow$, {
        scale: 3,
        duration: 0.5
      }, "<+0.05");
    }
    if (this.isActive) {
      tl.add(() => this.activate_Animation(clockElems$), "<+0.05");
    } else {
      tl.add(() => this.deactivate_Animation(clockElems$), "<+0.05");
    }
    return tl;
  }
  async reveal_SocketCall(displayContext) {
    if (!game.user.isGM) {
      return;
    }
    socketlib.system.executeForEveryone("reveal_SocketCall", displayContext, this.parentKey.id, this.index);
  }
  static reveal_SocketResponse(displayContext, keyID, index) {
    const key = game.eunoblades.ClockKeys.get(keyID);
    if (!(key == null ? void 0 : key.isVisible)) {
      return;
    }
    const clock = key.getClockByIndex(index);
    if (!clock) {
      return;
    }
    const clockElems$ = clock.getElements$(displayContext);
    clock.reveal_Animation(clockElems$);
  }
  hide_Animation(clockElems$, callback) {
    const fadeOutElements = [
      clockElems$.frame$,
      clockElems$.fill$
    ].filter((el$) => el$ !== void 0);
    const tl = U.gsap.timeline({
      callbackScope: this,
      onComplete() {
        callback == null ? void 0 : callback();
      }
    });
    tl.to(fadeOutElements, {
      autoAlpha: 0,
      scale: 2,
      duration: 0.5,
      stagger: 0.2,
      ease: "power2"
    });
    if (this.name && this.isNameVisible) {
      tl.blurRemove(clockElems$.clockLabel$, {
        ignoreMargin: true,
        duration: 0.75
      }, "<+0.05");
    }
    if (this.isHighlighted) {
      tl.scaleDownRemove(clockElems$.glow$, {
        scale: 3,
        duration: 0.5
      }, "<+0.05");
    }
    tl.to(clockElems$.cover$, { scale: 1, autoAlpha: 1, duration: 0.5, ease: "power2" });
    return tl;
  }
  async hide_SocketCall(displayContext) {
    if (!game.user.isGM) {
      return;
    }
    socketlib.system.executeForEveryone("hide_SocketCall", displayContext, this.parentKey.id, this.index);
  }
  static hide_SocketResponse(displayContext, keyID, index) {
    const key = game.eunoblades.ClockKeys.get(keyID);
    if (!(key == null ? void 0 : key.isVisible)) {
      return;
    }
    const clock = key.getClockByIndex(index);
    if (!clock) {
      return;
    }
    const clockElems$ = clock.getElements$(displayContext);
    clock.hide_Animation(clockElems$);
  }
  activate_Animation(clockElems$, callback) {
    U.gsap.to(clockElems$.bg$, { autoAlpha: 1, duration: 0.5, ease: "power2" });
    U.gsap.to(clockElems$.frame$, {
      filter: "brightness(0.5)",
      duration: 0.5,
      ease: "power2",
      onComplete: callback
    });
  }
  async activate_SocketCall(displayContext) {
    if (!game.user.isGM) {
      return;
    }
    socketlib.system.executeForEveryone("activate_SocketCall", displayContext, this.parentKey.id, this.index);
  }
  static activate_SocketResponse(displayContext, keyID, index) {
    const key = game.eunoblades.ClockKeys.get(keyID);
    if (!(key == null ? void 0 : key.isVisible)) {
      return;
    }
    const clock = key.getClockByIndex(index);
    if (!clock) {
      return;
    }
    clock.activate_Animation(clock.getElements$(displayContext));
  }
  deactivate_Animation(clockElems$, callback) {
    U.gsap.to(clockElems$.bg$, { autoAlpha: 0, duration: 0.5, ease: "power2" });
    U.gsap.to(clockElems$.frame$, {
      filter: "brightness(1) blur(5px)",
      duration: 0.5,
      ease: "power2",
      onComplete: callback
    });
  }
  async deactivate_SocketCall(displayContext) {
    if (!game.user.isGM) {
      return;
    }
    socketlib.system.executeForEveryone("deactivate_SocketCall", displayContext, this.parentKey.id, this.index);
  }
  static deactivate_SocketResponse(displayContext, keyID, index) {
    const key = game.eunoblades.ClockKeys.get(keyID);
    if (!(key == null ? void 0 : key.isVisible)) {
      return;
    }
    const clock = key.getClockByIndex(index);
    if (!clock) {
      return;
    }
    clock.deactivate_Animation(clock.getElements$(displayContext));
  }
  fadeInClockName_Animation(clockElems$) {
    U.gsap.effects.blurReveal(clockElems$.clockLabel$, {
      ignoreMargin: true,
      duration: 0.75
    });
  }
  async fadeInClockName_SocketCall(displayContext) {
    if (!game.user.isGM) {
      return;
    }
    socketlib.system.executeForEveryone("fadeInClockName_SocketCall", displayContext, this.parentKey.id, this.index);
  }
  static fadeInClockName_SocketResponse(displayContext, keyID, index) {
    const key = game.eunoblades.ClockKeys.get(keyID);
    if (!(key == null ? void 0 : key.isVisible)) {
      return;
    }
    const clock = key.getClockByIndex(index);
    if (!clock) {
      return;
    }
    clock.fadeInClockName_Animation(clock.getElements$(displayContext));
  }
  fadeOutClockName_Animation(clockElems$) {
    U.gsap.effects.blurRemove(clockElems$.clockLabel$, {
      ignoreMargin: true,
      duration: 0.75
    });
  }
  async fadeOutClockName_SocketCall(displayContext) {
    if (!game.user.isGM) {
      return;
    }
    socketlib.system.executeForEveryone("fadeOutClockName_SocketCall", displayContext, this.parentKey.id, this.index);
  }
  static fadeOutClockName_SocketResponse(displayContext, keyID, index) {
    const key = game.eunoblades.ClockKeys.get(keyID);
    if (!(key == null ? void 0 : key.isVisible)) {
      return;
    }
    const clock = key.getClockByIndex(index);
    if (!clock) {
      return;
    }
    clock.fadeOutClockName_Animation(clock.getElements$(displayContext));
  }
  highlight_Animation(clockElems$) {
    U.gsap.effects.scaleUpReveal(clockElems$.glow$, {
      duration: 0.5,
      scale: 3
    });
  }
  async highlight_SocketCall(displayContext) {
    if (!game.user.isGM) {
      return;
    }
    socketlib.system.executeForEveryone("highlight_SocketCall", displayContext, this.parentKey.id, this.index);
  }
  static highlight_SocketResponse(displayContext, keyID, index) {
    const key = game.eunoblades.ClockKeys.get(keyID);
    if (!(key == null ? void 0 : key.isVisible)) {
      return;
    }
    const clock = key.getClockByIndex(index);
    if (!clock) {
      return;
    }
    clock.highlight_Animation(clock.getElements$(displayContext));
  }
  unhighlight_Animation(clockElems$) {
    U.gsap.effects.scaleDownRemove(clockElems$.glow$, {
      duration: 0.5,
      scale: 3
    });
  }
  async unhighlight_SocketCall(displayContext) {
    if (!game.user.isGM) {
      return;
    }
    socketlib.system.executeForEveryone("unhighlight_SocketCall", displayContext, this.parentKey.id, this.index);
  }
  static unhighlight_SocketResponse(displayContext, keyID, index) {
    const key = game.eunoblades.ClockKeys.get(keyID);
    if (!(key == null ? void 0 : key.isVisible)) {
      return;
    }
    const clock = key.getClockByIndex(index);
    if (!clock) {
      return;
    }
    clock.unhighlight_Animation(clock.getElements$(displayContext));
  }
  getRotationOfSegment(segment) {
    const stepSize = 360 / this.max;
    return stepSize * (segment - 1);
  }
  initOneSegments(clockElems$, segmentNums, isReversing) {
    if (segmentNums.length > 3) {
      throw new Error(`Too many segments: [${segmentNums.join(", ")}]`);
    }
    const oneSegs = [...clockElems$.oneSegments$];
    const oneSegsToAnimate = Array.from(clockElems$.oneSegments$).slice(0, segmentNums.length);
    for (const segmentNum of segmentNums) {
      const oneSegment = oneSegs.shift();
      U.gsap.set(oneSegment, {
        rotation: this.getRotationOfSegment(segmentNum),
        autoAlpha: isReversing ? 1 : 0
      });
    }
    if (isReversing) {
      clockElems$.clockElem$.attr("data-value", U.getLast(segmentNums) - 1);
    }
    return oneSegsToAnimate;
  }
  changeSegments_Animation(clockElems$, startVal, endVal, callback) {
    startVal = U.gsap.utils.clamp(0, this.max, startVal);
    endVal = U.gsap.utils.clamp(0, this.max, endVal);
    let delta = endVal - startVal;
    if (delta === 0) {
      return;
    }
    const segmentNums = [];
    if (delta < 0) {
      while (Math.abs(delta) > startVal) {
        delta++;
      }
      for (let i = startVal; i > endVal; i--) {
        segmentNums.push(i);
      }
    } else {
      while (endVal > this.max) {
        delta--;
      }
      for (let i = startVal + 1; i <= endVal; i++) {
        segmentNums.push(i);
      }
    }
    const segmentsToAnimate = this.initOneSegments(clockElems$, segmentNums, startVal > endVal);
    eLog.checkLog3("BladesClock", "changeSegments_Animation", { clockElems$, delta, segmentNums, startVal, endVal, segmentsToAnimate });
    const tl = U.gsap.timeline();
    if (delta > 0) {
      tl.fromTo(segmentsToAnimate, {
        autoAlpha: 0,
        scale: 2
      }, {
        autoAlpha: 1,
        scale: 1,
        duration: 0.5,
        stagger: 0.2,
        ease: "power2",
        callbackScope: this,
        onComplete() {
          clockElems$.clockElem$.attr("data-value", endVal);
          U.gsap.to(segmentsToAnimate, {
            autoAlpha: 0,
            duration: 0.5,
            stagger: 0.2
            // onComplete() {
            //   // Return clock key to original size and focus
            //   clockFocusTimeline.reverse();
            // }
          });
        }
      });
    } else {
      tl.fromTo(segmentsToAnimate, {
        autoAlpha: 1,
        scale: 1
      }, {
        autoAlpha: 0,
        scale: 2,
        duration: 0.5,
        stagger: 0.2,
        ease: "power2"
        // onComplete() {
        //   // Return clock key to original size and focus
        //   clockFocusTimeline.reverse();
        // }
      });
    }
    return tl;
  }
  async changeSegments_SocketCall(displayContext, startVal, endVal) {
    if (!game.user.isGM) {
      return;
    }
    startVal = U.gsap.utils.clamp(0, this.max, startVal);
    endVal = U.gsap.utils.clamp(0, this.max, endVal);
    socketlib.system.executeForEveryone("changeSegments_SocketCall", displayContext, this.parentKey.id, this.index, startVal, endVal);
  }
  static changeSegments_SocketResponse(displayContext, keyID, index, startVal, endVal) {
    const key = game.eunoblades.ClockKeys.get(keyID);
    if (!(key == null ? void 0 : key.isVisible)) {
      return;
    }
    const clock = key.getClockByIndex(index);
    if (!clock) {
      return;
    }
    clock.changeSegments_Animation(clock.getElements$(displayContext), startVal, endVal);
  }
  // #endregion
  // #region Adding/Removing Clock Segments ~
  // Returns number of segments beyond max (or 0, if max not met)
  async fillSegments(count, isSilent = false) {
    const clockOverflow = Math.max(0, this.value + count - this.max);
    count = Math.min(this.value + count, this.max) - this.value;
    if (count === 0) {
      return clockOverflow;
    }
    await this.updateTarget("value", this.value + count);
    if (!isSilent) {
      this.parentKey.renderTargetAndKeeper();
    }
    return clockOverflow;
  }
  // Returns (positive) number of segments removed
  // in excess of the number of segments in the clock
  async clearSegments(count, isSilent = false) {
    const clockOverflow = Math.max(0, count - this.value);
    count = Math.min(this.value, count);
    if (count === 0) {
      return clockOverflow;
    }
    await this.updateTarget("value", this.value - count);
    if (!isSilent) {
      this.parentKey.renderTargetAndKeeper();
    }
    return clockOverflow;
  }
  async delete() {
    const { parentKey } = this;
    await super.delete(false);
    parentKey.updateClockIndices();
  }
  // #endregion
}
const _BladesDirector = class _BladesDirector {
  constructor() {
    __publicField(this, "_id");
    // #endregion
    // #endregion
    // #region OVERLAY ~
    // #region  >> Overlay Elements$ ~
    __publicField(this, "_overlayContainer");
    __publicField(this, "_overlayContainer$");
    // - As with notifications: placeholder animation until something more final can be coded.
    // #endregion
    // #region TOOLTIPS ~
    __publicField(this, "_tooltipObserver");
    __publicField(this, "_tooltipElems", /* @__PURE__ */ new Map());
    __publicField(this, "_displayedTooltipID");
    this._id = randomID();
  }
  static getInstance() {
    return _BladesDirector.instance ?? (_BladesDirector.instance = new _BladesDirector());
  }
  // #endregion
  static async Initialize() {
    Hooks.on("renderApplication", async () => {
      game.eunoblades.Director.initClockKeySection(true);
      if (game.user.isGM) {
        await game.eunoblades.ClockKeeper.update({ "system.targetScene": game.scenes.current.id });
        game.eunoblades.ClockKeeper.render();
      }
    });
    return loadTemplates([
      "systems/eunos-blades/templates/overlay/blades-overlay.hbs",
      "systems/eunos-blades/templates/overlay/location.hbs",
      "systems/eunos-blades/templates/overlay/score-panel.hbs",
      "systems/eunos-blades/templates/overlay/npc-portrait.hbs",
      "systems/eunos-blades/templates/overlay/pc-portrait.hbs",
      "systems/eunos-blades/templates/overlay/cohort-portrait.hbs",
      "systems/eunos-blades/templates/overlay/crew-status-bar.hbs",
      "systems/eunos-blades/templates/overlay/game-phase-bar.hbs",
      "systems/eunos-blades/templates/overlay/notices/push.hbs"
    ]);
  }
  // #region   >>  Sockets ~
  static InitSockets() {
    const director = _BladesDirector.getInstance();
    socketlib.system.register("renderOverlay_SocketCall", director.renderOverlay_SocketResponse.bind(director));
    director.initClockSockets();
    director.initScorePanelSockets();
    director.initLocationSockets();
    director.initNPCSockets();
    director.initPCSockets();
    director.initCohortSockets();
    director.initCrewSockets();
    director.initNotificationSockets();
    director.initTransitionSockets();
  }
  get overlayContainer() {
    if (!this._overlayContainer) {
      [this._overlayContainer] = $("#blades-overlay");
    }
    if (!this._overlayContainer) {
      $("body.vtt").append('<section id="blades-overlay"></section>');
      [this._overlayContainer] = $("#blades-overlay");
    }
    return this._overlayContainer;
  }
  get overlayContainer$() {
    if (!this._overlayContainer$) {
      this._overlayContainer$ = $(this.overlayContainer);
    }
    return this._overlayContainer$;
  }
  get clockKeySection$() {
    return this.overlayContainer$.find(".overlay-section-clock-keys");
  }
  get locationSection$() {
    return this.overlayContainer$.find(".overlay-section-location");
  }
  get scorePanelSection$() {
    return this.overlayContainer$.find(".overlay-section-score-panel");
  }
  get npcSection$() {
    return this.overlayContainer$.find(".overlay-section-npcs");
  }
  get playerSection$() {
    return this.overlayContainer$.find(".overlay-section-players");
  }
  get crewSection$() {
    return this.overlayContainer$.find(".overlay-section-crew");
  }
  get notificationSection$() {
    return this.overlayContainer$.find(".overlay-section-notifications");
  }
  get transitionSection$() {
    return this.overlayContainer$.find(".overlay-section-transitions");
  }
  get tooltipSection$() {
    return this.overlayContainer$.find(".overlay-section-tooltips");
  }
  get svgData() {
    return ClockKey_SVGDATA;
  }
  // #endregion
  // #region  >> Rendering ~
  renderOverlay_SocketCall() {
    if (!game.user.isGM) {
      return;
    }
    if (!this.overlayContainer) {
      return;
    }
    socketlib.system.executeForEveryone("renderOverlay_SocketCall");
  }
  async renderOverlay_SocketResponse() {
    const overlayContent = await renderTemplate(
      "systems/eunos-blades/templates/overlay/blades-overlay.hbs",
      this
    );
    this.overlayContainer$.empty().append(overlayContent);
    this.initClockKeySection();
    this.initTooltipSection();
  }
  // #endregion
  // #endregion
  // #region CLOCKS & CLOCK KEYS ~
  // #region   >> INITIALIZATION ~
  initClockKeySection(isResetting = false) {
    if (isResetting) {
      this.clockKeySection$.empty();
    }
    const visibleSceneKeys = U.shuffle(this.sceneKeys.filter((key) => key.isVisible));
    let staggerDelay = 0;
    while (visibleSceneKeys.length) {
      const key = visibleSceneKeys.shift();
      if (key) {
        setTimeout(() => this.renderClockKey(key), staggerDelay * 1e3);
        staggerDelay += 0.5;
      }
    }
    setTimeout(() => {
    }, staggerDelay * 1e3);
  }
  initClockSockets() {
    socketlib.system.register("renderClockKey_SocketCall", _BladesDirector.renderClockKey_SocketResponse.bind(_BladesDirector));
    socketlib.system.register("pullKey_SocketCall", _BladesDirector.pullKey_SocketResponse.bind(_BladesDirector));
    socketlib.system.register("fadeInName_SocketCall", BladesClockKey.fadeInName_SocketResponse.bind(BladesClockKey));
    socketlib.system.register("fadeOutName_SocketCall", BladesClockKey.fadeOutName_SocketResponse.bind(BladesClockKey));
    socketlib.system.register("reveal_SocketCall", BladesClock.reveal_SocketResponse.bind(BladesClock));
    socketlib.system.register("hide_SocketCall", BladesClock.hide_SocketResponse.bind(BladesClock));
    socketlib.system.register("activate_SocketCall", BladesClock.activate_SocketResponse.bind(BladesClock));
    socketlib.system.register("deactivate_SocketCall", BladesClock.deactivate_SocketResponse.bind(BladesClock));
    socketlib.system.register("fadeInClockName_SocketCall", BladesClock.fadeInClockName_SocketResponse.bind(BladesClock));
    socketlib.system.register("fadeOutClockName_SocketCall", BladesClock.fadeOutClockName_SocketResponse.bind(BladesClock));
    socketlib.system.register("highlight_SocketCall", BladesClock.highlight_SocketResponse.bind(BladesClock));
    socketlib.system.register("unhighlight_SocketCall", BladesClock.unhighlight_SocketResponse.bind(BladesClock));
    socketlib.system.register("changeSegments_SocketCall", BladesClock.changeSegments_SocketResponse.bind(BladesClock));
  }
  // #endregion
  get sceneKeys() {
    return game.eunoblades.ClockKeeper.getSceneKeys(game.scenes.current.id);
  }
  // #region   >> Rendering (Dropping) Clock Keys ~
  dropKey_Animation(key, keyElems$) {
    const {
      container$,
      label$,
      imgContainer$,
      clocks
    } = keyElems$ ?? key.getElements$(game.eunoblades.Director.clockKeySection$);
    const keySwingTimeline = imgContainer$.data("keySwingTimeline");
    const tl = U.gsap.timeline().call(() => {
      keySwingTimeline.seek("NEUTRAL").play();
    }).from(container$, {
      y: -800,
      ease: "bounce",
      duration: 1
    }, 0).to(container$, { autoAlpha: 1, duration: 0.5, ease: "power2" }, 0);
    key.visibleClocks.forEach((clock, i) => {
      tl.add(
        () => {
          clock.reveal_Animation(clocks[clock.id]);
        },
        i === 0 ? ">" : "<+0.15"
      );
    });
    if (key.name && key.isNameVisible) {
      tl.blurReveal(label$, {
        ignoreMargin: true,
        duration: 0.75
      }, "<+0.05");
    }
  }
  prepareClockKeyTimelines(key, keyElems$) {
    const { container$, imgContainer$, elem$, label$, clocks } = keyElems$;
    U.gsap.set(container$, { pointerEvents: "auto" });
    U.gsap.set(elem$, { filter: "brightness(1)" });
    U.gsap.set(imgContainer$, { transformOrigin: "50% 10%" });
    const keyElemScale = U.gsap.getProperty(container$[0], "scale");
    imgContainer$.data(
      "keySwingTimeline",
      U.gsap.timeline({ paused: true, repeat: -1, yoyo: true }).fromTo(imgContainer$, { rotateZ: -1 }, { rotateZ: 1, duration: 3, ease: "sine.inOut" }).addLabel("NEUTRAL", 1.5).seek("NEUTRAL")
    );
    container$.data(
      "hoverOverTimeline",
      U.gsap.timeline({
        paused: true,
        data: { key, imgContainer$, label$, isNameRevealed: false },
        onStart() {
          this.data.imgContainer$.data("keySwingTimeline").tweenTo("NEUTRAL", {
            duration: 0.25,
            ease: "back.out(1.5)"
          });
          if (this.data.key.name && !this.data.key.isNameVisible) {
            this.data.isNameRevealed = true;
            U.gsap.effects.blurReveal(this.data.label$, {
              ignoreMargin: true,
              duration: 0.5
            });
          }
        },
        onReverseComplete() {
          this.data.imgContainer$.data("keySwingTimeline").seek("NEUTRAL").play();
          if (this.data.isNameRevealed) {
            this.data.isNameRevealed = false;
            U.gsap.effects.blurRemove(this.data.label$, {
              ignoreMargin: true,
              duration: 0.5
            });
          }
        }
      }).to(elem$, { filter: "brightness(1.5)", scale: keyElemScale * 1.25, duration: 0.5, ease: "sine" })
    );
    key.clocks.forEach((clock) => {
      const { clockContainer$, clockLabel$, clockElem$ } = clocks[clock.id];
      if (!(clockContainer$ == null ? void 0 : clockContainer$.length)) {
        throw new Error(`[BladesDirector.prepareClockKeyTimelines] Error clockContainer$ not found for clock '${clock.id}' of key '${key.id}'.`);
      }
      U.gsap.set(clockContainer$, { pointerEvents: "auto" });
      clockContainer$.data(
        "hoverOverTimeline",
        U.gsap.timeline({
          paused: true,
          data: { clock, clockLabel$, isNameRevealed: false },
          onStart() {
            if (this.data.clock.name && !this.data.clock.isNameVisible) {
              this.data.isNameRevealed = true;
              U.gsap.effects.blurReveal(this.data.clockLabel$, {
                ignoreMargin: true,
                duration: 0.5
              });
            }
          },
          onReverseComplete() {
            if (this.data.isNameRevealed) {
              this.data.isNameRevealed = false;
              U.gsap.effects.blurRemove(this.data.clockLabel$, {
                ignoreMargin: true,
                duration: 0.5
              });
            }
          }
        }).to(clockElem$, { filter: "brightness(1.5)", scale: 1.25, duration: 0.25, ease: "sine" })
      );
    });
  }
  async activateClockKeyListeners(key, keyElems$) {
    const { container$, clocks } = keyElems$;
    if (game.user.isGM) {
      container$.on("dblclick", async () => {
        var _a;
        (_a = game.eunoblades.ClockKeeper.sheet) == null ? void 0 : _a.render(true);
      });
      container$.on("contextmenu", async () => {
        this.pullKey_SocketCall(key.id);
        key.updateTarget("isVisible", false);
      });
    } else {
      container$.on("mouseenter", () => {
        container$.data("hoverOverTimeline").play();
      }).on("mouseleave", () => {
        container$.data("hoverOverTimeline").reverse();
      });
      key.clocks.forEach((clock) => {
        const { clockContainer$ } = clocks[clock.id];
        clockContainer$.on("mouseenter", () => {
          if (clock.isVisible) {
            clockContainer$.data("hoverOverTimeline").play();
          }
        }).on("mouseleave", () => {
          if (clock.isVisible) {
            clockContainer$.data("hoverOverTimeline").reverse();
          }
        });
      });
    }
  }
  async renderClockKey(key) {
    await key.renderTo(this.clockKeySection$);
    if (key.positionDragger) {
      key.removePositionDragger();
    }
    const keyElems$ = key.initElementsInContext(this.clockKeySection$, ClockKeyDisplayMode.full);
    if (key.overlayPosition) {
      U.gsap.set(keyElems$.container$, {
        left: key.overlayPosition.x,
        top: key.overlayPosition.y
      });
    }
    this.prepareClockKeyTimelines(key, keyElems$);
    this.activateClockKeyListeners(key, keyElems$);
    this.dropKey_Animation(key, keyElems$);
  }
  async renderClockKey_SocketCall(keyID) {
    if (!game.user.isGM) {
      return;
    }
    socketlib.system.executeForEveryone("renderClockKey_SocketCall", keyID);
  }
  static async renderClockKey_SocketResponse(keyID) {
    const key = game.eunoblades.ClockKeys.get(keyID);
    if (!key) {
      return;
    }
    game.eunoblades.Director.renderClockKey(key);
  }
  // #endregion
  // #region   >> Un-Rendering (Pulling) Clock Keys ~
  pullKey_Animation(key) {
    const { container$ } = key.getElements$(game.eunoblades.Director.clockKeySection$);
    U.gsap.timeline().to(container$, {
      y: -800,
      ease: "back.in(1)",
      duration: 0.75
    }).to(container$, {
      opacity: 0,
      ease: "power2.out",
      duration: 0.25
    }, 0.75).call(() => {
      container$.remove();
    });
  }
  async pullKey_SocketCall(keyID) {
    if (!game.user.isGM) {
      return;
    }
    socketlib.system.executeForEveryone("pullKey_SocketCall", keyID);
  }
  static pullKey_SocketResponse(keyID) {
    const key = game.eunoblades.ClockKeys.get(keyID);
    if (!key) {
      return;
    }
    game.eunoblades.Director.pullKey_Animation(key);
  }
  // #endregion
  // #endregion
  // #region SCORE PANEL ~
  // #region   >> INITIALIZATION ~
  initScorePanelSockets() {
  }
  // #endregion
  // ## Score Details
  // - Small panel overlapping corner of Location
  // - Engagement roll result
  // - Plan & Detail
  // - Target tier
  activateScorePanelListeners() {
  }
  // #endregion
  // #region LOCATIONS ~
  // #region   >> INITIALIZATION ~
  initLocationSockets() {
  }
  // #endregion
  // ## Locations
  // - District wrapper/header
  // - Faction wrapper/footer
  // - Location main
  // - Slide-scroll of sublocations
  activateLocationListeners() {
  }
  // #endregion
  // #region NPCs ~
  // #region   >> INITIALIZATION ~
  initNPCSockets() {
  }
  // #endregion// ## NPCs
  // - Linked to a location: When location is displayed, so are they.  *(Can be linked to District wrapper, main Location, or sublocations)*
  // - Portrait images close to the central location display, hover-over popups provide more detailed information from sheet or `BladesScore` instance
  activateNPCListeners() {
  }
  // #endregion
  // #region PCs, COHORTs, CREW ~
  // #region   >> INITIALIZATION ~
  initPCSockets() {
  }
  initCohortSockets() {
  }
  initCrewSockets() {
  }
  // #endregion
  // ## PCs
  // - Display panels along bottom
  // - Signal lights
  activatePCListeners() {
  }
  // ## Cohorts
  // - Smaller panels alongside the PCs
  activateCohortListeners() {
  }
  // ## Crew
  // - Limited information displayed, maybe bar beneath PCs showing Heat, Wanted Level…
  activateCrewListeners() {
  }
  // #endregion
  // #region NOTIFICATIONS ~
  // #region   >> INITIALIZATION ~
  initNotificationSockets() {
    socketlib.system.register("pushNotice_SocketCall", _BladesDirector.pushNotice_SocketResponse.bind(_BladesDirector));
  }
  // #endregion
  pushNotice_SocketCall(targets, config) {
    const pushID = randomID();
    if (typeof targets === "string") {
      if (targets === "ALL") {
        return socketlib.system.executeForEveryone("pushNotice_SocketCall", pushID, config);
      } else if (targets === "GM") {
        return socketlib.system.executeForAllGMs("pushNotice_SocketCall", pushID, config);
      } else {
        targets = game.users.filter(
          (user) => {
            var _a, _b;
            return user.id === targets || user.name === targets || ((_a = user.character) == null ? void 0 : _a.id) === targets || ((_b = user.character) == null ? void 0 : _b.name) === targets || game.user.isGM;
          }
        ).map((user) => user.id);
      }
    }
    if (targets.length > 0) {
      return socketlib.system.executeForUsers("pushNotice_SocketCall", targets, pushID, config);
    }
    return void 0;
  }
  static async pushNotice_SocketResponse(pushID, config) {
    const director = game.eunoblades.Director;
    const pushElem$ = $(await renderTemplate("systems/eunos-blades/templates/overlay/notices/push.hbs", {
      id: pushID,
      ...config
    })).appendTo(director.notificationSection$).on("click", (event) => {
      director.$removePush(event.currentTarget);
    }).on("contextmenu", (event) => {
      director.$removeAndClear(event.currentTarget);
    });
    U.gsap.fromTo(
      pushElem$,
      {
        x: 200,
        skewX: 20,
        autoAlpha: 0,
        filter: "blur(10px)"
      },
      {
        x: 0,
        skewX: 0,
        autoAlpha: 1,
        filter: "blur(0px)",
        duration: 0.5,
        ease: "back"
      }
    );
  }
  async $removePush(target) {
    U.gsap.to(
      target,
      {
        x: "+=200",
        autoAlpha: 0,
        ease: "power2",
        duration: 0.5,
        onComplete: function() {
          $(target).remove();
        }
      }
    );
  }
  async $removeAndClear(target) {
    const targets = $(target).prevAll().get().reverse();
    targets.unshift(target);
    U.gsap.to(
      targets,
      {
        x: "+=200",
        autoAlpha: 0,
        ease: "power2",
        duration: 0.5,
        stagger: {
          each: 0.5,
          from: "start",
          ease: "power1.inOut"
        },
        onComplete: function() {
          targets.forEach((targ) => $(targ).remove());
        }
      }
    );
  }
  // #endregion
  // #region TRANSITIONS ~
  // #region   >> INITIALIZATION ~
  initTransitionSockets() {
  }
  // #endregion
  // ## Transitions
  async advanceGamePhase(phase) {
    var _a;
    U.gsap.utils.wrap(
      Object.values(BladesPhase),
      Object.values(BladesPhase).indexOf(phase ?? ((_a = game.eunoblades.Tracker) == null ? void 0 : _a.phase) ?? BladesPhase.Freeplay) + 1
    );
  }
  /**
   * Adjusts the tooltip's position to ensure it remains within its parent container using jQuery methods.
   * @param tooltip - The tooltip element, which can be either an HTMLElement or a JQuery<HTMLElement>.
   */
  adjustTooltipPosition(tooltip$) {
    if (tooltip$.css("position") !== "absolute") {
      throw new Error("Tooltip position must be 'absolute'.");
    }
    const tooltipRect = tooltip$[0].getBoundingClientRect();
    const containerRect = this.tooltipSection$[0].getBoundingClientRect();
    const currentTop = tooltip$.position().top;
    const currentLeft = tooltip$.position().left;
    if (tooltipRect.right > containerRect.right) {
      const xShift = containerRect.right - tooltipRect.right;
      tooltip$.css("left", `${currentLeft + xShift}px`);
    } else if (tooltipRect.left < containerRect.left) {
      const xShift = containerRect.left - tooltipRect.left;
      tooltip$.css("left", `${currentLeft + xShift}px`);
    }
    if (tooltipRect.bottom > containerRect.bottom) {
      const yShift = containerRect.bottom - tooltipRect.bottom;
      tooltip$.css("top", `${currentTop + yShift}px`);
    } else if (tooltipRect.top < containerRect.top) {
      const yShift = containerRect.top - tooltipRect.top;
      tooltip$.css("top", `${currentTop + yShift}px`);
    }
  }
  displayTooltip(tooltip) {
    var _a, _b;
    if (!tooltip.id) {
      throw new Error("Tooltip must have an ID to be cloned to the overlay.");
    }
    this._displayedTooltipID = tooltip.id;
    const self = this;
    game.eunoblades.Director.clearTooltips();
    if (!this._tooltipElems.has(tooltip.id)) {
      const ttClone$ = $(U.changeContainer(
        tooltip,
        game.eunoblades.Director.tooltipSection$[0],
        true
      ));
      this.adjustTooltipPosition(ttClone$);
      const revealTimeline = U.gsap.effects.blurRevealTooltip(
        ttClone$[0],
        {
          onReverseComplete() {
            if (ttClone$.attr("id") === self._displayedTooltipID) {
              delete self._displayedTooltipID;
            }
            game.eunoblades.Director._tooltipElems.delete(ttClone$.attr("id"));
            game.eunoblades.Director.tooltipSection$.find(`#${ttClone$.attr("id")}`).remove();
            game.eunoblades.Director.tooltipSection$.children("[style*='opacity: 0'], [style*='opacity:0']").each(function() {
              const id = this.id;
              if (id === self._displayedTooltipID) {
                return;
              }
              if (id) {
                game.eunoblades.Director._tooltipElems.delete(id);
              }
              $(this).remove();
            });
          }
        }
      );
      ttClone$.data("revealTimeline", revealTimeline);
      this._tooltipElems.set(tooltip.id, ttClone$);
    }
    (_b = (_a = this._tooltipElems.get(tooltip.id)) == null ? void 0 : _a.data("revealTimeline")) == null ? void 0 : _b.play();
  }
  clearTooltip(tooltipID, isClearingIfTweening = true) {
    if (tooltipID === this._displayedTooltipID) {
      delete this._displayedTooltipID;
    }
    const ttElem = game.eunoblades.Director._tooltipElems.get(tooltipID);
    if (!ttElem) {
      return;
    }
    const ttTimeline = ttElem.data("revealTimeline");
    if (ttTimeline.isActive() && !isClearingIfTweening) {
      return;
    }
    ttTimeline.reverse();
  }
  clearTooltips() {
    eLog.checkLog3("Observer", "Observer Triggered!");
    game.eunoblades.Director._tooltipElems.forEach((ttElem) => {
      if (ttElem.attr("id") === this._displayedTooltipID) {
        return;
      }
      game.eunoblades.Director.clearTooltip(ttElem.attr("id"), true);
    });
  }
  initTooltipSection() {
    var _a;
    const self = this;
    this.clearTooltips();
    (_a = this._tooltipObserver) == null ? void 0 : _a.kill();
    this._tooltipObserver = Observer.create({
      type: "touch,pointer",
      // onMove: throttledOnMove,
      onClick() {
        self.clearTooltips();
      }
    });
  }
  // #endregion
};
// #region INITIALIZATION ~
// #region   >>  Single-Instance Factory Construction ~
__publicField(_BladesDirector, "instance");
let BladesDirector = _BladesDirector;
class BladesItem extends Item {
  constructor() {
    super(...arguments);
    __publicField(this, "dialogCSSClasses", "");
  }
  // #region Static Overrides: Create ~
  static async create(data, options = {}) {
    if (Array.isArray(data)) {
      data = data[0];
    }
    data.system = data.system ?? {};
    eLog.checkLog2("item", "BladesItem.create(data,options)", { data, options });
    data.system.world_name = data.system.world_name ?? data.name.replace(/[^A-Za-z_0-9 ]/g, "").trim().replace(/ /g, "_");
    return super.create(data, options);
  }
  // #endregion
  // #region BladesDocument Implementation
  static get All() {
    return game.items;
  }
  static Get(itemRef) {
    if (itemRef instanceof BladesItem) {
      return itemRef;
    }
    if (U.isDocID(itemRef)) {
      return BladesItem.All.get(itemRef);
    }
    return BladesItem.All.find((a) => a.system.world_name === itemRef) || BladesItem.All.find((a) => a.name === itemRef);
  }
  static GetTypeWithTags(docType, ...tags) {
    if (Array.isArray(docType)) {
      return docType.map((dType) => BladesItem.All.filter((item) => item.type === dType)).flat();
    }
    return BladesItem.All.filter((item) => item.type === docType).filter((item) => item.hasTag(...tags));
  }
  static IsType(doc, ...types) {
    const typeSet = new Set(types);
    return doc instanceof BladesItem && typeSet.has(doc.type);
  }
  get tags() {
    return this.system.tags ?? [];
  }
  hasTag(...tags) {
    return tags.every((tag) => this.tags.includes(tag));
  }
  async addTag(...tags) {
    const curTags = this.tags;
    tags.forEach((tag) => {
      if (curTags.includes(tag)) {
        return;
      }
      curTags.push(tag);
    });
    await this.update({ "system.tags": curTags });
  }
  async remTag(...tags) {
    const curTags = this.tags.filter((tag) => !tags.includes(tag));
    await this.update({ "system.tags": curTags });
  }
  get tooltip() {
    const tooltipText = [
      this.system.concept,
      this.system.rules,
      this.system.notes
    ].filter(Boolean).join("");
    if (tooltipText) {
      return new Handlebars.SafeString(tooltipText).toString();
    }
    return void 0;
  }
  getFactorTotal(factor) {
    var _a, _b, _c;
    switch (factor) {
      case Factor.tier: {
        if (BladesItem.IsType(this, BladesItemType.cohort_gang)) {
          return this.system.tier.value + (((_a = this.parent) == null ? void 0 : _a.getFactorTotal(Factor.tier)) ?? 0);
        }
        if (BladesItem.IsType(this, BladesItemType.cohort_expert)) {
          return this.system.tier.value + (((_b = this.parent) == null ? void 0 : _b.getFactorTotal(Factor.tier)) ?? 0);
        }
        if (BladesItem.IsType(this, BladesItemType.gear)) {
          return this.system.tier.value + (((_c = this.parent) == null ? void 0 : _c.getFactorTotal(Factor.tier)) ?? 0);
        }
        return this.system.tier.value;
      }
      case Factor.quality: {
        if (BladesItem.IsType(this, BladesItemType.cohort_gang)) {
          return this.getFactorTotal(Factor.tier) + (this.system.quality_bonus ?? 0);
        }
        if (BladesItem.IsType(this, BladesItemType.cohort_expert)) {
          return this.getFactorTotal(Factor.tier) + (this.system.quality_bonus ?? 0) + 1;
        }
        if (BladesItem.IsType(this, BladesItemType.gear)) {
          let thisQuality = this.getFactorTotal(Factor.tier) + (this.hasTag("Fine") ? 1 : 0);
          if (BladesPC$1.IsType(this.parent)) {
            thisQuality += this.parent.getTaggedItemBonuses(this.tags);
          }
          return thisQuality;
        }
        if (BladesItem.IsType(this, BladesItemType.design)) {
          return this.system.min_quality;
        }
        return this.getFactorTotal(Factor.tier);
      }
      case Factor.scale: {
        if (BladesItem.IsType(this, BladesItemType.cohort_gang)) {
          return this.getFactorTotal(Factor.tier) + (this.system.scale_bonus ?? 0);
        }
        if (BladesItem.IsType(this, BladesItemType.cohort_expert)) {
          return 0 + (this.system.scale_bonus ?? 0);
        }
        return 0;
      }
      case Factor.magnitude: {
        if (BladesItem.IsType(this, BladesItemType.ritual)) {
          return this.system.magnitude.value;
        }
        return 0;
      }
      default:
        return 0;
    }
  }
  // #endregion
  // #region BladesItemDocument Implementation
  async archive() {
    await this.addTag(Tag.System.Archived);
    return this;
  }
  async unarchive() {
    await this.remTag(Tag.System.Archived);
    return this;
  }
  // #endregion
  // #region BladesRoll Implementation
  get rollFactors() {
    const factorsMap = {
      [BladesItemType.cohort_gang]: [Factor.quality, Factor.scale],
      [BladesItemType.cohort_expert]: [Factor.quality, Factor.scale],
      [BladesItemType.gear]: [Factor.quality],
      [BladesItemType.project]: [Factor.quality],
      [BladesItemType.ritual]: [Factor.magnitude],
      [BladesItemType.design]: [Factor.quality]
    };
    if (!factorsMap[this.type]) {
      return {};
    }
    const factors = factorsMap[this.type];
    const factorData = {};
    (factors ?? []).forEach((factor, i) => {
      const factorTotal = this.getFactorTotal(factor);
      factorData[factor] = {
        name: factor,
        value: factorTotal,
        max: factorTotal,
        baseVal: factorTotal,
        display: [Factor.tier, Factor.quality].includes(factor) ? U.romanizeNum(factorTotal) : `${factorTotal}`,
        isActive: i === 0,
        isPrimary: i === 0,
        isDominant: false,
        highFavorsPC: true,
        cssClasses: `factor-gold${i === 0 ? " factor-main" : ""}`
      };
    });
    return factorData;
  }
  // #region BladesRoll.PrimaryDoc Implementation
  get rollPrimaryID() {
    return this.id;
  }
  get rollPrimaryDoc() {
    return this;
  }
  get rollPrimaryName() {
    return this.name;
  }
  get rollPrimaryType() {
    if (![
      BladesItemType.cohort_gang,
      BladesItemType.cohort_expert,
      BladesItemType.gm_tracker,
      BladesItemType.score
    ].includes(this.type)) {
      throw new Error(`BladesItem of type '${this.type}' ("${this.name}") cannot be RollPrimary.`);
    }
    return this.type;
  }
  get rollPrimaryImg() {
    return this.img;
  }
  get rollPrimaryModsSchemaSet() {
    return BladesRollMod.ParseDocModsToSchemaSet(this);
  }
  async applyHarm(amount, _name2) {
    if (BladesItem.IsType(this, BladesItemType.cohort_expert, BladesItemType.cohort_gang)) {
      const curHarm = this.system.harm.value;
      let newHarm;
      if (amount > curHarm) {
        newHarm = amount;
      } else {
        newHarm = curHarm + 1;
      }
      const harmVerb = ["is Weakened", "is Impaired", "has been Broken", "has been Killed!"];
      const harmEffect = [
        "They act with Reduced Effect.",
        "They act with Reduced Effect and suffer -1d to all rolls.",
        "They cannot do anything until they recover.",
        "You may replace them during Downtime."
      ];
      BladesDirector.getInstance().pushNotice_SocketCall(
        "ALL",
        {
          title: `${this.name} ${harmVerb[newHarm - 1]}`,
          body: harmEffect[newHarm - 1],
          type: BladesNoticeType.push,
          cssClasses: "harm-alert"
        }
      );
      await this.update({ "system.harm": amount });
    }
  }
  async applyWorsePosition() {
    if (BladesItem.IsType(this, BladesItemType.cohort_expert, BladesItemType.cohort_gang)) {
      this.setFlag("eunos-blades", "isWorsePosition", true);
    }
  }
  // #endregion
  // #region BladesRoll.OppositionDoc Implementation
  get rollOppID() {
    return this.id;
  }
  get rollOppDoc() {
    return this;
  }
  get rollOppImg() {
    return this.img;
  }
  get rollOppName() {
    return this.name;
  }
  get rollOppSubName() {
    return "";
  }
  get rollOppType() {
    if (![
      BladesItemType.cohort_gang,
      BladesItemType.cohort_expert,
      BladesItemType.gm_tracker,
      BladesItemType.score,
      BladesItemType.location,
      BladesItemType.project,
      BladesItemType.design,
      BladesItemType.ritual
    ].includes(this.type)) {
      throw new Error(`BladesItem of type '${this.type}' ("${this.name}") cannot be RollOpposition.`);
    }
    return this.type;
  }
  get rollOppModsSchemaSet() {
    return [];
  }
  // #endregion
  // #region BladesRoll.ParticipantDoc Implementation
  get rollParticipantID() {
    return this.id;
  }
  get rollParticipantDoc() {
    return this;
  }
  get rollParticipantIcon() {
    return this.img;
  }
  get rollParticipantName() {
    return this.name;
  }
  get rollParticipantType() {
    if (![
      BladesItemType.cohort_gang,
      BladesItemType.cohort_expert,
      BladesItemType.gm_tracker
    ].includes(this.type)) {
      throw new Error(`BladesItem of type '${this.type}' ("${this.name}") cannot be RollParticipant.`);
    }
    return this.type;
  }
  get rollParticipantModsSchemaSet() {
    return [];
  }
  // #endregion
  // #endregion
  // #region PREPARING DERIVED DATA
  prepareDerivedData() {
    super.prepareDerivedData();
    if (BladesItem.IsType(this, BladesItemType.cohort_gang, BladesItemType.cohort_expert)) {
      this._prepareCohortData(this.system);
    }
    if (BladesItem.IsType(this, BladesItemType.crew_playbook)) {
      this._preparePlaybookData(this.system);
    }
    if (BladesItem.IsType(this, BladesItemType.gear)) {
      this._prepareGearData(this.system);
    }
    if (BladesItem.IsType(this, BladesItemType.playbook)) {
      this._preparePlaybookData(this.system);
    }
  }
  _prepareCohortData(system) {
    if (!BladesItem.IsType(this, BladesItemType.cohort_gang, BladesItemType.cohort_expert)) {
      return;
    }
    system.tier.name = "Quality";
    const subtypes = U.unique(Object.values(system.subtypes).map((subtype) => subtype.trim()).filter((subtype) => /[A-Za-z]/.test(subtype)));
    const eliteSubtypes = [
      ...Object.values(system.elite_subtypes)
    ];
    if (BladesCrew$1.IsType(this.parent)) {
      eliteSubtypes.push(
        ...this.parent.upgrades.filter((upgrade) => (upgrade.name ?? "").startsWith("Elite")).map((upgrade) => (upgrade.name ?? "").trim().replace(/^Elite /, ""))
      );
    }
    system.subtypes = Object.fromEntries(subtypes.map((subtype, i) => [`${i + 1}`, subtype]));
    system.elite_subtypes = Object.fromEntries(
      U.unique(
        eliteSubtypes.map((subtype) => subtype.trim()).filter((subtype) => /[A-Za-z]/.test(subtype) && subtypes.includes(subtype))
      ).map((subtype, i) => [`${i + 1}`, subtype])
    );
    system.edges = Object.fromEntries(Object.values(system.edges ?? []).filter((edge) => /[A-Za-z]/.test(edge)).map((edge, i) => [`${i + 1}`, edge.trim()]));
    system.flaws = Object.fromEntries(Object.values(system.flaws ?? []).filter((flaw) => /[A-Za-z]/.test(flaw)).map((flaw, i) => [`${i + 1}`, flaw.trim()]));
    system.quality = this.getFactorTotal(Factor.quality);
    if (BladesItem.IsType(this, BladesItemType.cohort_gang)) {
      if ([...subtypes, ...eliteSubtypes].includes(Tag.GangType.Vehicle)) {
        system.scale = this.getFactorTotal(Factor.scale);
        system.scaleExample = "(1 vehicle)";
      } else {
        system.scale = this.getFactorTotal(Factor.scale);
        const scaleIndex = Math.min(6, system.scale);
        system.scaleExample = C.ScaleExamples[scaleIndex];
        system.subtitle = C.ScaleSizes[scaleIndex];
      }
      if (subtypes.length + eliteSubtypes.length === 0) {
        system.subtitle = system.subtitle.replace(/\s+of\b/g, "").trim();
      }
    } else {
      system.scale = 0;
      system.scaleExample = [...subtypes, ...eliteSubtypes].includes("Pet") ? "(1 animal)" : "(1 person)";
      system.subtitle = "An Expert";
    }
    if (subtypes.length + eliteSubtypes.length > 0) {
      if ([...subtypes, ...eliteSubtypes].includes(Tag.GangType.Vehicle)) {
        system.subtitle = C.VehicleDescriptors[Math.min(6, this.getFactorTotal(Factor.tier))];
      } else {
        system.subtitle += ` ${U.oxfordize([
          ...subtypes.filter((subtype) => !eliteSubtypes.includes(subtype)),
          ...eliteSubtypes.map((subtype) => `Elite ${subtype}`)
        ], false, "&")}`;
      }
    }
  }
  _prepareGearData(system) {
    if (!BladesItem.IsType(this, BladesItemType.gear)) {
      return;
    }
    system.tier.name = "Quality";
  }
  _preparePlaybookData(system) {
    if (!BladesItem.IsType(this, BladesItemType.playbook, BladesItemType.crew_playbook)) {
      return;
    }
    const expClueData = {};
    [...Object.values(system.experience_clues).filter((clue) => /[A-Za-z]/.test(clue)), " "].forEach((clue, i) => {
      expClueData[(i + 1).toString()] = clue;
    });
    system.experience_clues = expClueData;
    if (BladesItem.IsType(this, BladesItemType.playbook)) {
      const gatherInfoData = {};
      [...Object.values(system.gather_info_questions).filter((question) => /[A-Za-z]/.test(question)), " "].forEach((question, i) => {
        gatherInfoData[(i + 1).toString()] = question;
      });
      system.gather_info_questions = gatherInfoData;
    }
  }
  // #endregion
  // Unlock lower-level update method for subclasses
  async callOnUpdate(...args) {
    await this._onUpdate(...args);
  }
}
const BladesItem$1 = BladesItem;
const FUNCQUEUE = {};
const CUSTOMFUNCS = {
  addItem: async (actor, funcData, _, isReversing = false) => {
    eLog.checkLog("activeEffects", "addItem", { actor, funcData, isReversing });
    if (actor.hasActiveSubItemOf(funcData)) {
      if (isReversing) {
        return actor.remSubItem(funcData);
      }
    } else if (!isReversing) {
      return actor.addSubItem(funcData);
    }
    return void 0;
  },
  addIfChargen: async (actor, funcData, _, isReversing = false) => {
    var _a;
    eLog.checkLog("activeEffects", "addIfChargen", { actor, funcData, isReversing });
    if (!isReversing && ((_a = game.eunoblades.Tracker) == null ? void 0 : _a.system.phase) !== BladesPhase.CharGen) {
      return;
    }
    const [target, qty] = funcData.split(/:/);
    if (isReversing) {
      await actor.update({ [target]: U.pInt(getProperty(actor, target)) - U.pInt(qty) });
      return;
    }
    await actor.update({ [target]: U.pInt(getProperty(actor, target)) + U.pInt(qty) });
  },
  upgradeIfChargen: async (actor, funcData, _, isReversing = false) => {
    var _a;
    eLog.checkLog("activeEffects", "upgradeIfChargen", { actor, funcData, isReversing });
    if (!isReversing && ((_a = game.eunoblades.Tracker) == null ? void 0 : _a.system.phase) !== BladesPhase.CharGen) {
      return;
    }
    const [target, qty] = funcData.split(/:/);
    if (getProperty(actor, target) < U.pInt(qty)) {
      await actor.update({ [target]: U.pInt(qty) });
    }
  },
  APPLYTOMEMBERS: async () => void 0,
  APPLYTOCOHORTS: async () => void 0,
  remItem: async (actor, funcData, _, isReversing = false) => {
    function testString(targetString, testDef) {
      if (testDef.startsWith("rX")) {
        const pat = new RegExp(testDef.replace(/^rX:\/(.*?)\//, "$1"));
        return pat.test(targetString);
      }
      return targetString === testDef;
    }
    if (funcData.startsWith("{")) {
      if (isReversing) {
        console.error("Cannot reverse a 'remItem' custom effect that was defined with a JSON object.");
        return void 0;
      }
      const { type, tags, name } = JSON.parse(funcData);
      let activeSubItems = actor.activeSubItems;
      if (activeSubItems.length === 0) {
        return void 0;
      }
      if (name) {
        activeSubItems = activeSubItems.filter((item) => testString(item.name, name));
      }
      if (activeSubItems.length === 0) {
        return void 0;
      }
      if (type) {
        activeSubItems = activeSubItems.filter((item) => testString(item.type, type));
      }
      if (activeSubItems.length === 0) {
        return void 0;
      }
      if (tags) {
        activeSubItems = activeSubItems.filter((item) => item.hasTag(...tags));
      }
      if (activeSubItems.length === 0) {
        return void 0;
      }
      eLog.checkLog("activeEffects", "remItem - JSON OBJECT", { actor, funcData: JSON.parse(funcData), isReversing, activeSubItems });
      activeSubItems.forEach((item) => actor.remSubItem(item));
    }
    eLog.checkLog("activeEffects", "remItem", { actor, funcData, isReversing });
    if (actor.hasActiveSubItemOf(funcData)) {
      return actor.remSubItem(funcData);
    }
    if (isReversing) {
      return actor.addSubItem(funcData);
    }
    return void 0;
  }
};
class BladesActiveEffect extends ActiveEffect {
  static Initialize() {
    CONFIG.ActiveEffect.documentClass = BladesActiveEffect;
    Hooks.on("preCreateActiveEffect", async (effect) => {
      var _a;
      eLog.checkLog3("effect", "PRECREATE ActiveEffect", { effect, parent: (_a = effect.parent) == null ? void 0 : _a.name });
      if (!(effect.parent instanceof BladesActor$1)) {
        return;
      }
      if (effect.changes.some((change) => change.key === "APPLYTOMEMBERS")) {
        if (BladesActor$1.IsType(effect.parent, BladesActorType.pc) && BladesActor$1.IsType(effect.parent.crew, BladesActorType.crew)) {
          const otherMembers = effect.parent.crew.members.filter((member) => {
            var _a2;
            return member.id !== ((_a2 = effect.parent) == null ? void 0 : _a2.id);
          });
          if (otherMembers.length > 0) {
            effect.changes = effect.changes.filter((change) => change.key !== "APPLYTOMEMBERS");
            await Promise.all(otherMembers.map(async (member) => member.createEmbeddedDocuments("ActiveEffect", [effect.toJSON()])));
            await effect.parent.setFlag("eunos-blades", `memberEffects.${effect.id}`, {
              appliedTo: otherMembers.map((member) => member.id),
              effect: effect.toJSON()
            });
          }
        } else if (BladesActor$1.IsType(effect.parent, BladesActorType.crew)) {
          const changeKey = U.pullElement(effect.changes, (change) => change.key === "APPLYTOMEMBERS");
          if (!changeKey) {
            return;
          }
          if (effect.parent.members.length > 0) {
            await Promise.all(effect.parent.members.map(async (member) => member.createEmbeddedDocuments("ActiveEffect", [effect.toJSON()])));
          }
          await effect.parent.setFlag("eunos-blades", `memberEffects.${effect.id}`, {
            appliedTo: effect.parent.members.map((member) => member.id),
            effect
          });
          await effect.updateSource({ changes: [changeKey] });
        }
      } else if (effect.changes.some((change) => change.key === "APPLYTOCOHORTS") && (BladesActor$1.IsType(effect.parent, BladesActorType.pc) || BladesActor$1.IsType(effect.parent, BladesActorType.crew))) {
        if (effect.parent.cohorts.length > 0) {
          await Promise.all(effect.parent.cohorts.map(async (cohort) => cohort.createEmbeddedDocuments("ActiveEffect", [effect.toJSON()])));
        }
        await effect.parent.setFlag("eunos-blades", `cohortEffects.${effect.id}`, {
          appliedTo: effect.parent.cohorts.map((cohort) => cohort.id),
          effect
        });
        await effect.updateSource({ changes: effect.changes.filter((change) => change.key === "APPLYTOCOHORTS") });
      }
      const [permChanges, changes] = U.partition(effect.changes, (change) => change.key.startsWith("perm"));
      await effect.updateSource({ changes });
      for (const permChange of permChanges) {
        const { key, value } = permChange;
        const permFuncName = key.replace(/^perm/, "");
        if (permFuncName in CUSTOMFUNCS) {
          const funcData = {
            funcName: permFuncName,
            funcData: value,
            isReversing: false,
            effect
          };
          BladesActiveEffect.ThrottleCustomFunc(effect.parent, funcData);
        } else if (permFuncName === "Add") {
          const [target, qty] = value.split(/:/);
          effect.parent.update({ [target]: U.pInt(getProperty(effect.parent, target)) + U.pInt(qty) });
        }
      }
    });
    Hooks.on("applyActiveEffect", (actor, changeData) => {
      if (!(actor instanceof BladesActor$1)) {
        return;
      }
      if (changeData.key in CUSTOMFUNCS) {
        const funcData = {
          funcName: changeData.key,
          funcData: changeData.value,
          isReversing: false,
          effect: changeData.effect
        };
        BladesActiveEffect.ThrottleCustomFunc(actor, funcData);
      }
    });
    Hooks.on("updateActiveEffect", (effect, { disabled }) => {
      if (!(effect.parent instanceof BladesActor$1)) {
        return;
      }
      const customEffects = effect.changes.filter((changes) => changes.mode === 0);
      customEffects.forEach(({ key, value }) => {
        const funcData = {
          funcName: key,
          funcData: value,
          isReversing: disabled,
          effect
        };
        BladesActiveEffect.ThrottleCustomFunc(effect.parent, funcData);
      });
    });
    Hooks.on("deleteActiveEffect", async (effect) => {
      if (!(effect.parent instanceof BladesActor$1)) {
        return;
      }
      if (effect.changes.some((change) => change.key === "APPLYTOMEMBERS")) {
        if (BladesActor$1.IsType(effect.parent, BladesActorType.pc) && BladesActor$1.IsType(effect.parent.crew, BladesActorType.crew)) {
          const otherMembers = effect.parent.crew.members.filter((member) => {
            var _a;
            return member.id !== ((_a = effect.parent) == null ? void 0 : _a.id);
          });
          if (otherMembers.length > 0) {
            await Promise.all(otherMembers.map(async (member) => Promise.all(member.effects.filter((e) => e.name === effect.name).map(async (e) => e.delete()))));
          }
          await effect.parent.unsetFlag("eunos-blades", `memberEffects.${effect.id}`);
        } else if (BladesActor$1.IsType(effect.parent, BladesActorType.crew)) {
          if (effect.parent.members.length > 0) {
            await Promise.all(effect.parent.members.map(async (member) => Promise.all(member.effects.filter((e) => e.name === effect.name).map(async (e) => e.delete()))));
          }
          await effect.parent.unsetFlag("eunos-blades", `memberEffects.${effect.id}`);
        }
      } else if (effect.changes.some((change) => change.key === "APPLYTOCOHORTS") && BladesActor$1.IsType(effect.parent, BladesActorType.pc, BladesActorType.crew)) {
        if (effect.parent.cohorts.length > 0) {
          await Promise.all(effect.parent.cohorts.map(async (cohort) => Promise.all(cohort.effects.filter((e) => e.name === effect.name).map(async (e) => e.delete()))));
        }
        await effect.parent.unsetFlag("eunos-blades", `cohortEffects.${effect.id}`);
      }
      const customEffects = effect.changes.filter((changes) => changes.mode === 0);
      customEffects.forEach(({ key, value }) => {
        const funcData = {
          funcName: key,
          funcData: value,
          isReversing: true,
          effect
        };
        BladesActiveEffect.ThrottleCustomFunc(effect.parent, funcData);
      });
    });
  }
  static async AddActiveEffect(doc, name, eChanges, icon = "systems/eunos-blades/assets/icons/effect-icons/default.png") {
    const changes = [eChanges].flat();
    await doc.createEmbeddedDocuments("ActiveEffect", [{ name, icon, changes }]);
  }
  static ThrottleCustomFunc(actor, data) {
    const { funcName, funcData, isReversing, effect } = data;
    if (!actor.id) {
      return;
    }
    eLog.checkLog3("activeEffect", `Throttling Func: ${funcName}(${funcData}, ${isReversing})`);
    if (actor.id && actor.id in FUNCQUEUE) {
      const matchingQueue = FUNCQUEUE[actor.id].queue.find((fData) => JSON.stringify(fData) === JSON.stringify(data));
      eLog.checkLog("activeEffects", "... Checking Queue", { data, FUNCQUEUE: FUNCQUEUE[actor.id], matchingQueue });
      if (matchingQueue) {
        eLog.error("... Function ALREADY QUEUED, SKIPPING");
        return;
      }
      FUNCQUEUE[actor.id].queue.push(data);
      return;
    }
    eLog.checkLog3("activeEffect", "... Creating New FUNCQUEUE, RUNNING:");
    FUNCQUEUE[actor.id] = {
      curFunc: BladesActiveEffect.RunCustomFunc(actor, CUSTOMFUNCS[funcName](actor, funcData, effect, isReversing)),
      queue: []
    };
  }
  static async RunCustomFunc(actor, funcPromise) {
    if (!actor.id) {
      return;
    }
    eLog.checkLog("activeEffects", "... Running Func ...");
    await funcPromise;
    eLog.checkLog("activeEffects", "... Function Complete!");
    if (FUNCQUEUE[actor.id].queue.length) {
      const { funcName, funcData, isReversing, effect } = FUNCQUEUE[actor.id].queue.shift() ?? {};
      if (!funcName || !(funcName in CUSTOMFUNCS)) {
        return;
      }
      if (!funcData) {
        return;
      }
      eLog.checkLog3("activeEffect", `Progressing Queue: ${funcName}(${funcData}, ${isReversing}) -- ${FUNCQUEUE[actor.id].queue.length} remaining funcs.`);
      FUNCQUEUE[actor.id].curFunc = BladesActiveEffect.RunCustomFunc(
        actor,
        CUSTOMFUNCS[funcName](actor, funcData, effect, isReversing)
      );
    } else {
      eLog.checkLog3("activeEffect", "Function Queue Complete! Deleting.");
      delete FUNCQUEUE[actor.id];
    }
  }
  /**
   * Manage Active Effect instances through the Actor Sheet via effect control buttons.
   * @param {MouseEvent} event      The left-click event on the effect control
   * @param {Actor|Item} owner      The owning entity which manages this effect
   */
  static onManageActiveEffect(event, owner) {
    var _a;
    event.preventDefault();
    const a = event.currentTarget;
    if (a.dataset.action === "create") {
      return owner.createEmbeddedDocuments("ActiveEffect", [{
        name: owner.name,
        icon: owner.img,
        origin: owner.uuid
      }]);
    }
    const selector = a.closest("tr");
    if (selector === null) {
      return null;
    }
    const effect = selector.dataset.effectId ? owner.effects.get(selector.dataset.effectId) : null;
    if (!effect) {
      return null;
    }
    switch (a.dataset.action) {
      case "edit":
        return (_a = effect.sheet) == null ? void 0 : _a.render(true);
      case "delete":
        eLog.checkLog("activeEffects", "delete effect");
        return effect.delete();
      case "toggle":
        return effect.update({ disabled: !effect.disabled });
      default:
        return null;
    }
  }
  async _preCreate(data, options, user) {
    eLog.checkLog3("effect", "ActiveEffect._preCreate()", { data, options, user });
    await super._preCreate(data, options, user);
  }
  _onDelete(options, userID) {
    eLog.checkLog3("effect", "ActiveEffect._onDelete()", { options, userID });
    super._onDelete(options, userID);
  }
  get isSuppressed() {
    if (!/Actor.*Item/.test(this.origin)) {
      return super.isSuppressed;
    }
    const [actorID, itemID] = this.origin.replace(/Actor\.|Item\./g, "").split(".");
    const actor = game.actors.get(actorID);
    const item = actor.items.get(itemID);
    return super.isSuppressed || (item == null ? void 0 : item.hasTag(Tag.System.Archived));
  }
}
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _defineProperty(obj, key, value) {
  key = _toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPrimitive(input, hint) {
  if (typeof input !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}
const sameStr = (s1, s2, caseSensitive, trim) => {
  s1 = "" + s1;
  s2 = "" + s2;
  if (trim) {
    s1 = s1.trim();
    s2 = s2.trim();
  }
  return caseSensitive ? s1 == s2 : s1.toLowerCase() == s2.toLowerCase();
};
const removeCollectionProp = (collection, unwantedProps) => collection && Array.isArray(collection) && collection.map((v) => omit(v, unwantedProps));
function omit(obj, props) {
  var newObj = {}, p;
  for (p in obj)
    if (props.indexOf(p) < 0)
      newObj[p] = obj[p];
  return newObj;
}
function decode(s) {
  var el = document.createElement("div");
  return s.replace(/\&#?[0-9a-z]+;/gi, function(enc) {
    el.innerHTML = enc;
    return el.innerText;
  });
}
function parseHTML(s) {
  var parser = new DOMParser(), node = parser.parseFromString(s.trim(), "text/html");
  return node.body.firstElementChild;
}
function minify(s) {
  return s ? s.replace(/\>[\r\n ]+\</g, "><").replace(/(<.*?>)|\s+/g, (m, $1) => $1 ? $1 : " ") : "";
}
function removeTextChildNodes(elm) {
  var iter = document.createNodeIterator(elm, NodeFilter.SHOW_TEXT, null, false), textnode;
  while (textnode = iter.nextNode()) {
    if (!textnode.textContent.trim())
      textnode.parentNode.removeChild(textnode);
  }
}
function getfirstTextNode(elm, action) {
  action = action || "previous";
  while (elm = elm[action + "Sibling"])
    if (elm.nodeType == 3)
      return elm;
}
function escapeHTML(s) {
  return typeof s == "string" ? s.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/`|'/g, "&#039;") : s;
}
function isObject(obj) {
  var type = Object.prototype.toString.call(obj).split(" ")[1].slice(0, -1);
  return obj === Object(obj) && type != "Array" && type != "Function" && type != "RegExp" && type != "HTMLUnknownElement";
}
function extend(o, o1, o2) {
  if (!(o instanceof Object))
    o = {};
  copy(o, o1);
  if (o2)
    copy(o, o2);
  function copy(a, b) {
    for (var key in b)
      if (b.hasOwnProperty(key)) {
        if (isObject(b[key])) {
          if (!isObject(a[key]))
            a[key] = Object.assign({}, b[key]);
          else
            copy(a[key], b[key]);
          continue;
        }
        if (Array.isArray(b[key])) {
          a[key] = Object.assign([], b[key]);
          continue;
        }
        a[key] = b[key];
      }
  }
  return o;
}
function concatWithoutDups() {
  const newArr = [], existingObj = {};
  for (let arr of arguments) {
    for (let item of arr) {
      if (isObject(item)) {
        if (!existingObj[item.value]) {
          newArr.push(item);
          existingObj[item.value] = 1;
        }
      } else if (!newArr.includes(item))
        newArr.push(item);
    }
  }
  return newArr;
}
function unaccent(s) {
  if (!String.prototype.normalize)
    return s;
  if (typeof s === "string")
    return s.normalize("NFD").replace(/[\u0300-\u036f]/g, "");
}
function getNodeHeight(node) {
  var height, clone = node.cloneNode(true);
  clone.style.cssText = "position:fixed; top:-9999px; opacity:0";
  document.body.appendChild(clone);
  height = clone.clientHeight;
  clone.parentNode.removeChild(clone);
  return height;
}
var isChromeAndroidBrowser = () => /(?=.*chrome)(?=.*android)/i.test(navigator.userAgent);
function getUID() {
  return ("10000000-1000-4000-8000" + -1e11).replace(/[018]/g, (c) => (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16));
}
function isNodeTag(node) {
  return node && node.classList && node.classList.contains(this.settings.classNames.tag);
}
function getCaretGlobalPosition() {
  const sel = document.getSelection();
  if (sel.rangeCount) {
    const r = sel.getRangeAt(0);
    const node = r.startContainer;
    const offset = r.startOffset;
    let rect, r2;
    if (offset > 0) {
      r2 = document.createRange();
      r2.setStart(node, offset - 1);
      r2.setEnd(node, offset);
      rect = r2.getBoundingClientRect();
      return {
        left: rect.right,
        top: rect.top,
        bottom: rect.bottom
      };
    }
    if (node.getBoundingClientRect)
      return node.getBoundingClientRect();
  }
  return {
    left: -9999,
    top: -9999
  };
}
function injectAtCaret(content, range) {
  var selection = window.getSelection();
  range = range || selection.getRangeAt(0);
  if (typeof content == "string")
    content = document.createTextNode(content);
  if (range) {
    range.deleteContents();
    range.insertNode(content);
  }
  return content;
}
function getSetTagData(tagElm, data, override) {
  if (!tagElm) {
    console.warn("tag element doesn't exist", tagElm, data);
    return data;
  }
  if (data)
    tagElm.__tagifyTagData = override ? data : extend({}, tagElm.__tagifyTagData || {}, data);
  return tagElm.__tagifyTagData;
}
var DEFAULTS = {
  delimiters: ",",
  // [RegEx] split tags by any of these delimiters ("null" to cancel) Example: ",| |."
  pattern: null,
  // RegEx pattern to validate input by. Ex: /[1-9]/
  tagTextProp: "value",
  // tag data Object property which will be displayed as the tag's text
  maxTags: Infinity,
  // Maximum number of tags
  callbacks: {},
  // Exposed callbacks object to be triggered on certain events
  addTagOnBlur: true,
  // automatically adds the text which was inputed as a tag when blur event happens
  onChangeAfterBlur: true,
  // By default, the native way of inputs' onChange events is kept, and it only fires when the field is blured.
  duplicates: false,
  // "true" - allow duplicate tags
  whitelist: [],
  // Array of tags to suggest as the user types (can be used along with "enforceWhitelist" setting)
  blacklist: [],
  // A list of non-allowed tags
  enforceWhitelist: false,
  // Only allow tags from the whitelist
  userInput: true,
  // disable manually typing/pasting/editing tags (tags may only be added from the whitelist)
  keepInvalidTags: false,
  // if true, do not remove tags which did not pass validation
  createInvalidTags: true,
  // if false, do not create invalid tags from invalid user input
  mixTagsAllowedAfter: /,|\.|\:|\s/,
  // RegEx - Define conditions in which mix-tags content allows a tag to be added after
  mixTagsInterpolator: ["[[", "]]"],
  // Interpolation for mix mode. Everything between these will become a tag, if is a valid Object
  backspace: true,
  // false / true / "edit"
  skipInvalid: false,
  // If `true`, do not add invalid, temporary, tags before automatically removing them
  pasteAsTags: true,
  // automatically converts pasted text into tags. if "false", allows for further text editing
  editTags: {
    clicks: 2,
    // clicks to enter "edit-mode": 1 for single click. any other value is considered as double-click
    keepInvalid: true
    // keeps invalid edits as-is until `esc` is pressed while in focus
  },
  // 1 or 2 clicks to edit a tag. false/null for not allowing editing
  transformTag: () => {
  },
  // Takes a tag input string as argument and returns a transformed value
  trim: true,
  // whether or not the value provided should be trimmed, before being added as a tag
  a11y: {
    focusableTags: false
  },
  mixMode: {
    insertAfterTag: " "
    // String/Node to inject after a tag has been added (see #588)
  },
  autoComplete: {
    enabled: true,
    // Tries to suggest the input's value while typing (match from whitelist) by adding the rest of term as grayed-out text
    rightKey: false
    // If `true`, when Right key is pressed, use the suggested value to create a tag, else just auto-completes the input. in mixed-mode this is set to "true"
  },
  classNames: {
    namespace: "tagify",
    mixMode: "tagify--mix",
    selectMode: "tagify--select",
    input: "tagify__input",
    focus: "tagify--focus",
    tagNoAnimation: "tagify--noAnim",
    tagInvalid: "tagify--invalid",
    tagNotAllowed: "tagify--notAllowed",
    scopeLoading: "tagify--loading",
    hasMaxTags: "tagify--hasMaxTags",
    hasNoTags: "tagify--noTags",
    empty: "tagify--empty",
    inputInvalid: "tagify__input--invalid",
    dropdown: "tagify__dropdown",
    dropdownWrapper: "tagify__dropdown__wrapper",
    dropdownHeader: "tagify__dropdown__header",
    dropdownFooter: "tagify__dropdown__footer",
    dropdownItem: "tagify__dropdown__item",
    dropdownItemActive: "tagify__dropdown__item--active",
    dropdownItemHidden: "tagify__dropdown__item--hidden",
    dropdownInital: "tagify__dropdown--initial",
    tag: "tagify__tag",
    tagText: "tagify__tag-text",
    tagX: "tagify__tag__removeBtn",
    tagLoading: "tagify__tag--loading",
    tagEditing: "tagify__tag--editable",
    tagFlash: "tagify__tag--flash",
    tagHide: "tagify__tag--hide"
  },
  dropdown: {
    classname: "",
    enabled: 2,
    // minimum input characters to be typed for the suggestions dropdown to show
    maxItems: 10,
    searchKeys: ["value", "searchBy"],
    fuzzySearch: true,
    caseSensitive: false,
    accentedSearch: true,
    includeSelectedTags: false,
    // Should the suggestions list Include already-selected tags (after filtering)
    highlightFirst: false,
    // highlights first-matched item in the list
    closeOnSelect: true,
    // closes the dropdown after selecting an item, if `enabled:0` (which means always show dropdown)
    clearOnSelect: true,
    // after selecting a suggetion, should the typed text input remain or be cleared
    position: "all",
    // 'manual' / 'text' / 'all'
    appendTarget: null
    // defaults to document.body once DOM has been loaded
  },
  hooks: {
    beforeRemoveTag: () => Promise.resolve(),
    beforePaste: () => Promise.resolve(),
    suggestionClick: () => Promise.resolve()
  }
};
function initDropdown() {
  this.dropdown = {};
  for (let p in this._dropdown)
    this.dropdown[p] = typeof this._dropdown[p] === "function" ? this._dropdown[p].bind(this) : this._dropdown[p];
  this.dropdown.refs();
}
var _dropdown = {
  refs() {
    this.DOM.dropdown = this.parseTemplate("dropdown", [this.settings]);
    this.DOM.dropdown.content = this.DOM.dropdown.querySelector("[data-selector='tagify-suggestions-wrapper']");
  },
  getHeaderRef() {
    return this.DOM.dropdown.querySelector("[data-selector='tagify-suggestions-header']");
  },
  getFooterRef() {
    return this.DOM.dropdown.querySelector("[data-selector='tagify-suggestions-footer']");
  },
  getAllSuggestionsRefs() {
    return [...this.DOM.dropdown.content.querySelectorAll(this.settings.classNames.dropdownItemSelector)];
  },
  /**
   * shows the suggestions select box
   * @param {String} value [optional, filter the whitelist by this value]
   */
  show(value) {
    var _s = this.settings, firstListItem, firstListItemValue, allowNewTags = _s.mode == "mix" && !_s.enforceWhitelist, noWhitelist = !_s.whitelist || !_s.whitelist.length, noMatchListItem, isManual = _s.dropdown.position == "manual";
    value = value === void 0 ? this.state.inputText : value;
    if (noWhitelist && !allowNewTags && !_s.templates.dropdownItemNoMatch || _s.dropdown.enable === false || this.state.isLoading || this.settings.readonly)
      return;
    clearTimeout(this.dropdownHide__bindEventsTimeout);
    this.suggestedListItems = this.dropdown.filterListItems(value);
    if (value && !this.suggestedListItems.length) {
      this.trigger("dropdown:noMatch", value);
      if (_s.templates.dropdownItemNoMatch)
        noMatchListItem = _s.templates.dropdownItemNoMatch.call(this, {
          value
        });
    }
    if (!noMatchListItem) {
      if (this.suggestedListItems.length) {
        if (value && allowNewTags && !this.state.editing.scope && !sameStr(this.suggestedListItems[0].value, value))
          this.suggestedListItems.unshift({
            value
          });
      } else {
        if (value && allowNewTags && !this.state.editing.scope) {
          this.suggestedListItems = [{
            value
          }];
        } else {
          this.input.autocomplete.suggest.call(this);
          this.dropdown.hide();
          return;
        }
      }
      firstListItem = this.suggestedListItems[0];
      firstListItemValue = "" + (isObject(firstListItem) ? firstListItem.value : firstListItem);
      if (_s.autoComplete && firstListItemValue) {
        if (firstListItemValue.indexOf(value) == 0)
          this.input.autocomplete.suggest.call(this, firstListItem);
      }
    }
    this.dropdown.fill(noMatchListItem);
    if (_s.dropdown.highlightFirst) {
      this.dropdown.highlightOption(this.DOM.dropdown.content.querySelector(_s.classNames.dropdownItemSelector));
    }
    if (!this.state.dropdown.visible)
      setTimeout(this.dropdown.events.binding.bind(this));
    this.state.dropdown.visible = value || true;
    this.state.dropdown.query = value;
    this.setStateSelection();
    if (!isManual) {
      setTimeout(() => {
        this.dropdown.position();
        this.dropdown.render();
      });
    }
    setTimeout(() => {
      this.trigger("dropdown:show", this.DOM.dropdown);
    });
  },
  /**
   * Hides the dropdown (if it's not managed manually by the developer)
   * @param {Boolean} overrideManual
   */
  hide(overrideManual) {
    var _this$DOM = this.DOM, scope = _this$DOM.scope, dropdown = _this$DOM.dropdown, isManual = this.settings.dropdown.position == "manual" && !overrideManual;
    if (!dropdown || !document.body.contains(dropdown) || isManual)
      return;
    window.removeEventListener("resize", this.dropdown.position);
    this.dropdown.events.binding.call(this, false);
    scope.setAttribute("aria-expanded", false);
    dropdown.parentNode.removeChild(dropdown);
    setTimeout(() => {
      this.state.dropdown.visible = false;
    }, 100);
    this.state.dropdown.query = this.state.ddItemData = this.state.ddItemElm = this.state.selection = null;
    if (this.state.tag && this.state.tag.value.length) {
      this.state.flaggedTags[this.state.tag.baseOffset] = this.state.tag;
    }
    this.trigger("dropdown:hide", dropdown);
    return this;
  },
  /**
   * Toggles dropdown show/hide
   * @param {Boolean} show forces the dropdown to show
   */
  toggle(show) {
    this.dropdown[this.state.dropdown.visible && !show ? "hide" : "show"]();
  },
  render() {
    var ddHeight = getNodeHeight(this.DOM.dropdown), _s = this.settings, enabled = typeof _s.dropdown.enabled == "number" && _s.dropdown.enabled >= 0;
    if (!enabled)
      return this;
    this.DOM.scope.setAttribute("aria-expanded", true);
    if (!document.body.contains(this.DOM.dropdown)) {
      this.DOM.dropdown.classList.add(_s.classNames.dropdownInital);
      this.dropdown.position(ddHeight);
      _s.dropdown.appendTarget.appendChild(this.DOM.dropdown);
      setTimeout(() => this.DOM.dropdown.classList.remove(_s.classNames.dropdownInital));
    }
    return this;
  },
  /**
   * re-renders the dropdown content element (see "dropdownContent" in templates file)
   * @param {String/Array} HTMLContent - optional
   */
  fill(HTMLContent) {
    HTMLContent = typeof HTMLContent == "string" ? HTMLContent : this.dropdown.createListHTML(HTMLContent || this.suggestedListItems);
    var dropdownContent = this.settings.templates.dropdownContent.call(this, HTMLContent);
    this.DOM.dropdown.content.innerHTML = minify(dropdownContent);
  },
  /**
   * Re-renders only the header & footer.
   * Used when selecting a suggestion and it is wanted that the suggestions dropdown stays open.
   * Since the list of sugegstions is not being re-rendered completely every time a suggestion is selected (the item is transitioned-out)
   * then the header & footer should be kept in sync with the suggestions data change
   */
  fillHeaderFooter() {
    var suggestions = this.dropdown.filterListItems(this.state.dropdown.query), newHeaderElem = this.parseTemplate("dropdownHeader", [suggestions]), newFooterElem = this.parseTemplate("dropdownFooter", [suggestions]), headerRef = this.dropdown.getHeaderRef(), footerRef = this.dropdown.getFooterRef();
    newHeaderElem && (headerRef == null ? void 0 : headerRef.parentNode.replaceChild(newHeaderElem, headerRef));
    newFooterElem && (footerRef == null ? void 0 : footerRef.parentNode.replaceChild(newFooterElem, footerRef));
  },
  /**
   * fill data into the suggestions list
   * (mainly used to update the list when removing tags while the suggestions dropdown is visible, so they will be re-added to the list. not efficient)
   */
  refilter(value) {
    value = value || this.state.dropdown.query || "";
    this.suggestedListItems = this.dropdown.filterListItems(value);
    this.dropdown.fill();
    if (!this.suggestedListItems.length)
      this.dropdown.hide();
    this.trigger("dropdown:updated", this.DOM.dropdown);
  },
  position(ddHeight) {
    var _sd = this.settings.dropdown;
    if (_sd.position == "manual")
      return;
    var rect, top, bottom, left, width, parentsPositions, ddElm = this.DOM.dropdown, placeAbove = _sd.placeAbove, isDefaultAppendTarget = _sd.appendTarget === document.body, appendTargetScrollTop = isDefaultAppendTarget ? window.pageYOffset : _sd.appendTarget.scrollTop, root = document.fullscreenElement || document.webkitFullscreenElement || document.documentElement, viewportHeight = root.clientHeight, viewportWidth = Math.max(root.clientWidth || 0, window.innerWidth || 0), positionTo = viewportWidth > 480 ? _sd.position : "all", ddTarget = this.DOM[positionTo == "input" ? "input" : "scope"];
    ddHeight = ddHeight || ddElm.clientHeight;
    function getParentsPositions(p) {
      var left2 = 0, top2 = 0;
      while (p && p != root) {
        left2 += p.offsetLeft || 0;
        top2 += p.offsetTop || 0;
        p = p.parentNode;
      }
      return {
        left: left2,
        top: top2
      };
    }
    function getAccumulatedAncestorsScrollTop() {
      var scrollTop = 0, p = _sd.appendTarget.parentNode;
      while (p) {
        scrollTop += p.scrollTop || 0;
        p = p.parentNode;
      }
      return scrollTop;
    }
    if (!this.state.dropdown.visible)
      return;
    if (positionTo == "text") {
      rect = getCaretGlobalPosition();
      bottom = rect.bottom;
      top = rect.top;
      left = rect.left;
      width = "auto";
    } else {
      parentsPositions = getParentsPositions(_sd.appendTarget);
      rect = ddTarget.getBoundingClientRect();
      top = rect.top - parentsPositions.top;
      bottom = rect.bottom - 1 - parentsPositions.top;
      left = rect.left - parentsPositions.left;
      width = rect.width + "px";
    }
    if (!isDefaultAppendTarget) {
      let accumulatedAncestorsScrollTop = getAccumulatedAncestorsScrollTop();
      top += accumulatedAncestorsScrollTop;
      bottom += accumulatedAncestorsScrollTop;
    }
    top = Math.floor(top);
    bottom = Math.ceil(bottom);
    placeAbove = placeAbove === void 0 ? viewportHeight - rect.bottom < ddHeight : placeAbove;
    ddElm.style.cssText = "left:" + (left + window.pageXOffset) + "px; width:" + width + ";" + (placeAbove ? "top: " + (top + appendTargetScrollTop) + "px" : "top: " + (bottom + appendTargetScrollTop) + "px");
    ddElm.setAttribute("placement", placeAbove ? "top" : "bottom");
    ddElm.setAttribute("position", positionTo);
  },
  events: {
    /**
     * Events should only be binded when the dropdown is rendered and removed when isn't
     * because there might be multiple Tagify instances on a certain page
     * @param  {Boolean} bindUnbind [optional. true when wanting to unbind all the events]
     */
    binding() {
      let bindUnbind = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
      var _CB = this.dropdown.events.callbacks, _CBR = this.listeners.dropdown = this.listeners.dropdown || {
        position: this.dropdown.position.bind(this, null),
        onKeyDown: _CB.onKeyDown.bind(this),
        onMouseOver: _CB.onMouseOver.bind(this),
        onMouseLeave: _CB.onMouseLeave.bind(this),
        onClick: _CB.onClick.bind(this),
        onScroll: _CB.onScroll.bind(this)
      }, action = bindUnbind ? "addEventListener" : "removeEventListener";
      if (this.settings.dropdown.position != "manual") {
        document[action]("scroll", _CBR.position, true);
        window[action]("resize", _CBR.position);
        window[action]("keydown", _CBR.onKeyDown);
      }
      this.DOM.dropdown[action]("mouseover", _CBR.onMouseOver);
      this.DOM.dropdown[action]("mouseleave", _CBR.onMouseLeave);
      this.DOM.dropdown[action]("mousedown", _CBR.onClick);
      this.DOM.dropdown.content[action]("scroll", _CBR.onScroll);
    },
    callbacks: {
      onKeyDown(e) {
        if (!this.state.hasFocus || this.state.composing)
          return;
        var selectedElm = this.DOM.dropdown.querySelector(this.settings.classNames.dropdownItemActiveSelector), selectedElmData = this.dropdown.getSuggestionDataByNode(selectedElm);
        switch (e.key) {
          case "ArrowDown":
          case "ArrowUp":
          case "Down":
          case "Up": {
            e.preventDefault();
            var dropdownItems = this.dropdown.getAllSuggestionsRefs(), actionUp = e.key == "ArrowUp" || e.key == "Up";
            if (selectedElm) {
              selectedElm = this.dropdown.getNextOrPrevOption(selectedElm, !actionUp);
            }
            if (!selectedElm || !selectedElm.matches(this.settings.classNames.dropdownItemSelector)) {
              selectedElm = dropdownItems[actionUp ? dropdownItems.length - 1 : 0];
            }
            this.dropdown.highlightOption(selectedElm, true);
            break;
          }
          case "Escape":
          case "Esc":
            this.dropdown.hide();
            break;
          case "ArrowRight":
            if (this.state.actions.ArrowLeft)
              return;
          case "Tab": {
            if (this.settings.mode != "mix" && selectedElm && !this.settings.autoComplete.rightKey && !this.state.editing) {
              e.preventDefault();
              var value = this.dropdown.getMappedValue(selectedElmData);
              this.input.autocomplete.set.call(this, value);
              return false;
            }
            return true;
          }
          case "Enter": {
            e.preventDefault();
            this.settings.hooks.suggestionClick(e, {
              tagify: this,
              tagData: selectedElmData,
              suggestionElm: selectedElm
            }).then(() => {
              if (selectedElm) {
                this.dropdown.selectOption(selectedElm);
                selectedElm = this.dropdown.getNextOrPrevOption(selectedElm, !actionUp);
                this.dropdown.highlightOption(selectedElm);
                return;
              } else
                this.dropdown.hide();
              if (this.settings.mode != "mix")
                this.addTags(this.state.inputText.trim(), true);
            }).catch((err) => err);
            break;
          }
          case "Backspace": {
            if (this.settings.mode == "mix" || this.state.editing.scope)
              return;
            const value2 = this.input.raw.call(this);
            if (value2 == "" || value2.charCodeAt(0) == 8203) {
              if (this.settings.backspace === true)
                this.removeTags();
              else if (this.settings.backspace == "edit")
                setTimeout(this.editTag.bind(this), 0);
            }
          }
        }
      },
      onMouseOver(e) {
        var ddItem = e.target.closest(this.settings.classNames.dropdownItemSelector);
        ddItem && this.dropdown.highlightOption(ddItem);
      },
      onMouseLeave(e) {
        this.dropdown.highlightOption();
      },
      onClick(e) {
        if (e.button != 0 || e.target == this.DOM.dropdown || e.target == this.DOM.dropdown.content)
          return;
        var selectedElm = e.target.closest(this.settings.classNames.dropdownItemSelector), selectedElmData = this.dropdown.getSuggestionDataByNode(selectedElm);
        this.state.actions.selectOption = true;
        setTimeout(() => this.state.actions.selectOption = false, 50);
        this.settings.hooks.suggestionClick(e, {
          tagify: this,
          tagData: selectedElmData,
          suggestionElm: selectedElm
        }).then(() => {
          if (selectedElm)
            this.dropdown.selectOption(selectedElm, e);
          else
            this.dropdown.hide();
        }).catch((err) => console.warn(err));
      },
      onScroll(e) {
        var elm = e.target, pos = elm.scrollTop / (elm.scrollHeight - elm.parentNode.clientHeight) * 100;
        this.trigger("dropdown:scroll", {
          percentage: Math.round(pos)
        });
      }
    }
  },
  /**
   * Given a suggestion-item, return the data associated with it
   * @param {HTMLElement} tagElm
   * @returns Object
   */
  getSuggestionDataByNode(tagElm) {
    var value = tagElm && tagElm.getAttribute("value");
    return this.suggestedListItems.find((item) => item.value == value) || null;
  },
  getNextOrPrevOption(selected) {
    let next = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
    var dropdownItems = this.dropdown.getAllSuggestionsRefs(), selectedIdx = dropdownItems.findIndex((item) => item === selected);
    return next ? dropdownItems[selectedIdx + 1] : dropdownItems[selectedIdx - 1];
  },
  /**
   * mark the currently active suggestion option
   * @param {Object}  elm            option DOM node
   * @param {Boolean} adjustScroll   when navigation with keyboard arrows (up/down), aut-scroll to always show the highlighted element
   */
  highlightOption(elm, adjustScroll) {
    var className = this.settings.classNames.dropdownItemActive, itemData;
    if (this.state.ddItemElm) {
      this.state.ddItemElm.classList.remove(className);
      this.state.ddItemElm.removeAttribute("aria-selected");
    }
    if (!elm) {
      this.state.ddItemData = null;
      this.state.ddItemElm = null;
      this.input.autocomplete.suggest.call(this);
      return;
    }
    itemData = this.dropdown.getSuggestionDataByNode(elm);
    this.state.ddItemData = itemData;
    this.state.ddItemElm = elm;
    elm.classList.add(className);
    elm.setAttribute("aria-selected", true);
    if (adjustScroll)
      elm.parentNode.scrollTop = elm.clientHeight + elm.offsetTop - elm.parentNode.clientHeight;
    if (this.settings.autoComplete) {
      this.input.autocomplete.suggest.call(this, itemData);
      this.dropdown.position();
    }
  },
  /**
   * Create a tag from the currently active suggestion option
   * @param {Object} elm  DOM node to select
   * @param {Object} event The original Click event, if available (since keyboard ENTER key also triggers this method)
   */
  selectOption(elm, event) {
    var _this$settings$dropdo = this.settings.dropdown, clearOnSelect = _this$settings$dropdo.clearOnSelect, closeOnSelect = _this$settings$dropdo.closeOnSelect;
    if (!elm) {
      this.addTags(this.state.inputText, true);
      closeOnSelect && this.dropdown.hide();
      return;
    }
    event = event || {};
    var value = elm.getAttribute("value"), isNoMatch = value == "noMatch", tagData = this.suggestedListItems.find((item) => (item.value ?? item) == value);
    this.trigger("dropdown:select", {
      data: tagData,
      elm,
      event
    });
    if (!value || !tagData && !isNoMatch) {
      closeOnSelect && setTimeout(this.dropdown.hide.bind(this));
      return;
    }
    if (this.state.editing) {
      this.onEditTagDone(null, extend({
        __isValid: true
      }, this.normalizeTags([tagData])[0]));
    } else {
      this[this.settings.mode == "mix" ? "addMixTags" : "addTags"]([tagData || this.input.raw.call(this)], clearOnSelect);
    }
    if (!this.DOM.input.parentNode)
      return;
    setTimeout(() => {
      this.DOM.input.focus();
      this.toggleFocusClass(true);
    });
    closeOnSelect && setTimeout(this.dropdown.hide.bind(this));
    elm.addEventListener("transitionend", () => {
      this.dropdown.fillHeaderFooter();
      setTimeout(() => elm.remove(), 100);
    }, {
      once: true
    });
    elm.classList.add(this.settings.classNames.dropdownItemHidden);
  },
  // adds all the suggested items, including the ones which are not currently rendered,
  // unless specified otherwise (by the "onlyRendered" argument)
  selectAll(onlyRendered) {
    this.suggestedListItems.length = 0;
    this.dropdown.hide();
    this.dropdown.filterListItems("");
    var tagsToAdd = this.dropdown.filterListItems("");
    if (!onlyRendered)
      tagsToAdd = this.state.dropdown.suggestions;
    this.addTags(tagsToAdd, true);
    return this;
  },
  /**
   * returns an HTML string of the suggestions' list items
   * @param {String} value string to filter the whitelist by
   * @param {Object} options "exact" - for exact complete match
   * @return {Array} list of filtered whitelist items according to the settings provided and current value
   */
  filterListItems(value, options) {
    var _s = this.settings, _sd = _s.dropdown, options = options || {}, list = [], exactMatchesList = [], whitelist = _s.whitelist, suggestionsCount = _sd.maxItems >= 0 ? _sd.maxItems : Infinity, searchKeys = _sd.searchKeys, whitelistItem, valueIsInWhitelist, searchBy, isDuplicate, niddle, i = 0;
    value = _s.mode == "select" && this.value.length && this.value[0][_s.tagTextProp] == value ? "" : value;
    if (!value || !searchKeys.length) {
      list = _sd.includeSelectedTags ? whitelist : whitelist.filter((item) => !this.isTagDuplicate(isObject(item) ? item.value : item));
      this.state.dropdown.suggestions = list;
      return list.slice(0, suggestionsCount);
    }
    niddle = _sd.caseSensitive ? "" + value : ("" + value).toLowerCase();
    function stringHasAll(s, query) {
      return query.toLowerCase().split(" ").every((q) => s.includes(q.toLowerCase()));
    }
    for (; i < whitelist.length; i++) {
      let startsWithMatch, exactMatch;
      whitelistItem = whitelist[i] instanceof Object ? whitelist[i] : {
        value: whitelist[i]
      };
      let itemWithoutSearchKeys = !Object.keys(whitelistItem).some((k) => searchKeys.includes(k)), _searchKeys = itemWithoutSearchKeys ? ["value"] : searchKeys;
      if (_sd.fuzzySearch && !options.exact) {
        searchBy = _searchKeys.reduce((values, k) => values + " " + (whitelistItem[k] || ""), "").toLowerCase().trim();
        if (_sd.accentedSearch) {
          searchBy = unaccent(searchBy);
          niddle = unaccent(niddle);
        }
        startsWithMatch = searchBy.indexOf(niddle) == 0;
        exactMatch = searchBy === niddle;
        valueIsInWhitelist = stringHasAll(searchBy, niddle);
      } else {
        startsWithMatch = true;
        valueIsInWhitelist = _searchKeys.some((k) => {
          var v = "" + (whitelistItem[k] || "");
          if (_sd.accentedSearch) {
            v = unaccent(v);
            niddle = unaccent(niddle);
          }
          if (!_sd.caseSensitive)
            v = v.toLowerCase();
          exactMatch = v === niddle;
          return options.exact ? v === niddle : v.indexOf(niddle) == 0;
        });
      }
      isDuplicate = !_sd.includeSelectedTags && this.isTagDuplicate(isObject(whitelistItem) ? whitelistItem.value : whitelistItem);
      if (valueIsInWhitelist && !isDuplicate)
        if (exactMatch && startsWithMatch)
          exactMatchesList.push(whitelistItem);
        else if (_sd.sortby == "startsWith" && startsWithMatch)
          list.unshift(whitelistItem);
        else
          list.push(whitelistItem);
    }
    this.state.dropdown.suggestions = exactMatchesList.concat(list);
    return typeof _sd.sortby == "function" ? _sd.sortby(exactMatchesList.concat(list), niddle) : exactMatchesList.concat(list).slice(0, suggestionsCount);
  },
  /**
   * Returns the final value of a tag data (object) with regards to the "mapValueTo" dropdown setting
   * @param {Object} tagData
   * @returns
   */
  getMappedValue(tagData) {
    var mapValueTo = this.settings.dropdown.mapValueTo, value = mapValueTo ? typeof mapValueTo == "function" ? mapValueTo(tagData) : tagData[mapValueTo] || tagData.value : tagData.value;
    return value;
  },
  /**
   * Creates the dropdown items' HTML
   * @param  {Array} sugegstionsList  [Array of Objects]
   * @return {String}
   */
  createListHTML(sugegstionsList) {
    return extend([], sugegstionsList).map((suggestion, idx) => {
      if (typeof suggestion == "string" || typeof suggestion == "number")
        suggestion = {
          value: suggestion
        };
      var mappedValue = this.dropdown.getMappedValue(suggestion);
      mappedValue = typeof mappedValue == "string" ? escapeHTML(mappedValue) : mappedValue;
      return this.settings.templates.dropdownItem.apply(this, [_objectSpread2(_objectSpread2({}, suggestion), {}, {
        mappedValue
      }), this]);
    }).join("");
  }
};
const VERSION = 1;
const STORE_KEY = "@yaireo/tagify/";
const getPersistedData = (id) => (key) => {
  let customKey = "/" + key, persistedData, versionMatch = localStorage.getItem(STORE_KEY + id + "/v", VERSION) == VERSION;
  if (versionMatch) {
    try {
      persistedData = JSON.parse(localStorage[STORE_KEY + id + customKey]);
    } catch (err) {
    }
  }
  return persistedData;
};
const setPersistedData = (id) => {
  if (!id)
    return () => {
    };
  localStorage.setItem(STORE_KEY + id + "/v", VERSION);
  return (data, key) => {
    let customKey = "/" + key, persistedData = JSON.stringify(data);
    if (data && key) {
      localStorage.setItem(STORE_KEY + id + customKey, persistedData);
      dispatchEvent(new Event("storage"));
    }
  };
};
const clearPersistedData = (id) => (key) => {
  const base = STORE_KEY + "/" + id + "/";
  if (key)
    localStorage.removeItem(base + key);
  else {
    for (let k in localStorage)
      if (k.includes(base))
        localStorage.removeItem(k);
  }
};
var TEXTS = {
  empty: "empty",
  exceed: "number of tags exceeded",
  pattern: "pattern mismatch",
  duplicate: "already exists",
  notAllowed: "not allowed"
};
var templates = {
  /**
   *
   * @param {DOM Object} input     Original input DOm element
   * @param {Object}     settings  Tagify instance settings Object
   */
  wrapper(input, _s) {
    return `<tags class="${_s.classNames.namespace} ${_s.mode ? `${_s.classNames[_s.mode + "Mode"]}` : ""} ${input.className}"
                    ${_s.readonly ? "readonly" : ""}
                    ${_s.disabled ? "disabled" : ""}
                    ${_s.required ? "required" : ""}
                    ${_s.mode === "select" ? "spellcheck='false'" : ""}
                    tabIndex="-1">
            <span ${!_s.readonly && _s.userInput ? "contenteditable" : ""} tabIndex="0" data-placeholder="${_s.placeholder || "&#8203;"}" aria-placeholder="${_s.placeholder || ""}"
                class="${_s.classNames.input}"
                role="textbox"
                aria-autocomplete="both"
                aria-multiline="${_s.mode == "mix" ? true : false}"></span>
                &#8203;
        </tags>`;
  },
  tag(tagData, _ref) {
    let _s = _ref.settings;
    return `<tag title="${tagData.title || tagData.value}"
                    contenteditable='false'
                    spellcheck='false'
                    tabIndex="${_s.a11y.focusableTags ? 0 : -1}"
                    class="${_s.classNames.tag} ${tagData.class || ""}"
                    ${this.getAttributes(tagData)}>
            <x title='' class="${_s.classNames.tagX}" role='button' aria-label='remove tag'></x>
            <div>
                <span class="${_s.classNames.tagText}">${tagData[_s.tagTextProp] || tagData.value}</span>
            </div>
        </tag>`;
  },
  dropdown(settings) {
    var _sd = settings.dropdown, isManual = _sd.position == "manual", className = `${settings.classNames.dropdown}`;
    return `<div class="${isManual ? "" : className} ${_sd.classname}" role="listbox" aria-labelledby="dropdown">
                    <div data-selector='tagify-suggestions-wrapper' class="${settings.classNames.dropdownWrapper}"></div>
                </div>`;
  },
  dropdownContent(HTMLContent) {
    var _s = this.settings, suggestions = this.state.dropdown.suggestions;
    return `
            ${_s.templates.dropdownHeader.call(this, suggestions)}
            ${HTMLContent}
            ${_s.templates.dropdownFooter.call(this, suggestions)}
        `;
  },
  dropdownItem(item) {
    return `<div ${this.getAttributes(item)}
                    class='${this.settings.classNames.dropdownItem} ${item.class ? item.class : ""}'
                    tabindex="0"
                    role="option">${item.mappedValue || item.value}</div>`;
  },
  /**
   * @param {Array} suggestions An array of all the matched suggested items, including those which were sliced away due to the "dropdown.maxItems" setting
   */
  dropdownHeader(suggestions) {
    return `<header data-selector='tagify-suggestions-header' class="${this.settings.classNames.dropdownHeader}"></header>`;
  },
  dropdownFooter(suggestions) {
    var hasMore = suggestions.length - this.settings.dropdown.maxItems;
    return hasMore > 0 ? `<footer data-selector='tagify-suggestions-footer' class="${this.settings.classNames.dropdownFooter}">
                ${hasMore} more items. Refine your search.
            </footer>` : "";
  },
  dropdownItemNoMatch: null
};
function EventDispatcher(instance) {
  var target = document.createTextNode("");
  function addRemove(op, events2, cb) {
    if (cb)
      events2.split(/\s+/g).forEach((name) => target[op + "EventListener"].call(target, name, cb));
  }
  return {
    off(events2, cb) {
      addRemove("remove", events2, cb);
      return this;
    },
    on(events2, cb) {
      if (cb && typeof cb == "function")
        addRemove("add", events2, cb);
      return this;
    },
    trigger(eventName, data, opts) {
      var e;
      opts = opts || {
        cloneData: true
      };
      if (!eventName)
        return;
      if (instance.settings.isJQueryPlugin) {
        if (eventName == "remove")
          eventName = "removeTag";
        jQuery(instance.DOM.originalInput).triggerHandler(eventName, [data]);
      } else {
        try {
          var eventData = typeof data === "object" ? data : {
            value: data
          };
          eventData = opts.cloneData ? extend({}, eventData) : eventData;
          eventData.tagify = this;
          if (data.event)
            eventData.event = this.cloneEvent(data.event);
          if (data instanceof Object) {
            for (var prop in data)
              if (data[prop] instanceof HTMLElement)
                eventData[prop] = data[prop];
          }
          e = new CustomEvent(eventName, {
            "detail": eventData
          });
        } catch (err) {
          console.warn(err);
        }
        target.dispatchEvent(e);
      }
    }
  };
}
var deleteBackspaceTimeout;
function triggerChangeEvent() {
  if (this.settings.mixMode.integrated)
    return;
  var inputElm = this.DOM.originalInput, changed = this.state.lastOriginalValueReported !== inputElm.value, event = new CustomEvent("change", {
    bubbles: true
  });
  if (!changed)
    return;
  this.state.lastOriginalValueReported = inputElm.value;
  event.simulated = true;
  if (inputElm._valueTracker)
    inputElm._valueTracker.setValue(Math.random());
  inputElm.dispatchEvent(event);
  this.trigger("change", this.state.lastOriginalValueReported);
  inputElm.value = this.state.lastOriginalValueReported;
}
var events = {
  // bind custom events which were passed in the settings
  customBinding() {
    this.customEventsList.forEach((name) => {
      this.on(name, this.settings.callbacks[name]);
    });
  },
  binding() {
    let bindUnbind = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
    var _CB = this.events.callbacks, _CBR, action = bindUnbind ? "addEventListener" : "removeEventListener";
    if (this.state.mainEvents && bindUnbind)
      return;
    this.state.mainEvents = bindUnbind;
    if (bindUnbind && !this.listeners.main) {
      this.events.bindGlobal.call(this);
      if (this.settings.isJQueryPlugin)
        jQuery(this.DOM.originalInput).on("tagify.removeAllTags", this.removeAllTags.bind(this));
    }
    _CBR = this.listeners.main = this.listeners.main || {
      focus: ["input", _CB.onFocusBlur.bind(this)],
      keydown: ["input", _CB.onKeydown.bind(this)],
      click: ["scope", _CB.onClickScope.bind(this)],
      dblclick: ["scope", _CB.onDoubleClickScope.bind(this)],
      paste: ["input", _CB.onPaste.bind(this)],
      drop: ["input", _CB.onDrop.bind(this)],
      compositionstart: ["input", _CB.onCompositionStart.bind(this)],
      compositionend: ["input", _CB.onCompositionEnd.bind(this)]
    };
    for (var eventName in _CBR) {
      this.DOM[_CBR[eventName][0]][action](eventName, _CBR[eventName][1]);
    }
    clearInterval(this.listeners.main.originalInputValueObserverInterval);
    this.listeners.main.originalInputValueObserverInterval = setInterval(_CB.observeOriginalInputValue.bind(this), 500);
    var inputMutationObserver = this.listeners.main.inputMutationObserver || new MutationObserver(_CB.onInputDOMChange.bind(this));
    inputMutationObserver.disconnect();
    if (this.settings.mode == "mix")
      inputMutationObserver.observe(this.DOM.input, {
        childList: true
      });
  },
  bindGlobal(unbind) {
    var _CB = this.events.callbacks, action = unbind ? "removeEventListener" : "addEventListener", e;
    if (!this.listeners || !unbind && this.listeners.global)
      return;
    this.listeners.global = this.listeners.global || [{
      type: this.isIE ? "keydown" : "input",
      // IE cannot register "input" events on contenteditable elements, so the "keydown" should be used instead..
      target: this.DOM.input,
      cb: _CB[this.isIE ? "onInputIE" : "onInput"].bind(this)
    }, {
      type: "keydown",
      target: window,
      cb: _CB.onWindowKeyDown.bind(this)
    }, {
      type: "blur",
      target: this.DOM.input,
      cb: _CB.onFocusBlur.bind(this)
    }, {
      type: "click",
      target: document,
      cb: _CB.onClickAnywhere.bind(this)
    }];
    for (e of this.listeners.global)
      e.target[action](e.type, e.cb);
  },
  unbindGlobal() {
    this.events.bindGlobal.call(this, true);
  },
  /**
   * DOM events callbacks
   */
  callbacks: {
    onFocusBlur(e) {
      var _a, _b;
      var _s = this.settings, text = e.target ? this.trim(e.target.textContent) : "", currentDisplayValue = (_b = (_a = this.value) == null ? void 0 : _a[0]) == null ? void 0 : _b[_s.tagTextProp], type = e.type, ddEnabled = _s.dropdown.enabled >= 0, eventData = {
        relatedTarget: e.relatedTarget
      }, isTargetSelectOption = this.state.actions.selectOption && (ddEnabled || !_s.dropdown.closeOnSelect), isTargetAddNewBtn = this.state.actions.addNew && ddEnabled, isRelatedTargetX = e.relatedTarget && isNodeTag.call(this, e.relatedTarget) && this.DOM.scope.contains(e.relatedTarget), shouldAddTags;
      if (type == "blur") {
        if (e.relatedTarget === this.DOM.scope) {
          this.dropdown.hide();
          this.DOM.input.focus();
          return;
        }
        this.postUpdate();
        _s.onChangeAfterBlur && this.triggerChangeEvent();
      }
      if (isTargetSelectOption || isTargetAddNewBtn)
        return;
      this.state.hasFocus = type == "focus" ? +/* @__PURE__ */ new Date() : false;
      this.toggleFocusClass(this.state.hasFocus);
      if (_s.mode == "mix") {
        if (type == "focus") {
          this.trigger("focus", eventData);
        } else if (e.type == "blur") {
          this.trigger("blur", eventData);
          this.loading(false);
          this.dropdown.hide();
          this.state.dropdown.visible = void 0;
          this.setStateSelection();
        }
        return;
      }
      if (type == "focus") {
        this.trigger("focus", eventData);
        if (_s.dropdown.enabled === 0 || !_s.userInput) {
          this.dropdown.show(this.value.length ? "" : void 0);
        }
        return;
      } else if (type == "blur") {
        this.trigger("blur", eventData);
        this.loading(false);
        if (_s.mode == "select") {
          if (isRelatedTargetX) {
            this.removeTags();
            text = "";
          }
          if (currentDisplayValue === text)
            text = "";
        }
        shouldAddTags = text && !this.state.actions.selectOption && _s.addTagOnBlur;
        shouldAddTags && this.addTags(text, true);
      }
      this.DOM.input.removeAttribute("style");
      this.dropdown.hide();
    },
    onCompositionStart(e) {
      this.state.composing = true;
    },
    onCompositionEnd(e) {
      this.state.composing = false;
    },
    onWindowKeyDown(e) {
      var focusedElm = document.activeElement, isTag = isNodeTag.call(this, focusedElm), isBelong = isTag && this.DOM.scope.contains(document.activeElement), isReadyOnlyTag = isBelong && focusedElm.hasAttribute("readonly"), nextTag;
      if (!isBelong || isReadyOnlyTag)
        return;
      nextTag = focusedElm.nextElementSibling;
      switch (e.key) {
        case "Backspace": {
          if (!this.settings.readonly) {
            this.removeTags(focusedElm);
            (nextTag ? nextTag : this.DOM.input).focus();
          }
          break;
        }
        case "Enter": {
          setTimeout(this.editTag.bind(this), 0, focusedElm);
          break;
        }
      }
    },
    onKeydown(e) {
      var _s = this.settings;
      if (this.state.composing || !_s.userInput)
        return;
      if (_s.mode == "select" && _s.enforceWhitelist && this.value.length && e.key != "Tab") {
        e.preventDefault();
      }
      var s = this.trim(e.target.textContent);
      this.trigger("keydown", {
        event: e
      });
      if (_s.mode == "mix") {
        switch (e.key) {
          case "Left":
          case "ArrowLeft": {
            this.state.actions.ArrowLeft = true;
            break;
          }
          case "Delete":
          case "Backspace": {
            if (this.state.editing)
              return;
            var sel = document.getSelection(), deleteKeyTagDetected = e.key == "Delete" && sel.anchorOffset == (sel.anchorNode.length || 0), prevAnchorSibling = sel.anchorNode.previousSibling, isCaretAfterTag = sel.anchorNode.nodeType == 1 || !sel.anchorOffset && prevAnchorSibling && prevAnchorSibling.nodeType == 1 && sel.anchorNode.previousSibling;
            decode(this.DOM.input.innerHTML);
            var lastTagElems = this.getTagElms(), tagBeforeCaret, tagElmToBeDeleted, firstTextNodeBeforeTag;
            if (_s.backspace == "edit" && isCaretAfterTag) {
              tagBeforeCaret = sel.anchorNode.nodeType == 1 ? null : sel.anchorNode.previousElementSibling;
              setTimeout(this.editTag.bind(this), 0, tagBeforeCaret);
              e.preventDefault();
              return;
            }
            if (isChromeAndroidBrowser() && isCaretAfterTag instanceof Element) {
              firstTextNodeBeforeTag = getfirstTextNode(isCaretAfterTag);
              if (!isCaretAfterTag.hasAttribute("readonly"))
                isCaretAfterTag.remove();
              this.DOM.input.focus();
              setTimeout(() => {
                this.placeCaretAfterNode(firstTextNodeBeforeTag);
                this.DOM.input.click();
              });
              return;
            }
            if (sel.anchorNode.nodeName == "BR")
              return;
            if ((deleteKeyTagDetected || isCaretAfterTag) && sel.anchorNode.nodeType == 1) {
              if (sel.anchorOffset == 0)
                tagElmToBeDeleted = deleteKeyTagDetected ? lastTagElems[0] : null;
              else
                tagElmToBeDeleted = lastTagElems[Math.min(lastTagElems.length, sel.anchorOffset) - 1];
            } else if (deleteKeyTagDetected)
              tagElmToBeDeleted = sel.anchorNode.nextElementSibling;
            else if (isCaretAfterTag instanceof Element)
              tagElmToBeDeleted = isCaretAfterTag;
            if (sel.anchorNode.nodeType == 3 && // node at caret location is a Text node
            !sel.anchorNode.nodeValue && // has some text
            sel.anchorNode.previousElementSibling)
              e.preventDefault();
            if ((isCaretAfterTag || deleteKeyTagDetected) && !_s.backspace) {
              e.preventDefault();
              return;
            }
            if (sel.type != "Range" && !sel.anchorOffset && sel.anchorNode == this.DOM.input && e.key != "Delete") {
              e.preventDefault();
              return;
            }
            if (sel.type != "Range" && tagElmToBeDeleted && tagElmToBeDeleted.hasAttribute("readonly")) {
              this.placeCaretAfterNode(getfirstTextNode(tagElmToBeDeleted));
              return;
            }
            clearTimeout(deleteBackspaceTimeout);
            deleteBackspaceTimeout = setTimeout(() => {
              var sel2 = document.getSelection();
              decode(this.DOM.input.innerHTML);
              !deleteKeyTagDetected && sel2.anchorNode.previousSibling;
              this.value = [].map.call(lastTagElems, (node, nodeIdx) => {
                var tagData = getSetTagData(node);
                if (node.parentNode || tagData.readonly)
                  return tagData;
                else
                  this.trigger("remove", {
                    tag: node,
                    index: nodeIdx,
                    data: tagData
                  });
              }).filter((n) => n);
            }, 20);
            break;
          }
        }
        return true;
      }
      switch (e.key) {
        case "Backspace":
          if (_s.mode == "select" && _s.enforceWhitelist && this.value.length)
            this.removeTags();
          else if (!this.state.dropdown.visible || _s.dropdown.position == "manual") {
            if (e.target.textContent == "" || s.charCodeAt(0) == 8203) {
              if (_s.backspace === true)
                this.removeTags();
              else if (_s.backspace == "edit")
                setTimeout(this.editTag.bind(this), 0);
            }
          }
          break;
        case "Esc":
        case "Escape":
          if (this.state.dropdown.visible)
            return;
          e.target.blur();
          break;
        case "Down":
        case "ArrowDown":
          if (!this.state.dropdown.visible)
            this.dropdown.show();
          break;
        case "ArrowRight": {
          let tagData = this.state.inputSuggestion || this.state.ddItemData;
          if (tagData && _s.autoComplete.rightKey) {
            this.addTags([tagData], true);
            return;
          }
          break;
        }
        case "Tab": {
          let selectMode = _s.mode == "select";
          if (s && !selectMode)
            e.preventDefault();
          else
            return true;
        }
        case "Enter":
          if (this.state.dropdown.visible && _s.dropdown.position != "manual")
            return;
          e.preventDefault();
          setTimeout(() => {
            if (this.state.dropdown.visible || this.state.actions.selectOption)
              return;
            this.addTags(s, true);
          });
      }
    },
    onInput(e) {
      this.postUpdate();
      var _s = this.settings;
      if (_s.mode == "mix")
        return this.events.callbacks.onMixTagsInput.call(this, e);
      var value = this.input.normalize.call(this), showSuggestions = value.length >= _s.dropdown.enabled, eventData = {
        value,
        inputElm: this.DOM.input
      }, validation = this.validateTag({
        value
      });
      if (_s.mode == "select") {
        this.toggleScopeValidation(validation);
      }
      eventData.isValid = validation;
      if (this.state.inputText == value)
        return;
      this.input.set.call(this, value, false);
      if (value.search(_s.delimiters) != -1) {
        if (this.addTags(value)) {
          this.input.set.call(this);
        }
      } else if (_s.dropdown.enabled >= 0) {
        this.dropdown[showSuggestions ? "show" : "hide"](value);
      }
      this.trigger("input", eventData);
    },
    onMixTagsInput(e) {
      var rangeText, match, matchedPatternCount, tag, showSuggestions, selection, _s = this.settings, lastTagsCount = this.value.length, matchFlaggedTag, matchDelimiters, tagsElems = this.getTagElms(), fragment = document.createDocumentFragment(), range = window.getSelection().getRangeAt(0), remainingTagsValues = [].map.call(tagsElems, (node) => getSetTagData(node).value);
      if (e.inputType == "deleteContentBackward" && isChromeAndroidBrowser()) {
        this.events.callbacks.onKeydown.call(this, {
          target: e.target,
          key: "Backspace"
        });
      }
      this.value.slice().forEach((item) => {
        if (item.readonly && !remainingTagsValues.includes(item.value))
          fragment.appendChild(this.createTagElem(item));
      });
      if (fragment.childNodes.length) {
        range.insertNode(fragment);
        this.setRangeAtStartEnd(false, fragment.lastChild);
      }
      if (tagsElems.length != lastTagsCount) {
        this.value = [].map.call(this.getTagElms(), (node) => getSetTagData(node));
        this.update({
          withoutChangeEvent: true
        });
        return;
      }
      if (this.hasMaxTags())
        return true;
      if (window.getSelection) {
        selection = window.getSelection();
        if (selection.rangeCount > 0 && selection.anchorNode.nodeType == 3) {
          range = selection.getRangeAt(0).cloneRange();
          range.collapse(true);
          range.setStart(selection.focusNode, 0);
          rangeText = range.toString().slice(0, range.endOffset);
          matchedPatternCount = rangeText.split(_s.pattern).length - 1;
          match = rangeText.match(_s.pattern);
          if (match)
            tag = rangeText.slice(rangeText.lastIndexOf(match[match.length - 1]));
          if (tag) {
            this.state.actions.ArrowLeft = false;
            this.state.tag = {
              prefix: tag.match(_s.pattern)[0],
              value: tag.replace(_s.pattern, "")
              // get rid of the prefix
            };
            this.state.tag.baseOffset = selection.baseOffset - this.state.tag.value.length;
            matchDelimiters = this.state.tag.value.match(_s.delimiters);
            if (matchDelimiters) {
              this.state.tag.value = this.state.tag.value.replace(_s.delimiters, "");
              this.state.tag.delimiters = matchDelimiters[0];
              this.addTags(this.state.tag.value, _s.dropdown.clearOnSelect);
              this.dropdown.hide();
              return;
            }
            showSuggestions = this.state.tag.value.length >= _s.dropdown.enabled;
            try {
              matchFlaggedTag = this.state.flaggedTags[this.state.tag.baseOffset];
              matchFlaggedTag = matchFlaggedTag.prefix == this.state.tag.prefix && matchFlaggedTag.value[0] == this.state.tag.value[0];
              if (this.state.flaggedTags[this.state.tag.baseOffset] && !this.state.tag.value)
                delete this.state.flaggedTags[this.state.tag.baseOffset];
            } catch (err) {
            }
            if (matchFlaggedTag || matchedPatternCount < this.state.mixMode.matchedPatternCount)
              showSuggestions = false;
          } else {
            this.state.flaggedTags = {};
          }
          this.state.mixMode.matchedPatternCount = matchedPatternCount;
        }
      }
      setTimeout(() => {
        this.update({
          withoutChangeEvent: true
        });
        this.trigger("input", extend({}, this.state.tag, {
          textContent: this.DOM.input.textContent
        }));
        if (this.state.tag)
          this.dropdown[showSuggestions ? "show" : "hide"](this.state.tag.value);
      }, 10);
    },
    onInputIE(e) {
      var _this = this;
      setTimeout(function() {
        _this.events.callbacks.onInput.call(_this, e);
      });
    },
    observeOriginalInputValue() {
      if (!this.DOM.originalInput.parentNode)
        this.destroy();
      if (this.DOM.originalInput.value != this.DOM.originalInput.tagifyValue)
        this.loadOriginalValues();
    },
    onClickAnywhere(e) {
      if (e.target != this.DOM.scope && !this.DOM.scope.contains(e.target)) {
        this.toggleFocusClass(false);
        this.state.hasFocus = false;
      }
    },
    onClickScope(e) {
      var _s = this.settings, tagElm = e.target.closest("." + _s.classNames.tag), timeDiffFocus = +/* @__PURE__ */ new Date() - this.state.hasFocus;
      if (e.target == this.DOM.scope) {
        this.DOM.input.focus();
        return;
      } else if (e.target.classList.contains(_s.classNames.tagX)) {
        this.removeTags(e.target.parentNode);
        return;
      } else if (tagElm) {
        this.trigger("click", {
          tag: tagElm,
          index: this.getNodeIndex(tagElm),
          data: getSetTagData(tagElm),
          event: e
        });
        if (_s.editTags === 1 || _s.editTags.clicks === 1)
          this.events.callbacks.onDoubleClickScope.call(this, e);
        return;
      } else if (e.target == this.DOM.input) {
        if (_s.mode == "mix") {
          this.fixFirefoxLastTagNoCaret();
        }
        if (timeDiffFocus > 500) {
          if (this.state.dropdown.visible)
            this.dropdown.hide();
          else if (_s.dropdown.enabled === 0 && _s.mode != "mix")
            this.dropdown.show(this.value.length ? "" : void 0);
          return;
        }
      }
      if (_s.mode == "select" && _s.dropdown.enabled === 0 && !this.state.dropdown.visible)
        this.dropdown.show();
    },
    // special proccess is needed for pasted content in order to "clean" it
    onPaste(e) {
      e.preventDefault();
      var _s = this.settings, selectModeWithoutInput = _s.mode == "select" && _s.enforceWhitelist;
      if (selectModeWithoutInput || !_s.userInput) {
        return false;
      }
      var clipboardData, pastedText;
      if (_s.readonly)
        return;
      clipboardData = e.clipboardData || window.clipboardData;
      pastedText = clipboardData.getData("Text");
      _s.hooks.beforePaste(e, {
        tagify: this,
        pastedText,
        clipboardData
      }).then((result) => {
        if (result === void 0)
          result = pastedText;
        if (result) {
          this.injectAtCaret(result, window.getSelection().getRangeAt(0));
          if (this.settings.mode == "mix") {
            this.events.callbacks.onMixTagsInput.call(this, e);
          } else if (this.settings.pasteAsTags) {
            this.addTags(this.state.inputText + result, true);
          } else
            this.state.inputText = result;
        }
      }).catch((err) => err);
    },
    onDrop(e) {
      e.preventDefault();
    },
    onEditTagInput(editableElm, e) {
      var tagElm = editableElm.closest("." + this.settings.classNames.tag), tagElmIdx = this.getNodeIndex(tagElm), tagData = getSetTagData(tagElm), textValue = this.input.normalize.call(this, editableElm), dataForChangedProp = {
        [this.settings.tagTextProp]: textValue,
        __tagId: tagData.__tagId
      }, isValid = this.validateTag(dataForChangedProp), hasChanged = this.editTagChangeDetected(extend(tagData, dataForChangedProp));
      if (!hasChanged && editableElm.originalIsValid === true)
        isValid = true;
      tagElm.classList.toggle(this.settings.classNames.tagInvalid, isValid !== true);
      tagData.__isValid = isValid;
      tagElm.title = isValid === true ? tagData.title || tagData.value : isValid;
      if (textValue.length >= this.settings.dropdown.enabled) {
        if (this.state.editing)
          this.state.editing.value = textValue;
        this.dropdown.show(textValue);
      }
      this.trigger("edit:input", {
        tag: tagElm,
        index: tagElmIdx,
        data: extend({}, this.value[tagElmIdx], {
          newValue: textValue
        }),
        event: e
      });
    },
    onEditTagPaste(tagElm, e) {
      var clipboardData = e.clipboardData || window.clipboardData, pastedText = clipboardData.getData("Text");
      e.preventDefault();
      var newNode = injectAtCaret(pastedText);
      this.setRangeAtStartEnd(false, newNode);
    },
    onEditTagFocus(tagElm) {
      this.state.editing = {
        scope: tagElm,
        input: tagElm.querySelector("[contenteditable]")
      };
    },
    onEditTagBlur(editableElm) {
      if (!this.state.hasFocus)
        this.toggleFocusClass();
      if (!this.DOM.scope.contains(editableElm))
        return;
      var _s = this.settings, tagElm = editableElm.closest("." + _s.classNames.tag), tagData = getSetTagData(tagElm), textValue = this.input.normalize.call(this, editableElm), dataForChangedProp = {
        [_s.tagTextProp]: textValue,
        __tagId: tagData.__tagId
      }, originalData = tagData.__originalData, hasChanged = this.editTagChangeDetected(extend(tagData, dataForChangedProp)), isValid = this.validateTag(dataForChangedProp), hasMaxTags, newTagData;
      if (!textValue) {
        this.onEditTagDone(tagElm);
        return;
      }
      if (!hasChanged) {
        this.onEditTagDone(tagElm, originalData);
        return;
      }
      hasMaxTags = this.hasMaxTags();
      newTagData = extend({}, originalData, {
        [_s.tagTextProp]: this.trim(textValue),
        __isValid: isValid
      });
      _s.transformTag.call(this, newTagData, originalData);
      isValid = (!hasMaxTags || originalData.__isValid === true) && this.validateTag(newTagData);
      if (isValid !== true) {
        this.trigger("invalid", {
          data: newTagData,
          tag: tagElm,
          message: isValid
        });
        if (_s.editTags.keepInvalid)
          return;
        if (_s.keepInvalidTags)
          newTagData.__isValid = isValid;
        else
          newTagData = originalData;
      } else if (_s.keepInvalidTags) {
        delete newTagData.title;
        delete newTagData["aria-invalid"];
        delete newTagData.class;
      }
      this.onEditTagDone(tagElm, newTagData);
    },
    onEditTagkeydown(e, tagElm) {
      if (this.state.composing)
        return;
      this.trigger("edit:keydown", {
        event: e
      });
      switch (e.key) {
        case "Esc":
        case "Escape": {
          tagElm.parentNode.replaceChild(tagElm.__tagifyTagData.__originalHTML, tagElm);
          this.state.editing = false;
        }
        case "Enter":
        case "Tab":
          e.preventDefault();
          e.target.blur();
      }
    },
    onDoubleClickScope(e) {
      var tagElm = e.target.closest("." + this.settings.classNames.tag), tagData = getSetTagData(tagElm), _s = this.settings, isEditingTag, isReadyOnlyTag;
      if (!tagElm || !_s.userInput || tagData.editable === false)
        return;
      isEditingTag = tagElm.classList.contains(this.settings.classNames.tagEditing);
      isReadyOnlyTag = tagElm.hasAttribute("readonly");
      if (_s.mode != "select" && !_s.readonly && !isEditingTag && !isReadyOnlyTag && this.settings.editTags)
        this.editTag(tagElm);
      this.toggleFocusClass(true);
      this.trigger("dblclick", {
        tag: tagElm,
        index: this.getNodeIndex(tagElm),
        data: getSetTagData(tagElm)
      });
    },
    /**
     *
     * @param {Object} m an object representing the observed DOM changes
     */
    onInputDOMChange(m) {
      m.forEach((record) => {
        record.addedNodes.forEach((addedNode) => {
          var _a;
          if (addedNode.outerHTML == "<div><br></div>") {
            addedNode.replaceWith(document.createElement("br"));
          } else if (addedNode.nodeType == 1 && addedNode.querySelector(this.settings.classNames.tagSelector)) {
            let newlineText = document.createTextNode("");
            if (addedNode.childNodes[0].nodeType == 3 && addedNode.previousSibling.nodeName != "BR")
              newlineText = document.createTextNode("\n");
            addedNode.replaceWith(...[newlineText, ...[...addedNode.childNodes].slice(0, -1)]);
            this.placeCaretAfterNode(newlineText);
          } else if (isNodeTag.call(this, addedNode)) {
            if (((_a = addedNode.previousSibling) == null ? void 0 : _a.nodeType) == 3 && !addedNode.previousSibling.textContent)
              addedNode.previousSibling.remove();
            if (addedNode.previousSibling && addedNode.previousSibling.nodeName == "BR") {
              addedNode.previousSibling.replaceWith("\n​");
              let nextNode = addedNode.nextSibling, anythingAfterNode = "";
              while (nextNode) {
                anythingAfterNode += nextNode.textContent;
                nextNode = nextNode.nextSibling;
              }
              anythingAfterNode.trim() && this.placeCaretAfterNode(addedNode.previousSibling);
            }
          }
        });
        record.removedNodes.forEach((removedNode) => {
          if (removedNode && removedNode.nodeName == "BR" && isNodeTag.call(this, lastInputChild)) {
            this.removeTags(lastInputChild);
            this.fixFirefoxLastTagNoCaret();
          }
        });
      });
      var lastInputChild = this.DOM.input.lastChild;
      if (lastInputChild && lastInputChild.nodeValue == "")
        lastInputChild.remove();
      if (!lastInputChild || lastInputChild.nodeName != "BR") {
        this.DOM.input.appendChild(document.createElement("br"));
      }
    }
  }
};
function Tagify(input, settings) {
  if (!input) {
    console.warn("Tagify:", "input element not found", input);
    const mockInstance = new Proxy(this, {
      get() {
        return () => mockInstance;
      }
    });
    return mockInstance;
  }
  if (input.__tagify) {
    console.warn("Tagify: ", "input element is already Tagified - Same instance is returned.", input);
    return input.__tagify;
  }
  extend(this, EventDispatcher(this));
  this.isFirefox = /firefox|fxios/i.test(navigator.userAgent) && !/seamonkey/i.test(navigator.userAgent);
  this.isIE = window.document.documentMode;
  settings = settings || {};
  this.getPersistedData = getPersistedData(settings.id);
  this.setPersistedData = setPersistedData(settings.id);
  this.clearPersistedData = clearPersistedData(settings.id);
  this.applySettings(input, settings);
  this.state = {
    inputText: "",
    editing: false,
    composing: false,
    actions: {},
    // UI actions for state-locking
    mixMode: {},
    dropdown: {},
    flaggedTags: {}
    // in mix-mode, when a string is detetced as potential tag, and the user has chocen to close the suggestions dropdown, keep the record of the tasg here
  };
  this.value = [];
  this.listeners = {};
  this.DOM = {};
  this.build(input);
  initDropdown.call(this);
  this.getCSSVars();
  this.loadOriginalValues();
  this.events.customBinding.call(this);
  this.events.binding.call(this);
  input.autofocus && this.DOM.input.focus();
  input.__tagify = this;
}
Tagify.prototype = {
  _dropdown,
  getSetTagData,
  helpers: {
    sameStr,
    removeCollectionProp,
    omit,
    isObject,
    parseHTML,
    escapeHTML,
    extend,
    concatWithoutDups,
    getUID,
    isNodeTag
  },
  customEventsList: ["change", "add", "remove", "invalid", "input", "click", "keydown", "focus", "blur", "edit:input", "edit:beforeUpdate", "edit:updated", "edit:start", "edit:keydown", "dropdown:show", "dropdown:hide", "dropdown:select", "dropdown:updated", "dropdown:noMatch", "dropdown:scroll"],
  dataProps: ["__isValid", "__removed", "__originalData", "__originalHTML", "__tagId"],
  // internal-uasge props
  trim(text) {
    return this.settings.trim && text && typeof text == "string" ? text.trim() : text;
  },
  // expose this handy utility function
  parseHTML,
  templates,
  parseTemplate(template, data) {
    template = this.settings.templates[template] || template;
    return parseHTML(template.apply(this, data));
  },
  set whitelist(arr) {
    const isArray2 = arr && Array.isArray(arr);
    this.settings.whitelist = isArray2 ? arr : [];
    this.setPersistedData(isArray2 ? arr : [], "whitelist");
  },
  get whitelist() {
    return this.settings.whitelist;
  },
  generateClassSelectors(classNames) {
    for (let name in classNames) {
      let currentName = name;
      Object.defineProperty(classNames, currentName + "Selector", {
        get() {
          return "." + this[currentName].split(" ")[0];
        }
      });
    }
  },
  applySettings(input, settings) {
    var _a, _b;
    DEFAULTS.templates = this.templates;
    var mixModeDefaults = {
      dropdown: {
        position: "text"
      }
    };
    var mergedDefaults = extend({}, DEFAULTS, settings.mode == "mix" ? mixModeDefaults : {});
    var _s = this.settings = extend({}, mergedDefaults, settings);
    _s.disabled = input.hasAttribute("disabled");
    _s.readonly = _s.readonly || input.hasAttribute("readonly");
    _s.placeholder = escapeHTML(input.getAttribute("placeholder") || _s.placeholder || "");
    _s.required = input.hasAttribute("required");
    this.generateClassSelectors(_s.classNames);
    if (_s.dropdown.includeSelectedTags === void 0)
      _s.dropdown.includeSelectedTags = _s.duplicates;
    if (this.isIE)
      _s.autoComplete = false;
    ["whitelist", "blacklist"].forEach((name) => {
      var attrVal = input.getAttribute("data-" + name);
      if (attrVal) {
        attrVal = attrVal.split(_s.delimiters);
        if (attrVal instanceof Array)
          _s[name] = attrVal;
      }
    });
    if ("autoComplete" in settings && !isObject(settings.autoComplete)) {
      _s.autoComplete = DEFAULTS.autoComplete;
      _s.autoComplete.enabled = settings.autoComplete;
    }
    if (_s.mode == "mix") {
      _s.pattern = _s.pattern || /@/;
      _s.autoComplete.rightKey = true;
      _s.delimiters = settings.delimiters || null;
      if (_s.tagTextProp && !_s.dropdown.searchKeys.includes(_s.tagTextProp))
        _s.dropdown.searchKeys.push(_s.tagTextProp);
    }
    if (input.pattern)
      try {
        _s.pattern = new RegExp(input.pattern);
      } catch (e) {
      }
    if (_s.delimiters) {
      _s._delimiters = _s.delimiters;
      try {
        _s.delimiters = new RegExp(this.settings.delimiters, "g");
      } catch (e) {
      }
    }
    if (_s.disabled)
      _s.userInput = false;
    this.TEXTS = _objectSpread2(_objectSpread2({}, TEXTS), _s.texts || {});
    if (_s.mode == "select" && !((_a = settings.dropdown) == null ? void 0 : _a.enabled) || !_s.userInput) {
      _s.dropdown.enabled = 0;
    }
    _s.dropdown.appendTarget = ((_b = settings.dropdown) == null ? void 0 : _b.appendTarget) || document.body;
    let persistedWhitelist = this.getPersistedData("whitelist");
    if (Array.isArray(persistedWhitelist))
      this.whitelist = Array.isArray(_s.whitelist) ? concatWithoutDups(_s.whitelist, persistedWhitelist) : persistedWhitelist;
  },
  /**
   * Returns a string of HTML element attributes
   * @param {Object} data [Tag data]
   */
  getAttributes(data) {
    var attrs = this.getCustomAttributes(data), s = "", k;
    for (k in attrs)
      s += " " + k + (data[k] !== void 0 ? `="${attrs[k]}"` : "");
    return s;
  },
  /**
   * Returns an object of attributes to be used for the templates
   */
  getCustomAttributes(data) {
    if (!isObject(data))
      return "";
    var output = {}, propName;
    for (propName in data) {
      if (propName.slice(0, 2) != "__" && propName != "class" && data.hasOwnProperty(propName) && data[propName] !== void 0)
        output[propName] = escapeHTML(data[propName]);
    }
    return output;
  },
  setStateSelection() {
    var selection = window.getSelection();
    var sel = {
      anchorOffset: selection.anchorOffset,
      anchorNode: selection.anchorNode,
      range: selection.getRangeAt && selection.rangeCount && selection.getRangeAt(0)
    };
    this.state.selection = sel;
    return sel;
  },
  /**
   * Get specific CSS variables which are relevant to this script and parse them as needed.
   * The result is saved on the instance in "this.CSSVars"
   */
  getCSSVars() {
    var compStyle = getComputedStyle(this.DOM.scope, null);
    const getProp = (name) => compStyle.getPropertyValue("--" + name);
    function seprateUnitFromValue(a) {
      if (!a)
        return {};
      a = a.trim().split(" ")[0];
      var unit = a.split(/\d+/g).filter((n) => n).pop().trim(), value = +a.split(unit).filter((n) => n)[0].trim();
      return {
        value,
        unit
      };
    }
    this.CSSVars = {
      tagHideTransition: ((_ref) => {
        let value = _ref.value, unit = _ref.unit;
        return unit == "s" ? value * 1e3 : value;
      })(seprateUnitFromValue(getProp("tag-hide-transition")))
    };
  },
  /**
   * builds the HTML of this component
   * @param  {Object} input [DOM element which would be "transformed" into "Tags"]
   */
  build(input) {
    var DOM = this.DOM;
    if (this.settings.mixMode.integrated) {
      DOM.originalInput = null;
      DOM.scope = input;
      DOM.input = input;
    } else {
      DOM.originalInput = input;
      DOM.originalInput_tabIndex = input.tabIndex;
      DOM.scope = this.parseTemplate("wrapper", [input, this.settings]);
      DOM.input = DOM.scope.querySelector(this.settings.classNames.inputSelector);
      input.parentNode.insertBefore(DOM.scope, input);
      input.tabIndex = -1;
    }
  },
  /**
   * revert any changes made by this component
   */
  destroy() {
    this.events.unbindGlobal.call(this);
    this.DOM.scope.parentNode.removeChild(this.DOM.scope);
    this.DOM.originalInput.tabIndex = this.DOM.originalInput_tabIndex;
    delete this.DOM.originalInput.__tagify;
    this.dropdown.hide(true);
    clearTimeout(this.dropdownHide__bindEventsTimeout);
    clearInterval(this.listeners.main.originalInputValueObserverInterval);
  },
  /**
   * if the original input has any values, add them as tags
   */
  loadOriginalValues(value) {
    var lastChild, _s = this.settings;
    this.state.blockChangeEvent = true;
    if (value === void 0) {
      const persistedOriginalValue = this.getPersistedData("value");
      if (persistedOriginalValue && !this.DOM.originalInput.value)
        value = persistedOriginalValue;
      else
        value = _s.mixMode.integrated ? this.DOM.input.textContent : this.DOM.originalInput.value;
    }
    this.removeAllTags();
    if (value) {
      if (_s.mode == "mix") {
        this.parseMixTags(value);
        lastChild = this.DOM.input.lastChild;
        if (!lastChild || lastChild.tagName != "BR")
          this.DOM.input.insertAdjacentHTML("beforeend", "<br>");
      } else {
        try {
          if (JSON.parse(value) instanceof Array)
            value = JSON.parse(value);
        } catch (err) {
        }
        this.addTags(value, true).forEach((tag) => tag && tag.classList.add(_s.classNames.tagNoAnimation));
      }
    } else
      this.postUpdate();
    this.state.lastOriginalValueReported = _s.mixMode.integrated ? "" : this.DOM.originalInput.value;
  },
  cloneEvent(e) {
    var clonedEvent = {};
    for (var v in e)
      if (v != "path")
        clonedEvent[v] = e[v];
    return clonedEvent;
  },
  /**
   * Toogle global loading state on/off
   * Useful when fetching async whitelist while user is typing
   * @param {Boolean} isLoading
   */
  loading(isLoading) {
    this.state.isLoading = isLoading;
    this.DOM.scope.classList[isLoading ? "add" : "remove"](this.settings.classNames.scopeLoading);
    return this;
  },
  /**
   * Toogle a tag loading state on/off
   * @param {Boolean} isLoading
   */
  tagLoading(tagElm, isLoading) {
    if (tagElm)
      tagElm.classList[isLoading ? "add" : "remove"](this.settings.classNames.tagLoading);
    return this;
  },
  /**
   * Toggles class on the main tagify container ("scope")
   * @param {String} className
   * @param {Boolean} force
   */
  toggleClass(className, force) {
    if (typeof className == "string")
      this.DOM.scope.classList.toggle(className, force);
  },
  toggleScopeValidation(validation) {
    var isValid = validation === true || validation === void 0;
    if (!this.settings.required && validation && validation === this.TEXTS.empty)
      isValid = true;
    this.toggleClass(this.settings.classNames.tagInvalid, !isValid);
    this.DOM.scope.title = isValid ? "" : validation;
  },
  toggleFocusClass(force) {
    this.toggleClass(this.settings.classNames.focus, !!force);
  },
  triggerChangeEvent,
  events,
  fixFirefoxLastTagNoCaret() {
    return;
  },
  /** https://stackoverflow.com/a/59156872/104380
   * @param {Boolean} start indicating where to place it (start or end of the node)
   * @param {Object}  node  DOM node to place the caret at
   */
  setRangeAtStartEnd(start, node) {
    if (!node)
      return;
    start = typeof start == "number" ? start : !!start;
    node = node.lastChild || node;
    var sel = document.getSelection();
    if (sel.focusNode instanceof Element && !this.DOM.input.contains(sel.focusNode)) {
      return true;
    }
    try {
      if (sel.rangeCount >= 1) {
        ["Start", "End"].forEach((pos) => sel.getRangeAt(0)["set" + pos](node, start ? start : node.length));
      }
    } catch (err) {
    }
  },
  placeCaretAfterNode(node) {
    if (!node || !node.parentNode)
      return;
    var nextSibling = node, sel = window.getSelection(), range = sel.getRangeAt(0);
    if (sel.rangeCount) {
      range.setStartAfter(nextSibling);
      range.collapse(true);
      sel.removeAllRanges();
      sel.addRange(range);
    }
  },
  insertAfterTag(tagElm, newNode) {
    newNode = newNode || this.settings.mixMode.insertAfterTag;
    if (!tagElm || !tagElm.parentNode || !newNode)
      return;
    newNode = typeof newNode == "string" ? document.createTextNode(newNode) : newNode;
    tagElm.parentNode.insertBefore(newNode, tagElm.nextSibling);
    return newNode;
  },
  // compares all "__originalData" property values with the current "tagData" properties
  // and returns "true" if something changed.
  editTagChangeDetected(tagData) {
    var originalData = tagData.__originalData;
    for (var prop in originalData)
      if (!this.dataProps.includes(prop) && tagData[prop] != originalData[prop])
        return true;
    return false;
  },
  // returns the node which has the actual tag's content
  getTagTextNode(tagElm) {
    return tagElm.querySelector(this.settings.classNames.tagTextSelector);
  },
  // sets the text of a tag
  setTagTextNode(tagElm, HTML) {
    this.getTagTextNode(tagElm).innerHTML = escapeHTML(HTML);
  },
  /**
   * Enters a tag into "edit" mode
   * @param {Node} tagElm the tag element to edit. if nothing specified, use last last
   */
  editTag(tagElm, opts) {
    tagElm = tagElm || this.getLastTag();
    opts = opts || {};
    this.dropdown.hide();
    var _s = this.settings, editableElm = this.getTagTextNode(tagElm), tagIdx = this.getNodeIndex(tagElm), tagData = getSetTagData(tagElm), _CB = this.events.callbacks, that = this, isValid = true, delayed_onEditTagBlur = function() {
      setTimeout(() => _CB.onEditTagBlur.call(that, that.getTagTextNode(tagElm)));
    };
    if (!editableElm) {
      console.warn("Cannot find element in Tag template: .", _s.classNames.tagTextSelector);
      return;
    }
    if (tagData instanceof Object && "editable" in tagData && !tagData.editable)
      return;
    tagData = getSetTagData(tagElm, {
      __originalData: extend({}, tagData),
      __originalHTML: tagElm.cloneNode(true)
    });
    getSetTagData(tagData.__originalHTML, tagData.__originalData);
    editableElm.setAttribute("contenteditable", true);
    tagElm.classList.add(_s.classNames.tagEditing);
    editableElm.addEventListener("focus", _CB.onEditTagFocus.bind(this, tagElm));
    editableElm.addEventListener("blur", delayed_onEditTagBlur);
    editableElm.addEventListener("input", _CB.onEditTagInput.bind(this, editableElm));
    editableElm.addEventListener("paste", _CB.onEditTagPaste.bind(this, editableElm));
    editableElm.addEventListener("keydown", (e) => _CB.onEditTagkeydown.call(this, e, tagElm));
    editableElm.addEventListener("compositionstart", _CB.onCompositionStart.bind(this));
    editableElm.addEventListener("compositionend", _CB.onCompositionEnd.bind(this));
    if (!opts.skipValidation)
      isValid = this.editTagToggleValidity(tagElm);
    editableElm.originalIsValid = isValid;
    this.trigger("edit:start", {
      tag: tagElm,
      index: tagIdx,
      data: tagData,
      isValid
    });
    editableElm.focus();
    this.setRangeAtStartEnd(false, editableElm);
    return this;
  },
  /**
   * If a tag is invalid, for any reason, set its class to "not allowed" (see defaults file)
   * @param {Node} tagElm required
   * @param {Object} tagData optional
   * @returns true if valid, a string (reason) if not
   */
  editTagToggleValidity(tagElm, tagData) {
    var tagData = tagData || getSetTagData(tagElm), isValid;
    if (!tagData) {
      console.warn("tag has no data: ", tagElm, tagData);
      return;
    }
    isValid = !("__isValid" in tagData) || tagData.__isValid === true;
    if (!isValid) {
      this.removeTagsFromValue(tagElm);
    }
    this.update();
    tagElm.classList.toggle(this.settings.classNames.tagNotAllowed, !isValid);
    return tagData.__isValid;
  },
  onEditTagDone(tagElm, tagData) {
    tagElm = tagElm || this.state.editing.scope;
    tagData = tagData || {};
    var eventData = {
      tag: tagElm,
      index: this.getNodeIndex(tagElm),
      previousData: getSetTagData(tagElm),
      data: tagData
    };
    this.trigger("edit:beforeUpdate", eventData, {
      cloneData: false
    });
    this.state.editing = false;
    delete tagData.__originalData;
    delete tagData.__originalHTML;
    if (tagElm && tagData[this.settings.tagTextProp]) {
      tagElm = this.replaceTag(tagElm, tagData);
      this.editTagToggleValidity(tagElm, tagData);
      if (this.settings.a11y.focusableTags)
        tagElm.focus();
      else
        this.placeCaretAfterNode(tagElm);
    } else if (tagElm)
      this.removeTags(tagElm);
    this.trigger("edit:updated", eventData);
    this.dropdown.hide();
    if (this.settings.keepInvalidTags)
      this.reCheckInvalidTags();
  },
  /**
   * Replaces an exisitng tag with a new one. Used for updating a tag's data
   * @param {Object} tagElm  [DOM node to replace]
   * @param {Object} tagData [data to create new tag from]
   */
  replaceTag(tagElm, tagData) {
    if (!tagData || !tagData.value)
      tagData = tagElm.__tagifyTagData;
    if (tagData.__isValid && tagData.__isValid != true)
      extend(tagData, this.getInvalidTagAttrs(tagData, tagData.__isValid));
    var newTagElm = this.createTagElem(tagData);
    tagElm.parentNode.replaceChild(newTagElm, tagElm);
    this.updateValueByDOMTags();
    return newTagElm;
  },
  /**
   * update "value" (Array of Objects) by traversing all valid tags
   */
  updateValueByDOMTags() {
    this.value.length = 0;
    [].forEach.call(this.getTagElms(), (node) => {
      if (node.classList.contains(this.settings.classNames.tagNotAllowed.split(" ")[0]))
        return;
      this.value.push(getSetTagData(node));
    });
    this.update();
  },
  /**
   * injects nodes/text at caret position, which is saved on the "state" when "blur" event gets triggered
   * @param {Node} injectedNode [the node to inject at the caret position]
   * @param {Object} selection [optional range Object. must have "anchorNode" & "anchorOffset"]
   */
  injectAtCaret(injectedNode, range) {
    var _a;
    range = range || ((_a = this.state.selection) == null ? void 0 : _a.range);
    if (!range && injectedNode) {
      this.appendMixTags(injectedNode);
      return this;
    }
    injectAtCaret(injectedNode, range);
    this.setRangeAtStartEnd(false, injectedNode);
    this.updateValueByDOMTags();
    this.update();
    return this;
  },
  /**
   * input bridge for accessing & setting
   * @type {Object}
   */
  input: {
    set() {
      let s = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
      let updateDOM = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
      var hideDropdown = this.settings.dropdown.closeOnSelect;
      this.state.inputText = s;
      if (updateDOM)
        this.DOM.input.innerHTML = escapeHTML("" + s);
      if (!s && hideDropdown)
        this.dropdown.hide.bind(this);
      this.input.autocomplete.suggest.call(this);
      this.input.validate.call(this);
    },
    raw() {
      return this.DOM.input.textContent;
    },
    /**
     * Marks the tagify's input as "invalid" if the value did not pass "validateTag()"
     */
    validate() {
      var isValid = !this.state.inputText || this.validateTag({
        value: this.state.inputText
      }) === true;
      this.DOM.input.classList.toggle(this.settings.classNames.inputInvalid, !isValid);
      return isValid;
    },
    // remove any child DOM elements that aren't of type TEXT (like <br>)
    normalize(node) {
      var clone = node || this.DOM.input, v = [];
      clone.childNodes.forEach((n) => n.nodeType == 3 && v.push(n.nodeValue));
      v = v.join("\n");
      try {
        v = v.replace(/(?:\r\n|\r|\n)/g, this.settings.delimiters.source.charAt(0));
      } catch (err) {
      }
      v = v.replace(/\s/g, " ");
      return this.trim(v);
    },
    /**
     * suggest the rest of the input's value (via CSS "::after" using "content:attr(...)")
     * @param  {String} s [description]
     */
    autocomplete: {
      suggest(data) {
        if (!this.settings.autoComplete.enabled)
          return;
        data = data || {
          value: ""
        };
        if (typeof data == "string")
          data = {
            value: data
          };
        var suggestedText = this.dropdown.getMappedValue(data);
        if (typeof suggestedText === "number")
          return;
        var suggestionStart = suggestedText.substr(0, this.state.inputText.length).toLowerCase(), suggestionTrimmed = suggestedText.substring(this.state.inputText.length);
        if (!suggestedText || !this.state.inputText || suggestionStart != this.state.inputText.toLowerCase()) {
          this.DOM.input.removeAttribute("data-suggest");
          delete this.state.inputSuggestion;
        } else {
          this.DOM.input.setAttribute("data-suggest", suggestionTrimmed);
          this.state.inputSuggestion = data;
        }
      },
      /**
       * sets the suggested text as the input's value & cleanup the suggestion autocomplete.
       * @param {String} s [text]
       */
      set(s) {
        var dataSuggest = this.DOM.input.getAttribute("data-suggest"), suggestion = s || (dataSuggest ? this.state.inputText + dataSuggest : null);
        if (suggestion) {
          if (this.settings.mode == "mix") {
            this.replaceTextWithNode(document.createTextNode(this.state.tag.prefix + suggestion));
          } else {
            this.input.set.call(this, suggestion);
            this.setRangeAtStartEnd(false, this.DOM.input);
          }
          this.input.autocomplete.suggest.call(this);
          this.dropdown.hide();
          return true;
        }
        return false;
      }
    }
  },
  /**
   * returns the index of the the tagData within the "this.value" array collection.
   * since values should be unique, it is suffice to only search by "value" property
   * @param {Object} tagData
   */
  getTagIdx(tagData) {
    return this.value.findIndex((item) => item.__tagId == (tagData || {}).__tagId);
  },
  getNodeIndex(node) {
    var index = 0;
    if (node)
      while (node = node.previousElementSibling)
        index++;
    return index;
  },
  getTagElms() {
    for (var _len = arguments.length, classess = new Array(_len), _key = 0; _key < _len; _key++) {
      classess[_key] = arguments[_key];
    }
    var classname = "." + [...this.settings.classNames.tag.split(" "), ...classess].join(".");
    return [].slice.call(this.DOM.scope.querySelectorAll(classname));
  },
  /**
   * gets the last non-readonly, not-in-the-proccess-of-removal tag
   */
  getLastTag() {
    var lastTag = this.DOM.scope.querySelectorAll(`${this.settings.classNames.tagSelector}:not(.${this.settings.classNames.tagHide}):not([readonly])`);
    return lastTag[lastTag.length - 1];
  },
  /**
   * Searches if any tag with a certain value already exis
   * @param  {String/Object} value [text value / tag data object]
   * @param  {Boolean} caseSensitive
   * @return {Number}
   */
  isTagDuplicate(value, caseSensitive, tagId) {
    var dupsCount = 0, _s = this.settings;
    if (_s.mode == "select")
      return false;
    for (let item of this.value) {
      let isSameStr = sameStr(this.trim("" + value), item.value, caseSensitive);
      if (isSameStr && tagId != item.__tagId)
        dupsCount++;
    }
    return dupsCount;
  },
  getTagIndexByValue(value) {
    var indices = [];
    this.getTagElms().forEach((tagElm, i) => {
      if (sameStr(this.trim(tagElm.textContent), value, this.settings.dropdown.caseSensitive))
        indices.push(i);
    });
    return indices;
  },
  getTagElmByValue(value) {
    var tagIdx = this.getTagIndexByValue(value)[0];
    return this.getTagElms()[tagIdx];
  },
  /**
   * Temporarily marks a tag element (by value or Node argument)
   * @param  {Object} tagElm [a specific "tag" element to compare to the other tag elements siblings]
   */
  flashTag(tagElm) {
    if (tagElm) {
      tagElm.classList.add(this.settings.classNames.tagFlash);
      setTimeout(() => {
        tagElm.classList.remove(this.settings.classNames.tagFlash);
      }, 100);
    }
  },
  /**
   * checks if text is in the blacklist
   */
  isTagBlacklisted(v) {
    v = this.trim(v.toLowerCase());
    return this.settings.blacklist.filter((x) => ("" + x).toLowerCase() == v).length;
  },
  /**
   * checks if text is in the whitelist
   */
  isTagWhitelisted(v) {
    return !!this.getWhitelistItem(v);
  },
  /**
   * Returns the first whitelist item matched, by value (if match found)
   * @param {String} value [text to match by]
   */
  getWhitelistItem(value, prop, whitelist) {
    var result, prop = prop || "value", _s = this.settings, whitelist = whitelist || _s.whitelist;
    whitelist.some((_wi) => {
      var _wiv = typeof _wi == "string" ? _wi : _wi[prop] || _wi.value, isSameStr = sameStr(_wiv, value, _s.dropdown.caseSensitive, _s.trim);
      if (isSameStr) {
        result = typeof _wi == "string" ? {
          value: _wi
        } : _wi;
        return true;
      }
    });
    if (!result && prop == "value" && _s.tagTextProp != "value") {
      result = this.getWhitelistItem(value, _s.tagTextProp, whitelist);
    }
    return result;
  },
  /**
   * validate a tag object BEFORE the actual tag will be created & appeneded
   * @param  {String} s
   * @param  {String} uid      [unique ID, to not inclue own tag when cheking for duplicates]
   * @return {Boolean/String}  ["true" if validation has passed, String for a fail]
   */
  validateTag(tagData) {
    var _s = this.settings, prop = "value" in tagData ? "value" : _s.tagTextProp, v = this.trim(tagData[prop] + "");
    if (!(tagData[prop] + "").trim())
      return this.TEXTS.empty;
    if (_s.pattern && _s.pattern instanceof RegExp && !_s.pattern.test(v))
      return this.TEXTS.pattern;
    if (!_s.duplicates && this.isTagDuplicate(v, _s.dropdown.caseSensitive, tagData.__tagId))
      return this.TEXTS.duplicate;
    if (this.isTagBlacklisted(v) || _s.enforceWhitelist && !this.isTagWhitelisted(v))
      return this.TEXTS.notAllowed;
    if (_s.validate)
      return _s.validate(tagData);
    return true;
  },
  getInvalidTagAttrs(tagData, validation) {
    return {
      "aria-invalid": true,
      "class": `${tagData.class || ""} ${this.settings.classNames.tagNotAllowed}`.trim(),
      "title": validation
    };
  },
  hasMaxTags() {
    return this.value.length >= this.settings.maxTags ? this.TEXTS.exceed : false;
  },
  setReadonly(toggle, attrribute) {
    var _s = this.settings;
    document.activeElement.blur();
    _s[attrribute || "readonly"] = toggle;
    this.DOM.scope[(toggle ? "set" : "remove") + "Attribute"](attrribute || "readonly", true);
    this.setContentEditable(!toggle);
  },
  setContentEditable(state) {
    if (!this.settings.userInput)
      return;
    this.DOM.input.contentEditable = state;
    this.DOM.input.tabIndex = !!state ? 0 : -1;
  },
  setDisabled(isDisabled) {
    this.setReadonly(isDisabled, "disabled");
  },
  /**
   * pre-proccess the tagsItems, which can be a complex tagsItems like an Array of Objects or a string comprised of multiple words
   * so each item should be iterated on and a tag created for.
   * @return {Array} [Array of Objects]
   */
  normalizeTags(tagsItems) {
    var _this$settings = this.settings, whitelist = _this$settings.whitelist, delimiters = _this$settings.delimiters, mode = _this$settings.mode, tagTextProp = _this$settings.tagTextProp, whitelistMatches = [], whitelistWithProps = whitelist ? whitelist[0] instanceof Object : false, isArray2 = Array.isArray(tagsItems), isCollection = isArray2 && tagsItems[0].value, mapStringToCollection = (s) => (s + "").split(delimiters).filter((n) => n).map((v) => ({
      [tagTextProp]: this.trim(v),
      value: this.trim(v)
    }));
    if (typeof tagsItems == "number")
      tagsItems = tagsItems.toString();
    if (typeof tagsItems == "string") {
      if (!tagsItems.trim())
        return [];
      tagsItems = mapStringToCollection(tagsItems);
    } else if (isArray2) {
      tagsItems = [].concat(...tagsItems.map((item) => item.value != void 0 ? item : mapStringToCollection(item)));
    }
    if (whitelistWithProps && !isCollection) {
      tagsItems.forEach((item) => {
        var whitelistMatchesValues = whitelistMatches.map((a) => a.value);
        var filteredList = this.dropdown.filterListItems.call(this, item[tagTextProp], {
          exact: true
        });
        if (!this.settings.duplicates)
          filteredList = filteredList.filter((filteredItem) => !whitelistMatchesValues.includes(filteredItem.value));
        var matchObj = filteredList.length > 1 ? this.getWhitelistItem(item[tagTextProp], tagTextProp, filteredList) : filteredList[0];
        if (matchObj && matchObj instanceof Object) {
          whitelistMatches.push(matchObj);
        } else if (mode != "mix") {
          if (item.value == void 0)
            item.value = item[tagTextProp];
          whitelistMatches.push(item);
        }
      });
      if (whitelistMatches.length)
        tagsItems = whitelistMatches;
    }
    return tagsItems;
  },
  /**
   * Parse the initial value of a textarea (or input) element and generate mixed text w/ tags
   * https://stackoverflow.com/a/57598892/104380
   * @param {String} s
   */
  parseMixTags(s) {
    var _this$settings2 = this.settings, mixTagsInterpolator = _this$settings2.mixTagsInterpolator, duplicates = _this$settings2.duplicates, transformTag = _this$settings2.transformTag, enforceWhitelist = _this$settings2.enforceWhitelist, maxTags = _this$settings2.maxTags, tagTextProp = _this$settings2.tagTextProp, tagsDataSet = [];
    s = s.split(mixTagsInterpolator[0]).map((s1, i) => {
      var s2 = s1.split(mixTagsInterpolator[1]), preInterpolated = s2[0], maxTagsReached = tagsDataSet.length == maxTags, textProp, tagData, tagElm;
      try {
        if (preInterpolated == +preInterpolated)
          throw Error;
        tagData = JSON.parse(preInterpolated);
      } catch (err) {
        tagData = this.normalizeTags(preInterpolated)[0] || {
          value: preInterpolated
        };
      }
      transformTag.call(this, tagData);
      if (!maxTagsReached && s2.length > 1 && (!enforceWhitelist || this.isTagWhitelisted(tagData.value)) && !(!duplicates && this.isTagDuplicate(tagData.value))) {
        textProp = tagData[tagTextProp] ? tagTextProp : "value";
        tagData[textProp] = this.trim(tagData[textProp]);
        tagElm = this.createTagElem(tagData);
        tagsDataSet.push(tagData);
        tagElm.classList.add(this.settings.classNames.tagNoAnimation);
        s2[0] = tagElm.outerHTML;
        this.value.push(tagData);
      } else if (s1)
        return i ? mixTagsInterpolator[0] + s1 : s1;
      return s2.join("");
    }).join("");
    this.DOM.input.innerHTML = s;
    this.DOM.input.appendChild(document.createTextNode(""));
    this.DOM.input.normalize();
    this.getTagElms().forEach((elm, idx) => getSetTagData(elm, tagsDataSet[idx]));
    this.update({
      withoutChangeEvent: true
    });
    return s;
  },
  /**
   * For mixed-mode: replaces a text starting with a prefix with a wrapper element (tag or something)
   * First there *has* to be a "this.state.tag" which is a string that was just typed and is staring with a prefix
   */
  replaceTextWithNode(newWrapperNode, strToReplace) {
    if (!this.state.tag && !strToReplace)
      return;
    strToReplace = strToReplace || this.state.tag.prefix + this.state.tag.value;
    var idx, nodeToReplace, selection = this.state.selection || window.getSelection(), nodeAtCaret = selection.anchorNode, firstSplitOffset = this.state.tag.delimiters ? this.state.tag.delimiters.length : 0;
    nodeAtCaret.splitText(selection.anchorOffset - firstSplitOffset);
    idx = nodeAtCaret.nodeValue.lastIndexOf(strToReplace);
    if (idx == -1)
      return true;
    nodeToReplace = nodeAtCaret.splitText(idx);
    newWrapperNode && nodeAtCaret.parentNode.replaceChild(newWrapperNode, nodeToReplace);
    return true;
  },
  /**
   * For selecting a single option (not used for multiple tags, but for "mode:select" only)
   * @param {Object} tagElm   Tag DOM node
   * @param {Object} tagData  Tag data
   */
  selectTag(tagElm, tagData) {
    var _s = this.settings;
    if (_s.enforceWhitelist && !this.isTagWhitelisted(tagData.value))
      return;
    this.input.set.call(this, tagData[_s.tagTextProp] || tagData.value, true);
    if (this.state.actions.selectOption)
      setTimeout(() => this.setRangeAtStartEnd(false, this.DOM.input));
    var lastTagElm = this.getLastTag();
    if (lastTagElm)
      this.replaceTag(lastTagElm, tagData);
    else
      this.appendTag(tagElm);
    this.value[0] = tagData;
    this.update();
    this.trigger("add", {
      tag: tagElm,
      data: tagData
    });
    return [tagElm];
  },
  /**
   * add an empty "tag" element in an editable state
   */
  addEmptyTag(initialData) {
    var tagData = extend({
      value: ""
    }, initialData || {}), tagElm = this.createTagElem(tagData);
    getSetTagData(tagElm, tagData);
    this.appendTag(tagElm);
    this.editTag(tagElm, {
      skipValidation: true
    });
  },
  /**
   * add a "tag" element to the "tags" component
   * @param {String/Array} tagsItems   [A string (single or multiple values with a delimiter), or an Array of Objects or just Array of Strings]
   * @param {Boolean}      clearInput  [flag if the input's value should be cleared after adding tags]
   * @param {Boolean}      skipInvalid [do not add, mark & remove invalid tags]
   * @return {Array} Array of DOM elements (tags)
   */
  addTags(tagsItems, clearInput, skipInvalid) {
    var tagElems = [], _s = this.settings, aggregatedinvalidInput = [], frag = document.createDocumentFragment();
    skipInvalid = skipInvalid || _s.skipInvalid;
    if (!tagsItems || tagsItems.length == 0) {
      return tagElems;
    }
    tagsItems = this.normalizeTags(tagsItems);
    switch (_s.mode) {
      case "mix":
        return this.addMixTags(tagsItems);
      case "select": {
        clearInput = false;
        this.removeAllTags();
      }
    }
    this.DOM.input.removeAttribute("style");
    tagsItems.forEach((tagData) => {
      var tagElm, tagElmParams = {}, originalData = Object.assign({}, tagData, {
        value: tagData.value + ""
      });
      tagData = Object.assign({}, originalData);
      _s.transformTag.call(this, tagData);
      tagData.__isValid = this.hasMaxTags() || this.validateTag(tagData);
      if (tagData.__isValid !== true) {
        if (skipInvalid)
          return;
        extend(tagElmParams, this.getInvalidTagAttrs(tagData, tagData.__isValid), {
          __preInvalidData: originalData
        });
        if (tagData.__isValid == this.TEXTS.duplicate)
          this.flashTag(this.getTagElmByValue(tagData.value));
        if (!_s.createInvalidTags) {
          aggregatedinvalidInput.push(tagData.value);
          return;
        }
      }
      if ("readonly" in tagData) {
        if (tagData.readonly)
          tagElmParams["aria-readonly"] = true;
        else
          delete tagData.readonly;
      }
      tagElm = this.createTagElem(tagData, tagElmParams);
      tagElems.push(tagElm);
      if (_s.mode == "select") {
        return this.selectTag(tagElm, tagData);
      }
      frag.appendChild(tagElm);
      if (tagData.__isValid && tagData.__isValid === true) {
        this.value.push(tagData);
        this.trigger("add", {
          tag: tagElm,
          index: this.value.length - 1,
          data: tagData
        });
      } else {
        this.trigger("invalid", {
          data: tagData,
          index: this.value.length,
          tag: tagElm,
          message: tagData.__isValid
        });
        if (!_s.keepInvalidTags)
          setTimeout(() => this.removeTags(tagElm, true), 1e3);
      }
      this.dropdown.position();
    });
    this.appendTag(frag);
    this.update();
    if (tagsItems.length && clearInput) {
      this.input.set.call(this, _s.createInvalidTags ? "" : aggregatedinvalidInput.join(_s._delimiters));
      this.setRangeAtStartEnd(false, this.DOM.input);
    }
    _s.dropdown.enabled && this.dropdown.refilter();
    return tagElems;
  },
  /**
   * Adds a mix-content tag
   * @param {String/Array} tagData    A string (single or multiple values with a delimiter), or an Array of Objects or just Array of Strings
   */
  addMixTags(tagsData) {
    tagsData = this.normalizeTags(tagsData);
    if (tagsData[0].prefix || this.state.tag) {
      return this.prefixedTextToTag(tagsData[0]);
    }
    var frag = document.createDocumentFragment();
    tagsData.forEach((tagData) => {
      var tagElm = this.createTagElem(tagData);
      frag.appendChild(tagElm);
    });
    this.appendMixTags(frag);
    return frag;
  },
  appendMixTags(node) {
    var selection = !!this.state.selection;
    if (selection) {
      this.injectAtCaret(node);
    } else {
      this.DOM.input.focus();
      selection = this.setStateSelection();
      selection.range.setStart(this.DOM.input, selection.range.endOffset);
      selection.range.setEnd(this.DOM.input, selection.range.endOffset);
      this.DOM.input.appendChild(node);
      this.updateValueByDOMTags();
      this.update();
    }
  },
  /**
   * Adds a tag which was activly typed by the user
   * @param {String/Array} tagItem   [A string (single or multiple values with a delimiter), or an Array of Objects or just Array of Strings]
   */
  prefixedTextToTag(tagItem) {
    var _s = this.settings, tagElm, createdFromDelimiters = this.state.tag.delimiters;
    _s.transformTag.call(this, tagItem);
    tagItem.prefix = tagItem.prefix || this.state.tag ? this.state.tag.prefix : (_s.pattern.source || _s.pattern)[0];
    tagElm = this.createTagElem(tagItem);
    if (!this.replaceTextWithNode(tagElm)) {
      this.DOM.input.appendChild(tagElm);
    }
    setTimeout(() => tagElm.classList.add(this.settings.classNames.tagNoAnimation), 300);
    this.value.push(tagItem);
    this.update();
    if (!createdFromDelimiters) {
      var elm = this.insertAfterTag(tagElm) || tagElm;
      setTimeout(this.placeCaretAfterNode, 0, elm);
    }
    this.state.tag = null;
    this.trigger("add", extend({}, {
      tag: tagElm
    }, {
      data: tagItem
    }));
    return tagElm;
  },
  /**
   * appened (validated) tag to the component's DOM scope
   */
  appendTag(tagElm) {
    var DOM = this.DOM, insertBeforeNode = DOM.input;
    DOM.scope.insertBefore(tagElm, insertBeforeNode);
  },
  /**
   * creates a DOM tag element and injects it into the component (this.DOM.scope)
   * @param  {Object}  tagData [text value & properties for the created tag]
   * @param  {Object}  extraData [properties which are for the HTML template only]
   * @return {Object} [DOM element]
   */
  createTagElem(tagData, extraData) {
    tagData.__tagId = getUID();
    var tagElm, templateData = extend({}, tagData, _objectSpread2({
      value: escapeHTML(tagData.value + "")
    }, extraData));
    tagElm = this.parseTemplate("tag", [templateData, this]);
    removeTextChildNodes(tagElm);
    getSetTagData(tagElm, tagData);
    return tagElm;
  },
  /**
   * re-check all invalid tags.
   * called after a tag was edited or removed
   */
  reCheckInvalidTags() {
    var _s = this.settings;
    this.getTagElms(_s.classNames.tagNotAllowed).forEach((tagElm, i) => {
      var tagData = getSetTagData(tagElm), hasMaxTags = this.hasMaxTags(), tagValidation = this.validateTag(tagData), isValid = tagValidation === true && !hasMaxTags;
      if (_s.mode == "select")
        this.toggleScopeValidation(tagValidation);
      if (isValid) {
        tagData = tagData.__preInvalidData ? tagData.__preInvalidData : {
          value: tagData.value
        };
        return this.replaceTag(tagElm, tagData);
      }
      tagElm.title = hasMaxTags || tagValidation;
    });
  },
  /**
   * Removes a tag
   * @param  {Array|Node|String}  tagElms         [DOM element(s) or a String value. if undefined or null, remove last added tag]
   * @param  {Boolean}            silent          [A flag, which when turned on, does not remove any value and does not update the original input value but simply removes the tag from tagify]
   * @param  {Number}             tranDuration    [Transition duration in MS]
   * TODO: Allow multiple tags to be removed at-once
   */
  removeTags(tagElms, silent, tranDuration) {
    var tagsToRemove, _s = this.settings;
    tagElms = tagElms && tagElms instanceof HTMLElement ? [tagElms] : tagElms instanceof Array ? tagElms : tagElms ? [tagElms] : [this.getLastTag()];
    tagsToRemove = tagElms.reduce((elms, tagElm) => {
      if (tagElm && typeof tagElm == "string")
        tagElm = this.getTagElmByValue(tagElm);
      var tagData = getSetTagData(tagElm);
      if (tagElm && tagData && !tagData.readonly)
        elms.push({
          node: tagElm,
          idx: this.getTagIdx(tagData),
          // this.getNodeIndex(tagElm); // this.getTagIndexByValue(tagElm.textContent)
          data: getSetTagData(tagElm, {
            "__removed": true
          })
        });
      return elms;
    }, []);
    tranDuration = typeof tranDuration == "number" ? tranDuration : this.CSSVars.tagHideTransition;
    if (_s.mode == "select") {
      tranDuration = 0;
      this.input.set.call(this);
    }
    if (tagsToRemove.length == 1 && _s.mode != "select") {
      if (tagsToRemove[0].node.classList.contains(_s.classNames.tagNotAllowed))
        silent = true;
    }
    if (!tagsToRemove.length)
      return;
    return _s.hooks.beforeRemoveTag(tagsToRemove, {
      tagify: this
    }).then(() => {
      function removeNode(tag) {
        if (!tag.node.parentNode)
          return;
        tag.node.parentNode.removeChild(tag.node);
        if (!silent) {
          this.trigger("remove", {
            tag: tag.node,
            index: tag.idx,
            data: tag.data
          });
          this.dropdown.refilter();
          this.dropdown.position();
          this.DOM.input.normalize();
          if (_s.keepInvalidTags)
            this.reCheckInvalidTags();
        } else if (_s.keepInvalidTags)
          this.trigger("remove", {
            tag: tag.node,
            index: tag.idx
          });
      }
      function animation(tag) {
        tag.node.style.width = parseFloat(window.getComputedStyle(tag.node).width) + "px";
        document.body.clientTop;
        tag.node.classList.add(_s.classNames.tagHide);
        setTimeout(removeNode.bind(this), tranDuration, tag);
      }
      if (tranDuration && tranDuration > 10 && tagsToRemove.length == 1)
        animation.call(this, tagsToRemove[0]);
      else
        tagsToRemove.forEach(removeNode.bind(this));
      if (!silent) {
        this.removeTagsFromValue(tagsToRemove.map((tag) => tag.node));
        this.update();
        if (_s.mode == "select")
          this.setContentEditable(true);
      }
    }).catch((reason) => {
    });
  },
  removeTagsFromDOM() {
    [].slice.call(this.getTagElms()).forEach((elm) => elm.parentNode.removeChild(elm));
  },
  /**
   * @param {Array/Node} tags to be removed from the this.value array
   */
  removeTagsFromValue(tags) {
    tags = Array.isArray(tags) ? tags : [tags];
    tags.forEach((tag) => {
      var tagData = getSetTagData(tag), tagIdx = this.getTagIdx(tagData);
      if (tagIdx > -1)
        this.value.splice(tagIdx, 1);
    });
  },
  removeAllTags(opts) {
    opts = opts || {};
    this.value = [];
    if (this.settings.mode == "mix")
      this.DOM.input.innerHTML = "";
    else
      this.removeTagsFromDOM();
    this.dropdown.refilter();
    this.dropdown.position();
    if (this.state.dropdown.visible)
      setTimeout(() => {
        this.DOM.input.focus();
      });
    if (this.settings.mode == "select") {
      this.input.set.call(this);
      this.setContentEditable(true);
    }
    this.update(opts);
  },
  postUpdate() {
    var _a, _b;
    this.state.blockChangeEvent = false;
    var _s = this.settings, classNames = _s.classNames, hasValue = _s.mode == "mix" ? _s.mixMode.integrated ? this.DOM.input.textContent : this.DOM.originalInput.value.trim() : this.value.length + this.input.raw.call(this).length;
    this.toggleClass(classNames.hasMaxTags, this.value.length >= _s.maxTags);
    this.toggleClass(classNames.hasNoTags, !this.value.length);
    this.toggleClass(classNames.empty, !hasValue);
    if (_s.mode == "select") {
      this.toggleScopeValidation((_b = (_a = this.value) == null ? void 0 : _a[0]) == null ? void 0 : _b.__isValid);
    }
  },
  setOriginalInputValue(v) {
    var inputElm = this.DOM.originalInput;
    if (!this.settings.mixMode.integrated) {
      inputElm.value = v;
      inputElm.tagifyValue = inputElm.value;
      this.setPersistedData(v, "value");
    }
  },
  /**
   * update the origianl (hidden) input field's value
   * see - https://stackoverflow.com/q/50957841/104380
   */
  update(args) {
    const UPDATE_DELAY = 100;
    clearTimeout(this.debouncedUpdateTimeout);
    this.debouncedUpdateTimeout = setTimeout(reallyUpdate.bind(this), UPDATE_DELAY);
    function reallyUpdate() {
      var inputValue = this.getInputValue();
      this.setOriginalInputValue(inputValue);
      if ((!this.settings.onChangeAfterBlur || !(args || {}).withoutChangeEvent) && !this.state.blockChangeEvent)
        this.triggerChangeEvent();
      this.postUpdate();
    }
  },
  getInputValue() {
    var value = this.getCleanValue();
    return this.settings.mode == "mix" ? this.getMixedTagsAsString(value) : value.length ? this.settings.originalInputValueFormat ? this.settings.originalInputValueFormat(value) : JSON.stringify(value) : "";
  },
  /**
   * removes properties from `this.value` which are only used internally
   */
  getCleanValue(v) {
    return removeCollectionProp(v || this.value, this.dataProps);
  },
  getMixedTagsAsString() {
    var result = "", that = this, _s = this.settings, originalInputValueFormat = _s.originalInputValueFormat || JSON.stringify, _interpolator = _s.mixTagsInterpolator;
    function iterateChildren(rootNode) {
      rootNode.childNodes.forEach((node) => {
        if (node.nodeType == 1) {
          const tagData = getSetTagData(node);
          if (node.tagName == "BR") {
            result += "\r\n";
          }
          if (tagData && isNodeTag.call(that, node)) {
            if (tagData.__removed)
              return;
            else
              result += _interpolator[0] + originalInputValueFormat(omit(tagData, that.dataProps)) + _interpolator[1];
          } else if (node.getAttribute("style") || ["B", "I", "U"].includes(node.tagName))
            result += node.textContent;
          else if (node.tagName == "DIV" || node.tagName == "P") {
            result += "\r\n";
            iterateChildren(node);
          }
        } else
          result += node.textContent;
      });
    }
    iterateChildren(this.DOM.input);
    return result;
  }
};
Tagify.prototype.removeTag = Tagify.prototype.removeTags;
const _onTagifyChange = (event, doc, targetKey) => {
  const tagString = event.target.value;
  if (tagString) {
    const tags = JSON.parse(tagString).map(({ value }) => value);
    doc.update({ [targetKey]: tags });
  } else {
    doc.update({ [targetKey]: [] });
  }
};
const Tags = {
  InitListeners: (html, doc) => {
    function makeTagInput(elem, tags) {
      const tagify = new Tagify(elem, {
        enforceWhitelist: true,
        editTags: false,
        whitelist: Object.entries(tags).map(([dataGroup, tagList]) => tagList.map((tag) => ({
          value: new Handlebars.SafeString(tag).toString(),
          "data-group": dataGroup
        }))).flat(),
        dropdown: {
          enabled: 0,
          maxItems: 1e4,
          placeAbove: false,
          appendTarget: html[0]
        }
      });
      tagify.dropdown.createListHTML = (optionsArr) => {
        const map = {};
        return structuredClone(optionsArr).map((suggestion, idx) => {
          const value = tagify.dropdown.getMappedValue.call(
            tagify,
            suggestion
          );
          let tagHTMLString = "";
          if (!map[suggestion["data-group"]]) {
            map[suggestion["data-group"]] = true;
            if (Object.keys(map).length) {
              tagHTMLString += "</div>";
            }
            tagHTMLString += `
                <div class="tagify__dropdown__itemsGroup">
                <h3>${suggestion["data-group"]}</h3>
              `;
          }
          suggestion.value = value && typeof value === "string" ? U.escapeHTML(value) : value;
          tagHTMLString += tagify.settings.templates.dropdownItem.apply(
            tagify,
            [suggestion, idx]
          );
          return tagHTMLString;
        }).join("");
      };
      function findDataGroup(tag) {
        for (const [group2, tagList] of Object.entries(tags)) {
          if (tagList.includes(tag)) {
            return group2;
          }
        }
        return false;
      }
      const targetKey = $(elem).data("tagTarget") ?? "system.tags";
      const curTags = [getProperty(doc, targetKey) ?? []].flat().filter(Boolean);
      tagify.addTags(
        curTags.filter(findDataGroup).map((tag) => ({
          value: new Handlebars.SafeString(tag).toString(),
          "data-group": findDataGroup(tag)
        })),
        true,
        true
      );
      setTimeout(() => elem.addEventListener("change", (event) => {
        _onTagifyChange(event, doc, targetKey);
      }), 1e3);
    }
    const systemTags = {
      "System Tags": Object.values(Tag.System),
      "Gear Tags": [
        ...Object.values(Tag.Gear),
        ...Object.values(Tag.GearCategory)
      ],
      "Actor Tags": [
        ...Object.values(Tag.PC),
        ...Object.values(Tag.NPC)
      ],
      Vices: Object.values(Vice),
      Playbooks: Object.values(Playbook),
      Inventions: Object.values(Tag.Invention),
      "Gang Types": Object.values(Tag.GangType)
    };
    const districtTags = {
      "City Districts": Object.values(MainDistrict),
      "Other Districts": Object.values(OtherDistrict)
    };
    const factionTags = { Factions: game.actors.filter((actor) => actor.type === BladesActorType.faction && actor.name !== null).map((faction) => faction.name) };
    $(html).find(".tags-gm").each((_, e) => makeTagInput(e, systemTags));
    $(html).find(".tags-district").each((_, e) => makeTagInput(e, districtTags));
    $(html).find(".tags-faction").each((_, e) => makeTagInput(e, factionTags));
  }
};
class BladesItemSheet extends ItemSheet {
  constructor() {
    super(...arguments);
    __publicField(this, "_getTypedItemData", {
      [BladesItemType.ability]: (context) => {
        if (!BladesItem$1.IsType(this.item, BladesItemType.ability)) {
          return void 0;
        }
        const sheetData = {};
        return {
          ...context,
          ...sheetData
        };
      },
      [BladesItemType.background]: (context) => {
        if (!BladesItem$1.IsType(this.item, BladesItemType.background)) {
          return void 0;
        }
        const sheetData = {};
        return {
          ...context,
          ...sheetData
        };
      },
      [BladesItemType.clock_keeper]: (context) => {
        if (!BladesItem$1.IsType(this.item, BladesItemType.clock_keeper)) {
          return void 0;
        }
        const sheetData = {
          phases: Object.values(BladesPhase)
        };
        return {
          ...context,
          ...sheetData
        };
      },
      [BladesItemType.cohort_gang]: (context) => {
        var _a, _b;
        if (!BladesItem$1.IsType(this.item, BladesItemType.cohort_gang, BladesItemType.cohort_expert)) {
          return void 0;
        }
        context.tierTotal = this.item.system.quality > 0 ? U.romanizeNum(this.item.system.quality) : "0";
        (_a = context.system).subtypes ?? (_a.subtypes = {});
        (_b = context.system).elite_subtypes ?? (_b.elite_subtypes = {});
        const sheetData = {
          tierData: {
            class: "comp-tier comp-vertical comp-teeth",
            dotline: {
              data: this.item.system.tier,
              target: "system.tier.value",
              iconEmpty: "dot-empty.svg",
              iconEmptyHover: "dot-empty-hover.svg",
              iconFull: "dot-full.svg",
              iconFullHover: "dot-full-hover.svg"
            }
          }
        };
        sheetData.edgeData = Object.fromEntries(Object.values(context.system.edges ?? []).filter((edge) => /[A-Za-z]/.test(edge)).map((edge) => [edge.trim(), C.EdgeTooltips[edge]]));
        sheetData.flawData = Object.fromEntries(Object.values(context.system.flaws ?? []).filter((flaw) => /[A-Za-z]/.test(flaw)).map((flaw) => [flaw.trim(), C.FlawTooltips[flaw]]));
        return {
          ...context,
          ...sheetData
        };
      },
      [BladesItemType.cohort_expert]: (context) => {
        const typedItemData = this._getTypedItemData[BladesItemType.cohort_gang];
        if (!typedItemData) {
          throw new Error(`No data for type ${this.item.type}`);
        }
        return typedItemData(context);
      },
      [BladesItemType.crew_ability]: (context) => {
        if (!BladesItem$1.IsType(this.item, BladesItemType.crew_ability)) {
          return void 0;
        }
        const sheetData = {};
        return {
          ...context,
          ...sheetData
        };
      },
      [BladesItemType.crew_reputation]: (context) => {
        if (!BladesItem$1.IsType(this.item, BladesItemType.crew_reputation)) {
          return void 0;
        }
        const sheetData = {};
        return {
          ...context,
          ...sheetData
        };
      },
      [BladesItemType.crew_playbook]: (context) => {
        if (!BladesItem$1.IsType(this.item, BladesItemType.crew_playbook)) {
          return void 0;
        }
        if (context.isGM) {
          const expClueData = {};
          [...Object.values(context.system.experience_clues ?? []).filter((clue) => /[A-Za-z]/.test(clue)), " "].forEach((clue, i) => {
            expClueData[(i + 1).toString()] = clue;
          });
          context.system.experience_clues = expClueData;
        }
        const sheetData = {};
        return {
          ...context,
          ...sheetData
        };
      },
      [BladesItemType.crew_upgrade]: (context) => {
        if (!BladesItem$1.IsType(this.item, BladesItemType.crew_upgrade)) {
          return void 0;
        }
        const sheetData = {};
        return {
          ...context,
          ...sheetData
        };
      },
      [BladesItemType.feature]: (context) => {
        if (!BladesItem$1.IsType(this.item, BladesItemType.feature)) {
          return void 0;
        }
        const sheetData = {};
        return {
          ...context,
          ...sheetData
        };
      },
      [BladesItemType.gm_tracker]: (context) => {
        if (!BladesItem$1.IsType(this.item, BladesItemType.gm_tracker)) {
          return void 0;
        }
        const sheetData = {
          phase: this.item.system.phase,
          phases: Object.values(BladesPhase)
        };
        return {
          ...context,
          ...sheetData
        };
      },
      [BladesItemType.heritage]: (context) => {
        if (!BladesItem$1.IsType(this.item, BladesItemType.heritage)) {
          return void 0;
        }
        const sheetData = {};
        return {
          ...context,
          ...sheetData
        };
      },
      [BladesItemType.gear]: (context) => {
        if (!BladesItem$1.IsType(this.item, BladesItemType.gear)) {
          return void 0;
        }
        const sheetData = {
          tierData: {
            class: "comp-tier comp-vertical comp-teeth",
            label: "Quality",
            labelClass: "filled-label full-width",
            dotline: {
              data: this.item.system.tier,
              target: "system.tier.value",
              iconEmpty: "dot-empty.svg",
              iconEmptyHover: "dot-empty-hover.svg",
              iconFull: "dot-full.svg",
              iconFullHover: "dot-full-hover.svg"
            }
          }
        };
        return {
          ...context,
          ...sheetData
        };
      },
      [BladesItemType.playbook]: (context) => {
        if (!BladesItem$1.IsType(this.item, BladesItemType.playbook)) {
          return void 0;
        }
        if (context.isGM) {
          const expClueData = {};
          [...Object.values(context.system.experience_clues ?? []).filter((clue) => /[A-Za-z]/.test(clue)), " "].forEach((clue, i) => {
            expClueData[(i + 1).toString()] = clue;
          });
          context.system.experience_clues = expClueData;
          const gatherInfoData = {};
          [...Object.values(context.system.gather_info_questions ?? []).filter((question) => /[A-Za-z]/.test(question)), " "].forEach((question, i) => {
            gatherInfoData[(i + 1).toString()] = question;
          });
          context.system.gather_info_questions = gatherInfoData;
        }
        const sheetData = {};
        return {
          ...context,
          ...sheetData
        };
      },
      [BladesItemType.preferred_op]: (context) => {
        if (!BladesItem$1.IsType(this.item, BladesItemType.preferred_op)) {
          return void 0;
        }
        const sheetData = {};
        return {
          ...context,
          ...sheetData
        };
      },
      [BladesItemType.stricture]: (context) => {
        if (!BladesItem$1.IsType(this.item, BladesItemType.stricture)) {
          return void 0;
        }
        const sheetData = {};
        return {
          ...context,
          ...sheetData
        };
      },
      [BladesItemType.vice]: (context) => {
        if (!BladesItem$1.IsType(this.item, BladesItemType.vice)) {
          return void 0;
        }
        const sheetData = {};
        return {
          ...context,
          ...sheetData
        };
      },
      [BladesItemType.ritual]: (context) => {
        if (!BladesItem$1.IsType(this.item, BladesItemType.ritual)) {
          return void 0;
        }
        const sheetData = {};
        return {
          ...context,
          ...sheetData
        };
      },
      [BladesItemType.design]: (context) => {
        if (!BladesItem$1.IsType(this.item, BladesItemType.design)) {
          return void 0;
        }
        const sheetData = {};
        return {
          ...context,
          ...sheetData
        };
      },
      [BladesItemType.location]: (context) => {
        if (!BladesItem$1.IsType(this.item, BladesItemType.location)) {
          return void 0;
        }
        const sheetData = {};
        return {
          ...context,
          ...sheetData
        };
      },
      [BladesItemType.score]: (context) => {
        if (!BladesItem$1.IsType(this.item, BladesItemType.score)) {
          return void 0;
        }
        return context;
      }
    });
  }
  static get defaultOptions() {
    return foundry.utils.mergeObject(super.defaultOptions, {
      classes: ["eunos-blades", "sheet", "item"],
      width: 560,
      height: 500,
      tabs: [{ navSelector: ".sheet-tabs", contentSelector: ".sheet-body", initial: "description" }]
    });
  }
  /* -------------------------------------------- */
  // constructor(item: BladesItem, options: Partial<ItemSheet.Options> = {}) {
  //   options.classes = [...options.classes ?? [], "eunos-blades", "sheet", "item", item.type];
  //   super(item, options);
  // }
  // override async getData() {
  getData() {
    var _a;
    const context = super.getData();
    const sheetData = {
      cssClass: this.item.type,
      editable: this.options.editable,
      isGM: ((_a = game.eunoblades.Tracker) == null ? void 0 : _a.system.is_spoofing_player) ? false : Boolean(game.user.isGM),
      isEmbeddedItem: Boolean(this.item.parent),
      item: this.item,
      system: this.item.system,
      tierTotal: this.item.getFactorTotal(Factor.tier) > 0 ? U.romanizeNum(this.item.getFactorTotal(Factor.tier)) : "0",
      activeEffects: Array.from(this.item.effects)
    };
    const typedItemData = this._getTypedItemData[this.item.type];
    if (typedItemData) {
      return typedItemData({ ...context, ...sheetData });
    }
    return {
      ...context,
      ...sheetData
    };
  }
  get template() {
    const pathComps = [
      "systems/eunos-blades/templates/items"
    ];
    if (C.SimpleItemTypes.includes(this.item.type)) {
      pathComps.push("simple-sheet.hbs");
    } else {
      pathComps.push(`${this.item.type}-sheet.hbs`);
    }
    return pathComps.join("/");
  }
  /* -------------------------------------------- */
  addDotlineListeners(html) {
    html.find(".dotline").each((__, elem) => {
      if ($(elem).hasClass("locked")) {
        return;
      }
      const targetDoc = this.item;
      const targetField = $(elem).data("target");
      const comp$ = $(elem).closest("comp");
      const curValue = U.pInt($(elem).data("value"));
      $(elem).find(".dot").each((_, dot) => {
        $(dot).on("click", (event) => {
          event.preventDefault();
          const thisValue = U.pInt($(dot).data("value"));
          if (thisValue !== curValue) {
            if (comp$.hasClass("comp-coins") || comp$.hasClass("comp-stash")) {
              G.effects.fillCoins($(dot).prevAll(".dot")).then(() => targetDoc.update({ [targetField]: thisValue }));
            } else {
              targetDoc.update({ [targetField]: thisValue });
            }
          }
        });
        $(dot).on("contextmenu", (event) => {
          event.preventDefault();
          const thisValue = U.pInt($(dot).data("value")) - 1;
          if (thisValue !== curValue) {
            targetDoc.update({ [targetField]: thisValue });
          }
        });
      });
    });
  }
  async activateListeners(html) {
    await super.activateListeners(html);
    const self = this;
    Tags.InitListeners(html, this.item);
    ApplyTooltipAnimations(html);
    if (!this.options.editable) {
      return;
    }
    this.addDotlineListeners(html);
    if (BladesItem$1.IsType(this.item, BladesItemType.cohort_expert, BladesItemType.cohort_gang)) {
      html.find("[data-harm-click]").on({
        click: (event) => {
          var _a;
          event.preventDefault();
          const harmLevel = U.pInt($(event.currentTarget).data("harmClick"));
          if (((_a = this.item.system.harm) == null ? void 0 : _a.value) !== harmLevel) {
            this.item.update({ "system.harm.value": harmLevel });
          }
        },
        contextmenu: (event) => {
          var _a;
          event.preventDefault();
          const harmLevel = Math.max(0, U.pInt($(event.currentTarget).data("harmClick")) - 1);
          if (((_a = this.item.system.harm) == null ? void 0 : _a.value) !== harmLevel) {
            this.item.update({ "system.harm.value": harmLevel });
          }
        }
      });
    }
    if (this.options.submitOnChange) {
      html.on("change", "textarea", this._onChangeInput.bind(this));
    }
    html.find(".effect-control").on("click", (ev) => {
      var _a;
      if (self.item.isOwned) {
        (_a = ui.notifications) == null ? void 0 : _a.warn(game.i18n.localize("BITD.EffectWarning"));
        return;
      }
      BladesActiveEffect.onManageActiveEffect(ev, self.item);
    });
    html.find('[data-action="toggle-turf-connection"').on("click", this.toggleTurfConnection.bind(this));
  }
  toggleTurfConnection(event) {
    const button$ = $(event.currentTarget);
    const connector$ = button$.parent();
    const turfNum = parseInt(connector$.data("index") ?? 0, 10);
    const turfDir = connector$.data("dir");
    if (!turfNum || !turfDir) {
      return;
    }
    const toggleState = connector$.hasClass("no-connect");
    const updateData = {
      [`system.turfs.${turfNum}.connects.${turfDir}`]: toggleState
    };
    const partner = connector$.data("partner");
    if (typeof partner === "string" && /-/.test(partner)) {
      const [partnerNum, partnerDir] = partner.split("-");
      updateData[`system.turfs.${partnerNum}.connects.${partnerDir}`] = toggleState;
    }
    this.item.update(updateData);
  }
}
class BladesProjectSheet extends BladesItemSheet {
  constructor() {
    super(...arguments);
    __publicField(this, "_htmlContext");
  }
  static get defaultOptions() {
    return foundry.utils.mergeObject(super.defaultOptions, {
      classes: ["eunos-blades", "sheet", "item", "project-sheet"],
      template: "systems/eunos-blades/templates/items/project-sheet.hbs"
    });
  }
  getData() {
    const context = super.getData();
    const sheetData = {};
    sheetData.presentingClock = this.presentedClock;
    return {
      ...context,
      ...sheetData
    };
  }
  get presentedClock() {
    const { clockKey } = this.document;
    if (!clockKey) {
      throw new Error(`ClockKey not initialized for Project ${this.document.name}`);
    }
    let focusedClockIndex;
    if (U.isInt(clockKey.displayMode)) {
      focusedClockIndex = clockKey.displayMode;
    } else if (clockKey.displayMode === ClockKeyDisplayMode.presentCurrentClock) {
      focusedClockIndex = this.document.currentClock.index;
    } else if (clockKey.displayMode.startsWith("present")) {
      focusedClockIndex = U.pInt(clockKey.displayMode.slice(7));
    } else {
      return false;
    }
    return this.document.clockKey.getClockByIndex(focusedClockIndex) ?? false;
  }
  getClockKeyComponents(html) {
    const { clockKey } = this.document;
    if (!clockKey) {
      throw new Error(`ClockKey not initialized for Project ${this.document.name}`);
    }
    return {
      clockKey,
      keyElems$: clockKey.getElements$(html.find(".clock-key-panel"))
    };
  }
  switchToPresentAllClocks(clockKey, keyElems$) {
    const { clocks } = keyElems$;
    const timeline = clockKey.switchToMode(keyElems$, ClockKeyDisplayMode.clocks);
    if (clockKey.size > 1) {
      clockKey.visibleClocks.forEach((clock, i) => {
        const { clockLabel$ } = clocks[clock.id];
        timeline.blurReveal(clockLabel$, i === 0 ? ">" : "<+0.05");
      });
    }
    timeline.play().then(() => {
      if (this._htmlContext && this.document.currentClock) {
        this._htmlContext.find(".sheet-subtitle").attr("data-action", "current-clock-name").val(this.document.currentClock.name);
      }
    });
  }
  switchToPresentClock(clockRef, clockKey, keyElems$) {
    const timeline = clockKey.switchToMode(
      keyElems$,
      clockRef === ClockKeyDisplayMode.presentCurrentClock ? clockRef : `present${clockRef}`,
      void 0,
      void 0,
      true,
      () => {
        eLog.checkLog3("BladesProject", "Clock Switch", { clockRef, clockKey, keyElems$, htmlContext: this._htmlContext, presentedClock: this.presentedClock });
        if (this._htmlContext && this.presentedClock) {
          this._htmlContext.find(".sheet-subtitle").attr("data-action", "presented-clock-name").val(this.presentedClock.name);
        }
      }
    );
    timeline.to(keyElems$.container$.find(".clock-label, .clock-key-label"), { autoAlpha: 0, duration: 0.5, ease: "sine" }, 0);
    timeline.play().then();
  }
  activateClockKeyListeners(clockKey, keyElems$) {
    eLog.checkLog2("BladesProject", "Clock Key Data", { clockKey, keyElems$ });
    const { container$ } = keyElems$;
    container$.css("pointer-events", "auto");
    container$.on("contextmenu", () => {
      this.switchToPresentAllClocks(clockKey, keyElems$);
    });
    Object.entries(keyElems$.clocks).forEach(([clockId, clockElems$]) => {
      clockElems$.clockContainer$.css("pointer-events", "auto");
      clockElems$.clockContainer$.on("click", () => {
        var _a;
        this.switchToPresentClock(
          ((_a = clockKey.clocks.get(clockId)) == null ? void 0 : _a.index) ?? ClockKeyDisplayMode.presentCurrentClock,
          clockKey,
          keyElems$
        );
      });
    });
  }
  async activateListeners(html) {
    this._htmlContext = html;
    await super.activateListeners(html);
    const { clockKey, keyElems$ } = this.getClockKeyComponents(html);
    html.find("input.sheet-subtitle").on({
      change: (event) => {
        event.preventDefault();
        const action = $(event.currentTarget).data("action");
        eLog.checkLog3("BladesProject", "Clock Name Change", { action, value: $(event.currentTarget).val() });
        if (action === "presented-clock-name" && this.presentedClock) {
          this.presentedClock.updateTarget("name", $(event.currentTarget).val());
          keyElems$.clocks[this.presentedClock.id].clockLabel$.text($(event.currentTarget).val());
        } else if (action === "current-clock-name") {
          this.document.clockKey.currentClock.updateTarget("name", $(event.currentTarget).val());
          keyElems$.clocks[this.document.clockKey.currentClock.id].clockLabel$.text($(event.currentTarget).val());
        }
        clockKey.formatLabels(keyElems$);
      }
    });
    clockKey.initElementsInContext(html);
    this.activateClockKeyListeners(clockKey, keyElems$);
    await Promise.all([
      ...clockKey.visibleClocks.map((clock) => new Promise((resolve) => {
        const clockElems$ = keyElems$.clocks[clock.id];
        clock.reveal_Animation(clockElems$, () => {
          resolve();
        });
      })),
      ...clockKey.activeClocks.map((clock) => new Promise((resolve) => {
        const clockElems$ = keyElems$.clocks[clock.id];
        clock.activate_Animation(clockElems$, () => {
          resolve();
        });
      }))
    ]);
  }
}
class BladesProject extends BladesItem$1 {
  constructor() {
    super(...arguments);
    __publicField(this, "_clockKey");
  }
  // #region INITIALIZATION ~
  static async Initialize() {
    Object.assign(globalThis, { BladesProject, BladesProjectSheet });
    Items.registerSheet("blades", BladesProjectSheet, { types: ["project"], makeDefault: true });
    return loadTemplates(["systems/eunos-blades/templates/items/project-sheet.hbs"]);
  }
  // #endregion
  static IsType(doc) {
    return super.IsType(doc, BladesItemType.project);
  }
  static async create(data, options = {}) {
    const project = await super.create(data, { ...options, renderSheet: false });
    if (!project._clockKey) {
      project._clockKey = await BladesClockKey.Create({
        name: project.name,
        target: project,
        targetKey: "system.clocksData",
        isNameVisible: false,
        isSpotlit: false,
        isVisible: true,
        displayMode: ClockKeyDisplayMode.clocks
        // oneKeyIndex: U.gsap.utils.random(0, 4, 1) as OneKeyImgIndex
      }, void 0, [{
        name: "",
        index: 0,
        color: ClockColor.yellow,
        value: 0,
        max: 8,
        isVisible: true,
        isActive: true,
        isNameVisible: false,
        isHighlighted: false
      }]);
    }
    return project;
  }
  get clockKey() {
    var _a, _b, _c;
    if (this._clockKey) {
      return this._clockKey;
    }
    const keysData = Object.values(this.system.clocksData);
    if (keysData.length === 0) {
      throw new Error(`ClockKey not initialized for Project ${this.name}`);
    }
    let keyID;
    if (keysData.length === 1) {
      keyID = keysData[0].id;
    } else if (this.isEmbedded) {
      keyID = (_a = keysData.find((keyData) => {
        var _a2;
        return keyData.targetID.includes((_a2 = this.parent) == null ? void 0 : _a2.id);
      })) == null ? void 0 : _a.id;
      if (!keyID) {
        throw new Error(`ClockKey not initialized for Project ${this.name} embedded in document '${(_b = this.parent) == null ? void 0 : _b.name}'.`);
      }
    } else {
      keyID = (_c = keysData.find((keyData) => /^Item\.[^.]{16}$/.exec(keyData.targetID))) == null ? void 0 : _c.id;
      if (!keyID) {
        throw new Error(`ClockKey not initialized for Project ${this.name}.`);
      }
    }
    this._clockKey = game.eunoblades.ClockKeys.get(keyID) ?? new BladesClockKey(this.system.clocksData[keyID]);
    if (!this._clockKey) {
      throw new Error(`ClockKey not initialized for Project ${this.name}`);
    }
    return this._clockKey;
  }
  get ownerName() {
    if (this.parent) {
      return this.parent.name;
    }
    return void 0;
  }
  get currentClock() {
    return this.clockKey.currentClock;
  }
  get isComplete() {
    return this.clockKey.isComplete;
  }
  get rollOppClock() {
    var _a;
    return (_a = this.currentClock) == null ? void 0 : _a.data;
  }
  async advanceClock(segments = 1) {
    if (!this.currentClock) {
      return void 0;
    }
    return this.currentClock.fillSegments(segments);
  }
  get rollFactors() {
    const factorData = {};
    [
      Factor.tier,
      Factor.quality
    ].forEach((factor, i) => {
      const factorTotal = this.getFactorTotal(factor);
      factorData[factor] = {
        name: factor,
        value: factorTotal,
        max: factorTotal,
        baseVal: factorTotal,
        display: factor === Factor.tier ? U.romanizeNum(factorTotal) : `${factorTotal}`,
        isActive: i === 0,
        isPrimary: i === 0,
        isDominant: false,
        highFavorsPC: true,
        cssClasses: `factor-gold${i === 0 ? " factor-main" : ""}`
      };
    });
    return factorData;
  }
  getFactorTotal(factor) {
    switch (factor) {
      case Factor.tier:
        return this.system.tier.value;
      case Factor.quality:
        return this.getFactorTotal(Factor.tier);
    }
    return 0;
  }
  get rollOppImg() {
    return "";
  }
  get keyElem() {
    if (!this.clockKey) {
      return void 0;
    }
    return $(`#${this.clockKey.id}`)[0];
  }
  get currentClockElem() {
    if (!this.keyElem) {
      return void 0;
    }
    if (!this.currentClock) {
      return void 0;
    }
    return $(this.keyElem).find(`.clock[data-id="${this.currentClock.id}"]`)[0];
  }
}
const BladesProject$1 = BladesProject;
class BladesLocation extends BladesItem$1 {
  get rollFactors() {
    const factorData = {};
    [
      Factor.tier,
      Factor.quality,
      Factor.scale
    ].forEach((factor, i) => {
      const factorTotal = this.getFactorTotal(factor);
      factorData[factor] = {
        name: factor,
        value: factorTotal,
        max: factorTotal,
        baseVal: factorTotal,
        display: factor === Factor.tier ? U.romanizeNum(factorTotal) : `${factorTotal}`,
        isActive: i === 0,
        isPrimary: i === 0,
        isDominant: false,
        highFavorsPC: true,
        cssClasses: `factor-gold${i === 0 ? " factor-main" : ""}`
      };
    });
    return factorData;
  }
  getFactorTotal(factor) {
    switch (factor) {
      case Factor.tier:
        return this.system.tier.value;
      case Factor.quality:
        return this.getFactorTotal(Factor.tier);
      case Factor.scale:
        return this.system.scale;
    }
    return 0;
  }
  get rollOppImg() {
    return this.img ?? "";
  }
  // #region OVERRIDES: _onUpdate
  // override async _onUpdate(changed: any, options: any, userId: string) {
  //   await super._onUpdate(changed, options, userId);
  //   BladesActor.GetTypeWithTags(BladesActorType.pc).forEach((actor) => actor.render());
  // }
  // #endregion
}
class BladesClockKeeper extends BladesItem$1 {
  static async Initialize() {
    const clockKeeper = game.items.find((item) => item.type === "clock_keeper");
    if (!clockKeeper) {
      game.eunoblades.ClockKeeper = await BladesClockKeeper.create({
        name: "Clock Keeper",
        type: "clock_keeper",
        img: "systems/eunos-blades/assets/icons/misc-icons/clock-keeper.svg"
      });
    } else {
      game.eunoblades.ClockKeeper = clockKeeper;
    }
    return loadTemplates([
      "systems/eunos-blades/templates/parts/clock-sheet-key-controls.hbs",
      "systems/eunos-blades/templates/parts/clock-sheet-clock-controls.hbs"
    ]);
  }
  showClockKeyControls(keyID) {
    var _a;
    if ((_a = this.sheet) == null ? void 0 : _a.element)
      ;
  }
  hideClockKeyControls(keyID) {
    var _a;
    if ((_a = this.sheet) == null ? void 0 : _a.element)
      ;
  }
  // #region CLOCKS OVERLAY
  get clockKeys() {
    return this.getSceneKeys();
  }
  get currentScene() {
    var _a, _b;
    return (_b = (_a = game.scenes) == null ? void 0 : _a.current) == null ? void 0 : _b.id;
  }
  get currentSceneID() {
    var _a;
    if (!((_a = game.scenes) == null ? void 0 : _a.current)) {
      throw new Error("[BladesClockKeeper.currentScene] Error retrieving 'game.scenes.current'.");
    }
    return game.scenes.current.id;
  }
  get targetSceneID() {
    return this.system.targetScene ?? this.currentSceneID;
  }
  get keys() {
    return new Collection(
      Object.entries(this.system.clocksData ?? {}).map(([id, data]) => [
        id,
        game.eunoblades.ClockKeys.get(id) ?? new BladesClockKey(data)
      ])
    );
  }
  getSceneKeys(sceneID) {
    sceneID ?? (sceneID = this.targetSceneID);
    return new Collection(Array.from(game.eunoblades.ClockKeys).filter((clockKey) => clockKey.sceneIDs.includes(sceneID)).map((clockKey) => [clockKey.id, clockKey]));
  }
  async addClockKey(clockKeyConfig = {}) {
    var _a;
    if (!((_a = clockKeyConfig.sceneIDs) == null ? void 0 : _a.length)) {
      clockKeyConfig.sceneIDs = [this.targetSceneID];
    }
    const key = await BladesClockKey.Create({
      target: this,
      targetKey: "system.clocksData",
      ...clockKeyConfig
    });
    return key;
  }
  async deleteClockKey(keyID) {
    var _a;
    await ((_a = game.eunoblades.ClockKeys.get(keyID)) == null ? void 0 : _a.delete(game.eunoblades.ClockKeys));
  }
  async addClockToKey(keyID, clockData) {
    const key = await game.eunoblades.ClockKeys.get(keyID);
    if (!key) {
      return;
    }
    await key.addClock(clockData);
  }
  async deleteClockFromKey(keyID, clockID) {
    const key = await game.eunoblades.ClockKeys.get(keyID);
    if (!key) {
      return;
    }
    await key.deleteClock(clockID);
  }
  // #endregion
  // #region OVERRIDES: prepareDerivedData, _onUpdate
  prepareDerivedData() {
    var _a, _b;
    super.prepareDerivedData();
    (_b = this.system).targetScene ?? (_b.targetScene = ((_a = game.scenes.current) == null ? void 0 : _a.id) || null);
  }
  // #endregion
}
const BladesClockKeeper$1 = BladesClockKeeper;
class BladesGMTracker extends BladesItem$1 {
  static async Initialize() {
    const tracker = game.items.find((item) => BladesItem$1.IsType(item, BladesItemType.gm_tracker));
    if (tracker) {
      game.eunoblades.Tracker = tracker;
    } else {
      game.eunoblades.Tracker = await BladesGMTracker.create({
        name: "GM Tracker",
        type: "gm_tracker",
        img: "systems/eunos-blades/assets/icons/misc-icons/gm-tracker.svg"
      });
    }
  }
  get phase() {
    return this.system.phase ?? BladesPhase.Freeplay;
  }
  set phase(phase) {
    this.update({ "system.phase": phase });
  }
  prepareDerivedData() {
    this.system.phases = Object.values(BladesPhase);
  }
  // #region OVERRIDES: prepareDerivedData, _onUpdate
  async _onUpdate(...args) {
    await super.callOnUpdate(...args);
    BladesActor$1.GetTypeWithTags(BladesActorType.pc).forEach((actor) => actor.render());
  }
  // #endregion
}
class BladesScoreSheet extends BladesItemSheet {
  static get defaultOptions() {
    return foundry.utils.mergeObject(super.defaultOptions, {
      classes: ["eunos-blades", "sheet", "item", "score-sheet"],
      template: "systems/eunos-blades/templates/items/score-sheet.hbs",
      width: 900,
      submitOnChange: false,
      height: 970
    });
  }
  async generateRandomizerData(category) {
    const randomData = {
      Bargains: Object.fromEntries(Object.entries(U.sample(Randomizers.GM.Bargains.filter((bData) => !Object.values(this.document.system.randomizers.Bargains).some((_bData) => _bData.name === bData.name || _bData.effect === bData.effect)), 3, true, (e, a) => a.filter((_e) => e.category === _e.category).length === 0)).map(([k, v]) => {
        k = `${k}`;
        Object.assign(v, { notes: "" });
        return [k, v];
      })),
      Obstacles: Object.fromEntries(Object.entries(U.sample(Randomizers.GM.Obstacles.filter((bData) => !Object.values(this.document.system.randomizers.Obstacles).some((_bData) => _bData.name === bData.name || _bData.desc === bData.desc)), 3, true, (e, a) => a.filter((_e) => e.category === _e.category).length === 0)).map(([k, v]) => {
        k = `${k}`;
        Object.assign(v, { notes: "" });
        return [k, v];
      })),
      NPCs: Object.fromEntries(Object.entries(U.sample(
        Randomizers.GM.NPCs.filter(
          (bData) => !Object.values(this.document.system.randomizers.NPCs).some((_bData) => _bData.name === bData.name || _bData.description === bData.description)
        ),
        3,
        true,
        (e, a) => a.filter((_e) => e.arena === _e.arena).length === 0
      )).map(([k, v]) => {
        k = `${k}`;
        Object.assign(v, { notes: "" });
        return [k, v];
      })),
      Scores: Object.fromEntries(Object.entries(U.sample(Randomizers.GM.Scores.filter((bData) => !Object.values(this.document.system.randomizers.Scores).some((_bData) => _bData.name === bData.name || _bData.desc === bData.desc)), 3, true, (e, a) => a.filter((_e) => e.category === _e.category).length === 0)).map(([k, v]) => {
        k = `${k}`;
        Object.assign(v, { notes: "" });
        return [k, v];
      }))
    };
    if (category) {
      Object.keys(randomData).filter((cat) => cat !== category).forEach((cat) => {
        const _cat = cat;
        randomData[_cat] = this.document.system.randomizers[_cat];
      });
    }
    const finalRandomData = {
      Bargains: {},
      Obstacles: {},
      NPCs: {},
      Scores: {}
    };
    Object.keys(randomData).forEach((cat) => {
      const _cat = cat;
      Object.keys(randomData[_cat]).forEach((index) => {
        var _a;
        if ((_a = this.document.system.randomizers) == null ? void 0 : _a[_cat][index].isLocked) {
          finalRandomData[_cat][index] = this.document.system.randomizers[_cat][index];
        } else {
          finalRandomData[_cat][index] = randomData[_cat][index];
        }
      });
    });
    await this.document.update({ "system.randomizers": finalRandomData });
  }
  getData() {
    const context = super.getData();
    const sheetData = {};
    sheetData.playerCharacters = BladesActor$1.GetTypeWithTags(BladesActorType.pc, Tag.PC.ActivePC).map((pc) => {
      return Object.assign(
        pc,
        {
          actionData: Object.fromEntries(Object.entries(pc.system.attributes).map(([attrName, attrData]) => {
            return [
              attrName,
              Object.fromEntries(Object.entries(attrData).map(([actionName, actionData]) => {
                return [
                  U.uCase(actionName).slice(0, 3),
                  actionData
                ];
              }))
            ];
          }))
        }
      );
    });
    const validOppositions = {};
    for (const [id, data] of Object.entries(context.system.oppositions)) {
      if (!data.rollOppName && !data.rollOppSubName) {
        continue;
      }
      validOppositions[id] = data;
    }
    context.system.oppositions = validOppositions;
    return {
      ...context,
      ...sheetData
    };
  }
  _toggleRandomizerLock(event) {
    const elem$ = $(event.currentTarget);
    const elemCat = elem$.data("category");
    const elemIndex = `${elem$.data("index")}`;
    const elemValue = elem$.data("value");
    if (`${elemValue}` === "true") {
      this.document.update({ [`system.randomizers.${elemCat}.${elemIndex}.isLocked`]: false });
    } else {
      this.document.update({ [`system.randomizers.${elemCat}.${elemIndex}.isLocked`]: true });
    }
  }
  _selectImage(event) {
    const elem$ = $(event.currentTarget);
    const imageNum = elem$.data("imgNum");
    this.document.update({ "system.imageSelected": imageNum });
  }
  _deselectOrDeleteImage(event) {
    const elem$ = $(event.currentTarget);
    const imageNum = elem$.data("imgNum");
    if (this.document.system.imageSelected === imageNum) {
      this.document.update({ "system.-=imageSelected": null });
      return;
    }
    const images = { ...this.document.system.images };
    this.document.update({ "system.-=images": null }).then(() => this.document.update({
      "system.images": Object.fromEntries(Object.entries(Object.values(images).filter((_, i) => U.pInt(imageNum) !== i)))
    }));
  }
  _addImage() {
    U.displayImageSelector(
      (path) => {
        const imgIndex = U.objSize(this.document.system.images);
        return this.document.update({ [`system.images.${imgIndex}`]: path });
      },
      "systems/eunos-blades/assets",
      this.position
    );
  }
  _selectRollOpposition(event) {
    var _a;
    eLog.checkLog3("Select Roll Opposition", { event });
    const elem$ = $(event.currentTarget);
    const oppId = elem$.data("oppId");
    this.document.update({ "system.oppositionSelected": oppId });
    if (((_a = BladesScore$1.Active) == null ? void 0 : _a.id) === this.document.id && BladesRoll$1.Active) {
      BladesRoll$1.Active.rollOpposition = new BladesRollOpposition(
        BladesRoll$1.Active,
        this.document.system.oppositions[oppId]
      );
    }
  }
  _triggerRandomize(event) {
    const elem$ = $(event.currentTarget);
    const category = elem$.data("category");
    if (category && category in Randomizers.GM) {
      this.generateRandomizerData(category);
    } else {
      this.generateRandomizerData();
    }
  }
  async _updateGMNotesOnPC(event) {
    const elem$ = $(event.currentTarget);
    const actor = BladesActor$1.Get(elem$.data("id"));
    if (!actor) {
      throw new Error(`Unable to retrieve actor with id '${elem$.data("id")}'`);
    }
    const updateText = event.currentTarget.innerHTML;
    eLog.checkLog3("scoreSheet", "Retrieved Text, Updating ...", { updateText });
    await actor.update({ "system.gm_notes": updateText });
    eLog.checkLog3("scoreSheet", "Updated!", { gm_notes: actor.system.gm_notes });
  }
  async activateListeners(html) {
    super.activateListeners(html);
    html.find("[data-action='select-image']").on({
      click: this._selectImage.bind(this),
      contextmenu: this._deselectOrDeleteImage.bind(this)
    });
    html.find("[data-action='add-image']").on({
      click: this._addImage.bind(this)
    });
    html.find(".roll-opposition-name").on({
      dblclick: this._selectRollOpposition.bind(this)
    });
    html.find(".toggle-lock").on({
      click: this._toggleRandomizerLock.bind(this)
    });
    html.find("[data-action='randomize'").on({
      click: this._triggerRandomize.bind(this)
    });
    html.find("textarea.pc-summary-notes-body").on({
      change: this._updateGMNotesOnPC.bind(this)
    });
  }
  async _onSubmit(event, params = {}) {
    let isForcingRender = true;
    const prevPhase = this.item.system.phase;
    const submitData = await super._onSubmit(event, params);
    const newPhase = this.item.system.phase;
    if (prevPhase !== newPhase) {
      switch (prevPhase) {
        case BladesPhase.CharGen: {
          break;
        }
        case BladesPhase.Freeplay: {
          break;
        }
        case BladesPhase.Score: {
          isForcingRender = false;
          game.actors.filter((actor) => BladesActor$1.IsType(actor, BladesActorType.pc)).forEach((actor) => actor.clearLoadout());
          break;
        }
        case BladesPhase.Downtime: {
          break;
        }
      }
      switch (newPhase) {
        case BladesPhase.CharGen: {
          break;
        }
        case BladesPhase.Freeplay: {
          break;
        }
        case BladesPhase.Score: {
          break;
        }
        case BladesPhase.Downtime: {
          break;
        }
      }
    }
    if (isForcingRender) {
      game.actors.filter((actor) => actor.type === BladesActorType.pc).forEach((actor) => {
        var _a;
        return (_a = actor.sheet) == null ? void 0 : _a.render();
      });
    }
    return submitData;
  }
}
class BladesScore extends BladesItem$1 {
  // #region INITIALIZATION ~
  static async Initialize() {
    Object.assign(globalThis, { BladesScore, BladesScoreSheet });
    Items.registerSheet("blades", BladesScoreSheet, { types: ["score"], makeDefault: true });
    return loadTemplates(["systems/eunos-blades/templates/items/score-sheet.hbs"]);
  }
  // #endregion
  static get Active() {
    return BladesItem$1.GetTypeWithTags(BladesItemType.score).find((score) => score.system.isActive);
  }
  static set Active(val) {
    var _a;
    (_a = BladesItem$1.GetTypeWithTags(BladesItemType.score).find((score) => score.system.isActive)) == null ? void 0 : _a.update({ "system.isActive": false }).then(() => {
      if (val) {
        val.update({ "system.isActive": true });
      }
    });
  }
  // #region BladesRoll.OppositionData Implementation
  get rollFactors() {
    const tierTotal = this.getFactorTotal(Factor.tier);
    return {
      [Factor.tier]: {
        name: "Tier",
        value: tierTotal,
        max: tierTotal,
        baseVal: tierTotal,
        display: U.romanizeNum(tierTotal),
        isActive: true,
        isPrimary: true,
        isDominant: false,
        highFavorsPC: true,
        cssClasses: "factor-gold factor-main"
      }
    };
  }
  get rollOppImg() {
    return this.img ?? "";
  }
  getFactorTotal(factor) {
    switch (factor) {
      case Factor.tier:
        return this.system.tier.value;
      case Factor.quality:
        return this.getFactorTotal(Factor.tier);
      case Factor.scale:
        return 0;
      case Factor.magnitude:
        return 0;
      default:
        return 0;
    }
  }
  // #endregion
  // #region OVERRIDES: _onUpdate
  async _onUpdate(changed, options, userId) {
    super._onUpdate(changed, options, userId);
    BladesActor$1.GetTypeWithTags(BladesActorType.pc).forEach((actor) => actor.render());
  }
  // #endregion
}
const BladesScore$1 = BladesScore;
const ItemsMap = {
  [BladesItemType.clock_keeper]: BladesClockKeeper$1,
  [BladesItemType.gm_tracker]: BladesGMTracker,
  [BladesItemType.location]: BladesLocation,
  [BladesItemType.project]: BladesProject$1,
  [BladesItemType.score]: BladesScore$1
};
const BladesItemProxy = new Proxy(function() {
}, {
  construct(_, args) {
    const [{ type }] = args;
    if (!type) {
      throw new Error(`Invalid Item Type: ${String(type)}`);
    }
    const MappedConstructor = ItemsMap[type];
    if (!MappedConstructor) {
      return new BladesItem$1(...args);
    }
    return new MappedConstructor(...args);
  },
  get(_, prop) {
    switch (prop) {
      case "create":
      case "createDocuments":
        return function(data, options = {}) {
          if (U.isArray(data)) {
            return data.map((i) => CONFIG.Item.documentClass.create(i, options));
          }
          const MappedConstructor = ItemsMap[data.type];
          if (!MappedConstructor) {
            return BladesItem$1.create(data, options);
          }
          return MappedConstructor.create(data, options);
        };
      case Symbol.hasInstance:
        return function(instance) {
          return Object.values(ItemsMap).some((i) => instance instanceof i);
        };
      default:
        return BladesItem$1[prop];
    }
  }
});
var SelectionCategory = /* @__PURE__ */ ((SelectionCategory2) => {
  SelectionCategory2["Heritage"] = "Heritage";
  SelectionCategory2["Background"] = "Background";
  SelectionCategory2["Vice"] = "Vice";
  SelectionCategory2["Playbook"] = "Playbook";
  SelectionCategory2["Reputation"] = "Reputation";
  SelectionCategory2["Preferred_Op"] = "Preferred_Op";
  SelectionCategory2["Gear"] = "Gear";
  SelectionCategory2["Ability"] = "Ability";
  SelectionCategory2["Faction"] = "Faction";
  SelectionCategory2["Upgrade"] = "Upgrade";
  SelectionCategory2["Cohort_Gang"] = "Cohort_Gang";
  SelectionCategory2["Cohort_Expert"] = "Cohort_Expert";
  SelectionCategory2["Feature"] = "Feature";
  SelectionCategory2["Stricture"] = "Stricture";
  SelectionCategory2["VicePurveyor"] = "VicePurveyor";
  SelectionCategory2["Acquaintance"] = "Acquaintance";
  SelectionCategory2["Friend"] = "Friend";
  SelectionCategory2["Rival"] = "Rival";
  SelectionCategory2["Crew"] = "Crew";
  SelectionCategory2["Member"] = "Member";
  SelectionCategory2["Contact"] = "Contact";
  return SelectionCategory2;
})(SelectionCategory || {});
class BladesDialog extends Dialog {
  constructor(data, options) {
    super(data, options);
    __publicField(this, "parent");
    __publicField(this, "tabs");
    __publicField(this, "dialogType");
    __publicField(this, "tags", []);
    __publicField(this, "width");
    __publicField(this, "docType");
    // csqData?: Record<
    // Position,
    // Record<
    //   RollResult.partial|RollResult.fail,
    //   Record<
    //     string,
    //     BladesRoll.ConsequenceData
    //     >
    //   >
    // >;
    __publicField(this, "prompt");
    __publicField(this, "target");
    __publicField(this, "flagTarget");
    this.dialogType = data.dialogType ?? "Selection";
    this.parent = data.parent;
    this.width = (options == null ? void 0 : options.width) ?? 500;
    this.prompt = data.prompt;
    this.target = data.target;
    this.flagTarget = data.flagTarget;
    switch (this.dialogType) {
      case "Input":
        return;
      case "Selection":
        this.constructSelectionData(
          data
          /* , options */
        );
        return;
      default:
        throw new Error(`Unrecognized type for BladesDialog constructor: '${this.dialogType}'`);
    }
  }
  static get defaultOptions() {
    return foundry.utils.mergeObject(super.defaultOptions, {
      classes: ["eunos-blades", "sheet", "dialog"],
      width: "auto",
      height: "auto",
      tabs: [{ navSelector: ".nav-tabs", contentSelector: ".tab-content", initial: "front" }]
    });
  }
  static Initialize() {
    return loadTemplates([
      "systems/eunos-blades/templates/dialog-selection.hbs",
      "systems/eunos-blades/templates/dialog-consequence.hbs",
      "systems/eunos-blades/templates/dialog-input.hbs",
      "systems/eunos-blades/templates/parts/dialog-consequence-block.hbs"
    ]);
  }
  static async DisplaySimpleInputDialog(parent, prompt, target, flagTarget) {
    const app = new BladesDialog({
      parent,
      title: parent instanceof BladesRoll$1 ? "Roll Input" : `${parent.name}: Input`,
      dialogType: "Input",
      content: "",
      prompt,
      target,
      flagTarget,
      buttons: {
        apply: {
          icon: '<i class="fa-solid fa-arrow-down-to-arc"></i>',
          label: "Apply",
          callback: (html) => app
          //   .writeToRollInstance(html as JQuery<HTMLElement>)
        },
        cancel: {
          icon: '<i class="fas fa-times"></i>',
          label: game.i18n.localize("Cancel"),
          callback: (html) => {
            eLog.checkLog3("dialog", "Callback Scope", { this: app, html });
            return false;
          }
        }
      },
      default: "apply"
    }, { classes: ["eunos-blades", "sheet", "dialog", "simple-input-dialog"] });
    return app._render(true, { width: app.width }).then(() => eLog.checkLog3("dialog", "Input Dialog Instance", { this: app }));
  }
  static async DisplaySelectionDialog(parent, title, docType, tabs, tags) {
    const app = new BladesDialog({
      parent,
      title,
      docType,
      tabs,
      tags: tags == null ? void 0 : tags.filter((tag) => tag !== ""),
      content: "",
      buttons: {
        cancel: {
          icon: '<i class="fas fa-times"></i>',
          label: game.i18n.localize("Cancel"),
          callback: (html) => {
            eLog.checkLog3("dialog", "Callback Scope", { this: this, html });
            return false;
          }
        }
      },
      default: "cancel"
    });
    return app.hasItems ? app.render(true, { width: app.width }) : void 0;
  }
  // static async DisplayRollConsequenceDialog(rollInst: BladesRoll) {
  // const app: BladesDialog = new BladesDialog({
  //   parent: rollInst,
  //   title: "Consequences",
  //   dialogType: BladesDialogType.Consequence,
  //   content: "",
  //   buttons: {
  //     apply: {
  //       icon: '<i class="fa-solid fa-arrow-down-to-arc"></i>',
  //       label: "Apply",
  //       callback: (html: HTMLElement|JQuery<HTMLElement>) => (app as BladesDialog)
  //         .writeToRollInstance(html as JQuery<HTMLElement>)
  //     },
  //     cancel: {
  //       icon: '<i class="fas fa-times"></i>',
  //       label: game.i18n.localize("Cancel"),
  //       callback: (html: JQuery|HTMLElement) => {
  //         eLog.checkLog3("dialog", "Callback Scope", {this: app, html});
  //         return false;
  //       }
  //     }
  //   },
  //   default: "apply"
  // }, {classes: ["eunos-blades", "sheet", "dialog", "consequence-dialog"]});
  // return app._render(true, {width: app.width}).then(() => eLog.checkLog3("dialog", "Dialog Instance", {this: app}));
  // }
  get template() {
    return `systems/eunos-blades/templates/dialog-${U.lCase(this.dialogType)}.hbs`;
  }
  get hasItems() {
    return Object.values(this.tabs ?? []).some((tabItems) => tabItems.length > 0);
  }
  constructSelectionData(data) {
    const validTabs = [];
    if (!data.tabs) {
      return;
    }
    for (const [tabName, tabItems] of Object.entries(data.tabs)) {
      if (tabItems.length === 0) {
        delete data.tabs[tabName];
      } else {
        validTabs.push(tabName);
      }
    }
    if (validTabs.length === 1 && !("Main" in data.tabs)) {
      data.tabs.Main = [...data.tabs[validTabs[0]]];
      delete data.tabs[validTabs[0]];
    }
    this.docType = data.docType;
    this.tabs = data.tabs;
    this.tags = data.tags ?? [];
    this.width = 150 * Math.ceil(Math.sqrt(Object.values(data.tabs)[0].length));
  }
  // constructConsequenceData(data: BladesDialog.Data/* , options?: Partial<BladesDialog.Options> */) {
  //   eLog.checkLog3("dialog", "constructConsequenceData", {incoming: {...data}});
  //   if (!(this.parent instanceof BladesRoll)) { throw new Error("Cannot call 'constructConsequenceData' without a rollInst parent!"); }
  //   // Get existing consequence data, if any, on roll instance
  //   const rollCsqData = this.parent.data.consequenceData ?? {};
  //   // Extend consequence data by applying new blank consequence instances,
  //   //   so at least three csq entries are available for each position/result combination
  //   (Object.values(Position) as Position[]).forEach((rollPos: Position) => {
  //     rollCsqData[rollPos] ??= {
  //       [RollResult.partial]: {},
  //       [RollResult.fail]: {}
  //     };
  //     ([RollResult.partial, RollResult.fail] as const).forEach((rollResult: RollResult.partial|RollResult.fail) => {
  //       rollCsqData[rollPos] ??= {};
  //       rollCsqData[rollPos][rollResult] ??= {};
  //       while (Object.values(rollCsqData[rollPos][rollResult as RollResult.partial|RollResult.fail]).length < 3) {
  //         const blankCsqData: BladesConsequence.Data = {
  //           id: randomID() as IDString,
  //           name: "",
  //           type: "",
  //           attribute: ""
  //         };
  //         rollCsqData[rollPos][rollResult as RollResult.partial|RollResult.fail][blankCsqData.id] = blankCsqData;
  //       }
  //     });
  //   });
  //   this._consequenceAI = new BladesAI(AGENTS.ConsequenceAdjuster);
  //   return rollCsqData;
  // }
  getData() {
    const data = super.getData();
    switch (this.dialogType) {
      case "Input":
        return this.prepareInputData(data);
      case "Selection":
        return this.prepareSelectionData(data);
      default:
        return null;
    }
  }
  prepareInputData(data) {
    data.prompt = this.prompt;
    data.target = this.target;
    data.flagTarget = this.flagTarget;
    return data;
  }
  prepareSelectionData(data) {
    data.title = this.title;
    data.tabs = this.tabs;
    data.docType = this.docType;
    data.tags = this.tags;
    return data;
  }
  // prepareConsequenceData(data: BladesDialog.Data) {
  //   eLog.checkLog3("dialog", "prepareConsequenceData this.csqData", {...this.csqData});
  //   eLog.checkLog3("dialog", "prepareConsequenceData", {incoming: {...data}});
  //   data.consequenceData = this.csqData;
  //   data.consequenceTypeOptions = this.consequenceTypeOptions;
  //   data.consequenceTypeOptionsAll = Object.keys(C.ConsequenceDisplay)
  //     .map((cType) => ({value: cType, display: cType}));
  //   data.consequenceAttributeOptions = [
  //     {value: AttributeTrait.insight, display: "Insight"},
  //     {value: AttributeTrait.prowess, display: "Prowess"},
  //     {value: AttributeTrait.resolve, display: "Resolve"}
  //   ];
  //   eLog.checkLog3("dialog", "prepareConsequenceData", {outgoing: {...data}});
  //   return data;
  // }
  // get consequenceTypeOptions(): Record<
  //   Position,
  //   Record<
  //     RollResult.partial|RollResult.fail,
  //     Array<BladesSelectOption<string, ConsequenceType>>
  //   >
  //   > {
  //   if (this.parent instanceof BladesRoll) {
  //     const returnData: Partial<Record<
  //     Position,
  //     Record<
  //       RollResult.partial|RollResult.fail,
  //       Array<BladesSelectOption<string, ConsequenceType>>
  //     >
  //   >> = {};
  //     [Position.controlled, Position.risky, Position.desperate].forEach((pos) => {
  //       returnData[pos] = {
  //         [RollResult.partial]: C.Consequences[pos][RollResult.partial]
  //           .map((cType) => ({value: cType, display: cType})),
  //         [RollResult.fail]: C.Consequences[pos][RollResult.fail]
  //           .map((cType) => ({value: cType, display: cType}))
  //       };
  //     });
  //     return returnData as Record<
  //     Position,
  //     Record<
  //       RollResult.partial|RollResult.fail,
  //       Array<BladesSelectOption<string, ConsequenceType>>
  //     >
  //   >;
  //   }
  //   return {} as never;
  // }
  updateInputText(inputElem$) {
    const value = inputElem$.val();
    if (this.parent instanceof BladesRoll$1) {
      const flagTarget = inputElem$.data("flagTarget");
      eLog.checkLog3("dialog", "updateInputText", { value, flagTarget });
      this.parent.updateTarget(flagTarget, value).then(() => this.parent.renderRollCollab_SocketCall());
    } else if (this.parent instanceof BladesItem$1 || this.parent instanceof BladesActor$1) {
      this.parent.update({ [inputElem$.data("target")]: inputElem$.val() });
    }
  }
  // updateConsequenceType(csqElem$: JQuery<HTMLElement>, cData: BladesConsequence.Data) {
  //   const type$ = csqElem$.find(".roll-consequence-type-select") as JQuery<HTMLSelectElement>;
  //   const typeVal = type$.val() as string|undefined;
  //   if (typeVal && typeVal in ConsequenceType) {
  //     cData.type = typeVal as ConsequenceType;
  //     cData.icon = C.ConsequenceIcons[cData.type];
  //     cData.typeDisplay = C.ConsequenceDisplay[cData.type];
  //   }
  // }
  // updateConsequenceAttribute(csqElem$: JQuery<HTMLElement>, cData: BladesConsequence.Data) {
  //   if (/Insight/.exec(cData.type)) { cData.attribute = AttributeTrait.insight; }
  //   else if (/Prowess/.exec(cData.type)) { cData.attribute = AttributeTrait.prowess; }
  //   else if (/Resolve/.exec(cData.type)) { cData.attribute = AttributeTrait.resolve; }
  //   else {
  //     const attribute$ = csqElem$.find(".roll-consequence-attribute-select") as JQuery<HTMLSelectElement>;
  //     const attrVal = attribute$.val() as AttributeTrait|undefined;
  //     if (attrVal) {
  //       cData.attribute = attrVal;
  //     }
  //   }
  // }
  // updateConsequenceAttributeVal(cData: BladesConsequence.Data) {
  //   if (this.parent.rollPrimaryDoc instanceof BladesPC) {
  //     cData.attributeVal = this.parent.rollPrimaryDoc.attributes[cData.attribute as AttributeTrait];
  //   } else if (this.parent.rollPrimaryDoc?.parent instanceof BladesPC) {
  //     cData.attributeVal = this.parent.rollPrimaryDoc.parent.attributes[cData.attribute as AttributeTrait];
  //   } else {
  //     eLog.error(`Unable to get attribute from rollPrimaryDoc '${this.parent.rollPrimaryDoc?.name}' of type '${this.parent.rollPrimaryDoc?.rollPrimaryType}' (may need to log via flags if either of the previous show 'undefined'.`);
  //   }
  // }
  // getSelectedResistOption(cData: BladesConsequence.Data): BladesConsequence|false {
  //   return cData.resistTo
  //     ? new BladesConsequence(cData.resistTo)
  //     : false;
  // }
  // updateConsequenceResist(csqElem$: JQuery<HTMLElement>, cData: BladesConsequence.Data) {
  //   const resistOptions: Record<string, BladesRoll.ConsequenceResistOption> = cData.resistOptions ?? {};
  //   // If consequence is already minimal, toggle resistNegates to true and set 'resistTo' to None-type
  //   const minimalCsqTypes = Object.entries(C.ResistedConsequenceTypes)
  //     .filter(([_, rCsqType]) => rCsqType === ConsequenceType.None)
  //     .map(([csqType]) => csqType as ConsequenceType);
  //   if (minimalCsqTypes.includes(cData.type as ConsequenceType)) {
  //     cData.resistNegates = true;
  //     const noneCsq = BladesConsequence.None;
  //     cData.resistOptions = {[noneCsq.id]: noneCsq};
  //     cData.resistTo = noneCsq;
  //     return;
  //   } else {
  //     // Clear 'resistTo' (will be redetermined below)
  //     delete cData.resistTo;
  //     delete cData.resistNegates;
  //     csqElem$.find(".consequence-resist-option").each((_, elem) => {
  //       const resCsqID = $(elem).data("csq-id");
  //       resistOptions[resCsqID] ??= {id: resCsqID, name: "", type: undefined, isSelected: false};
  //       // Update Resistance Option Type
  //       const resType$ = $(elem).find(".roll-consequence-type-select") as JQuery<HTMLSelectElement>;
  //       const resTypeVal = resType$.val() as string|undefined;
  //       if (resTypeVal && resTypeVal in ConsequenceType) {
  //         resistOptions[resCsqID].type = resTypeVal as ConsequenceType;
  //         resistOptions[resCsqID].icon = C.ConsequenceIcons[resistOptions[resCsqID].type as ConsequenceType];
  //         resistOptions[resCsqID].typeDisplay = C.ConsequenceDisplay[resistOptions[resCsqID].type as ConsequenceType];
  //       }
  //       // Update Resistance Option Name
  //       const resName$ = $(elem).find(".consequence-name") as JQuery<HTMLInputElement>;
  //       const resNameVal = resName$.val();
  //       resistOptions[resCsqID].name = resNameVal ?? "";
  //       // If this is selected, update 'resistTo' data as well
  //       if (resistOptions[resCsqID].isSelected) {
  //         cData.resistTo = resistOptions[resCsqID];
  //       }
  //     });
  //   }
  //   cData.resistOptions = resistOptions;
  // }
  // updateConsequenceArmorResist(_csqElem$: JQuery<HTMLElement>, cData: BladesConsequence.Data) {
  //   // If consequence is already minimal, toggle armorNegates to true and set 'armorTo' to None-type
  //   const minimalCsqTypes = Object.entries(C.ResistedConsequenceTypes)
  //     .filter(([_, rCsqType]) => rCsqType === ConsequenceType.None)
  //     .map(([csqType]) => csqType as ConsequenceType);
  //   if (minimalCsqTypes.includes(cData.type as ConsequenceType)) {
  //     cData.armorNegates = true;
  //     cData.armorTo = BladesConsequence.None;
  //   } else {
  //     delete cData.armorNegates;
  //     cData.armorTo = this.getSelectedResistOption(cData);
  //   }
  // }
  // updateConsequenceSpecialArmorResist(_csqElem$: JQuery<HTMLElement>, cData: BladesConsequence.Data) {
  //   // If consequence is already minimal, toggle specialArmorNegates to true and set 'specialTo' to None-type
  //   const minimalCsqTypes = Object.entries(C.ResistedConsequenceTypes)
  //     .filter(([_, rCsqType]) => rCsqType === ConsequenceType.None)
  //     .map(([csqType]) => csqType as ConsequenceType);
  //   if (minimalCsqTypes.includes(cData.type as ConsequenceType)) {
  //     cData.specialArmorNegates = true;
  //     cData.specialTo = BladesConsequence.None;
  //   } else {
  //     delete cData.specialArmorNegates;
  //     cData.specialArmorNegates ??= false;
  //     cData.specialTo = this.getSelectedResistOption(cData);
  //   }
  // }
  // updateConsequenceData(
  //   html: JQuery<HTMLElement|HTMLInputElement>,
  //   cData: BladesConsequence.Data
  // ) {
  //   const csqElem$ = html.find(`.roll-consequence-row[data-csq-id='${cData.id}']`);
  //   // Update Type
  //   this.updateConsequenceType(csqElem$, cData);
  //   // Update Name
  //   if (cData.type === ConsequenceType.None) {
  //     cData.name = "";
  //   } else {
  //     const name$ = csqElem$.find(".consequence-name") as JQuery<HTMLInputElement>;
  //     const nameVal = name$.val();
  //     cData.name = nameVal ?? "";
  //   }
  //   // Update Resistance Attribute
  //   this.updateConsequenceAttribute(csqElem$, cData);
  //   this.updateConsequenceAttributeVal(cData);
  //   // Update Resistance Options
  //   this.updateConsequenceResist(csqElem$, cData);
  //   // Update Armor Options
  //   if ((<BladesRoll> this.parent).canResistWithArmor(cData)) {
  //     cData.isDisplayingArmorToggle = true;
  //     this.updateConsequenceArmorResist(csqElem$, cData);
  //   } else {
  //     cData.isDisplayingArmorToggle = false;
  //   }
  //   // Update Special Armor Options
  //   if ((<BladesRoll> this.parent).canResistWithSpecialArmor(cData)) {
  //     cData.isDisplayingSpecialArmorToggle = true;
  //     this.updateConsequenceSpecialArmorResist(csqElem$, cData);
  //   } else {
  //     cData.isDisplayingSpecialArmorToggle = false;
  //   }
  //   return cData;
  // }
  // updateConsequenceDialog(html: JQuery<HTMLElement|HTMLInputElement>, isRendering = true) {
  //   if (!(this.parent instanceof BladesRoll)) { return; }
  //   if (!this.csqData) { return; }
  //   eLog.checkLog3("dialog", "updateConsequenceDialog() this.csqData INCOMING", {...this.csqData});
  //   const {csqData} = this;
  //   const {rollPrimaryDoc} = this.parent;
  //   if (!(rollPrimaryDoc instanceof BladesPC)) { return; }
  //   (Object.keys(csqData) as Position[]).forEach((rollPos) => {
  //     const positionCsqData = csqData[rollPos];
  //     (Object.keys(csqData[rollPos]) as [RollResult.partial, RollResult.fail]).forEach((rollResult) => {
  //       positionCsqData[rollResult] = U.objMap(
  //         positionCsqData[rollResult],
  //         (cData: BladesConsequence.Data) => this.updateConsequenceData(html, cData)
  //       );
  //     });
  //     csqData[rollPos] = positionCsqData;
  //   });
  //   this.csqData = csqData;
  //   eLog.checkLog3("dialog", "updateConsequenceDialog() this.csqData OUTGOING", {...this.csqData});
  //   if (isRendering) {
  //     this.render();
  //   }
  // }
  // async writeToRollInstance(html: JQuery<HTMLElement>) {
  // if (this.parent instanceof BladesRoll) {
  // this.updateConsequenceDialog(html, false);
  // await this.parent.updateTarget("consequenceData", this.csqData);
  // }
  // }
  // _consequenceAI?: BladesAI;
  // getCsqDataFromElem(elem: HTMLElement, paramCount = 3): string[] {
  //   const dataAction = elem.dataset.action;
  //   if (dataAction) {
  //     const params = dataAction.split(/-/).reverse().slice(0, paramCount);
  //     return params.reverse();
  //   }
  //   return [];
  // }
  // async queryAI(event: ClickEvent) {
  //   if (!this.csqData) { return; }
  //   // If the AI generator has not been initialized, do so.
  //   if (!this._consequenceAI) {
  //     this._consequenceAI = new BladesAI(AGENTS.ConsequenceAdjuster);
  //   }
  //   const [rollPosition, rollResult, csqID] = this.getCsqDataFromElem(event.currentTarget);
  //   const csqName: string|undefined =
  //     this.csqData[rollPosition as Position][rollResult as RollResult.partial|RollResult.fail][csqID]?.name;
  //   if (csqName) {
  //     const response = await this._consequenceAI?.query(csqName, csqName);
  //     if (response) {
  //       this.refreshResistanceOptions(rollPosition as Position, rollResult as RollResult.partial|RollResult.fail, csqID, response.split("|"));
  //     }
  //   }
  // }
  // async spawnBlankResistOption(event: ClickEvent) {
  //   if (!this.csqData) { return; }
  //   const [rollPosition, rollResult, csqID] = this.getCsqDataFromElem(event.currentTarget);
  //   const rCsqID = randomID() as IDString;
  //   this.csqData[rollPosition as Position][rollResult as RollResult.partial|RollResult.fail][csqID]
  //     .resistOptions = {
  //       [rCsqID]: {
  //         id: rCsqID,
  //         name: "",
  //         type: undefined,
  //         isSelected: true
  //       }
  //     };
  //   this.render();
  // }
  // async setFlagVal(target: string, value: unknown) {
  //   if (this.parent instanceof BladesRoll) {
  //     await this.parent.updateTarget(target, value);
  //   }
  // }
  // async refreshResistanceOptions(rollPosition: Position, rollResult: RollResult, cID: string, rOptions: string[]) {
  //   if (!this.csqData) { return; }
  //   const cData = this.csqData[rollPosition][rollResult as RollResult.partial|RollResult.fail][cID];
  //   if (!cData) { return; }
  //   const cType = cData.type as keyof typeof C["ResistedConsequenceTypes"];
  //   const rType = C.ResistedConsequenceTypes[cType] ?? undefined;
  //   const resistOptions: Record<string, BladesRoll.ConsequenceResistOption> = {};
  //   for (let i = 0; i < rOptions.length; i++) {
  //     const rID = randomID() as IDString;
  //     resistOptions[rID] = {
  //       id: rID,
  //       name: rOptions[i],
  //       isSelected: false
  //     };
  //     if (rType) {
  //       resistOptions[rID].type = rType;
  //       resistOptions[rID].typeDisplay = C.ConsequenceDisplay[rType];
  //       resistOptions[rID].icon = C.ConsequenceIcons[rType];
  //     }
  //   }
  //   this.csqData[rollPosition][rollResult as RollResult.partial|RollResult.fail][cID].resistOptions = resistOptions;
  //   eLog.checkLog3("dialog", "addResistanceOptions() this.csqData", {...this.csqData});
  //   this.render();
  // }
  // async selectResistOption(event: ClickEvent) {
  //   if (!this.csqData) { return; }
  //   const [rollPosition, rollResult, csqID, resID] = this.getCsqDataFromElem(event.currentTarget, 4);
  //   eLog.checkLog3("dialog", "... Action Passed", {rollResult, csqIndex: csqID, resIndex: resID});
  //   // Get consequence data
  //   const cData = this.csqData[rollPosition as Position][rollResult as RollResult.partial|RollResult.fail][csqID];
  //   cData.resistOptions ??= {};
  //   // Toggle clicked resistance option
  //   cData.resistOptions[resID].isSelected = !cData.resistOptions[resID].isSelected;
  //   // If resistance option is now selected...
  //   if (cData.resistOptions[resID].isSelected) {
  //     // ... deselect & hide other options
  //     Object.keys(cData.resistOptions)
  //       .filter((key) => key !== resID)
  //       .forEach((key) => {
  //         Object.assign(cData.resistOptions?.[key] ?? {}, {isSelected: false, isVisible: false});
  //       });
  //     // ... and set 'resistTo' to this consequence.
  //     cData.resistTo = cData.resistOptions[resID];
  //   } else {
  //     // Otherwise, set 'resistTo' to false...
  //     cData.resistTo = false;
  //     // ... and unhide other options.
  //     Object.keys(cData.resistOptions)
  //       .filter((key) => key !== resID)
  //       .forEach((key) => {
  //         Object.assign(cData.resistOptions?.[key] ?? {}, {isVisible: true});
  //       });
  //   }
  //   // Assign new cData instance.
  //   this.csqData[rollPosition as Position][rollResult as RollResult.partial|RollResult.fail][csqID] = cData;
  //   this.render();
  // }
  // async clearResistOptions(event: ContextMenuEvent) {
  //   if (!this.csqData) { return; }
  //   const [rollPosition, rollResult, csqID] = this.getCsqDataFromElem(event.currentTarget);
  //   this.csqData[rollPosition as Position][rollResult as RollResult.partial|RollResult.fail][csqID].resistOptions = {};
  //   this.render();
  // }
  // async toggleArmor(event: ClickEvent) {
  //   if (!this.csqData) { return; }
  //   const [rollPosition, rollResult, csqID] = this.getCsqDataFromElem(event.currentTarget);
  //   const cData = this.csqData[rollPosition as Position][rollResult as RollResult.partial|RollResult.fail][csqID];
  //   cData.canArmor = !cData.canArmor;
  //   this.render();
  // }
  // async toggleSpecialArmor(event: ClickEvent) {
  //   if (!this.csqData) { return; }
  //   const [rollPosition, rollResult, csqID] = this.getCsqDataFromElem(event.currentTarget);
  //   const cData = this.csqData[rollPosition as Position][rollResult as RollResult.partial|RollResult.fail][csqID];
  //   cData.canSpecialArmor = !cData.canSpecialArmor;
  //   this.render();
  // }
  activateListeners(html) {
    super.activateListeners(html);
    ApplyTooltipAnimations(html);
    switch (this.dialogType) {
      case "Input":
        this.activateInputListeners(html);
        break;
      case "Selection":
        this.activateSelectionListeners(html);
        break;
    }
  }
  activateInputListeners(html) {
    html.find("textarea").on({ change: (event) => this.updateInputText($(event.currentTarget)) });
  }
  activateSelectionListeners(html) {
    const self = this;
    html.find(".nav-tabs .tab-selector").on("click", (event) => {
      const tabIndex = U.pInt($(event.currentTarget).data("tab"));
      const numItems = Object.values(self.tabs ?? [])[tabIndex].length;
      const width = U.pInt(150 * Math.ceil(Math.sqrt(numItems)));
      eLog.checkLog3("nav", "Nav Tab Size Recalculation", { tabIndex, numItems, width });
      this.render(false, { width });
    });
    html.find("[data-item-id]").on("click", function() {
      if ($(this).parent().hasClass("locked")) {
        return;
      }
      const docId = $(this).data("itemId");
      const docType = $(this).data("docType");
      eLog.checkLog("dialog", "[BladesDialog] on Click", { elem: this, docId, docType, parent: self.parent });
      if (self.parent instanceof BladesActor$1) {
        if (docType === "Actor") {
          self.parent.addSubActor(docId, self.tags);
        } else if (docType === "Item") {
          self.parent.addSubItem(docId);
        }
      }
      self.close();
    });
  }
  async close() {
    $("#eunos-blades-tooltips > *").remove();
    super.close();
  }
  // activateConsequenceListeners(html: JQuery<HTMLElement>) {
  // html.find("input").on({change: () => this.updateConsequenceDialog(html)});
  // html.find("select").on({change: () => this.updateConsequenceDialog(html)});
  // html.find('[data-action^="ai-query"]').on({
  //   click: (event) => this.queryAI(event),
  //   contextmenu: (event) => this.clearResistOptions(event)
  // });
  // html.find('[data-action^="blank-option"]').on({
  //   click: (event) => this.spawnBlankResistOption(event),
  //   contextmenu: (event) => this.clearResistOptions(event)
  // });
  // html.find('[data-action^="gm-select-toggle"]').on({click: (event) => this.selectResistOption(event) });
  // html.find('[data-action^="toggle-armor"]').on({click: (event) => this.toggleArmor(event) });
  // html.find('[data-action^="toggle-special"]').on({click: (event) => this.toggleSpecialArmor(event) });
  // }
}
var BladesActorUniqueTags = ((BladesActorUniqueTags2) => {
  BladesActorUniqueTags2[BladesActorUniqueTags2["CharacterCrew"] = Tag.PC.CharacterCrew] = "CharacterCrew";
  BladesActorUniqueTags2[BladesActorUniqueTags2["VicePurveyor"] = Tag.NPC.VicePurveyor] = "VicePurveyor";
  return BladesActorUniqueTags2;
})(BladesActorUniqueTags || {});
var BladesItemUniqueTypes = ((BladesItemUniqueTypes2) => {
  BladesItemUniqueTypes2[BladesItemUniqueTypes2["background"] = BladesItemType.background] = "background";
  BladesItemUniqueTypes2[BladesItemUniqueTypes2["vice"] = BladesItemType.vice] = "vice";
  BladesItemUniqueTypes2[BladesItemUniqueTypes2["crew_playbook"] = BladesItemType.crew_playbook] = "crew_playbook";
  BladesItemUniqueTypes2[BladesItemUniqueTypes2["crew_reputation"] = BladesItemType.crew_reputation] = "crew_reputation";
  BladesItemUniqueTypes2[BladesItemUniqueTypes2["heritage"] = BladesItemType.heritage] = "heritage";
  BladesItemUniqueTypes2[BladesItemUniqueTypes2["playbook"] = BladesItemType.playbook] = "playbook";
  BladesItemUniqueTypes2[BladesItemUniqueTypes2["preferred_op"] = BladesItemType.preferred_op] = "preferred_op";
  return BladesItemUniqueTypes2;
})(BladesItemUniqueTypes || {});
class BladesActor extends Actor {
  constructor() {
    super(...arguments);
    // #endregion
    // #region BladesSubActor Implementation ~
    __publicField(this, "parentActor");
  }
  // #region Static Overrides: Create ~
  static async create(data, options = {}) {
    data.token = data.token || {};
    data.system = data.system ?? {};
    data.system.world_name = data.system.world_name ?? data.name.replace(/[^A-Za-z_0-9 ]/g, "").trim().replace(/ /g, "_");
    return await super.create(data, options);
  }
  // #endregion
  // #region BladesDocument Implementation ~
  static get All() {
    return game.actors;
  }
  static Get(actorRef) {
    if (actorRef instanceof BladesActor) {
      return actorRef;
    }
    if (U.isDocID(actorRef)) {
      return BladesActor.All.get(actorRef);
    }
    return BladesActor.All.find((a) => a.system.world_name === actorRef) || BladesActor.All.find((a) => a.name === actorRef);
  }
  static GetTypeWithTags(docType, ...tags) {
    return BladesActor.All.filter((actor) => actor.type === docType).filter((actor) => actor.hasTag(...tags));
  }
  static IsType(doc, ...types) {
    const typeSet = new Set(types);
    return doc instanceof BladesActor && typeSet.has(doc.type);
  }
  get tags() {
    return this.system.tags ?? [];
  }
  hasTag(...tags) {
    return tags.every((tag) => this.tags.includes(tag));
  }
  async addTag(...tags) {
    const curTags = this.tags;
    tags.forEach((tag) => {
      if (curTags.includes(tag)) {
        return;
      }
      curTags.push(tag);
    });
    eLog.checkLog2("actor", "BladesActor.addTag(...tags)", { tags, curTags });
    await this.update({ "system.tags": curTags });
  }
  async remTag(...tags) {
    const curTags = this.tags.filter((tag) => !tags.includes(tag));
    eLog.checkLog2("actor", "BladesActor.remTag(...tags)", { tags, curTags });
    await this.update({ "system.tags": curTags });
  }
  get tooltip() {
    const tooltipText = [this.system.concept, this.system.subtitle].filter(Boolean).join("<br><br>");
    return tooltipText ? new Handlebars.SafeString(tooltipText).toString() : void 0;
  }
  get dialogCSSClasses() {
    return "";
  }
  getFactorTotal(factor) {
    var _a;
    switch (factor) {
      case Factor.tier: {
        if (BladesActor.IsType(this, BladesActorType.pc)) {
          return this.system.tier.value + (((_a = this.crew) == null ? void 0 : _a.getFactorTotal(Factor.tier)) ?? 0);
        }
        return this.system.tier.value;
      }
      case Factor.quality:
        return this.getFactorTotal(Factor.tier);
      case Factor.scale: {
        if (BladesActor.IsType(this, BladesActorType.npc)) {
          return this.system.scale;
        }
        return 0;
      }
      case Factor.magnitude: {
        if (BladesActor.IsType(this, BladesActorType.npc)) {
          return this.system.magnitude;
        }
        return 0;
      }
      default:
        return 0;
    }
  }
  // #endregion
  // #region SubActorControl Implementation ~
  get subActors() {
    return Object.keys(this.system.subactors).map((id) => this.getSubActor(id)).filter((subActor) => Boolean(subActor));
  }
  get activeSubActors() {
    return this.subActors.filter((subActor) => !subActor.hasTag(Tag.System.Archived));
  }
  get archivedSubActors() {
    return this.subActors.filter((subActor) => subActor.hasTag(Tag.System.Archived));
  }
  checkActorPrereqs(actor) {
    return Boolean(actor);
  }
  processEmbeddedActorMatches(globalActors) {
    return globalActors.filter(this.checkActorPrereqs).filter((gActor) => !this.activeSubActors.some((aActor) => aActor.id === gActor.id)).map((gActor) => this.getSubActor(gActor) || gActor).sort((a, b) => {
      if (a.name === b.name) {
        return 0;
      }
      if (a.name === null) {
        return 1;
      }
      if (b.name === null) {
        return -1;
      }
      if (a.name > b.name) {
        return 1;
      }
      if (a.name < b.name) {
        return -1;
      }
      return 0;
    });
  }
  getDialogActors(category) {
    var _a;
    const dialogData = {};
    switch (category) {
      case SelectionCategory.Contact:
      case SelectionCategory.Rival:
      case SelectionCategory.Friend:
      case SelectionCategory.Acquaintance: {
        if (!BladesActor.IsType(this, BladesActorType.pc, BladesActorType.crew) || this.playbookName === null) {
          return false;
        }
        dialogData.Main = this.processEmbeddedActorMatches(
          BladesActor.GetTypeWithTags(BladesActorType.npc, this.playbookName)
        );
        return dialogData;
      }
      case SelectionCategory.VicePurveyor: {
        if (!BladesActor.IsType(this, BladesActorType.pc) || !((_a = this.vice) == null ? void 0 : _a.name)) {
          return false;
        }
        dialogData.Main = this.processEmbeddedActorMatches(
          BladesActor.GetTypeWithTags(BladesActorType.npc, this.vice.name)
        );
        return dialogData;
      }
      case SelectionCategory.Crew: {
        dialogData.Main = BladesActor.GetTypeWithTags(BladesActorType.crew);
        return dialogData;
      }
      default:
        return false;
    }
  }
  async addSubActor(actorRef, tags) {
    let focusSubActor;
    if (this.hasSubActorOf(actorRef)) {
      const subActor = this.getSubActor(actorRef);
      if (!subActor) {
        return;
      }
      if (subActor.hasTag(Tag.System.Archived)) {
        await subActor.remTag(Tag.System.Archived);
      }
      focusSubActor = subActor;
    } else {
      const actor = BladesActor.Get(actorRef);
      if (!actor) {
        return;
      }
      const subActorData = {};
      if (tags) {
        subActorData.tags = U.unique([
          ...actor.tags,
          ...tags
        ]);
      }
      await this.update({ [`system.subactors.${actor.id}`]: subActorData });
      focusSubActor = this.getSubActor(actor.id);
    }
    if (!focusSubActor) {
      return;
    }
    const uniqueTags = focusSubActor.tags.filter((tag) => tag in BladesActorUniqueTags);
    if (uniqueTags.length > 0) {
      uniqueTags.forEach((uTag) => this.activeSubActors.filter(
        (subActor) => Boolean((focusSubActor == null ? void 0 : focusSubActor.id) && subActor.id !== focusSubActor.id && subActor.hasTag(uTag))
      ).map((subActor) => this.remSubActor(subActor.id)));
    }
  }
  getSubActor(actorRef) {
    const actor = BladesActor.Get(actorRef);
    if (!(actor == null ? void 0 : actor.id)) {
      return void 0;
    }
    if (!BladesActor.IsType(actor, BladesActorType.npc, BladesActorType.faction)) {
      return actor;
    }
    const subActorData = this.system.subactors[actor.id] ?? {};
    Object.assign(
      actor.system,
      subActorData
    );
    actor.parentActor = this;
    return actor;
  }
  hasSubActorOf(actorRef) {
    const actor = BladesActor.Get(actorRef);
    if (!actor) {
      return false;
    }
    return (actor == null ? void 0 : actor.id) ? actor.id in this.system.subactors : false;
  }
  async updateSubActor(actorRef, upData) {
    const updateData = U.objExpand(upData);
    if (!updateData.system) {
      return void 0;
    }
    const actor = BladesActor.Get(actorRef);
    if (!actor) {
      return void 0;
    }
    const diffUpdateSystem = U.objDiff(actor.system, updateData.system);
    const mergedSubActorSystem = U.objMerge(
      this.system.subactors[actor.id] ?? {},
      diffUpdateSystem,
      { isReplacingArrays: true, isConcatenatingArrays: false }
    );
    if (JSON.stringify(this.system.subactors[actor.id]) === JSON.stringify(mergedSubActorSystem)) {
      return void 0;
    }
    return this.update({ [`system.subactors.${actor.id}`]: null }, void 0, true).then(() => this.update({ [`system.subactors.${actor.id}`]: mergedSubActorSystem }, void 0, true)).then(() => {
      var _a;
      return (_a = actor.sheet) == null ? void 0 : _a.render();
    });
  }
  async remSubActor(actorRef) {
    const subActor = this.getSubActor(actorRef);
    if (!subActor) {
      return;
    }
    await this.update({ "system.subactors": mergeObject(this.system.subactors, { [`-=${subActor.id}`]: null }) }, void 0, true);
  }
  async clearSubActors(isReRendering = true) {
    var _a;
    this.subActors.forEach((subActor) => {
      var _a2;
      if (((_a2 = subActor.parentActor) == null ? void 0 : _a2.id) === this.id) {
        subActor.clearParentActor(isReRendering);
      }
    });
    await ((_a = this.sheet) == null ? void 0 : _a.render());
  }
  async clearParentActor(isReRendering = true) {
    var _a;
    const { parentActor } = this;
    if (!parentActor) {
      return;
    }
    this.parentActor = void 0;
    this.system = this._source.system;
    this.ownership = this._source.ownership;
    this.prepareData();
    if (isReRendering) {
      await ((_a = this.sheet) == null ? void 0 : _a.render());
    }
  }
  // #endregion
  // #region SubItemControl Implementation ~
  get subItems() {
    return Array.from(this.items);
  }
  getSubItemsOfType(itemType) {
    return this.items.filter((item) => item.type === itemType);
  }
  get activeSubItems() {
    return this.items.filter((item) => !item.hasTag(Tag.System.Archived));
  }
  get archivedSubItems() {
    return this.items.filter((item) => item.hasTag(Tag.System.Archived));
  }
  _checkItemPrereqs(item) {
    if (!item.system.prereqs) {
      return true;
    }
    for (const [pType, pReqs] of Object.entries(
      item.system.prereqs
    )) {
      const pReqArray = Array.isArray(pReqs) ? pReqs : [pReqs.toString()];
      const hitRecord = {};
      if (!this._processPrereqArray(pReqArray, pType, hitRecord)) {
        return false;
      }
    }
    return true;
  }
  _processPrereqArray(pReqArray, pType, hitRecord) {
    while (pReqArray.length) {
      const pString = pReqArray.pop();
      hitRecord[pType] ?? (hitRecord[pType] = []);
      if (!this._processPrereqType(pType, pString, hitRecord)) {
        return false;
      }
    }
    return true;
  }
  _processPrereqType(pType, pString, hitRecord) {
    switch (pType) {
      case PrereqType.HasActiveItem: {
        return this._processActiveItemPrereq(pString, hitRecord, pType);
      }
      case PrereqType.HasActiveItemsByTag: {
        return this._processActiveItemsByTagPrereq(pString, hitRecord, pType);
      }
      case PrereqType.AdvancedPlaybook: {
        return this._processAdvancedPlaybookPrereq();
      }
      default:
        return true;
    }
  }
  _processActiveItemPrereq(pString, hitRecord, pType) {
    var _a;
    const thisItem = this.activeSubItems.filter((i) => {
      var _a2;
      return !((_a2 = hitRecord[pType]) == null ? void 0 : _a2.includes(i.id));
    }).find((i) => i.system.world_name === pString);
    if (thisItem) {
      (_a = hitRecord[pType]) == null ? void 0 : _a.push(thisItem.id);
      return true;
    } else {
      return false;
    }
  }
  _processActiveItemsByTagPrereq(pString, hitRecord, pType) {
    var _a;
    const thisItem = this.activeSubItems.filter((i) => {
      var _a2;
      return !((_a2 = hitRecord[pType]) == null ? void 0 : _a2.includes(i.id));
    }).find((i) => i.hasTag(pString));
    if (thisItem) {
      (_a = hitRecord[pType]) == null ? void 0 : _a.push(thisItem.id);
      return true;
    } else {
      return false;
    }
  }
  _processAdvancedPlaybookPrereq() {
    if (!BladesActor.IsType(this, BladesActorType.pc)) {
      return false;
    }
    if (!this.playbookName || ![Playbook.Ghost, Playbook.Hull, Playbook.Vampire].includes(this.playbookName)) {
      return false;
    }
    return true;
  }
  _processEmbeddedItemMatches(globalItems) {
    return globalItems.filter((item) => this._checkItemPrereqs(item)).filter((gItem) => gItem.hasTag(Tag.System.MultiplesOK) || (gItem.system.max_per_score ?? 1) > this.activeSubItems.filter((sItem) => sItem.system.world_name === gItem.system.world_name).length).map((gItem) => {
      const matchingSubItems = this.archivedSubItems.filter((sItem) => sItem.system.world_name === gItem.system.world_name);
      if (matchingSubItems.length > 0) {
        return matchingSubItems;
      } else {
        return gItem;
      }
    }).flat().map((sItem) => {
      sItem.dialogCSSClasses = "";
      const cssClasses = [];
      if (sItem.isEmbedded) {
        cssClasses.push("embedded");
      }
      if (sItem.hasTag(Tag.Gear.Fine)) {
        cssClasses.push("fine-quality");
      }
      if (sItem.hasTag(Tag.System.Featured)) {
        cssClasses.push("featured-item");
      }
      if ([BladesItemType.ability, BladesItemType.crew_ability].includes(sItem.type)) {
        if (this.getAvailableAdvancements("Ability") === 0) {
          cssClasses.push("locked");
        } else if ((sItem.system.price ?? 1) > this.getAvailableAdvancements("Ability")) {
          cssClasses.push("locked", "unaffordable");
        } else if ((sItem.system.price ?? 1) > 1) {
          cssClasses.push("expensive");
        }
      }
      if ([BladesItemType.crew_upgrade].includes(sItem.type)) {
        if (this.getAvailableAdvancements("Upgrade") === 0) {
          cssClasses.push("locked");
        } else if ((sItem.system.price ?? 1) > this.getAvailableAdvancements("Upgrade")) {
          cssClasses.push("locked", "unaffordable");
        } else if ((sItem.system.price ?? 1) > 1) {
          cssClasses.push("expensive");
        }
      }
      if (cssClasses.length > 0) {
        sItem.dialogCSSClasses = cssClasses.join(" ");
      }
      return sItem;
    }).sort((a, b) => {
      if (a.hasTag(Tag.System.Featured) && !b.hasTag(Tag.System.Featured)) {
        return -1;
      }
      if (!a.hasTag(Tag.System.Featured) && b.hasTag(Tag.System.Featured)) {
        return 1;
      }
      if (a.hasTag(Tag.Gear.Fine) && !b.hasTag(Tag.Gear.Fine)) {
        return -1;
      }
      if (!a.hasTag(Tag.Gear.Fine) && b.hasTag(Tag.Gear.Fine)) {
        return 1;
      }
      if (a.system.world_name > b.system.world_name) {
        return 1;
      }
      if (a.system.world_name < b.system.world_name) {
        return -1;
      }
      if (a.isEmbedded && !b.isEmbedded) {
        return -1;
      }
      if (!a.isEmbedded && b.isEmbedded) {
        return 1;
      }
      if (a.name === b.name) {
        return 0;
      }
      if (a.name === null) {
        return 1;
      }
      if (b.name === null) {
        return -1;
      }
      if (a.name > b.name) {
        return 1;
      }
      if (a.name < b.name) {
        return -1;
      }
      return 0;
    });
  }
  getSubItem(itemRef, activeOnly = false) {
    const activeCheck = (i) => !activeOnly || !i.hasTag(Tag.System.Archived);
    if (typeof itemRef === "string" && this.items.get(itemRef)) {
      const returnItem = this.items.get(itemRef);
      if (returnItem && activeCheck(returnItem)) {
        return returnItem;
      } else {
        return void 0;
      }
    } else {
      const globalItem = BladesItem$1.Get(itemRef);
      if (!globalItem) {
        return void 0;
      }
      return this.items.find((item) => item.name === globalItem.name && activeCheck(item)) ?? this.items.find((item) => item.system.world_name === globalItem.system.world_name && activeCheck(item));
    }
  }
  hasSubItemOf(itemRef) {
    const item = BladesItem$1.Get(itemRef);
    if (!item) {
      return false;
    }
    return Boolean(this.items.find((i) => i.system.world_name === item.system.world_name));
  }
  hasActiveSubItemOf(itemRef) {
    const item = BladesItem$1.Get(itemRef);
    if (!item) {
      return false;
    }
    return Boolean(this.items.find((i) => !i.hasTag(Tag.System.Archived) && i.system.world_name === item.system.world_name));
  }
  async addSubItem(itemRef) {
    function isBladesItemUniqueTypes(type) {
      return Object.values(BladesItemUniqueTypes).includes(type);
    }
    eLog.checkLog3("subitems", "[addSubItem] itemRef", itemRef);
    let focusItem;
    const embeddedItem = this.getSubItem(itemRef);
    if (embeddedItem) {
      if (embeddedItem.hasTag(Tag.System.Archived)) {
        await embeddedItem.remTag(Tag.System.Archived);
        focusItem = embeddedItem;
        eLog.checkLog3("subitems", `[addSubItem] IS ARCHIVED EMBEDDED > Removing 'Archived' Tag, '${focusItem.id}':`, focusItem);
      } else {
        focusItem = await BladesItem$1.create(
          [embeddedItem],
          { parent: this }
        );
        eLog.checkLog3("subitems", `[addSubItem] IS ACTIVE EMBEDDED > Duplicating, focusItem '${focusItem.id}':`, focusItem);
      }
    } else {
      const globalItem = BladesItem$1.Get(itemRef);
      eLog.checkLog3("subitems", `[addSubItem] IS NOT EMBEDDED > Fetching Global, globalItem '${globalItem == null ? void 0 : globalItem.id}':`, globalItem);
      if (!globalItem) {
        return;
      }
      focusItem = await BladesItem$1.create(
        [globalItem],
        { parent: this }
      );
      focusItem = this.items.getName(globalItem.name);
    }
    if (focusItem && isBladesItemUniqueTypes(focusItem.type)) {
      await Promise.all(this.activeSubItems.filter((subItem) => subItem.type === (focusItem == null ? void 0 : focusItem.type) && subItem.system.world_name !== (focusItem == null ? void 0 : focusItem.system.world_name) && !subItem.hasTag(Tag.System.Archived)).map(this.remSubItem.bind(this)));
    }
  }
  async remSubItem(itemRef) {
    const subItem = this.getSubItem(itemRef);
    if (!subItem) {
      return;
    }
    if (subItem.type !== BladesItemType.gear) {
      this.purgeSubItem(itemRef);
      return;
    }
    eLog.checkLog("actorTrigger", `Removing SubItem ${subItem.name}`, subItem);
    if (subItem.hasTag(Tag.System.Archived)) {
      return;
    }
    await subItem.addTag(Tag.System.Archived);
  }
  async purgeSubItem(itemRef) {
    const subItem = this.getSubItem(itemRef);
    if (!subItem || subItem.hasTag(Tag.System.Archived)) {
      return;
    }
    await subItem.delete();
  }
  // #endregion
  // #region Advancement Implementation ~
  // get totalAbilityPoints(): number {
  //   if (!BladesActor.IsType(this, BladesActorType.pc, BladesActorType.crew)) { return 0 }
  //   if (!this.playbook) { return 0 }
  //   switch (this.type) {
  //     case BladesActorType.pc: return this.system.advancement.ability ?? 0;
  //     case BladesActorType.crew: return Math.floor(0.5 * (this.system.advancement.general ?? 0))
  //      + (this.system.advancement.ability ?? 0);
  //     default: return 0;
  //   }
  // }
  // get spentAbilityPoints(): number {
  //   if (!BladesActor.IsType(this, BladesActorType.pc, BladesActorType.crew)) { return 0 }
  //   if (!this.playbook) { return 0 }
  //   return this.abilities.reduce((total, ability) => total + (ability.system.price ?? 1), 0);
  // }
  // get getAvailableAdvancements("Ability")(): number {
  //   if (!BladesActor.IsType(this, BladesActorType.pc, BladesActorType.crew)) { return 0 }
  //   if (!this.playbook) { return 0 }
  //   return this.totalAbilityPoints - this.spentAbilityPoints;
  // }
  /* Need simple getters for total ability & upgrade points that check for PRICES of items
        (upgrade.system.price ?? 1) */
  async grantAdvancementPoints(allowedTypes, amount = 1) {
    var _a;
    const aPtKey = Array.isArray(allowedTypes) ? [...allowedTypes].sort((a, b) => a.localeCompare(b)).join("_") : allowedTypes;
    await this.update({ [`system.advancement_points.${aPtKey}`]: (((_a = this.system.advancement_points) == null ? void 0 : _a[aPtKey]) ?? 0) + amount });
  }
  async removeAdvancementPoints(allowedTypes, amount = 1) {
    var _a;
    const aPtKey = Array.isArray(allowedTypes) ? [...allowedTypes].sort((a, b) => a.localeCompare(b)).join("_") : allowedTypes;
    const newCount = ((_a = this.system.advancement_points) == null ? void 0 : _a[aPtKey]) ?? 0 - amount;
    if (newCount <= 0 && aPtKey in (this.system.advancement_points ?? [])) {
      await this.update({ [`system.advancement_points.-=${aPtKey}`]: null });
    } else {
      await this.update({ [`system.advancement_points.${aPtKey}`]: newCount });
    }
  }
  getAvailableAdvancements(trait) {
    var _a, _b, _c, _d, _e;
    if (!BladesActor.IsType(this, BladesActorType.pc, BladesActorType.crew)) {
      return 0;
    }
    if (trait in ActionTrait) {
      return 1;
    }
    if (trait === "Cohort") {
      const pointsCohort = ((_a = this.system.advancement_points) == null ? void 0 : _a[AdvancementPoint.Cohort]) ?? 0;
      const spentCohort = this.cohorts.length;
      return Math.max(0, pointsCohort - spentCohort);
    }
    const pointsAbility = ((_b = this.system.advancement_points) == null ? void 0 : _b[AdvancementPoint.Ability]) ?? 0;
    const pointsCohortType = ((_c = this.system.advancement_points) == null ? void 0 : _c[AdvancementPoint.CohortType]) ?? 0;
    const pointsUpgrade = ((_d = this.system.advancement_points) == null ? void 0 : _d[AdvancementPoint.Upgrade]) ?? 0;
    const pointsUpgradeOrAbility = ((_e = this.system.advancement_points) == null ? void 0 : _e[AdvancementPoint.UpgradeOrAbility]) ?? 0;
    const spentAbility = U.sum(this.items.filter((item) => BladesItem$1.IsType(item, BladesItemType.ability, BladesItemType.crew_ability)).map((abil) => abil.system.price ?? 1));
    const spentCohortType = U.sum(
      this.cohorts.map((cohort) => Math.max(0, U.unique(Object.values(cohort.system.subtypes)).length - 1))
    );
    const spentUpgrade = U.sum(this.items.filter((item) => BladesItem$1.IsType(item, BladesItemType.crew_upgrade)).map((upgrade) => upgrade.system.price ?? 1));
    const excessUpgrade = Math.max(0, spentUpgrade - pointsUpgrade);
    const excessCohortType = Math.max(0, spentCohortType - pointsCohortType);
    const excessAbility = Math.max(0, spentAbility - pointsAbility);
    const remainingAbility = Math.max(0, pointsAbility - spentAbility);
    const remainingCohortType = Math.max(0, pointsCohortType - spentCohortType);
    const remainingUpgrade = Math.max(0, pointsUpgrade - spentUpgrade);
    const remainingUpgradeOrAbility = Math.max(
      0,
      pointsUpgradeOrAbility - excessUpgrade - 2 * excessAbility - 2 * excessCohortType
    );
    if (trait === "Ability") {
      return remainingAbility + Math.floor(0.5 * remainingUpgradeOrAbility);
    }
    if (trait === "Upgrade") {
      return remainingUpgrade + remainingUpgradeOrAbility;
    }
    if (trait === "CohortType") {
      return remainingCohortType + remainingUpgradeOrAbility;
    }
    return 0;
  }
  get availableAbilityPoints() {
    return this.getAvailableAdvancements("Ability");
  }
  get availableUpgradePoints() {
    return this.getAvailableAdvancements("Upgrade");
  }
  get availableCohortPoints() {
    return this.getAvailableAdvancements("Cohort");
  }
  get availableCohortTypePoints() {
    return this.getAvailableAdvancements("CohortType");
  }
  get canPurchaseAbility() {
    return this.availableAbilityPoints > 0;
  }
  get canPurchaseUpgrade() {
    return this.availableUpgradePoints > 0;
  }
  get canPurchaseCohort() {
    return this.availableCohortPoints > 0;
  }
  get canPurchaseCohortType() {
    return this.availableCohortTypePoints > 0;
  }
  async advancePlaybook() {
    if (!BladesActor.IsType(this, BladesActorType.pc, BladesActorType.crew) || !this.playbook) {
      return;
    }
    await this.update({ "system.experience.playbook.value": 0 });
    if (this instanceof BladesPC$1) {
      BladesDirector.getInstance().pushNotice_SocketCall(
        "ALL",
        {
          title: `${this.name} Advances their Playbook!`,
          body: `${this.name}, select a new Ability on your Character Sheet.`,
          type: BladesNoticeType.push,
          cssClasses: "advancement-alert"
        }
      );
      this.grantAdvancementPoints(AdvancementPoint.Ability);
      return;
    }
    if (this instanceof BladesCrew$1) {
      BladesDirector.getInstance().pushNotice_SocketCall(
        "ALL",
        {
          title: "You Advance your Crew Playbook!",
          body: "Select new Upgrades and/or Abilities on your Crew Sheet.",
          type: BladesNoticeType.push,
          cssClasses: "advancement-alert crew-advancement-alert"
        }
      );
      const coinGained = this.system.tier.value + 2;
      this.members.forEach((member) => {
        var _a, _b;
        if ((_a = member.primaryUser) == null ? void 0 : _a.id) {
          BladesDirector.getInstance().pushNotice_SocketCall(
            (_b = member.primaryUser) == null ? void 0 : _b.id,
            {
              title: "Your Stash Increases! <em>(Crew Advancement)</em>",
              type: BladesNoticeType.push,
              body: `You gain ${coinGained} Stash from Crew Advancement.`,
              cssClasses: "stash-alert"
            }
          );
          member.addStash(coinGained);
        }
      });
      this.grantAdvancementPoints(AdvancementPoint.UpgradeOrAbility, 2);
    }
  }
  async advanceAttribute(attribute) {
    var _a;
    if (!(this instanceof BladesPC$1)) {
      return;
    }
    if (!((_a = this.primaryUser) == null ? void 0 : _a.id)) {
      return;
    }
    await this.update({ [`system.experience.${attribute}.value`]: 0 });
    const actions = C.Action[attribute].map((action) => `<strong>${U.tCase(action)}</strong>`);
    BladesDirector.getInstance().pushNotice_SocketCall(
      this.primaryUser.id,
      {
        title: `${this.name} Advances their ${U.uCase(attribute)}!`,
        body: `${this.name}, add a dot to one of ${U.oxfordize(actions, true, "or")}.`,
        type: BladesNoticeType.push,
        cssClasses: "advancement-alert"
      }
    );
  }
  get isAtWar() {
    var _a;
    if (BladesNPC$1.IsType(this)) {
      return false;
    }
    if (BladesPC$1.IsType(this)) {
      return ((_a = this.crew) == null ? void 0 : _a.isAtWar) ?? false;
    }
    return Object.values(this.system.at_war_with ?? {}).filter((val) => val === true).length > 0;
  }
  get isSubActor() {
    return this.parentActor !== void 0;
  }
  // #endregion
  // #region BladesRoll Implementation ~
  get rollPrimaryModsSchemaSet() {
    return BladesRollMod.ParseDocModsToSchemaSet(this);
  }
  get rollFactors() {
    const factorData = {
      [Factor.tier]: {
        name: Factor.tier,
        display: "Tier",
        value: this.getFactorTotal(Factor.tier),
        max: this.getFactorTotal(Factor.tier),
        baseVal: this.getFactorTotal(Factor.tier),
        isActive: true,
        isPrimary: true,
        isDominant: false,
        highFavorsPC: true
      },
      [Factor.quality]: {
        name: Factor.quality,
        display: "Quality",
        value: this.getFactorTotal(Factor.quality),
        max: this.getFactorTotal(Factor.quality),
        baseVal: this.getFactorTotal(Factor.quality),
        isActive: false,
        isPrimary: false,
        isDominant: false,
        highFavorsPC: true
      }
    };
    return factorData;
  }
  // #region BladesRoll.PrimaryDoc Implementation
  get rollPrimaryID() {
    return this.id;
  }
  get rollPrimaryDoc() {
    return this;
  }
  get rollPrimaryName() {
    return this.name;
  }
  get rollPrimaryType() {
    if (![BladesActorType.pc, BladesActorType.crew].includes(this.type)) {
      throw new Error(`BladesActor of type '${this.type}' ("${this.name}") cannot be RollPrimary.`);
    }
    return this.type;
  }
  get rollPrimaryImg() {
    return this.img;
  }
  // #endregion
  // #endregion
  // #region BladesCrew Implementation ~
  // #endregion
  // #region PREPARING DERIVED DATA ~
  prepareDerivedData() {
    if (BladesActor.IsType(this, BladesActorType.pc)) {
      this._preparePCData(this.system);
    }
    if (BladesActor.IsType(this, BladesActorType.crew)) {
      this._prepareCrewData(this.system);
    }
  }
  _preparePCData(system) {
    if (!BladesActor.IsType(this, BladesActorType.pc)) {
      return;
    }
    if (this.playbook) {
      system.experience.clues = [
        ...system.experience.clues,
        ...Object.values(this.playbook.system.experience_clues).filter((clue) => Boolean(clue.trim()))
      ];
    }
    if (this.playbook) {
      system.gather_info = [
        ...system.gather_info,
        ...Object.values(this.playbook.system.gather_info_questions).filter((question) => Boolean(question.trim()))
      ];
    }
  }
  _prepareCrewData(system) {
    if (!BladesActor.IsType(this, BladesActorType.crew)) {
      return;
    }
    if (this.playbook) {
      system.experience.clues = [
        ...system.experience.clues,
        ...Object.values(this.playbook.system.experience_clues).filter((clue) => Boolean(clue.trim()))
      ];
      system.turfs = this.playbook.system.turfs;
    }
  }
  // #endregion
  // #region OVERRIDES: _onCreateDescendantDocuments, update ~
  // @ts-expect-error New method not defined in @league VTT types.
  async _onCreateDescendantDocuments(parent, collection, docs, data, options, userId) {
    await Promise.all(docs.map(async (doc) => {
      if (BladesItem$1.IsType(doc, BladesItemType.playbook, BladesItemType.crew_playbook)) {
        await Promise.all(this.activeSubItems.filter((aItem) => aItem.type === doc.type && aItem.system.world_name !== doc.system.world_name).map((aItem) => this.remSubItem(aItem)));
      }
    }));
    await super._onCreateDescendantDocuments(parent, collection, docs, data, options, userId);
    eLog.checkLog("actorTrigger", "_onCreateDescendantDocuments", { parent, collection, docs, data, options, userId });
    docs.forEach((doc) => {
      if (BladesItem$1.IsType(doc, BladesItemType.vice) && BladesActor.IsType(this, BladesActorType.pc)) {
        this.activeSubActors.filter((subActor) => subActor.hasTag(Tag.NPC.VicePurveyor) && !subActor.hasTag(doc.name)).forEach((subActor) => {
          this.remSubActor(subActor);
        });
      }
    });
  }
  async update(updateData, context, isSkippingSubActorCheck = false) {
    if (!updateData) {
      return super.update(updateData);
    }
    if (BladesActor.IsType(this, BladesActorType.crew)) {
      if (!this.playbook) {
        return void 0;
      }
      eLog.checkLog("actorTrigger", "Updating Crew", { updateData });
      const playbookUpdateData = Object.fromEntries(
        Object.entries(flattenObject(updateData)).filter(([key, _]) => key.startsWith("system.turfs."))
      );
      updateData = Object.fromEntries(Object.entries(flattenObject(updateData)).filter(([key, _]) => !key.startsWith("system.turfs.")));
      eLog.checkLog("actorTrigger", "Updating Crew", { crewUpdateData: updateData, playbookUpdateData });
      const diffPlaybookData = diffObject(
        flattenObject(this.playbook),
        playbookUpdateData
      );
      delete diffPlaybookData._id;
      if (!U.isEmpty(diffPlaybookData)) {
        await this.playbook.update(playbookUpdateData, context).then(() => {
          var _a;
          return (_a = this.sheet) == null ? void 0 : _a.render(false);
        });
      }
    } else if ((BladesActor.IsType(this, BladesActorType.npc) || BladesActor.IsType(this, BladesActorType.faction)) && this.parentActor && !isSkippingSubActorCheck) {
      return this.parentActor.updateSubActor(this.id, updateData).then(() => this);
    }
    return super.update(updateData, context);
  }
  // #endregion
  // #region Rolling Dice ~
  /**
   * Creates <options> modifiers for dice roll.
   *
   * @param {int} rs
   *  Min die modifier
   * @param {int} re
   *  Max die modifier
   * @param {int} s
   *  Selected die
   */
  createListOfDiceMods(rs, re, s) {
    let text = "";
    if (s === "") {
      s = 0;
    }
    for (let i = rs; i <= re; i++) {
      let plus = "";
      if (i >= 0) {
        plus = "+";
      }
      text += `<option value="${i}"`;
      if (i === s) {
        text += " selected";
      }
      text += `>${plus}${i}d</option>`;
    }
    return text;
  }
  // #endregion Rolling Dice
  // #region NPC Randomizers ~
  updateRandomizers() {
    if (!BladesActor.IsType(this, BladesActorType.npc)) {
      return;
    }
    const titleChance = 0.05;
    const suffixChance = 0.01;
    const { persona, secret, random } = this.system;
    function sampleArray(arr, ...curVals) {
      arr = arr.filter((elem) => !curVals.includes(elem));
      if (!arr.length) {
        return "";
      }
      return arr[Math.floor(Math.random() * arr.length)];
    }
    const randomGen = {
      name: (gen) => {
        return [
          Math.random() <= titleChance ? sampleArray(Randomizers.NPC.name_title) : "",
          sampleArray([
            ...(gen ?? "").charAt(0).toLowerCase() !== "m" ? Randomizers.NPC.name_first.female : [],
            ...(gen ?? "").charAt(0).toLowerCase() !== "f" ? Randomizers.NPC.name_first.male : []
          ]),
          `"${sampleArray(Randomizers.NPC.name_alias)}"`,
          sampleArray(Randomizers.NPC.name_surname),
          Math.random() <= suffixChance ? sampleArray(Randomizers.NPC.name_suffix) : ""
        ].filter((val) => Boolean(val)).join(" ");
      },
      background: () => sampleArray(Randomizers.NPC.background, random.background.value),
      heritage: () => sampleArray(Randomizers.NPC.heritage, random.heritage.value),
      profession: () => sampleArray(Randomizers.NPC.profession, random.profession.value),
      gender: () => sampleArray(Randomizers.NPC.gender, persona.gender.value),
      appearance: () => sampleArray(Randomizers.NPC.appearance, persona.appearance.value),
      goal: () => sampleArray(Randomizers.NPC.goal, persona.goal.value, secret.goal.value),
      method: () => sampleArray(Randomizers.NPC.method, persona.method.value, secret.method.value),
      trait: () => sampleArray(
        Randomizers.NPC.trait,
        persona.trait1.value,
        persona.trait2.value,
        persona.trait3.value,
        secret.trait.value
      ),
      interests: () => sampleArray(Randomizers.NPC.interests, persona.interests.value, secret.interests.value),
      quirk: () => sampleArray(Randomizers.NPC.quirk, persona.quirk.value),
      style: (gen = "") => sampleArray([
        ...gen.charAt(0).toLowerCase() !== "m" ? Randomizers.NPC.style.female : [],
        ...gen.charAt(0).toLowerCase() !== "f" ? Randomizers.NPC.style.male : []
      ], persona.style.value)
    };
    const gender = persona.gender.isLocked ? persona.gender.value : randomGen.gender();
    const updateKeys = [
      ...Object.keys(persona).filter((key) => {
        var _a;
        return !((_a = persona[key]) == null ? void 0 : _a.isLocked);
      }),
      ...Object.keys(random).filter((key) => {
        var _a;
        return !((_a = random[key]) == null ? void 0 : _a.isLocked);
      }),
      ...Object.keys(secret).filter((key) => {
        var _a;
        return !((_a = secret[key]) == null ? void 0 : _a.isLocked);
      }).map((secretKey) => `secret-${secretKey}`)
    ];
    eLog.checkLog("Update Keys", { updateKeys });
    const updateData = {};
    updateKeys.forEach((key) => {
      switch (key) {
        case "name":
        case "heritage":
        case "background":
        case "profession": {
          const randomVal = randomGen[key]();
          updateData[`system.random.${key}`] = {
            isLocked: false,
            value: randomVal || random[key].value
          };
          break;
        }
        case "secret-goal":
        case "secret-interests":
        case "secret-method": {
          key = key.replace(/^secret-/, "");
          const randomVal = randomGen[key]();
          updateData[`system.secret.${key}`] = {
            isLocked: false,
            value: randomVal || secret[key].value
          };
          break;
        }
        case "gender": {
          updateData[`system.persona.${key}`] = {
            isLocked: persona.gender.isLocked,
            value: gender
          };
          break;
        }
        case "trait1":
        case "trait2":
        case "trait3":
        case "secret-trait": {
          const trait1 = persona.trait1.isLocked ? persona.trait1.value : sampleArray(
            Randomizers.NPC.trait,
            persona.trait1.value,
            persona.trait2.value,
            persona.trait3.value,
            secret.trait.value
          );
          const trait2 = persona.trait2.isLocked ? persona.trait2.value : sampleArray(
            Randomizers.NPC.trait,
            trait1,
            persona.trait1.value,
            persona.trait2.value,
            persona.trait3.value,
            secret.trait.value
          );
          const trait3 = persona.trait3.isLocked ? persona.trait3.value : sampleArray(
            Randomizers.NPC.trait,
            trait1,
            trait2,
            persona.trait1.value,
            persona.trait2.value,
            persona.trait3.value,
            secret.trait.value
          );
          const secretTrait = secret.trait.isLocked ? secret.trait.value : sampleArray(
            Randomizers.NPC.trait,
            trait1,
            trait2,
            trait3,
            persona.trait1.value,
            persona.trait2.value,
            persona.trait3.value,
            secret.trait.value
          );
          if (!persona.trait1.isLocked) {
            updateData["system.persona.trait1"] = {
              isLocked: false,
              value: trait1
            };
          }
          if (!persona.trait2.isLocked) {
            updateData["system.persona.trait2"] = {
              isLocked: false,
              value: trait2
            };
          }
          if (!persona.trait3.isLocked) {
            updateData["system.persona.trait3"] = {
              isLocked: false,
              value: trait3
            };
          }
          if (!secret.trait.isLocked) {
            updateData["system.secret.trait"] = {
              isLocked: false,
              value: secretTrait
            };
          }
          break;
        }
        default: {
          const randomVal = randomGen[key]();
          updateData[`system.persona.${key}`] = {
            isLocked: false,
            value: randomVal || persona[key].value
          };
          break;
        }
      }
    });
    this.update(updateData);
  }
  // #endregion NPC Randomizers
  // Unlock lower-level update method for subclasses
  async callOnUpdate(...args) {
    await this._onUpdate(...args);
  }
}
const BladesActor$1 = BladesActor;
class BladesActorSheet extends ActorSheet {
  /**
   * Override the default getData method to provide additional data for the actor sheet.
   * This includes: cssClass, editable, isGM, actor, system, tierTotal, rollData, activeEffects,
   *                 hasFullVision, hasLimitedVision, hasControl, preparedItems.
   * @returns {BladesActorSheetData} The data object for the actor sheet.
   */
  getData() {
    var _a, _b;
    const context = super.getData();
    const sheetData = {
      // Basic actor data.
      cssClass: this.actor.type,
      editable: this.options.editable,
      isGM: ((_a = game.eunoblades.Tracker) == null ? void 0 : _a.system.is_spoofing_player) ? false : game.user.isGM,
      actor: this.actor,
      system: this.actor.system,
      gamePhase: ((_b = game.eunoblades.Tracker) == null ? void 0 : _b.phase) || BladesPhase.Freeplay,
      tierTotal: this.actor.getFactorTotal(Factor.tier) > 0 ? U.romanizeNum(this.actor.getFactorTotal(Factor.tier)) : "0",
      rollData: this.actor.getRollData(),
      activeEffects: Array.from(this.actor.effects),
      hasFullVision: game.user.isGM || this.actor.testUserPermission(game.user, CONST.DOCUMENT_PERMISSION_LEVELS.OBSERVER),
      hasLimitedVision: game.user.isGM || this.actor.testUserPermission(game.user, CONST.DOCUMENT_PERMISSION_LEVELS.LIMITED),
      hasControl: game.user.isGM || this.actor.testUserPermission(game.user, CONST.DOCUMENT_PERMISSION_LEVELS.OWNER)
    };
    if (BladesPC$1.IsType(this.actor) || BladesCrew$1.IsType(this.actor)) {
      sheetData.preparedItems = {
        abilities: [],
        loadout: [],
        cohorts: {
          gang: this.actor.cohorts.filter((item) => item.type === BladesItemType.cohort_gang).map((item) => {
            const subtypes = U.unique(Object.values(item.system.subtypes).map((subtype) => subtype.trim()).filter((subtype) => /[A-Za-z]/.test(subtype)));
            const eliteSubtypes = [
              ...Object.values(item.system.elite_subtypes)
            ];
            if (BladesCrew$1.IsType(item.parent)) {
              eliteSubtypes.push(...(item.parent.upgrades ?? []).map((upgrade) => (upgrade.name ?? "").trim().replace(/^Elite /, "")));
            }
            const imgTypes = [...U.unique(
              eliteSubtypes.map((subtype) => subtype.trim()).filter(
                (subtype) => /[A-Za-z]/.test(subtype) && subtypes.includes(subtype)
              )
            )];
            if (imgTypes.length < 2) {
              imgTypes.push(...subtypes.filter((subtype) => !imgTypes.includes(subtype)));
            }
            if (U.unique(imgTypes).length === 1) {
              item.system.image = Object.values(item.system.elite_subtypes).includes(imgTypes[0]) ? `elite-${U.lCase(imgTypes[0])}.svg` : `${U.lCase(imgTypes[0])}.svg`;
            } else if (U.unique(imgTypes).length > 1) {
              const [rightType, leftType] = imgTypes;
              item.system.imageLeft = Object.values(item.system.elite_subtypes).includes(leftType) ? `elite-${U.lCase(leftType)}.svg` : `${U.lCase(leftType)}.svg`;
              item.system.imageRight = Object.values(item.system.elite_subtypes).includes(rightType) ? `elite-${U.lCase(rightType)}.svg` : `${U.lCase(rightType)}.svg`;
            }
            Object.assign(
              item.system,
              {
                tierTotal: item.getFactorTotal(Factor.tier) > 0 ? U.romanizeNum(item.getFactorTotal(Factor.tier)) : "0",
                cohortRollData: [
                  { mode: "untrained", label: "Untrained", color: "transparent", tooltip: "<p>Roll Untrained</p>" }
                ],
                edgeData: Object.fromEntries(Object.values(item.system.edges ?? []).filter((edge) => /[A-Za-z]/.test(edge)).map((edge) => [edge.trim(), C.EdgeTooltips[edge]])),
                flawData: Object.fromEntries(Object.values(item.system.flaws ?? []).filter((flaw) => /[A-Za-z]/.test(flaw)).map((flaw) => [flaw.trim(), C.FlawTooltips[flaw]]))
              }
            );
            return item;
          }),
          expert: this.actor.activeSubItems.filter((item) => item.type === BladesItemType.cohort_expert).map((item) => {
            Object.assign(
              item.system,
              {
                tierTotal: item.getFactorTotal(Factor.tier) > 0 ? U.romanizeNum(item.getFactorTotal(Factor.tier)) : "0",
                cohortRollData: [
                  { mode: "untrained", label: "Untrained", tooltip: "<h2>Roll Untrained</h2>" }
                ],
                edgeData: Object.fromEntries(Object.values(item.system.edges ?? []).filter((edge) => /[A-Za-z]/.test(edge)).map((edge) => [edge.trim(), C.EdgeTooltips[edge]])),
                flawData: Object.fromEntries(Object.values(item.system.flaws ?? []).filter((flaw) => /[A-Za-z]/.test(flaw)).map((flaw) => [flaw.trim(), C.FlawTooltips[flaw]]))
              }
            );
            return item;
          })
        },
        projects: []
      };
    }
    if (BladesActor$1.IsType(this.actor, BladesActorType.pc) || BladesActor$1.IsType(this.actor, BladesActorType.crew)) {
      sheetData.playbookData = {
        dotline: {
          data: this.actor.system.experience.playbook,
          dotlineClass: "xp-playbook",
          target: "system.experience.playbook.value",
          svgKey: "teeth.tall",
          svgFull: "full|frame",
          svgEmpty: "full|half|frame",
          advanceButton: "advance-playbook"
        }
      };
      if (this.actor.system.experience.playbook.value !== this.actor.system.experience.playbook.max) {
        sheetData.playbookData.tooltip = new Handlebars.SafeString([
          "<h2>At the End of the Session, Gain XP If ...</h2>",
          "<ul>",
          ...Object.values(this.actor.system.experience.clues ?? []).map((line) => `<li>${line.replace(/^Y/, "... y")}</li>`) ?? [],
          "</ul>"
        ].join("")).toString();
      }
      sheetData.coinsData = {
        dotline: {
          data: this.actor.system.coins,
          target: "system.coins.value",
          iconEmpty: "coin-full.svg",
          iconFull: "coin-full.svg"
        }
      };
    }
    return {
      ...context,
      ...sheetData
    };
  }
  // #region LISTENERS & EVENT HANDLERS
  activateListeners(html) {
    super.activateListeners(html);
    if (game.user.isGM) {
      html.attr("style", "--secret-text-display: initial");
    } else {
      html.find('.editor:not(.tinymce) [data-is-secret="true"]').remove();
    }
    ApplyTooltipAnimations(html);
    Tags.InitListeners(html, this.actor);
    if (!this.options.editable) {
      return;
    }
    html.find(".dotline").each((__, elem) => {
      if ($(elem).hasClass("locked")) {
        return;
      }
      let targetDoc = this.actor;
      let targetField = $(elem).data("target");
      const comp$ = $(elem).closest("comp");
      if (targetField.startsWith("item")) {
        targetField = targetField.replace(/^item\./, "");
        const itemId = $(elem).closest("[data-comp-id]").data("compId");
        if (!itemId) {
          return;
        }
        const item = this.actor.items.get(itemId);
        if (!item) {
          return;
        }
        targetDoc = item;
      }
      const curValue = U.pInt($(elem).data("value"));
      $(elem).find(".dot").each((_, dot) => {
        $(dot).on("click", (event) => {
          event.preventDefault();
          const thisValue = U.pInt($(dot).data("value"));
          if (thisValue !== curValue) {
            if (comp$.hasClass("comp-coins") || comp$.hasClass("comp-stash")) {
              G.effects.fillCoins($(dot).prevAll(".dot")).then(() => targetDoc.update({ [targetField]: thisValue }));
            } else {
              targetDoc.update({ [targetField]: thisValue });
            }
          }
        });
        $(dot).on("contextmenu", (event) => {
          event.preventDefault();
          const thisValue = U.pInt($(dot).data("value")) - 1;
          if (thisValue !== curValue) {
            targetDoc.update({ [targetField]: thisValue });
          }
        });
      });
    });
    html.find("[data-comp-id]").find(".comp-title").on({ click: this._onItemOpenClick.bind(this) });
    html.find(".comp-control.comp-add").on({ click: this._onItemAddClick.bind(this) });
    html.find(".comp-control.comp-delete").on({ click: this._onItemRemoveClick.bind(this) });
    html.find(".comp-control.comp-delete-full").on({ click: this._onItemFullRemoveClick.bind(this) });
    html.find(".comp-control.comp-toggle").on({ click: this._onItemToggleClick.bind(this) });
    html.find(`
        select[data-action='player-select'],
        select[data-action='gm-select']
      `).on({ change: this._onSelectChange.bind(this) });
    html.find("[data-action='toggle-value'").on({ click: this._onToggleValueClick.bind(this) });
    html.find(".advance-button").on({ click: this._onAdvanceClick.bind(this) });
    html.find(".effect-control").on({ click: this._onActiveEffectControlClick.bind(this) });
    html.find("[data-roll-trait]").on({ click: this._onRollTraitClick.bind(this) });
    html.find("[data-action*='downtime-action-']").on({ click: this._onDowntimeActionClick.bind(this) });
    if (this.options.submitOnChange) {
      html.on("change", "textarea", this._onChangeInput.bind(this));
    }
  }
  async _onSubmit(event, params = {}) {
    if (!game.user.isGM && !this.actor.testUserPermission(game.user, CONST.DOCUMENT_PERMISSION_LEVELS.OWNER)) {
      eLog.checkLog("actorSheetTrigger", "User does not have permission to edit this actor", { user: game.user, actor: this.actor });
      return {};
    }
    return super._onSubmit(event, params);
  }
  async close(options) {
    if (this.actor.type === BladesActorType.pc) {
      return super.close(options).then(() => this.actor.clearSubActors());
    } else if (this.actor.type === BladesActorType.npc && this.actor.parentActor) {
      return super.close(options).then(() => this.actor.clearParentActor(false));
    }
    return super.close(options);
  }
  // #region Component Handlers
  _getCompData(event) {
    const elem$ = $(event.currentTarget).closest(".comp");
    const compData = {
      elem$,
      docID: elem$.data("compId"),
      docCat: elem$.data("compCat"),
      docType: elem$.data("compType"),
      docTags: (elem$.data("compTags") ?? "").split(/\s+/g)
    };
    eLog.checkLog2("dialog", "Component Data", { elem: elem$, ...compData });
    if (compData.docID && compData.docType) {
      compData.doc = {
        Actor: this.actor.getSubActor(compData.docID),
        Item: this.actor.getSubItem(compData.docID)
      }[compData.docType];
    }
    if (compData.docCat && compData.docType && (BladesPC$1.IsType(this.actor) || BladesCrew$1.IsType(this.actor))) {
      compData.dialogDocs = {
        Actor: this.actor.getDialogActors(compData.docCat),
        Item: this.actor.getDialogItems(compData.docCat)
      }[compData.docType];
    }
    return compData;
  }
  _onItemOpenClick(event) {
    var _a;
    event.preventDefault();
    const { doc } = this._getCompData(event);
    if (!doc) {
      return;
    }
    (_a = doc.sheet) == null ? void 0 : _a.render(true);
  }
  async _onItemAddClick(event) {
    event.preventDefault();
    const addType = $(event.currentTarget).closest(".comp").data("addType");
    if (addType && addType in BladesItemType) {
      await this.actor.createEmbeddedDocuments("Item", [
        {
          name: {
            [BladesItemType.cohort_gang]: "A Gang",
            [BladesItemType.cohort_expert]: "An Expert"
          }[addType] ?? randomID(),
          type: addType
        }
      ]);
      return;
    }
    const { docCat, docType, dialogDocs, docTags } = this._getCompData(event);
    if (!dialogDocs || !docCat || !docType) {
      return;
    }
    await BladesDialog.DisplaySelectionDialog(
      this.actor,
      U.tCase(`Add ${docCat.replace(/_/g, " ")}`),
      docType,
      dialogDocs,
      docTags
    );
  }
  async _onItemRemoveClick(event) {
    event.preventDefault();
    const { elem$, doc } = this._getCompData(event);
    if (!doc) {
      return;
    }
    await G.effects.blurRemove(elem$).then(async () => {
      if (doc instanceof BladesItem$1) {
        await this.actor.remSubItem(doc);
      } else {
        await this.actor.remSubActor(doc);
      }
    });
  }
  async _onItemFullRemoveClick(event) {
    event.preventDefault();
    const { elem$, doc } = this._getCompData(event);
    if (!doc) {
      return;
    }
    await G.effects.blurRemove(elem$).then(async () => await doc.delete());
  }
  async _onItemToggleClick(event) {
    event.preventDefault();
    const target = $(event.currentTarget).data("target");
    await this.actor.update({
      [target]: !getProperty(this.actor, target)
    });
  }
  async _onSelectChange(event) {
    event.preventDefault();
    await U.EventHandlers.onSelectChange(this, event);
  }
  async _onToggleValueClick(event) {
    event.preventDefault();
    const elem$ = $(event.currentTarget);
    const targetKey = elem$.data("target");
    const toggleOnVal = elem$.data("toggleOnVal") || "";
    const toggleOffVal = elem$.data("toggleOffVal") || "";
    if (getProperty(this.actor, targetKey) === toggleOnVal) {
      await this.actor.update({ [targetKey]: toggleOffVal });
    } else {
      await this.actor.update({ [targetKey]: toggleOnVal });
    }
  }
  async _onAdvanceClick(event) {
    event.preventDefault();
    if ($(event.currentTarget).data("action") === "advance-playbook") {
      await this.actor.advancePlaybook();
    }
  }
  // #endregion
  // #region Roll Handlers
  async _onRollTraitClick(event) {
    const traitName = $(event.currentTarget).data("rollTrait");
    const rollType = $(event.currentTarget).data("rollType");
    const rollData = {
      target: this.actor,
      targetFlagKey: "rollCollab"
    };
    if (U.lCase(traitName) in { ...ActionTrait, ...AttributeTrait, ...Factor }) {
      rollData.rollTrait = U.lCase(traitName);
    } else if (U.isInt(traitName)) {
      rollData.rollTrait = U.pInt(traitName);
    }
    if (U.tCase(rollType) in RollType) {
      rollData.rollType = U.tCase(rollType);
    } else if (typeof rollData.rollTrait === "string") {
      if (rollData.rollTrait in AttributeTrait) {
        rollData.rollType = RollType.Resistance;
      } else if (rollData.rollTrait in ActionTrait) {
        rollData.rollType = RollType.Action;
      }
    }
    if (game.user.isGM) {
      if (BladesRollPrimary.IsDoc(this.actor)) {
        rollData.rollPrimaryData = this.actor;
      } else if (BladesRollOpposition.IsDoc(this.actor)) {
        rollData.rollOppData = this.actor;
      }
    }
    await BladesActionRoll.New(rollData);
  }
  // Returns TRUE if can proceed, FALSE if action should stop (i.e. panel revealed for another user click)
  async _validateOrRevealSubData(downtimeAction, actionSubData) {
    switch (downtimeAction) {
      case DowntimeAction.LongTermProject: {
        if (actionSubData === "NewProject") {
          return false;
        }
        const projectItem = game.items.get(actionSubData ?? "");
        if (BladesProject$1.IsType(projectItem)) {
          return true;
        }
        return false;
      }
      case DowntimeAction.Recover: {
        const healerActor = game.actors.get(actionSubData ?? "");
        if (healerActor instanceof BladesActor$1 && healerActor.hasTag(Tag.NPC.CanHeal)) {
          return true;
        }
        return false;
      }
      case DowntimeAction.Train: {
        return Boolean(/^[a-z]+:\d$/.exec(actionSubData ?? ""));
      }
      default:
        return true;
    }
  }
  async _onDowntimeActionClick(event) {
    var _a, _b, _c;
    const elem$ = $(event.currentTarget);
    const downtimeAction = elem$.data("action").substring(elem$.data("action").lastIndexOf("-") + 1);
    const actionSubData = elem$.data("actionSubData");
    if (!await this._validateOrRevealSubData(downtimeAction, actionSubData)) {
      $("#eunos-blades-tooltips").children(".tooltip").remove();
      await this.actor.update({ "system.downtime_actions_open_submenu": downtimeAction });
      $("#eunos-blades-tooltips").children(".tooltip").remove();
      return;
    }
    const config = {
      target: this.actor,
      targetFlagKey: "rollCollab",
      rollDowntimeAction: downtimeAction
    };
    switch (downtimeAction) {
      case DowntimeAction.AcquireAsset:
      case DowntimeAction.LongTermProject:
      case DowntimeAction.ReduceHeat: {
        config.rollType = RollType.Action;
        break;
      }
      case DowntimeAction.Recover: {
        config.rollType = RollType.Action;
        if (BladesPC$1.IsType(this.actor) && this.actor.healingClock) {
          config.rollClockKey = this.actor.healingClock.id;
        }
        break;
      }
      case DowntimeAction.IndulgeVice: {
        config.rollType = RollType.IndulgeVice;
        break;
      }
      case DowntimeAction.Train: {
        const [attr, value] = actionSubData.split(/:/);
        if (attr === "playbook") {
          this.actor.update({ [`system.experience.${attr}.value`]: U.pInt(((_b = (_a = this.actor.system.experience) == null ? void 0 : _a.playbook) == null ? void 0 : _b.value) ?? 0) + U.pInt(value) });
        } else if (BladesPC$1.IsType(this.actor)) {
          this.actor.update({ [`system.experience.${attr}.value`]: U.pInt(this.actor.system.experience[attr].value) + U.pInt(value) });
        }
        break;
      }
    }
    await this.actor.update({
      "system.downtime_actions_open_submenu": "",
      "system.downtime_actions.value": (((_c = this.actor.system.downtime_actions) == null ? void 0 : _c.value) ?? 0) + 1
    });
    if ("rollType" in config) {
      if (downtimeAction === DowntimeAction.IndulgeVice) {
        BladesIndulgeViceRoll.New(config);
      } else {
        BladesActionRoll.New(config);
      }
    }
  }
  async _onGatherInfoClick(event) {
    const elem$ = $(event.currentTarget);
    if (elem$.data("isFortuneRoll")) {
      BladesFortuneRoll.New({
        target: this.actor,
        targetFlagKey: "rollCollab",
        rollType: RollType.Fortune
      });
    } else {
      BladesActionRoll.New({
        target: this.actor,
        targetFlagKey: "rollCollab",
        rollType: RollType.Action,
        rollTrait: ""
      });
    }
  }
  // #endregion
  // #region Active Effect Handlers
  _onActiveEffectControlClick(event) {
    BladesActiveEffect.onManageActiveEffect(event, this.actor);
  }
  // #endregion
  // #endregion
}
class BladesPCSheet extends BladesActorSheet {
  static get defaultOptions() {
    return foundry.utils.mergeObject(super.defaultOptions, {
      classes: ["eunos-blades", "sheet", "actor", "pc"],
      template: "systems/eunos-blades/templates/actor-sheet.hbs",
      width: 775,
      height: 775,
      tabs: [{ navSelector: ".nav-tabs", contentSelector: ".tab-content", initial: "abilities" }]
    });
  }
  getData() {
    var _a, _b, _c, _d;
    const context = super.getData();
    const { activeSubItems, activeSubActors } = this.actor;
    const sheetData = {};
    sheetData.preparedItems = Object.assign(
      context.preparedItems ?? {},
      {
        abilities: activeSubItems.filter((item) => item.type === BladesItemType.ability).map((item) => {
          if (item.system.uses_per_score.max) {
            Object.assign(item, {
              inRuleDotline: {
                data: item.system.uses_per_score,
                dotlineLabel: "Uses",
                target: "item.system.uses_per_score.value",
                iconEmpty: "dot-empty.svg",
                iconEmptyHover: "dot-empty-hover.svg",
                iconFull: "dot-full.svg",
                iconFullHover: "dot-full-hover.svg"
              }
            });
          }
          return item;
        }),
        background: activeSubItems.find((item) => item.type === BladesItemType.background),
        heritage: activeSubItems.find((item) => item.type === BladesItemType.heritage),
        vice: activeSubItems.find((item) => item.type === BladesItemType.vice),
        loadout: activeSubItems.filter((item) => item.type === BladesItemType.gear).map((item) => {
          if (item.system.load) {
            Object.assign(item, {
              numberCircle: item.system.load,
              numberCircleClass: "item-load"
            });
          }
          if (item.system.uses_per_score.max) {
            Object.assign(item, {
              inRuleDotline: {
                data: item.system.uses_per_score,
                dotlineLabel: "Uses",
                target: "item.system.uses_per_score.value",
                iconEmpty: "dot-empty.svg",
                iconEmptyHover: "dot-empty-hover.svg",
                iconFull: "dot-full.svg",
                iconFullHover: "dot-full-hover.svg"
              }
            });
          }
          return item;
        }),
        playbook: this.actor.playbook,
        projects: activeSubItems.filter((item) => item.type === BladesItemType.project),
        cohorts: (_a = context.preparedItems) == null ? void 0 : _a.cohorts
      }
    );
    sheetData.preparedActors = {
      crew: activeSubActors.find((actor) => actor.type === BladesActorType.crew),
      vice_purveyor: activeSubActors.find((actor) => actor.hasTag(Tag.NPC.VicePurveyor)),
      acquaintances: activeSubActors.filter((actor) => actor.hasTag(Tag.NPC.Acquaintance))
    };
    sheetData.hasVicePurveyor = Boolean(((_b = this.actor.playbook) == null ? void 0 : _b.hasTag(Tag.Gear.Advanced)) === false && activeSubItems.find((item) => item.type === BladesItemType.vice));
    sheetData.healing_clock = this.actor.healingClock;
    sheetData.stashData = {
      label: "Stash:",
      dotline: {
        data: this.actor.system.stash,
        target: "system.stash.value",
        iconEmpty: "coin-empty.svg",
        iconEmptyHover: "coin-empty-hover.svg",
        iconFull: "coin-full.svg",
        iconFullHover: "coin-full-hover.svg",
        altIconFull: "coin-ten.svg",
        altIconFullHover: "coin-ten-hover.svg",
        altIconStep: 10
      }
    };
    sheetData.stressData = {
      label: this.actor.system.stress.name,
      dotline: {
        data: this.actor.system.stress,
        dotlineClass: this.actor.system.stress.max >= 13 ? "narrow-stress" : "",
        target: "system.stress.value",
        svgKey: "teeth.tall",
        svgFull: "full|half|frame",
        svgEmpty: "full|half|frame"
      }
    };
    if (BladesActor$1.IsType(this.actor, BladesActorType.pc)) {
      sheetData.traumaData = {
        label: this.actor.system.trauma.name,
        dotline: {
          data: { value: this.actor.trauma, max: this.actor.system.trauma.max },
          svgKey: "teeth.short",
          svgFull: "full|frame",
          svgEmpty: "frame",
          isLocked: true
        },
        compContainer: {
          class: "comp-trauma-conditions comp-vertical full-width",
          blocks: [
            this.actor.traumaList.slice(0, Math.ceil(this.actor.traumaList.length / 2)).map((tName) => ({
              checkLabel: tName,
              checkClasses: {
                active: "comp-toggle-red",
                inactive: "comp-toggle-grey"
              },
              checkTarget: `system.trauma.checked.${tName}`,
              checkValue: this.actor.system.trauma.checked[tName] ?? false,
              tooltip: C.TraumaTooltips[tName],
              tooltipClass: "tooltip-trauma"
            })),
            this.actor.traumaList.slice(Math.ceil(this.actor.traumaList.length / 2)).map((tName) => ({
              checkLabel: tName,
              checkClasses: {
                active: "comp-toggle-red",
                inactive: "comp-toggle-grey"
              },
              checkTarget: `system.trauma.checked.${tName}`,
              checkValue: this.actor.system.trauma.checked[tName] ?? false,
              tooltip: C.TraumaTooltips[tName],
              tooltipClass: "tooltip-trauma"
            }))
          ]
        }
      };
    }
    sheetData.abilityData = {
      dotline: {
        dotlineClass: "dotline-right dotline-glow",
        data: {
          value: this.actor.getAvailableAdvancements("Ability"),
          max: this.actor.getAvailableAdvancements("Ability")
        },
        dotlineLabel: "Available Abilities",
        isLocked: true,
        iconFull: "dot-full.svg"
      }
    };
    sheetData.loadData = {
      curLoad: this.actor.currentLoad,
      selLoadCount: this.actor.system.loadout.levels[U.lCase(this.actor.system.loadout.selected)],
      options: C.Loadout.selections,
      selected: this.actor.system.loadout.selected ?? ""
    };
    sheetData.armor = Object.fromEntries(Object.entries(this.actor.system.armor.active).filter(([, isActive]) => isActive).map(([armor]) => [
      armor,
      this.actor.system.armor.checked[armor]
    ]));
    sheetData.attributeData = {};
    const attrEntries = Object.entries(this.actor.system.attributes);
    for (const [attribute, attrData] of attrEntries) {
      sheetData.attributeData[attribute] = {
        tooltip: C.AttributeTooltips[attribute],
        actions: {}
      };
      const actionEntries = Object.entries(attrData);
      for (const [action, actionData] of actionEntries) {
        sheetData.attributeData[attribute].actions[action] = {
          tooltip: C.ActionTooltips[action],
          value: actionData.value,
          max: game.eunoblades.Tracker.phase === BladesPhase.CharGen ? 2 : this.actor.system.attributes[attribute][action].max
        };
      }
    }
    if (((_c = game.eunoblades.Tracker) == null ? void 0 : _c.phase) === BladesPhase.Downtime) {
      const actionsList = {
        [DowntimeAction.AcquireAsset]: "Acquire Asset",
        [DowntimeAction.IndulgeVice]: "Indulge Vice",
        [DowntimeAction.LongTermProject]: "Project",
        [DowntimeAction.Recover]: "Recover",
        [DowntimeAction.ReduceHeat]: "Reduce Heat",
        [DowntimeAction.Train]: "Train"
      };
      const healCapableDocs = [
        ...BladesActor$1.GetTypeWithTags(BladesActorType.pc, Tag.PC.CanHeal),
        ...BladesActor$1.GetTypeWithTags(BladesActorType.npc, Tag.NPC.CanHeal)
        /* ALSO NEED TO INCLUDE EXPERT COHORTS WITH CANHEAL TAG */
      ];
      if (this.actor.stress === 0) {
        delete actionsList[DowntimeAction.IndulgeVice];
      }
      if (this.actor.harmLevel === 0 || healCapableDocs.length === 0) {
        delete actionsList[DowntimeAction.Recover];
      }
      if (!this.actor.crew || this.actor.crew.system.heat.value === 0) {
        delete actionsList[DowntimeAction.ReduceHeat];
      }
      let actionsSubmenuData = void 0;
      switch (this.actor.system.downtime_actions_open_submenu) {
        case DowntimeAction.LongTermProject: {
          actionsSubmenuData = [
            {
              actionSubData: "NewProject",
              display: "New Project"
            }
          ];
          break;
        }
        case DowntimeAction.Recover: {
          actionsSubmenuData = [];
          healCapableDocs.forEach((hDoc) => {
            if (hDoc.id === this.actor.id) {
              actionsSubmenuData == null ? void 0 : actionsSubmenuData.unshift({
                actionSubData: this.actor.id,
                display: "Heal Self"
              });
            } else if (BladesPC$1.IsType(hDoc)) {
              actionsSubmenuData == null ? void 0 : actionsSubmenuData.push({
                actionSubData: hDoc.id,
                display: U.uCase(hDoc.name)
              });
            } else if (BladesNPC$1.IsType(hDoc)) {
              actionsSubmenuData == null ? void 0 : actionsSubmenuData.push({
                actionSubData: hDoc.id,
                display: hDoc.name
              });
            }
          });
          break;
        }
        case DowntimeAction.Train: {
          const crewTrainingUpgrades = ((_d = this.actor.crew) == null ? void 0 : _d.upgrades.filter((upgrade) => /^Training_/.exec(upgrade.system.world_name)).map((upgrade) => U.lCase(upgrade.system.world_name.split(/_/)[1]))) ?? [];
          actionsSubmenuData = [
            {
              actionSubData: `playbook:${crewTrainingUpgrades.includes("playbook") ? 2 : 1}`,
              display: `${crewTrainingUpgrades.includes("playbook") ? 2 : 1} Playbook XP`
            },
            {
              actionSubData: `insight:${crewTrainingUpgrades.includes(AttributeTrait.insight) ? 2 : 1}`,
              display: `${crewTrainingUpgrades.includes(AttributeTrait.insight) ? 2 : 1} Insight XP`
            },
            {
              actionSubData: `prowess:${crewTrainingUpgrades.includes(AttributeTrait.prowess) ? 2 : 1}`,
              display: `${crewTrainingUpgrades.includes(AttributeTrait.prowess) ? 2 : 1} Prowess XP`
            },
            {
              actionSubData: `resolve:${crewTrainingUpgrades.includes(AttributeTrait.resolve) ? 2 : 1}`,
              display: `${crewTrainingUpgrades.includes(AttributeTrait.resolve) ? 2 : 1} Resolve XP`
            }
          ];
          break;
        }
      }
      const actionsTooltips = {
        [DowntimeAction.AcquireAsset]: `<h1>Acquire an Asset</h1>
        <p>Roll your <strong class='gold-bright'>Tier</strong> to acquire temporary use of an asset or service.</p>
        <p>The <strong>Quality</strong> of the acquired asset depends on the result of your roll:</p>
        <ul>
        <li><strong class='gold-bright'>Critical Success</strong> &mdash; <strong class='gold-bright'>Tier</strong> <strong>+ 2</strong></li>
        <li><strong>Success</strong> &mdash; <strong class='gold-bright'>Tier</strong> <strong>+ 2</strong></li>
        <li><b>Partial Success</b> &mdash; <strong class='gold-bright'>Tier</strong></li>
        <li><strong class='red-bright'>Fail</strong> &mdash; <strong class='gold-bright'>Tier</strong> <strong>− 1</strong></li>
        </ul>`,
        [DowntimeAction.IndulgeVice]: `<h1>Indulge Your Vice</h1>
        <p>Roll your <strong class='red-bright'>lowest</strong> <strong>Attribute</strong>. Clear <strong>Stress</strong> equal to the <strong>highest</strong> die result.</p>
        <p><strong class="red-bright">Warning:</strong> If you clear more <strong>Stress</strong> than you have, you will <strong class="red-bright">overindulge</strong>.</p>`,
        [DowntimeAction.LongTermProject]: `<h1>Work on a Long-Term Project</h1>
        <p>Work to <strong>advance the clock</strong> of one of your existing <strong>Long-Term Projects</strong>, or begin a new one.</p>
        <p>Roll the <strong>Action</strong> most appropriate to the work you are doing. The results of your roll determine how far you will <strong>advance the clock</strong>:</p>
        <ul>
        <li><strong class='gold-bright'>Critical Success</strong> &mdash; <strong class='gold-bright'>Five</strong> Segments</li>
        <li><strong>Success</strong> &mdash;  <strong>Three</strong> Segments</li>
        <li><b>Partial Success</b> &mdash; <b>Two</b> Segments</li>
        <li><strong class='red-bright'>Fail</strong> &mdash; <strong class='red-bright'>One</strong> Segment</li>
        </ul>`,
        [DowntimeAction.Recover]: `<h1>Recover from Harm</h1>
        <p>Make a <strong>healing treatment roll</strong> using the appropriate trait of the character healing you:</p>
        <ul>
        <li><strong>A PC with 'Physicker'</strong> &mdash; <strong>Tinker</strong>. <em>(You can heal yourself this way, but suffer <strong class="red-bright">2 Stress</strong> for doing so.)</em></li>
        <li><strong>An NPC</strong> &mdash; <strong>Quality</strong></li>
        </ul>
        <p>The results of your roll determine how far you will <strong>Advance your healing clock</strong>:</p>
        <ul>
        <li><strong class='gold-bright'>Critical Success</strong> &mdash; <strong class='gold-bright'>Five</strong> Segments</li>
        <li><strong>Success</strong> &mdash;  <strong>Three</strong> Segments</li>
        <li><b>Partial Success</b> &mdash; <b>Two</b> Segments</li>
        <li><strong class='red-bright'>Fail</strong> &mdash; <strong class='red-bright'>One</strong> Segment</li>
        </ul>
        <p>When your <strong>healing clock</strong> is filled, reduce each Harm by one level of severity.</p>`,
        [DowntimeAction.ReduceHeat]: `<h1>Reduce Heat</h1>
        <p>Work to <strong>reduce the Heat</strong> on your Crew.</p>
        <p>Roll the <strong>Action</strong> most appropriate to the measures you are taking. The results of your roll determine how much <strong class="red-bright">Heat</strong> you clear:</p>
        <ul>
        <li><strong class='gold-bright'>Critical Success</strong> &mdash; <strong class='gold-bright'>Five</strong> Heat</li>
        <li><strong>Success</strong> &mdash;  <strong>Three</strong> Heat</li>
        <li><b>Partial Success</b> &mdash; <b>Two</b> Heat</li>
        <li><strong class='red-bright'>Fail</strong> &mdash; <strong class='red-bright'>One</strong> Heat</li>
        </ul>`,
        [DowntimeAction.Train]: `<h1>Train</h1>
        <p>Select an <strong>Experience Track</strong> <em>(i.e. Insight, Prowess, Resolve, or your Playbook)</em>. Gain <strong>1 XP</strong> in that track, or <strong>2 XP</strong> if your Crew has the corresponding <strong>Training Upgrade</strong>.</p>`
      };
      const actionsRemaining = this.actor.system.downtime_actions.max + this.actor.system.downtime_action_bonus - this.actor.system.downtime_actions.value - (this.actor.isAtWar ? 1 : 0);
      const canPayCoin = Boolean(
        this.actor.system.coins.value >= 1 || this.actor.system.stash.value >= 2
      );
      const canPayRep = Boolean(
        this.actor.crew && this.actor.crew.system.rep.value >= 1
      );
      const isDisplayingCosts = actionsRemaining <= 0;
      const isDisplayingActions = actionsRemaining > 0 || canPayCoin && this.actor.system.downtime_action_selected_cost === "Coin" || canPayRep && this.actor.system.downtime_action_selected_cost === "Rep";
      sheetData.downtimeData = {
        actionsList,
        actionsTooltips,
        actionsRemaining,
        actionsSubmenuData,
        canPayCoin,
        canPayRep,
        isDisplayingCosts,
        isDisplayingActions,
        dotline: {
          dotlineClass: "dotline-right dotline-glow",
          data: {
            value: actionsRemaining,
            max: actionsRemaining
          },
          dotlineLabel: "Actions Remaining",
          isLocked: true,
          iconFull: "dot-full.svg"
        }
      };
    }
    sheetData.gatherInfoTooltip = new Handlebars.SafeString([
      "<h1>Gathering Information</h1>",
      "<h2>Questions to Consider</h2>",
      "<ul>",
      ...Object.values(this.actor.system.gather_info ?? []).map((line) => `<li>${line}</li>`) ?? [],
      "</ul>"
    ].join("")).toString();
    eLog.checkLog("Attribute", "[BladesPCSheet] attributeData", { attributeData: sheetData.attributeData });
    eLog.checkLog("actor", "[BladesPCSheet] getData()", { ...context, ...sheetData });
    return { ...context, ...sheetData };
  }
  get activeArmor() {
    return Object.keys(U.objFilter(this.actor.system.armor.active, (val) => val === true));
  }
  get checkedArmor() {
    return Object.keys(U.objFilter(
      this.actor.system.armor.checked,
      (val, key) => val === true && this.actor.system.armor.active[key] === true
    ));
  }
  get uncheckedArmor() {
    return Object.keys(U.objFilter(
      this.actor.system.armor.active,
      (val, key) => val === true && this.actor.system.armor.checked[key] === false
    ));
  }
  _getHoverArmor() {
    if (!this.activeArmor.length) {
      return false;
    }
    if (this.activeArmor.includes("heavy")) {
      return this.checkedArmor.includes("heavy") ? "light" : "heavy";
    } else if (this.activeArmor.includes("light")) {
      return "light";
    }
    return "special";
  }
  _getClickArmor() {
    if (!this.uncheckedArmor.length) {
      return false;
    }
    if (this.uncheckedArmor.includes("heavy")) {
      return "heavy";
    }
    if (this.uncheckedArmor.includes("light")) {
      return "light";
    }
    return "special";
  }
  _getContextMenuArmor() {
    if (!this.checkedArmor.length) {
      return false;
    }
    if (this.checkedArmor.includes("light")) {
      return "light";
    }
    if (this.checkedArmor.includes("heavy")) {
      return "heavy";
    }
    return "special";
  }
  async _onAdvanceClick(event) {
    event.preventDefault();
    super._onAdvanceClick(event);
    const action = $(event.currentTarget).data("action").replace(/^advance-/, "");
    if (action in AttributeTrait) {
      await this.actor.advanceAttribute(action);
    }
  }
  activateListeners(html) {
    super.activateListeners(html);
    if (!this.options.editable) {
      return;
    }
    const self = this;
    html.find(".main-armor-control").on({
      click() {
        const targetArmor = self._getClickArmor();
        if (!targetArmor) {
          return;
        }
        self.actor.update({ [`system.armor.checked.${targetArmor}`]: true });
      },
      contextmenu() {
        const targetArmor = self._getContextMenuArmor();
        if (!targetArmor) {
          return;
        }
        self.actor.update({ [`system.armor.checked.${targetArmor}`]: false });
      },
      mouseenter() {
        const targetArmor = self._getHoverArmor();
        eLog.log4("Mouse Enter", targetArmor, this, $(this), $(this).next());
        if (!targetArmor) {
          return;
        }
        $(this).siblings(`.svg-armor.armor-${targetArmor}`).addClass("hover-over");
      },
      mouseleave() {
        const targetArmor = self._getHoverArmor();
        if (!targetArmor) {
          return;
        }
        $(this).siblings(`.svg-armor.armor-${targetArmor}`).removeClass("hover-over");
      }
    });
    html.find(".special-control").on({
      click() {
        if (!self.activeArmor.includes("special")) {
          return;
        }
        self.actor.update({ "system.armor.checked.special": self.uncheckedArmor.includes("special") });
      },
      contextmenu() {
        if (!self.activeArmor.includes("special")) {
          return;
        }
        self.actor.update({ "system.armor.checked.special": self.uncheckedArmor.includes("special") });
      },
      mouseenter() {
        if (!self.activeArmor.includes("special") || self.activeArmor.length === 1) {
          return;
        }
        $(this).siblings(".svg-armor.armor-special").addClass("hover-over");
      },
      mouseleave() {
        if (!self.activeArmor.includes("special") || self.activeArmor.length === 1) {
          return;
        }
        $(this).siblings(".svg-armor.armor-special").removeClass("hover-over");
      }
    });
  }
}
class BladesPC extends BladesActor$1 {
  // #region INITIALIZATION ~
  static async Initialize() {
    Object.assign(globalThis, { BladesPC, BladesPCSheet });
    Actors.registerSheet("blades", BladesPCSheet, { types: ["pc"], makeDefault: true });
    Hooks.on("dropActorSheetData", async (parentActor, _, { uuid }) => {
      const doc = fromUuidSync(uuid);
      if (doc instanceof BladesActor$1) {
        if (parentActor.type === BladesActorType.crew && doc.type === BladesActorType.pc) {
          doc.addSubActor(parentActor);
        } else if (parentActor.type === BladesActorType.pc && doc.type === BladesActorType.crew) {
          parentActor.addSubActor(doc);
        }
      }
    });
    return loadTemplates(["systems/eunos-blades/templates/actor-sheet.hbs"]);
  }
  // #endregion
  // #region Static Overrides: Create, get All ~
  // static override IsType<T extends BladesActorType = BladesActorType.pc>(doc: unknown): doc is BladesActorOfType<T> {
  //   return super.IsType(doc, BladesActorType.pc);
  // }
  static IsType(doc) {
    return super.IsType(doc, BladesActorType.pc);
  }
  static GetUser(userRef) {
    let user;
    if (typeof userRef === "string") {
      user = game.users.get(userRef) ?? game.users.getName(userRef);
    } else if (userRef instanceof User) {
      user = userRef;
    }
    return user;
  }
  static GetFromUser(userRef) {
    var _a;
    const user = BladesPC.GetUser(userRef);
    if (!user) {
      throw new Error(`Unable to find user '${userRef}'`);
    }
    const actor = game.actors.get(((_a = user.character) == null ? void 0 : _a.id) ?? "");
    if (BladesPC.IsType(actor)) {
      return actor;
    }
    return void 0;
  }
  static async create(data, options = {}) {
    data.token = data.token || {};
    data.system = data.system ?? {};
    eLog.checkLog2("actor", "BladesPC.create(data,options)", { data, options });
    data.token.actorLink = true;
    data.system.experience = {
      playbook: { value: 0, max: 8 },
      insight: { value: 0, max: 6 },
      prowess: { value: 0, max: 6 },
      resolve: { value: 0, max: 6 },
      clues: [],
      ...data.system.experience ?? {}
    };
    const pc = await super.create(data, options);
    await BladesClockKey.Create({
      name: "",
      target: pc,
      targetKey: "system.clocksData",
      isVisible: true,
      isNameVisible: false,
      isSpotlit: false
    }, void 0, [
      {
        color: ClockColor.white,
        value: 0,
        max: 4,
        index: 0,
        isVisible: true,
        isActive: true,
        isNameVisible: false,
        isHighlighted: false
      }
    ]);
    return pc;
  }
  static get All() {
    return new Collection(
      super.GetTypeWithTags(BladesActorType.pc).map((pc) => [pc.id, pc])
    );
  }
  // #endregion
  constructor(data) {
    super(data);
    eLog.checkLog3("pcConstructor", "new BladesPC()", { data });
  }
  // #region BladesPrimaryActor Implementation ~
  get primaryUser() {
    var _a;
    return ((_a = game.users) == null ? void 0 : _a.find((user) => {
      var _a2;
      return ((_a2 = user.character) == null ? void 0 : _a2.id) === (this == null ? void 0 : this.id);
    })) || null;
  }
  async clearLoadout() {
    await this.update({ "system.loadout.selected": "" });
    this.updateEmbeddedDocuments(
      "Item",
      [
        ...this.activeSubItems.filter((item) => BladesItem$1.IsType(item, BladesItemType.gear) && !item.hasTag(Tag.System.Archived)).map((item) => ({
          _id: item.id,
          "system.tags": [...item.tags, Tag.System.Archived],
          "system.uses_per_score.value": 0
        })),
        ...this.activeSubItems.filter((item) => BladesItem$1.IsType(item, BladesItemType.ability) && item.system.uses_per_score.max).map((item) => ({
          _id: item.id,
          "system.uses_per_score.value": 0
        }))
      ]
    );
  }
  // #endregion
  getSubActor(actorRef) {
    var _a;
    const actor = super.getSubActor(actorRef);
    if (!actor) {
      return void 0;
    }
    if ((_a = this.primaryUser) == null ? void 0 : _a.id) {
      actor.ownership[this.primaryUser.id] = CONST.DOCUMENT_PERMISSION_LEVELS.OWNER;
    }
    return actor;
  }
  get isLightArmorEquipped() {
    return this.system.armor.active.light;
  }
  get isLightArmorEquippable() {
    return !this.isLightArmorEquipped && this.remainingLoad >= 2;
  }
  get isLightArmorUsed() {
    return this.system.armor.checked.light;
  }
  get isLightArmorAvailable() {
    return (this.isLightArmorEquipped || this.isLightArmorEquippable) && !this.isLightArmorUsed;
  }
  get isHeavyArmorEquipped() {
    return this.system.armor.active.heavy;
  }
  get isHeavyArmorEquippable() {
    if (this.isHeavyArmorEquipped) {
      return false;
    }
    if (this.isLightArmorEquipped) {
      return this.remainingLoad >= 3;
    }
    return this.remainingLoad >= 5;
  }
  get isHeavyArmorUsed() {
    return this.system.armor.checked.heavy;
  }
  get isHeavyArmorAvailable() {
    return (this.isHeavyArmorEquipped || this.isHeavyArmorEquippable) && !this.isHeavyArmorUsed;
  }
  get availableArmor() {
    const armor = [];
    if (this.isLightArmorAvailable) {
      armor.push("Light Armor");
    }
    if (this.isHeavyArmorAvailable) {
      armor.push("Heavy Armor");
    }
    return armor;
  }
  get isSpecialArmorAvailable() {
    return this.system.armor.active.special && !this.system.armor.checked.special;
  }
  // #region BladesScoundrel Implementation ~
  isMember(crew) {
    var _a;
    return ((_a = this.crew) == null ? void 0 : _a.id) === crew.id;
  }
  get vice() {
    if (this.type !== BladesActorType.pc) {
      return void 0;
    }
    return this.activeSubItems.find((item) => item.type === BladesItemType.vice);
  }
  get crew() {
    return this.activeSubActors.find((subActor) => BladesActor$1.IsType(subActor, BladesActorType.crew));
  }
  get abilities() {
    if (!this.playbook) {
      return [];
    }
    return this.activeSubItems.filter((item) => [BladesItemType.ability, BladesItemType.crew_ability].includes(item.type));
  }
  get cohorts() {
    return this.activeSubItems.filter(
      (item) => BladesItem$1.IsType(item, BladesItemType.cohort_gang, BladesItemType.cohort_expert)
    );
  }
  get playbookName() {
    var _a;
    return (_a = this.playbook) == null ? void 0 : _a.name;
  }
  get playbook() {
    return this.activeSubItems.find((item) => item.type === BladesItemType.playbook);
  }
  get attributes() {
    if (!BladesActor$1.IsType(this, BladesActorType.pc)) {
      return void 0;
    }
    return {
      insight: Object.values(this.system.attributes.insight).filter(({ value }) => value > 0).length + this.system.resistance_bonus.insight,
      prowess: Object.values(this.system.attributes.prowess).filter(({ value }) => value > 0).length + this.system.resistance_bonus.prowess,
      resolve: Object.values(this.system.attributes.resolve).filter(({ value }) => value > 0).length + this.system.resistance_bonus.resolve
    };
  }
  get actions() {
    if (!BladesActor$1.IsType(this, BladesActorType.pc)) {
      return void 0;
    }
    return U.objMap({
      ...this.system.attributes.insight,
      ...this.system.attributes.prowess,
      ...this.system.attributes.resolve
    }, ({ value, max }) => U.gsap.utils.clamp(0, max, value));
  }
  get rollable() {
    if (!BladesActor$1.IsType(this, BladesActorType.pc)) {
      return void 0;
    }
    return {
      ...this.attributes,
      ...this.actions
    };
  }
  get stress() {
    return this.system.stress.value;
  }
  get stressMax() {
    return this.system.stress.max;
  }
  get isHealingClockReady() {
    const [clockKeyID] = Object.keys(this.system.clocksData);
    return game.eunoblades.ClockKeys.has(clockKeyID ?? "");
  }
  get healingClock() {
    if (!this.isHealingClockReady) {
      return void 0;
    }
    const [clockKeyID] = Object.keys(this.system.clocksData);
    const clockKey = game.eunoblades.ClockKeys.get(clockKeyID ?? "");
    return clockKey;
  }
  get harmLevel() {
    if (this.system.harm.severe.one.length > 1) {
      return 3;
    }
    if (this.system.harm.moderate.one.length + this.system.harm.moderate.two.length > 0) {
      return 2;
    }
    if (this.system.harm.lesser.one.length + this.system.harm.lesser.two.length > 0) {
      return 1;
    }
    return 0;
  }
  get trauma() {
    if (!BladesActor$1.IsType(this, BladesActorType.pc)) {
      return 0;
    }
    return Object.keys(this.system.trauma.checked).filter((traumaName) => (
      // @ts-ignore Compiler linter mismatch.
      this.system.trauma.active[traumaName] && this.system.trauma.checked[traumaName]
    )).length;
  }
  get traumaList() {
    return BladesActor$1.IsType(this, BladesActorType.pc) ? Object.keys(this.system.trauma.active).filter((key) => this.system.trauma.active[key]) : [];
  }
  get activeTraumaConditions() {
    if (!BladesActor$1.IsType(this, BladesActorType.pc)) {
      return {};
    }
    return U.objFilter(
      this.system.trauma.checked,
      // @ts-ignore Compiler linter mismatch.
      (_v, traumaName) => Boolean(
        traumaName in this.system.trauma.active && this.system.trauma.active[traumaName]
      )
    );
  }
  get currentLoad() {
    if (!BladesActor$1.IsType(this, BladesActorType.pc)) {
      return 0;
    }
    const activeLoadItems = this.activeSubItems.filter((item) => item.type === BladesItemType.gear);
    return U.gsap.utils.clamp(0, 10, activeLoadItems.reduce((tot, i) => tot + U.pInt(i.system.load), 0));
  }
  get remainingLoad() {
    if (!BladesActor$1.IsType(this, BladesActorType.pc)) {
      return 0;
    }
    if (!this.system.loadout.selected) {
      return 0;
    }
    const maxLoad = this.system.loadout.levels[game.i18n.localize(this.system.loadout.selected.toString()).toLowerCase()];
    return Math.max(0, maxLoad - this.currentLoad);
  }
  async addStash(amount) {
    if (!BladesActor$1.IsType(this, BladesActorType.pc)) {
      return;
    }
    await this.update({ "system.stash.value": Math.min(this.system.stash.value + amount, this.system.stash.max) });
  }
  get projects() {
    return this.getSubItemsOfType(BladesItemType.project);
  }
  get remainingDowntimeActions() {
    if (!BladesActor$1.IsType(this, BladesActorType.pc)) {
      return 0;
    }
    return this.system.downtime_actions.max + this.system.downtime_action_bonus - this.system.downtime_actions.value;
  }
  _processAbilityDialogItems(dialogData) {
    if (!this.playbookName) {
      return;
    }
    dialogData[this.playbookName] = this._processEmbeddedItemMatches(
      BladesItem$1.GetTypeWithTags(BladesItemType.ability, this.playbookName)
    );
    dialogData.Veteran = this._processEmbeddedItemMatches(BladesItem$1.GetTypeWithTags(BladesItemType.ability)).filter((item) => !item.hasTag(this.playbookName)).map((item) => {
      if (item.dialogCSSClasses) {
        item.dialogCSSClasses = item.dialogCSSClasses.replace(/featured-item\s?/g, "");
      }
      return item;
    }).sort((a, b) => {
      if (a.system.world_name > b.system.world_name) {
        return 1;
      }
      if (a.system.world_name < b.system.world_name) {
        return -1;
      }
      return 0;
    });
  }
  processGearDialogItems(dialogData) {
    if (this.playbookName === null) {
      return;
    }
    const gearItems = this._processEmbeddedItemMatches([
      ...BladesItem$1.GetTypeWithTags(BladesItemType.gear, this.playbookName),
      ...BladesItem$1.GetTypeWithTags(BladesItemType.gear, Tag.Gear.General)
    ]).filter((item) => this.remainingLoad >= item.system.load);
    dialogData[this.playbookName] = gearItems.filter((item) => item.hasTag(this.playbookName));
    dialogData.General = gearItems.filter((item) => item.hasTag(Tag.Gear.General)).map((item) => {
      if (item.dialogCSSClasses) {
        item.dialogCSSClasses = item.dialogCSSClasses.replace(/featured-item\s?/g, "");
      }
      return item;
    }).sort((a, b) => {
      if (a.system.world_name > b.system.world_name) {
        return 1;
      }
      if (a.system.world_name < b.system.world_name) {
        return -1;
      }
      return 0;
    });
  }
  getDialogItems(category) {
    const dialogData = {};
    const { playbookName } = this;
    if (category === SelectionCategory.Heritage) {
      dialogData.Main = this._processEmbeddedItemMatches(BladesItem$1.GetTypeWithTags(BladesItemType.heritage));
    } else if (category === SelectionCategory.Background) {
      dialogData.Main = this._processEmbeddedItemMatches(BladesItem$1.GetTypeWithTags(BladesItemType.background));
    } else if (category === SelectionCategory.Vice && playbookName !== null) {
      dialogData.Main = this._processEmbeddedItemMatches(BladesItem$1.GetTypeWithTags(BladesItemType.vice, playbookName));
    } else if (category === SelectionCategory.Playbook) {
      dialogData.Basic = this._processEmbeddedItemMatches(
        BladesItem$1.GetTypeWithTags(BladesItemType.playbook).filter((item) => !item.hasTag(Tag.Gear.Advanced))
      );
      dialogData.Advanced = this._processEmbeddedItemMatches(
        BladesItem$1.GetTypeWithTags(BladesItemType.playbook, Tag.Gear.Advanced)
      );
    } else if (category === SelectionCategory.Gear) {
      this.processGearDialogItems(dialogData);
    } else if (category === SelectionCategory.Ability) {
      this._processAbilityDialogItems(dialogData);
    }
    return dialogData;
  }
  getTaggedItemBonuses(tags) {
    return tags.length;
  }
  // #endregion
  // #region BladesRoll.PrimaryDoc Implementation
  get rollPrimaryModsSchemaSet() {
    const rollModsSchemaSet = super.rollPrimaryModsSchemaSet;
    [
      [/1d/, RollModSection.roll],
      [/Less Effect/, RollModSection.effect]
    ].forEach(([effectPat, effectCat]) => {
      const { one: harmConditionOne, two: harmConditionTwo } = Object.values(this.system.harm).find((harmData) => effectPat.test(harmData.effect)) ?? {};
      const harmString = U.objCompact([harmConditionOne, harmConditionTwo === "" ? null : harmConditionTwo]).join(" & ");
      if (harmString.length > 0) {
        rollModsSchemaSet.push({
          key: `Harm-negative-${effectCat}`,
          name: harmString,
          section: effectCat,
          posNeg: "negative",
          base_status: RollModStatus.ToggledOn,
          modType: RollModType.harm,
          value: 1,
          tooltip: [
            `<h1 class='sur-title'>${effectCat === RollModSection.roll ? Harm.Impaired : Harm.Weakened} (Harm)</h1>`,
            `<h1 class='red-bright'>${harmString}</h1>`,
            effectCat === RollModSection.roll ? "<p>If your injuries apply to the situation at hand, you suffer <strong class='red-bright'>−1d</strong> to your roll.</p>" : "<p>If your injuries apply to the situation at hand, you suffer <strong class='red-bright'>−1 effect</strong>."
          ].join("")
        });
      }
    });
    const { one: harmCondition } = Object.values(this.system.harm).find((harmData) => /Need Help/.test(harmData.effect)) ?? {};
    if (harmCondition && harmCondition.trim() !== "") {
      rollModsSchemaSet.push({
        key: "Push-negative-roll",
        name: "PUSH",
        sideString: harmCondition.trim(),
        section: RollModSection.roll,
        posNeg: "negative",
        base_status: RollModStatus.ToggledOn,
        modType: RollModType.harm,
        value: 0,
        effectKeys: ["Cost-Stress2"],
        tooltip: [
          "<h1 class='sur-title'>Broken (Harm)</h1>",
          `<h1 class='red-bright'>${harmCondition.trim()}</h1>`,
          "<p>If your injuries apply to the situation at hand, you must <strong>Push</strong> to act.</p>"
        ].join("")
      });
    }
    return rollModsSchemaSet;
  }
  async applyHarm(num, name) {
    if (num === 4) {
      BladesDirector.getInstance().pushNotice_SocketCall(
        "ALL",
        {
          title: `${this.name} Suffers <u><strong>FATAL</strong></u> Harm: ${name}`,
          body: `${this.name}, will you continue as a Ghost, or create a new character?`,
          type: BladesNoticeType.push,
          cssClasses: "harm-alert fatal-harm-alert"
        }
      );
      return;
    }
    const harmSequence = [
      [["lesser", "one"], ["lesser", "two"]],
      [["moderate", "one"], ["moderate", "two"]],
      [["severe", "one"]]
    ].slice(num - 1).flat(1);
    while (harmSequence.length) {
      const theseHarmKeys = harmSequence.shift();
      if (!theseHarmKeys) {
        break;
      }
      const [thisHarmLevel, thisHarmKey] = theseHarmKeys;
      const thisHarmVal = this.system.harm[thisHarmLevel][thisHarmKey];
      if (!thisHarmVal) {
        BladesDirector.getInstance().pushNotice_SocketCall(
          "ALL",
          {
            title: `${this.name} Suffers ${U.tCase(thisHarmLevel)} Harm: ${name}`,
            type: BladesNoticeType.push,
            cssClasses: "harm-alert"
          }
        );
        await this.update({ [`system.harm.${thisHarmLevel}.${thisHarmKey}`]: name });
        return;
      }
    }
    BladesDirector.getInstance().pushNotice_SocketCall(
      "ALL",
      {
        title: `${this.name} Suffers a Catastrophic, Permanent Injury!`,
        body: `${this.name}, you're out of the action - either left for dead, or otherwise dropped from the action. You can choose to return at the beginning of the next Phase with a permanent injury, or die.`,
        type: BladesNoticeType.push,
        cssClasses: "harm-alert fatal-harm-alert"
      }
    );
  }
  async applyWorsePosition() {
    this.setFlag("eunos-blades", "isWorsePosition", true);
  }
  // #endregion
  // #region BladesRoll.ParticipantDoc Implementation
  get rollParticipantID() {
    return this.id;
  }
  get rollParticipantDoc() {
    return this;
  }
  get rollParticipantIcon() {
    var _a;
    return ((_a = this.playbook) == null ? void 0 : _a.img) ?? this.img;
  }
  get rollParticipantName() {
    return this.name ?? "";
  }
  get rollParticipantType() {
    return this.type;
  }
  get rollParticipantModsSchemaSet() {
    return [];
  }
  // #endregion
  async adjustStress(deltaStress) {
    const newStress = Math.min(this.stressMax, Math.max(0, this.stress + deltaStress));
    if (newStress === this.stressMax) {
      BladesDirector.getInstance().pushNotice_SocketCall("ALL", {
        title: `${this.name} breaks under the stress!`,
        body: `${this.name}: Select a Trauma Condition on your sheet. You are taken out of action and will no longer participate in this score. Narrate what happens.`,
        type: BladesNoticeType.push,
        cssClasses: "stress-alert"
      });
      await this.update({ "system.stress.value": 0 });
      return;
    }
    await this.update({ "system.stress.value": newStress });
  }
  async indulgeStress(deltaStress) {
    if (deltaStress > this.stress) {
      BladesDirector.getInstance().pushNotice_SocketCall("ALL", {
        title: `${this.name} Overindulges!`,
        body: `${this.name}: Select an option from the list below, and narrate how overindulging your vice led to this result: <ul><li><strong>Attract Trouble:</strong> Roll for an <strong>Entanglement</strong>.</li><li><strong>Brag About Your Exploits:</strong> +2 Heat</li><li><strong>Go AWOL</strong> Vanish for a few weeks. <em>(You will play a different character until the next Downtime Phase, at which point you will return with all Harm healed.)</em></li><li><strong>Tapped:</strong> Your current Vice Purveyor cuts you off. <em>(Until you find a new source for your vice, you will be unable to Indulge Vice during Downtime.)</em></li></ul>`,
        type: BladesNoticeType.push,
        cssClasses: "stress-alert"
      });
    }
    await this.update({ "system.stress.value": this.stress - deltaStress });
  }
  async spendArmor(amount) {
    const updateData = {};
    while (amount > 0) {
      if (this.isLightArmorAvailable) {
        if (!this.isLightArmorEquipped) {
          updateData["system.armor.active.light"] = true;
        }
        updateData["system.armor.checked.light"] = true;
      } else if (this.isHeavyArmorAvailable) {
        if (!this.isHeavyArmorEquipped) {
          updateData["system.armor.active.heavy"] = true;
        }
        updateData["system.armor.checked.heavy"] = true;
      } else {
        throw new Error("No armor available to spend");
      }
      amount--;
    }
    this.update(updateData);
  }
  async spendSpecialArmor() {
    if (this.system.armor.active.special && !this.system.armor.checked.special) {
      await this.update({ "system.armor.checked.special": true });
    }
  }
  get rollTraitPCTooltipActions() {
    const tooltipStrings = ["<table><tbody>"];
    const actionRatings = this.actions;
    Object.values(AttributeTrait).forEach((attribute) => {
      C.Action[attribute].forEach((action) => {
        tooltipStrings.push([
          "<tr>",
          `<td><strong>${U.uCase(action)}</strong></td>`,
          `<td>${"⚪".repeat(actionRatings[action])}</td>`,
          `<td><em style="font-family: 'Minion Pro Cond'; font-size: 10px;">(${C.ShortActionTooltips[action]})</em></td>`,
          "</tr>"
        ].join(""));
      });
    });
    tooltipStrings.push("</tbody></table>");
    return tooltipStrings.join("");
  }
  get rollTraitPCTooltipAttributes() {
    const tooltipStrings = ["<table><tbody>"];
    const attributeRatings = this.attributes;
    Object.values(AttributeTrait).forEach((attribute) => {
      tooltipStrings.push([
        "<tr>",
        `<td><strong>${U.uCase(attribute)}</strong></td>`,
        `<td>${"⚪".repeat(attributeRatings[attribute])}</td>`,
        `<td><em>(${C.ShortAttributeTooltips[attribute]})</em></td>`,
        "</tr>"
      ].join(""));
    });
    tooltipStrings.push("</tbody></table>");
    return tooltipStrings.join("");
  }
  // #endregion
  render(force) {
    if (!this.isHealingClockReady) {
      setTimeout(() => this.render(force), 1e3);
      return;
    }
    super.render(force);
  }
}
const BladesPC$1 = BladesPC;
class BladesNPCSheet extends BladesActorSheet {
  static get defaultOptions() {
    return foundry.utils.mergeObject(super.defaultOptions, {
      classes: ["eunos-blades", "sheet", "actor", "npc"],
      template: "systems/eunos-blades/templates/npc-sheet.hbs",
      width: 500,
      height: 400,
      // height: "auto",
      tabs: [{ navSelector: ".nav-tabs", contentSelector: ".tab-content", initial: "description" }]
    });
  }
  getData() {
    const context = super.getData();
    context.isSubActor = context.actor.isSubActor;
    context.parentActor = context.actor.parentActor;
    context.persona = context.actor.system.persona;
    context.random = context.actor.system.random;
    context.secret = context.actor.system.secret;
    const rStatus = {
      name: { size: 3, label: "Name" },
      gender: { size: "half", label: "Gender" },
      heritage: { size: "third", label: "Heritage" },
      background: { size: "third", label: "Background" },
      profession: { size: "third", label: "Profession" },
      appearance: { size: 2, label: "Appearance" },
      style: { size: 2, label: "Style" },
      quirk: { size: 4, label: "Quirk" },
      goal: { size: 2, label: "Goal" },
      method: { size: 2, label: "Method" },
      interests: { size: 4, label: "Interests" },
      trait: { size: "half", label: "Trait" },
      trait1: { size: "half", label: null },
      trait2: { size: "half", label: null },
      trait3: { size: "half", label: null }
    };
    for (const cat of ["persona", "random", "secret"]) {
      for (const [key] of Object.entries(context[cat])) {
        if (key in rStatus) {
          Object.assign(
            context[cat][key],
            rStatus[key]
          );
        }
      }
    }
    console.log({ persona: context.persona, random: context.random, secret: context.secret });
    return context;
  }
  activateListeners(html) {
    super.activateListeners(html);
    if (!this.options.editable) {
      return;
    }
    html.find(".gm-alert-header").on("click", async (event) => {
      event.preventDefault();
      this.actor.clearParentActor();
    });
    html.find('[data-action="randomize"').on("click", () => {
      this.actor.updateRandomizers();
    });
    html.find(".comp-status-toggle").on("click", () => {
      const { tags } = this.actor;
      if (this.actor.system.status === 1) {
        U.remove(tags, "Friend");
        tags.push("Rival");
        this.actor.update({
          "system.status": -1,
          "system.tags": U.unique(tags)
        });
      } else {
        U.remove(tags, "Rival");
        tags.push("Friend");
        this.actor.update({
          "system.status": 1,
          "system.tags": U.unique(tags)
        });
      }
    }).on("contextmenu", () => {
      this.actor.update({ "system.status": 0 });
    });
  }
}
class BladesNPC extends BladesActor$1 {
  // #region INITIALIZATION ~
  static async Initialize() {
    Object.assign(globalThis, { BladesNPC, BladesNPCSheet });
    Actors.registerSheet("blades", BladesNPCSheet, { types: ["npc"], makeDefault: true });
    return loadTemplates(["systems/eunos-blades/templates/npc-sheet.hbs"]);
  }
  // #endregion
  static IsType(doc) {
    return super.IsType(doc, BladesActorType.npc);
  }
  // #region BladesRoll Implementation
  get rollFactors() {
    const factorData = super.rollFactors;
    factorData[Factor.scale] = {
      name: Factor.scale,
      display: "Scale",
      value: this.getFactorTotal(Factor.scale),
      max: this.getFactorTotal(Factor.scale),
      baseVal: this.getFactorTotal(Factor.scale),
      cssClasses: "factor-grey",
      isActive: false,
      isPrimary: false,
      isDominant: false,
      highFavorsPC: true
    };
    factorData[Factor.magnitude] = {
      name: Factor.magnitude,
      display: "Magnitude",
      value: this.getFactorTotal(Factor.magnitude),
      max: this.getFactorTotal(Factor.magnitude),
      baseVal: this.getFactorTotal(Factor.magnitude),
      isActive: false,
      isPrimary: false,
      isDominant: false,
      highFavorsPC: true
    };
    return factorData;
  }
  // #region BladesRoll.OppositionDoc Implementation
  get rollOppID() {
    return this.id;
  }
  get rollOppDoc() {
    return this;
  }
  get rollOppImg() {
    return this.img;
  }
  get rollOppName() {
    return this.name;
  }
  get rollOppSubName() {
    return this.system.subtitle || this.system.concept || " ";
  }
  get rollOppType() {
    return this.type;
  }
  get rollOppModsSchemaSet() {
    return [];
  }
  // #endregion
  // #region BladesRoll.ParticipantDoc Implementation
  get rollParticipantID() {
    return this.id;
  }
  get rollParticipantDoc() {
    return this;
  }
  get rollParticipantIcon() {
    return this.img;
  }
  get rollParticipantName() {
    return this.name;
  }
  get rollParticipantType() {
    return this.type;
  }
  get rollParticipantModsSchemaSet() {
    return [];
  }
  // #endregion
  // #endregion
}
const BladesNPC$1 = BladesNPC;
class BladesFactionSheet extends BladesActorSheet {
  static get defaultOptions() {
    return foundry.utils.mergeObject(super.defaultOptions, {
      classes: ["eunos-blades", "sheet", "actor", "faction"],
      template: "systems/eunos-blades/templates/faction-sheet.hbs",
      width: 900,
      height: "auto",
      tabs: [{ navSelector: ".nav-tabs", contentSelector: ".tab-content", initial: "overview" }]
    });
  }
  getData() {
    const context = super.getData();
    if (!BladesActor$1.IsType(this.actor, BladesActorType.faction)) {
      return context;
    }
    const sheetData = {
      tierData: {
        class: "comp-tier comp-vertical comp-teeth",
        label: "Tier",
        labelClass: "filled-label full-width",
        dotline: {
          data: this.actor.system.tier,
          target: "system.tier.value",
          svgKey: "teeth.tall",
          svgFull: "full|half|frame",
          svgEmpty: "full|half|frame"
        }
      },
      clockKeys: this.actor.clocks
    };
    return {
      ...context,
      ...sheetData
    };
  }
  async _onClockAddClick(event) {
    event.preventDefault();
    this.actor.addClock();
  }
  async _onClockDeleteClick(event) {
    event.preventDefault();
    const clockID = $(event.currentTarget).data("clockId");
    if (!clockID) {
      return;
    }
    this.actor.deleteClock(clockID);
  }
  activateListeners(html) {
    super.activateListeners(html);
    if (!this.options.editable) {
      return;
    }
    html.find(".item-body").on("click", (event) => {
      var _a;
      const element = $(event.currentTarget).parents(".item");
      const item = this.actor.items.get(element.data("itemId"));
      (_a = item == null ? void 0 : item.sheet) == null ? void 0 : _a.render(true);
    });
    html.find(".comp-control.comp-add-clock").on("click", this._onClockAddClick.bind(this));
    html.find(".comp-control.comp-delete-clock").on("click", this._onClockDeleteClick.bind(this));
  }
}
class BladesFaction extends BladesActor$1 {
  // #region INITIALIZATION ~
  static async Initialize() {
    Object.assign(globalThis, { BladesFaction, BladesFactionSheet });
    Actors.registerSheet("blades", BladesFactionSheet, { types: ["faction"], makeDefault: true });
    return loadTemplates(["systems/eunos-blades/templates/faction-sheet.hbs"]);
  }
  // #endregion
  static get All() {
    return new Collection(
      super.GetTypeWithTags(BladesActorType.faction).map((faction) => [faction.id, faction])
    );
  }
  static IsType(doc) {
    return super.IsType(doc, BladesActorType.faction);
  }
  // #region BladesRoll Implementation
  // #region BladesRoll.OppositionDoc Implementation
  get rollOppID() {
    return this.id;
  }
  get rollOppDoc() {
    return this;
  }
  get rollOppImg() {
    return this.img ?? "";
  }
  get rollOppName() {
    return this.name ?? "";
  }
  get rollOppSubName() {
    return this.system.subtitle || this.system.concept || " ";
  }
  get rollOppType() {
    return this.type;
  }
  get rollOppModsSchemaSet() {
    return [];
  }
  // #endregion
  // #endregion
  // _clocks: Collection<BladesClock> = new Collection();
  // get clocks(): Collection<BladesClock> = {
  //   return new Collection()
  // }
  get clocks() {
    return new Collection(
      Object.entries(this.system.clocksData ?? {}).map(([id, data]) => [
        id,
        game.eunoblades.ClockKeys.get(id) ?? new BladesClockKey(data)
      ])
    );
  }
  async addClock() {
    return await BladesClockKey.Create({
      target: this,
      targetKey: "system.clocksData"
    });
  }
  async deleteClock(clockKeyID) {
    var _a;
    await ((_a = game.eunoblades.ClockKeys.get(clockKeyID)) == null ? void 0 : _a.delete(game.eunoblades.ClockKeys));
  }
}
const BladesFaction$1 = BladesFaction;
class BladesCrewSheet extends BladesActorSheet {
  static get defaultOptions() {
    return foundry.utils.mergeObject(super.defaultOptions, {
      classes: ["eunos-blades", "sheet", "actor", "crew"],
      template: "systems/eunos-blades/templates/crew-sheet.hbs",
      width: 940,
      height: 820,
      tabs: [{ navSelector: ".nav-tabs", contentSelector: ".tab-content", initial: "claims" }]
    });
  }
  getData() {
    const context = super.getData();
    eLog.checkLog("actor", "[BladesCrewSheet] super.getData()", { ...context });
    const { activeSubItems } = this.actor;
    const sheetData = {};
    sheetData.preparedItems = Object.assign(
      context.preparedItems ?? {},
      {
        abilities: activeSubItems.filter((item) => item.type === BladesItemType.crew_ability),
        playbook: this.actor.playbook,
        reputation: activeSubItems.find((item) => item.type === BladesItemType.crew_reputation),
        upgrades: activeSubItems.filter((item) => item.type === BladesItemType.crew_upgrade),
        preferredOp: activeSubItems.find((item) => item.type === BladesItemType.preferred_op)
      }
    );
    sheetData.preparedActors = {
      members: this.actor.members,
      contacts: this.actor.contacts
    };
    sheetData.tierData = {
      label: "Tier",
      dotline: {
        data: this.actor.system.tier,
        target: "system.tier.value",
        iconEmpty: "dot-empty.svg",
        iconEmptyHover: "dot-empty-hover.svg",
        iconFull: "dot-full.svg",
        iconFullHover: "dot-full-hover.svg"
      }
    };
    sheetData.upgradeData = {
      dotline: {
        dotlineClass: "dotline-right",
        data: {
          value: this.actor.availableUpgradePoints,
          max: this.actor.availableUpgradePoints
        },
        dotlineLabel: "Available Upgrade Points",
        isLocked: true,
        iconFull: "dot-full.svg"
      }
    };
    sheetData.abilityData = {
      dotline: {
        dotlineClass: "dotline-right",
        data: {
          value: this.actor.availableAbilityPoints,
          max: this.actor.availableAbilityPoints
        },
        dotlineLabel: "Available Ability Points",
        isLocked: true,
        iconFull: "dot-full.svg"
      }
    };
    sheetData.cohortData = {
      dotline: {
        dotlineClass: "dotline-right",
        data: {
          value: this.actor.availableCohortPoints,
          max: this.actor.availableCohortPoints
        },
        dotlineLabel: "Available Cohort Points",
        isLocked: true,
        iconFull: "dot-full.svg"
      }
    };
    sheetData.repData = {
      label: "Rep",
      dotlines: [
        {
          data: {
            value: Math.min(this.actor.system.rep.value, this.actor.system.rep.max - this.actor.turfCount),
            max: this.actor.system.rep.max - this.actor.turfCount
          },
          target: "system.rep.value",
          svgKey: "teeth.tall",
          svgFull: "full|half|frame",
          svgEmpty: "full|half|frame"
        },
        {
          data: {
            value: this.actor.turfCount,
            max: this.actor.turfCount
          },
          target: "none",
          svgKey: "teeth.tall",
          svgFull: "full|half|frame",
          svgEmpty: "full|half|frame",
          dotlineClass: "flex-row-reverse",
          isLocked: true
        }
      ]
    };
    sheetData.heatData = {
      label: "Heat",
      dotline: {
        data: this.actor.system.heat,
        target: "system.heat.value",
        svgKey: "teeth.tall",
        svgFull: "full|half|frame",
        svgEmpty: "full|half|frame"
      }
    };
    sheetData.wantedData = {
      label: "Wanted",
      dotline: {
        data: this.actor.system.wanted,
        target: "system.wanted.value",
        svgKey: "teeth.short",
        svgFull: "full|frame",
        svgEmpty: "frame"
      }
    };
    eLog.checkLog("actor", "[BladesCrewSheet] return getData()", { ...context, ...sheetData });
    return { ...context, ...sheetData };
  }
  activateListeners(html) {
    super.activateListeners(html);
    if (!this.options.editable) {
      return;
    }
    html.find(".item-sheet-open").on("click", (event) => {
      var _a;
      const element = $(event.currentTarget).parents(".item");
      const item = this.actor.items.get(element.data("itemId"));
      (_a = item == null ? void 0 : item.sheet) == null ? void 0 : _a.render(true);
    });
    html.find(".hold-toggle").on("click", () => {
      this.actor.update({ "system.hold": this.actor.system.hold === "weak" ? "strong" : "weak" });
    });
    html.find(".turf-select").on("click", async (event) => {
      var _a;
      const turf_id = $(event.currentTarget).data("turfId");
      const turf_current_status = $(event.currentTarget).data("turfStatus");
      (_a = this.actor.playbook) == null ? void 0 : _a.update({ [`system.turfs.${turf_id}.value`]: !turf_current_status }).then(() => this.render(false));
    });
  }
}
class BladesCrew extends BladesActor$1 {
  // #region INITIALIZATION ~
  static async Initialize() {
    Object.assign(globalThis, { BladesCrew, BladesCrewSheet });
    Actors.registerSheet("blades", BladesCrewSheet, { types: ["crew"], makeDefault: true });
    return loadTemplates(["systems/eunos-blades/templates/crew-sheet.hbs"]);
  }
  // #endregion
  // #region Static Overrides: Create ~
  // static override IsType<T extends BladesActorType = BladesActorType.crew>(doc: unknown): doc is BladesActorOfType<T> {
  //   return super.IsType(doc, BladesActorType.crew);
  // }
  static IsType(doc) {
    return super.IsType(doc, BladesActorType.crew);
  }
  static GetFromUser(userRef) {
    const actor = BladesPC$1.GetFromUser(userRef);
    if (!actor) {
      return void 0;
    }
    return actor.crew;
  }
  static GetFromPC(pcRef) {
    let actor;
    if (typeof pcRef === "string") {
      actor = game.actors.get(pcRef) ?? game.actors.getName(pcRef);
    } else if (pcRef instanceof BladesPC$1) {
      actor = pcRef;
    } else {
      actor ?? (actor = BladesPC$1.GetFromUser(pcRef));
    }
    if (!BladesPC$1.IsType(actor)) {
      throw new Error(`Unable to find BladesPC from '${pcRef}'`);
    }
    return actor.crew;
  }
  static async create(data, options = {}) {
    data.token = data.token || {};
    data.system = data.system ?? {};
    eLog.checkLog2("actor", "BladesActor.create(data,options)", { data, options });
    data.token.actorLink = true;
    data.system.world_name = data.system.world_name ?? data.name.replace(/[^A-Za-z_0-9 ]/g, "").trim().replace(/ /g, "_");
    data.system.experience = {
      playbook: { value: 0, max: 8 },
      clues: [],
      ...data.system.experience ?? {}
    };
    return super.create(data, options);
  }
  // #endregion
  // #region BladesCrew Implementation
  getDialogItems(category) {
    const dialogData = {};
    const { playbookName } = this;
    if (category === SelectionCategory.Playbook) {
      dialogData.Main = this._processEmbeddedItemMatches(BladesItem$1.GetTypeWithTags(BladesItemType.crew_playbook));
    } else if (category === SelectionCategory.Reputation) {
      dialogData.Main = this._processEmbeddedItemMatches(BladesItem$1.GetTypeWithTags(BladesItemType.crew_reputation));
    } else if (category === SelectionCategory.Preferred_Op && playbookName !== null) {
      dialogData.Main = this._processEmbeddedItemMatches(
        BladesItem$1.GetTypeWithTags(BladesItemType.preferred_op, playbookName)
      );
    } else if (category === SelectionCategory.Ability) {
      dialogData.Main = this._processEmbeddedItemMatches(
        BladesItem$1.GetTypeWithTags(BladesItemType.crew_ability, this.playbookName)
      );
    } else if (category === SelectionCategory.Upgrade && playbookName !== null) {
      dialogData[playbookName] = this._processEmbeddedItemMatches(
        BladesItem$1.GetTypeWithTags(BladesItemType.crew_upgrade, playbookName)
      );
      dialogData.General = this._processEmbeddedItemMatches(
        BladesItem$1.GetTypeWithTags(BladesItemType.crew_upgrade, Tag.Gear.General)
      );
    }
    return dialogData;
  }
  get members() {
    if (!BladesActor$1.IsType(this, BladesActorType.crew)) {
      return [];
    }
    const self = this;
    return BladesActor$1.GetTypeWithTags(BladesActorType.pc).filter((actor) => actor.isMember(self));
  }
  get contacts() {
    if (!BladesActor$1.IsType(this, BladesActorType.crew) || !this.playbook) {
      return [];
    }
    const self = this;
    return this.activeSubActors.filter((actor) => actor.hasTag(self.playbookName));
  }
  get claims() {
    if (!BladesActor$1.IsType(this, BladesActorType.crew) || !this.playbook) {
      return {};
    }
    return this.playbook.system.turfs;
  }
  get turfCount() {
    if (!BladesActor$1.IsType(this, BladesActorType.crew) || !this.playbook) {
      return 0;
    }
    return Object.values(this.playbook.system.turfs).filter((claim) => claim.isTurf && claim.value).length;
  }
  get upgrades() {
    if (!BladesActor$1.IsType(this, BladesActorType.crew) || !this.playbook) {
      return [];
    }
    return this.activeSubItems.filter((item) => item.type === BladesItemType.crew_upgrade);
  }
  get cohorts() {
    return this.activeSubItems.filter((item) => [BladesItemType.cohort_gang, BladesItemType.cohort_expert].includes(item.type));
  }
  getTaggedItemBonuses(tags) {
    return tags.length;
  }
  // #endregion
  // #region BladesRoll Implementation
  // #region BladesRoll.ParticipantDoc Implementation
  get rollParticipantID() {
    return this.id;
  }
  get rollParticipantDoc() {
    return this;
  }
  get rollParticipantIcon() {
    var _a;
    return ((_a = this.playbook) == null ? void 0 : _a.img) ?? this.img;
  }
  get rollParticipantName() {
    return this.name;
  }
  get rollParticipantType() {
    return this.type;
  }
  get rollParticipantModsSchemaSet() {
    return [];
  }
  async applyHarm(_amount, _name2) {
    console.error("Attempt to apply harm directly to a Crew document.");
  }
  async applyWorsePosition() {
    console.error("Attempt to apply worse position directly to a Crew document.");
  }
  // #endregion
  // #endregion
  get abilities() {
    if (!this.playbook) {
      return [];
    }
    return this.activeSubItems.filter((item) => [BladesItemType.ability, BladesItemType.crew_ability].includes(item.type));
  }
  get playbookName() {
    var _a;
    return (_a = this.playbook) == null ? void 0 : _a.name;
  }
  get playbook() {
    return this.activeSubItems.find((item) => item.type === BladesItemType.crew_playbook);
  }
}
const BladesCrew$1 = BladesCrew;
const ActorsMap = {
  [BladesActorType.pc]: BladesPC$1,
  [BladesActorType.npc]: BladesNPC$1,
  [BladesActorType.faction]: BladesFaction$1,
  [BladesActorType.crew]: BladesCrew$1
};
const BladesActorProxy = new Proxy(function() {
}, {
  construct(_, args) {
    const [{ type }] = args;
    if (!type) {
      throw new Error(`Invalid Actor Type: ${String(type)}`);
    }
    const MappedConstructor = ActorsMap[type];
    if (!MappedConstructor) {
      return new BladesActor$1(...args);
    }
    return new MappedConstructor(...args);
  },
  get(_, prop) {
    switch (prop) {
      case "create":
      case "createDocuments":
        return function(data, options = {}) {
          if (U.isArray(data)) {
            return data.map((i) => CONFIG.Actor.documentClass.create(i, options));
          }
          const MappedConstructor = ActorsMap[data.type];
          if (!MappedConstructor) {
            return BladesActor$1.create(data, options);
          }
          return MappedConstructor.create(data, options);
        };
      case Symbol.hasInstance:
        return function(instance) {
          return Object.values(ActorsMap).some((i) => instance instanceof i);
        };
      default:
        return BladesActor$1[prop];
    }
  }
});
class BladesConsequence extends BladesTargetLink {
  // #region Static Methods ~
  static async Initialize() {
    if (!game.messages) {
      throw new Error("[BladesConsequence] Messages Not Ready!");
    }
    return (await Promise.all(game.messages.contents.map(async (msg) => msg.rollConsequences))).flat();
  }
  /**
  * Checks if the given value is valid consequence data for a Resistance Roll.
  * @param val The value to check.
  * @param isCheckingResistedTo If the check is being recursively applied to the 'resistTo' value.
  * @returns True if the val is valid BladesConsequence.Data, false otherwise.
  */
  static IsValidConsequenceData(val, isCheckingResistedTo = false) {
    if (!U.isList(val)) {
      return false;
    }
    if (typeof val.type !== "string" || !(val.type in ConsequenceType)) {
      return false;
    }
    if (typeof val.name !== "string") {
      return false;
    }
    if (isCheckingResistedTo) {
      return true;
    }
    if (val.attribute && (typeof val.attribute !== "string" || !(val.attribute in AttributeTrait))) {
      return false;
    }
    if (!this.IsValidConsequenceData(val.resistTo, true)) {
      return false;
    }
    return true;
  }
  static ApplySchemaDefaults(schemaData) {
    if (!schemaData.primaryID) {
      throw new Error("A primaryID is required for BladesConsequence.Schema");
    }
    if (typeof schemaData.name === "string" && (!schemaData.name && schemaData.type !== ConsequenceType.None)) {
      throw new Error(`A name must be provided for non-None-type consequences (${schemaData.name}).`);
    }
    return {
      name: "",
      type: ConsequenceType.None,
      ...schemaData
    };
  }
  static GetCsqTypeValue(cType, rollData) {
    if (cType === ConsequenceType.WorsePosition) {
      if (!rollData) {
        throw new Error(`Cannot resolve consequence type value for '${cType}' without roll data.`);
      }
      let position;
      if ("rollPositionFinal" in rollData) {
        position = rollData.rollPositionFinal;
      } else if ("position" in rollData) {
        position = rollData.position;
      }
      if (!position) {
        throw new Error(`Cannot resolve consequence type value for '${cType}' without roll data that includes final position data.`);
      }
      return {
        [Position.controlled]: 1,
        [Position.risky]: 2,
        [Position.desperate]: 0
      }[position];
    }
    if (cType === ConsequenceType.ReducedEffect) {
      if (!rollData) {
        throw new Error(`Cannot resolve consequence type value for '${cType}' without roll data.`);
      }
      let effect;
      if ("rollEffectFinal" in rollData) {
        effect = rollData.rollEffectFinal;
      } else if ("effect" in rollData) {
        effect = rollData.effect;
      }
      if (!effect) {
        throw new Error(`Cannot resolve consequence type value for '${cType}' without roll data that includes final effect data.`);
      }
      return {
        [Effect.extreme]: 1,
        [Effect.great]: 1,
        [Effect.standard]: 1,
        [Effect.limited]: 2,
        [Effect.zero]: 0
      }[effect];
    }
    return C.ConsequenceValues[cType];
  }
  // #endregion
  // #region *** GETTERS *** ~
  // #region Getters (Target Data) ~
  get primaryID() {
    var _a;
    return this.data.primaryID ?? ((_a = this.parentConsequence) == null ? void 0 : _a.primaryID);
  }
  get parentCsqID() {
    return this.data.parentCsqID;
  }
  get name() {
    return this.data.name;
  }
  get type() {
    return this.data.type;
  }
  get attribute() {
    var _a;
    return this.data.attribute ?? ((_a = this.parentConsequence) == null ? void 0 : _a.attribute);
  }
  get attributeVal() {
    var _a;
    return this.data.attributeVal ?? ((_a = this.parentConsequence) == null ? void 0 : _a.attributeVal);
  }
  get specialFooterMsg() {
    var _a;
    return this.data.specialFooterMsg ?? ((_a = this.parentConsequence) == null ? void 0 : _a.specialFooterMsg);
  }
  // #endregion
  // #region Getters (Derived Data) ~
  get primary() {
    const primary = fromUuidSync(this.primaryID);
    if (!BladesRollPrimary.IsDoc(primary)) {
      throw new Error(`Could not find primary with UUID '${this.primaryID}'`);
    }
    if (this.roll) {
      return new BladesRollPrimary(this.roll, primary);
    }
    return new BladesRollPrimary(primary);
  }
  get parentConsequence() {
    if (!this.parentCsqID) {
      return void 0;
    }
    const parentCsq = game.eunoblades.Consequences.get(this.parentCsqID);
    if (!parentCsq) {
      throw new Error(`Error locating parent consequence with id '${this.parentCsqID}'`);
    }
    return parentCsq;
  }
  get typeDisplay() {
    return C.ConsequenceDisplay[this.type];
  }
  get icon() {
    return C.ConsequenceIcons[this.type];
  }
  get value() {
    return BladesConsequence.GetCsqTypeValue(this.type, this);
  }
  // #endregion
  // #region Getters (Resolved Roll Data that Applied This Consequence) ~
  get rollData() {
    var _a;
    return this.data.actionRollData ?? ((_a = this.parentConsequence) == null ? void 0 : _a.rollData);
  }
  get roll() {
    if (!this.rollData) {
      return void 0;
    }
    return game.eunoblades.Rolls.get(this.rollData.id) ?? new BladesRoll$1({
      ...this.rollData,
      isScopingById: false
    });
  }
  get position() {
    var _a;
    return (_a = this.roll) == null ? void 0 : _a.rollPositionFinal;
  }
  get effect() {
    var _a;
    return (_a = this.roll) == null ? void 0 : _a.rollEffectFinal;
  }
  get result() {
    var _a;
    return (_a = this.roll) == null ? void 0 : _a.rollResultFinal;
  }
  // #endregion
  // #region Getters (Resistibility & Acceptance Status) ~
  isResistible() {
    return Boolean(this.type !== ConsequenceType.None && !this.isAccepted && this.data.resistSchema);
  }
  get resistanceModes() {
    return this.data.resistanceModes ?? [];
  }
  get wasResisted() {
    return Boolean(this.resistanceModes.length);
  }
  get wasResistedByRoll() {
    return this.resistanceModes.includes("resist");
  }
  get wasResistedByArmor() {
    return this.resistanceModes.includes("armor");
  }
  get wasResistedBySpecialArmor() {
    var _a;
    return (_a = this.resistanceModes) == null ? void 0 : _a.includes("special");
  }
  get canResistWithRoll() {
    if (!this.isResistible()) {
      return false;
    }
    if (!BladesPC$1.IsType(this.primary.rollPrimaryDoc)) {
      return false;
    }
    if (this.wasResistedByRoll) {
      return false;
    }
    return true;
  }
  get canResistWithArmor() {
    if (!this.isResistible()) {
      return false;
    }
    if (!this.data.canResistWithArmor) {
      return false;
    }
    return this.primary.availableArmorCount > 0;
  }
  get canResistWithSpecial() {
    if (!this.isResistible()) {
      return false;
    }
    if (!this.data.canResistWithSpecial) {
      return false;
    }
    if (!BladesPC$1.IsType(this.primary.rollPrimaryDoc)) {
      return false;
    }
    if (this.wasResistedBySpecialArmor) {
      return false;
    }
    return this.primary.hasSpecialArmor;
  }
  get resistWithRollNegates() {
    if (!this.canResistWithRoll) {
      return false;
    }
    if (this.wasResisted) {
      return true;
    }
    return Boolean(this.data.resistWithRollNegates);
  }
  get resistWithArmorNegates() {
    if (!this.canResistWithArmor) {
      return false;
    }
    if (this.wasResisted) {
      return true;
    }
    return Boolean(this.data.resistWithArmorNegates);
  }
  get resistWithSpecialNegates() {
    if (!this.canResistWithSpecial) {
      return false;
    }
    if (this.wasResisted) {
      return true;
    }
    return Boolean(this.data.resistWithSpecialNegates);
  }
  get isAccepted() {
    return "acceptanceMode" in this.data;
  }
  get acceptanceMode() {
    return this.data.acceptanceMode;
  }
  // #endregion
  // #endregion
  // #region *** RESISTING CONSEQUENCES ***
  // #region Constructing Resistable Consequence Schema
  get noneSchema() {
    return {
      name: "",
      type: ConsequenceType.None,
      primaryID: this.primaryID
    };
  }
  get resistSchema() {
    if (!this.isResistible()) {
      return void 0;
    }
    const resSchema = {
      name: this.data.resistSchema.name,
      type: this.data.resistSchema.type,
      primaryID: this.primaryID,
      resistSchema: {
        name: "",
        type: ConsequenceType.None
      },
      resistanceModes: this.resistanceModes,
      resistWithRollNegates: true,
      attribute: this.attribute,
      attributeVal: this.attributeVal,
      canResistWithArmor: this.canResistWithArmor,
      resistWithArmorNegates: true,
      canResistWithSpecial: this.canResistWithSpecial,
      resistWithSpecialNegates: true,
      specialFooterMsg: this.specialFooterMsg
    };
    if (this.wasResisted) {
      resSchema.name = "";
      resSchema.type = ConsequenceType.None;
      delete resSchema.resistSchema;
      resSchema.canResistWithArmor = false;
      resSchema.canResistWithSpecial = false;
    }
    return resSchema;
  }
  // #endregion
  async resistConsequence(resistMode, rollInstance) {
    if (!this.isResistible()) {
      throw new Error("Cannot resist a consequence that is not resistible.");
    }
    const updateData = {
      resistanceModes: this.resistanceModes,
      ...this.resistSchema
    };
    updateData.resistanceModes.push(resistMode);
    updateData.parentCsqID = void 0;
    if (resistMode === "resist") {
      if (!(rollInstance == null ? void 0 : rollInstance.isResolved)) {
        throw new Error("Cannot transform to resisted consequence without a resolved resistance roll instance.");
      }
      updateData.resistanceRollData = rollInstance.data;
    }
    if (this.wasResisted || updateData.type === ConsequenceType.None) {
      updateData.acceptanceMode = "base";
    } else if (resistMode === "resist" && !this.canResistWithArmor && !this.canResistWithSpecial) {
      updateData.acceptanceMode = resistMode;
    }
    await this.updateTargetData(updateData);
    if (updateData.acceptanceMode) {
      socketlib.system.executeForEveryone("acceptConsequence_SocketCall", this.id);
    } else {
      socketlib.system.executeForEveryone("resistConsequence_SocketCall", this.id);
    }
  }
  // #endregion
  // #region *** ACCEPTING CONSEQUENCES ***
  async acceptConsequence() {
    if (this.isAccepted) {
      return;
    }
    await this.updateTarget("acceptanceMode", U.getLast(this.resistanceModes) ?? "accept");
    socketlib.system.executeForEveryone("acceptConsequence_SocketCall", this.id);
  }
  async applyConsequenceEffects() {
    if (/Harm/.test(this.type)) {
      this.primary.applyHarm(
        U.pInt(this.type.substring(this.type.length - 1)),
        this.name
      );
    } else if (this.type === ConsequenceType.WorsePosition) {
      this.primary.applyWorsePosition();
    } else if (this.type === ConsequenceType.ReducedEffect) {
      const curIndex = Object.values(Effect).findIndex((val) => val === this.effect);
      if (curIndex >= 1) {
        const newEffect = Object.values(Effect)[curIndex - 1];
        await this.updateTarget("rollData.rollEffectFinal", newEffect);
      }
    }
  }
  // #endregion
  // #region === CONSTRUCTOR === ~
  // constructor(
  //   config: BladesConsequence.Config,
  //   parentCsq?: BladesConsequence.Data
  // )
  // constructor(
  //   data: BladesConsequence.Data
  // )
  // constructor(
  //   schema: Partial<BladesConsequence.Schema>,
  //   parentCsq: BladesConsequence.Data
  // )
  // constructor(
  //   dataConfigOrSchema: BladesConsequence.Config | BladesConsequence.Data | Partial<BladesConsequence.Schema>,
  //   parentCsq?: BladesConsequence.Data
  // ) {
  //   // If a parentCsq is provided...
  //   if (parentCsq) {
  //     super({
  //       ...BladesTargetLink.BuildLinkConfig(parentCsq),
  //       ...dataConfigOrSchema
  //     });
  //   } else {
  //     super(dataConfigOrSchema as BladesConsequence.Config | BladesConsequence.Data);
  //   }
  // }
  // #endregion
  // #region *** HTML INTERACTION ***
  // #region *** BladesDialog *** ~
  // #endregion
  // #region *** BladesChat *** ~
  static ApplyChatListeners(message) {
    const html$ = message.elem$;
    html$.find(".comp.consequence-display-container").each((_i, csqContainer) => {
      if (!$(csqContainer).hasClass("consequence-accepted")) {
        const iconContainer$ = $(csqContainer).find(".consequence-icon-container");
        const rightInteractionPad$ = $(csqContainer).find(".interaction-pad-right");
        const leftInteractionPad$ = $(csqContainer).find(".interaction-pad-left");
        const resistInteractionPad$ = $(csqContainer).find(".interaction-pad-left-resist");
        const armorInteractionPad$ = $(csqContainer).find(".interaction-pad-left-armor");
        const specialInteractionPad$ = $(csqContainer).find(".interaction-pad-left-special");
        $(csqContainer).data("hoverTimeline", U.gsap.effects.csqEnter(csqContainer));
        $(csqContainer).on({
          mouseenter: function() {
            $(csqContainer).css("z-index", 10);
            $(csqContainer).data("hoverTimeline").play();
          },
          mouseleave: function() {
            if (!(iconContainer$.data("isToggled") || iconContainer$.data("isTogglingOn")) || iconContainer$.data("isTogglingOff")) {
              $(csqContainer).data("hoverTimeline").reverse().then(() => {
                $(csqContainer).css("z-index", "");
              });
            }
          }
        });
        iconContainer$.data("clickTimeline", U.gsap.effects.csqClickIcon(iconContainer$[0]));
        iconContainer$.on({
          click: function() {
            if (iconContainer$.data("isToggled") || iconContainer$.data("isTogglingOn")) {
              iconContainer$.data("isTogglingOn", false);
              iconContainer$.data("isTogglingOff", true);
              iconContainer$.data("clickTimeline").reverse().then(() => {
                iconContainer$.data("isTogglingOff", false);
                iconContainer$.data("isToggled", false);
              });
            } else {
              iconContainer$.data("isTogglingOn", true);
              iconContainer$.data("isTogglingOff", false);
              Array.from($(csqContainer).siblings(".consequence-display-container")).forEach((containerElem) => {
                const iContainer$ = $(containerElem).find(".consequence-icon-container");
                if ((iContainer$ == null ? void 0 : iContainer$.data("isToggled")) || (iContainer$ == null ? void 0 : iContainer$.data("isTogglingOn"))) {
                  iContainer$.data("isTogglingOn", false);
                  iContainer$.data("isTogglingOff", true);
                  iContainer$.data("clickTimeline").reverse().then(() => {
                    iContainer$.data("isTogglingOff", false);
                    iContainer$.data("isToggled", false);
                    $(containerElem).data("hoverTimeline").reverse().then(() => {
                      $(containerElem).css("z-index", "");
                    });
                  });
                }
              });
              iconContainer$.data("clickTimeline").play().then(() => {
                iconContainer$.data("isTogglingOn", false);
                iconContainer$.data("isToggled", true);
              });
            }
          }
        });
        rightInteractionPad$.data("hoverTimeline", U.gsap.effects.csqEnterRight(csqContainer));
        rightInteractionPad$.on({
          mouseenter: function() {
            if (iconContainer$.data("isToggled")) {
              rightInteractionPad$.data("hoverTimeline").play();
            }
          },
          mouseleave: function() {
            rightInteractionPad$.data("hoverTimeline").reverse();
          }
        });
        leftInteractionPad$.data("hoverTimeline", U.gsap.effects.csqEnterLeft(csqContainer));
        leftInteractionPad$.on({
          mouseenter: function() {
            if (iconContainer$.data("isToggled")) {
              leftInteractionPad$.data("hoverTimeline").play();
            }
          },
          mouseleave: function() {
            leftInteractionPad$.data("hoverTimeline").reverse();
          }
        });
        resistInteractionPad$.data("hoverTimeline", U.gsap.effects.csqEnterSubLeft(csqContainer, { type: "resist" }));
        resistInteractionPad$.on({
          mouseenter: function() {
            if (iconContainer$.data("isToggled")) {
              resistInteractionPad$.data("hoverTimeline").play();
            }
          },
          mouseleave: function() {
            if (iconContainer$.data("isToggled")) {
              resistInteractionPad$.data("hoverTimeline").reverse();
            }
          }
        });
        armorInteractionPad$.data("hoverTimeline", U.gsap.effects.csqEnterSubLeft(csqContainer, { type: "armor" }));
        armorInteractionPad$.on({
          mouseenter: function() {
            if (iconContainer$.data("isToggled")) {
              armorInteractionPad$.data("hoverTimeline").play();
            }
          },
          mouseleave: function() {
            if (iconContainer$.data("isToggled")) {
              armorInteractionPad$.data("hoverTimeline").reverse();
            }
          }
        });
        specialInteractionPad$.data("hoverTimeline", U.gsap.effects.csqEnterSubLeft(csqContainer, { type: "special" }));
        specialInteractionPad$.on({
          mouseenter: function() {
            if (iconContainer$.data("isToggled")) {
              specialInteractionPad$.data("hoverTimeline").play();
            }
          },
          mouseleave: function() {
            if (iconContainer$.data("isToggled")) {
              specialInteractionPad$.data("hoverTimeline").reverse();
            }
          }
        });
      }
    });
  }
  // #endregion
  // #endregion
}
function isAction(trait) {
  return Boolean(trait && typeof trait === "string" && U.lCase(trait) in ActionTrait);
}
function isAttribute(trait) {
  return Boolean(trait && typeof trait === "string" && U.lCase(trait) in AttributeTrait);
}
function isFactor(trait) {
  return Boolean(trait && typeof trait === "string" && U.lCase(trait) in Factor);
}
function isModStatus(str) {
  return typeof str === "string" && str in RollModStatus;
}
function isParticipantSection(section) {
  return [
    RollModSection.roll,
    RollModSection.position,
    RollModSection.effect
  ].includes(section);
}
function isParticipantSubSection(subSection) {
  if (subSection.startsWith("Group_")) {
    return true;
  }
  if (["Assist", "Setup"].includes(subSection)) {
    return true;
  }
  return false;
}
class BladesRollMod extends BladesTargetLink {
  constructor(modData, rollInstance) {
    super(modData);
    __publicField(this, "isRerendering", false);
    __publicField(this, "_rollInstance");
    this._rollInstance = rollInstance;
  }
  static ApplySchemaDefaults(schemaData) {
    if (!schemaData.name) {
      throw new Error("name is required for BladesRollMod.Schema");
    }
    return {
      key: `${schemaData.name}-positive-roll`,
      modType: RollModType.general,
      section: RollModSection.roll,
      posNeg: "positive",
      base_status: RollModStatus.Hidden,
      value: 1,
      tooltip: "",
      ...schemaData
    };
  }
  static get GMOnlyModStatuses() {
    return [RollModStatus.ForcedOn, RollModStatus.ForcedOff, RollModStatus.Hidden];
  }
  static getSchemaFromStrings(mStrings) {
    const nameString = U.pullElement(mStrings, (v) => typeof v === "string" && /^na/i.test(v));
    const nameVal = typeof nameString === "string" && nameString.replace(/^.*:/, "");
    if (!nameVal) {
      throw new Error(`RollMod Missing Name: '${mStrings.join("@")}'`);
    }
    const catString = U.pullElement(mStrings, (v) => typeof v === "string" && /^cat/i.test(v));
    const catVal = typeof catString === "string" && catString.replace(/^.*:/, "");
    if (!catVal || !(catVal in RollModSection)) {
      throw new Error(`RollMod Missing Category: '${mStrings.join("@")}'`);
    }
    const posNegString = U.pullElement(mStrings, (v) => typeof v === "string" && /^p/i.test(v)) || "posNeg:positive";
    const posNegVal = posNegString.replace(/^.*:/, "");
    return {
      key: `${nameVal}-${posNegVal}-${catVal}`,
      name: nameVal,
      section: catVal,
      posNeg: posNegVal,
      base_status: RollModStatus.ToggledOff,
      modType: RollModType.general,
      tooltip: "",
      value: 1,
      ...Object.fromEntries(
        mStrings.map(getModParameterKeyVal)
      )
    };
    function getModParameterKeyVal(mString) {
      const [keyString, valString] = mString.split(/:/);
      let val = /\|/.test(valString) ? valString.split(/\|/) : valString;
      let key;
      if (/^stat/i.test(keyString)) {
        key = "base_status";
      } else if (/^val/i.test(keyString)) {
        key = "value";
      } else if (/^eff|^ekey/i.test(keyString)) {
        key = "effectKeys";
      } else if (/^side|^ss/i.test(keyString)) {
        key = "sideString";
      } else if (/^s.*ame/i.test(keyString)) {
        key = "source_name";
      } else if (/^tool|^tip/i.test(keyString)) {
        key = "tooltip";
      } else if (/^ty/i.test(keyString)) {
        key = "modType";
      } else if (/^c.{0,10}r?.{0,3}ty/i.test(keyString)) {
        key = "conditionalRollTypes";
      } else if (/^a.{0,3}r?.{0,3}y/i.test(keyString)) {
        key = "autoRollTypes";
      } else if (/^p.{0,10}r?.{0,3}y/i.test(keyString)) {
        key = "participantRollTypes";
      } else if (/^c.{0,10}r?.{0,3}tr/i.test(keyString)) {
        key = "conditionalRollTraits";
      } else if (/^a.{0,3}r?.{0,3}tr/i.test(keyString)) {
        key = "autoRollTraits";
      } else if (/^p.{0,10}r?.{0,3}tr/i.test(keyString)) {
        key = "participantRollTypes";
      } else {
        throw new Error(`Bad Roll Mod Key: ${keyString}`);
      }
      if (key === "base_status" && val === "Conditional") {
        val = RollModStatus.Hidden;
      }
      let valProcessed;
      if (["value"].includes(key)) {
        valProcessed = U.pInt(val);
      } else if (["effectKeys", "conditionalRollTypes", "autoRollTypes", "conditionalRollTraits", "autoRollTraits"].includes(key)) {
        valProcessed = [val].flat();
      } else {
        valProcessed = val.replace(/%COLON%/g, ":");
      }
      return [key, valProcessed];
    }
  }
  static ParseDocModsToSchemaSet(doc) {
    if (doc instanceof BladesChat$1) {
      throw new Error("BladesRollMod.ParseDocRollMods cannot be called on a BladesChat document.");
    }
    const { roll_mods } = doc.system;
    if (!roll_mods || roll_mods.length === 0) {
      return [];
    }
    return roll_mods.filter((elem) => Boolean(elem && typeof elem === "string")).map((modString) => {
      return this.getSchemaFromStrings(modString.split(/@/));
    });
  }
  get status() {
    if (this.userStatus && BladesRollMod.GMOnlyModStatuses.includes(this.userStatus)) {
      return this.userStatus;
    }
    if (this.heldStatus && [RollModStatus.ToggledOff, RollModStatus.ToggledOn].includes(this.heldStatus)) {
      return this.userStatus ?? this.heldStatus;
    }
    return this.heldStatus ?? this.userStatus ?? this.baseStatus;
  }
  get isActive() {
    return [RollModStatus.ToggledOn, RollModStatus.ForcedOn].includes(this.status);
  }
  get isVisible() {
    return this.status !== RollModStatus.Hidden;
  }
  // get flagParams() {
  //   return [C.SYSTEM_ID, `rollCollab.rollModsData.${this.id}`] as const;}
  // async setUserStatusFlag(val: RollModStatus | undefined) {
  // }
  get isConditional() {
    return [
      ...this.conditionalRollTraits,
      ...this.autoRollTraits,
      ...this.participantRollTraits,
      ...this.conditionalRollTypes,
      ...this.autoRollTypes,
      ...this.participantRollTypes
    ].length > 0;
  }
  get isInInactiveBlock() {
    if (game.user.isGM) {
      return [RollModStatus.Hidden, RollModStatus.ForcedOff, RollModStatus.ToggledOff].includes(this.status) && (this.isConditional || this.modType === RollModType.ability);
    }
    return [RollModStatus.ForcedOff, RollModStatus.ToggledOff].includes(this.status) && (this.isConditional || this.modType === RollModType.ability);
  }
  get isPush() {
    return Boolean(U.lCase(this.name) === "push" || this.effectKeys.find((eKey) => eKey === "Is-Push"));
  }
  get isBasicPush() {
    return U.lCase(this.name) === "push";
  }
  get stressCost() {
    const costKeys = this.effectKeys.filter((key) => key.startsWith("Cost-Stress"));
    if (costKeys.length === 0) {
      return 0;
    }
    let stressCost = 0;
    costKeys.forEach((key) => {
      const [thisParam] = (key.split(/-/) ?? []).slice(1);
      const [_, valStr] = (/([A-Za-z]+)(\d*)/.exec(thisParam) ?? []).slice(1);
      stressCost += U.pInt(valStr);
    });
    return stressCost;
  }
  isValidForRollType() {
    switch (this.rollInstance.rollType) {
      case RollType.Action: {
        return true;
      }
      case RollType.Resistance:
      case RollType.Fortune:
      case RollType.IndulgeVice: {
        if (this.isPush || ["bargain", "setup", "assist", "potency"].includes(U.lCase(this.name))) {
          return false;
        }
        return true;
      }
      default:
        return false;
    }
  }
  /**
   * Checks if any types or traits apply to the roll instance.
   * @param {AnyRollType[]} types The types to check.
   * @param {RollTrait[]} traits The traits to check.
   * @returns {boolean} - Returns true if any types or traits apply, false otherwise.
   */
  checkTypesOrTraits(types, traits) {
    const rollTypes = [this.rollInstance.rollType, this.rollInstance.rollSubType, this.rollInstance.rollDowntimeAction].filter((rType) => Boolean(rType));
    const typesApply = !this.rollInstance.isParticipantRoll && types.length === 0 || rollTypes.some((rType) => types.includes(rType));
    const traitsApply = !this.rollInstance.isParticipantRoll && traits.length === 0 || this.rollInstance.rollTrait && traits.includes(this.rollInstance.rollTrait);
    return Boolean(typesApply && traitsApply);
  }
  /**
   * Sets the conditional status of the roll mod instance.
   * @returns {boolean} - Returns false if the status is ForcedOn or ToggledOff, true if the status is Hidden.
   */
  setConditionalStatus() {
    if (!this.isConditional) {
      return false;
    }
    if (this.autoRollTypes.includes(this.rollInstance.rollType) || this.rollInstance.rollSubType && this.autoRollTypes.includes(this.rollInstance.rollSubType) || this.rollInstance.rollDowntimeAction && this.autoRollTypes.includes(this.rollInstance.rollDowntimeAction)) {
      this.heldStatus = RollModStatus.ForcedOn;
      return false;
    }
    if (this.rollInstance.rollTrait && this.autoRollTraits.includes(this.rollInstance.rollTrait)) {
      this.heldStatus = RollModStatus.ForcedOn;
      return false;
    }
    if (this.checkTypesOrTraits(this.conditionalRollTypes, this.conditionalRollTraits)) {
      this.heldStatus = RollModStatus.ToggledOff;
      return false;
    }
    if (this.rollInstance.isParticipantRoll && this.checkTypesOrTraits(this.participantRollTypes, this.participantRollTraits)) {
      this.heldStatus = RollModStatus.ToggledOff;
      return false;
    }
    this.heldStatus = RollModStatus.Hidden;
    return true;
  }
  /**
   * Sets the auto-reveal/enable status of the roll mod instance.
   * @returns {boolean} - Returns false if the status is ForcedOn or ToggledOff, true if the status is Hidden.
   */
  setAutoStatus() {
    const holdKeys = this.effectKeys.filter((key) => key.startsWith("Auto"));
    if (holdKeys.length === 0) {
      return false;
    }
    for (const key of holdKeys) {
      const [thisKey, thisParam] = key.split(/-/) ?? [];
      if (U.lCase(thisParam) in Position && this.rollInstance.rollPositionFinal === U.lCase(thisParam)) {
        if (thisKey === "AutoRevealOn") {
          this.heldStatus = RollModStatus.ToggledOff;
          return false;
        } else if (thisKey === "AutoEnableOn") {
          this.heldStatus = RollModStatus.ForcedOn;
          return false;
        }
      }
    }
    this.heldStatus = RollModStatus.Hidden;
    return true;
  }
  /**
   * Sets the relevancy status of the roll mod instance (i.e. hides irrelevant rollMods).
   * @returns {boolean} - Returns true if mod is irrelevant and status is Hidden, false otherwise.
   */
  setRelevancyStatus() {
    const holdKeys = this.effectKeys.filter((key) => /^Negate|^Increase/.test(key));
    if (holdKeys.length === 0) {
      return false;
    }
    const relevantKeys = holdKeys.filter((key) => {
      const [thisKey, thisParam] = key.split(/-/) ?? [];
      if (thisKey === "Negate") {
        const negateOperations = {
          PushCost: () => this.rollInstance.isPushed(),
          QualityPenalty: () => {
            var _a, _b;
            return this.rollInstance.isTraitRelevant(Factor.quality) && (((_a = this.rollInstance.rollFactors.source[Factor.quality]) == null ? void 0 : _a.value) ?? 0) < (((_b = this.rollInstance.rollFactors.opposition[Factor.quality]) == null ? void 0 : _b.value) ?? 0);
          },
          ScalePenalty: () => {
            var _a, _b;
            return this.rollInstance.isTraitRelevant(Factor.scale) && (((_a = this.rollInstance.rollFactors.source[Factor.scale]) == null ? void 0 : _a.value) ?? 0) < (((_b = this.rollInstance.rollFactors.opposition[Factor.scale]) == null ? void 0 : _b.value) ?? 0);
          },
          TierPenalty: () => {
            var _a, _b;
            return this.rollInstance.isTraitRelevant(Factor.tier) && (((_a = this.rollInstance.rollFactors.source[Factor.tier]) == null ? void 0 : _a.value) ?? 0) < (((_b = this.rollInstance.rollFactors.opposition[Factor.tier]) == null ? void 0 : _b.value) ?? 0);
          }
        };
        if (Object.hasOwn(negateOperations, thisParam)) {
          return negateOperations[thisParam]();
        } else {
          throw new Error(`Unrecognized Negate parameter: ${thisParam}`);
        }
      } else if (thisKey === "Increase") {
        const [_, traitStr] = /(\w+)\d+/.exec(thisParam) ?? [];
        return this.rollInstance.isTraitRelevant(traitStr);
      } else {
        throw new Error(`Unrecognized Function Key: ${thisKey}`);
      }
    });
    if (relevantKeys.length === 0) {
      this.heldStatus = RollModStatus.Hidden;
      return true;
    }
    return false;
  }
  /**
   * Sets the payable status of the roll mod instance (i.e. forces off rollMods the primary can't pay for).
   * @returns {boolean} - Returns true if mod is unpayable and status is ForcedOff, false otherwise.
   */
  setPayableStatus() {
    const holdKeys = this.effectKeys.filter((key) => key.startsWith("Cost"));
    if (holdKeys.length === 0) {
      return false;
    }
    const payableKeys = holdKeys.filter((key) => {
      const [thisParam] = (key.split(/-/) ?? []).slice(1);
      const [traitStr, valStr] = (/([A-Za-z]+)(\d*)/.exec(thisParam) ?? []).slice(1);
      const { rollPrimaryDoc } = this.rollInstance.rollPrimary ?? {};
      if (!BladesRollPrimary.IsDoc(rollPrimaryDoc)) {
        return false;
      }
      switch (traitStr) {
        case "SpecialArmor": {
          return BladesActor$1.IsType(rollPrimaryDoc, BladesActorType.pc) && rollPrimaryDoc.system.armor.active.special && !rollPrimaryDoc.system.armor.checked.special;
        }
        case "Stress": {
          const val = U.pInt(valStr);
          return BladesActor$1.IsType(rollPrimaryDoc, BladesActorType.pc) && rollPrimaryDoc.system.stress.max - rollPrimaryDoc.system.stress.value >= val;
        }
        case "Heat": {
          return BladesPC$1.IsType(rollPrimaryDoc) && BladesCrew$1.IsType(rollPrimaryDoc.crew) || BladesCrew$1.IsType(
            rollPrimaryDoc
          );
        }
        default:
          throw new Error(`Unrecognize Payable Key: ${traitStr}`);
      }
    });
    if (payableKeys.length === 0) {
      this.heldStatus = RollModStatus.ForcedOff;
      return true;
    }
    return false;
  }
  applyRollModEffectKeys() {
    if (!this.isActive) {
      return;
    }
    const holdKeyParams = this.effectKeys.filter((key) => /^Negate|^Increase/.test(key)).map((key) => key.split(/-/));
    if (holdKeyParams.length === 0) {
      return;
    }
    holdKeyParams.forEach(([key, param]) => {
      if (key === "Negate") {
        const negateOperations = {
          PushCost: () => {
            this.rollInstance.negatePushCost();
          },
          QualityPenalty: () => {
            this.rollInstance.negateFactorPenalty(Factor.quality);
          },
          ScalePenalty: () => {
            this.rollInstance.negateFactorPenalty(Factor.scale);
          },
          TierPenalty: () => {
            this.rollInstance.negateFactorPenalty(Factor.tier);
          }
        };
        if (Object.hasOwn(negateOperations, param)) {
          return negateOperations[param]();
        } else {
          throw new Error(`Unrecognized Negate parameter: ${param}`);
        }
      } else if (key === "Increase") {
        const [_, traitStr] = /(\w+)\d+/.exec(param) ?? [];
        return this.rollInstance.isTraitRelevant(traitStr);
      } else {
        throw new Error(`Unrecognized Function Key: ${key} (key: ${key})`);
      }
    });
  }
  get selectOptions() {
    if (this.modType !== RollModType.teamwork) {
      return null;
    }
    if (this.name === "Assist" || this.name === "Setup") {
      return this.rollInstance.rollParticipantSelectOptions[this.name];
    } else if (this.name.startsWith("Group_")) {
      return this.rollInstance.rollParticipantSelectOptions.Group;
    }
    return null;
  }
  get selectedParticipant() {
    if (this.modType !== RollModType.teamwork) {
      return null;
    }
    return this.rollInstance.getRollParticipant(this.section, this.name);
  }
  get allFlagData() {
    return this.rollInstance.data;
  }
  get costs() {
    if (!this.isActive) {
      return void 0;
    }
    const holdKeys = this.effectKeys.filter((key) => key.startsWith("Cost"));
    if (holdKeys.length === 0) {
      return void 0;
    }
    return holdKeys.map((key) => {
      const [thisParam] = (key.split(/-/) ?? []).slice(1);
      const [traitStr, valStr] = (/([A-Za-z]+)(\d*)/.exec(thisParam) ?? []).slice(1);
      let label = this.name;
      if (this.isBasicPush) {
        if (this.posNeg === "negative") {
          label = `${this.name} (<span class='red-bright'>To Act</span>)`;
        } else {
          const effect = this.section === RollModSection.roll ? "+1d" : "+1 effect";
          label = `${this.name} (<span class='gold-bright'>${effect}</span>)`;
        }
      }
      return {
        id: this.id,
        label,
        costType: traitStr,
        costAmount: valStr ? U.pInt(valStr) : 1
      };
    });
  }
  get rollInstance() {
    return this._rollInstance;
  }
  get name() {
    return this.data.name;
  }
  get modType() {
    return this.data.modType;
  }
  get sourceName() {
    return this.data.source_name ?? this.data.name;
  }
  get section() {
    return this.data.section;
  }
  get posNeg() {
    return this.data.posNeg;
  }
  get userStatus() {
    return this.data.user_status;
  }
  set userStatus(val) {
    if (val === this.userStatus) {
      return;
    }
    const { isRerendering } = this;
    if (!val || val === this.baseStatus) {
      this.updateTarget("user_status", null).then(() => {
        if (isRerendering) {
          this.rollInstance.renderRollCollab_SocketCall();
        }
      });
    } else {
      if (!game.user.isGM && (BladesRollMod.GMOnlyModStatuses.includes(val) || this.userStatus && BladesRollMod.GMOnlyModStatuses.includes(this.userStatus))) {
        return;
      }
      this.updateTarget("user_status", val).then(() => {
        if (isRerendering) {
          this.rollInstance.renderRollCollab_SocketCall();
        }
      });
    }
  }
  get baseStatus() {
    return this.data.base_status;
  }
  get heldStatus() {
    return this.data.held_status;
  }
  set heldStatus(val) {
    if (val === this.heldStatus) {
      return;
    }
    const { isRerendering } = this;
    if (!val) {
      this.updateTarget("held_status", null).then(() => {
        if (isRerendering) {
          this.rollInstance.renderRollCollab_SocketCall();
        }
      });
    } else {
      this.updateTarget("held_status", val).then(() => {
        if (isRerendering) {
          this.rollInstance.renderRollCollab_SocketCall();
        }
      });
    }
  }
  get value() {
    return this.data.value;
  }
  get effectKeys() {
    return this.data.effectKeys ?? [];
  }
  get sideString() {
    if (this.data.sideString) {
      return this.data.sideString;
    }
    if (this.selectedParticipant) {
      return this.selectedParticipant.rollParticipantName;
    }
    return void 0;
  }
  get tooltip() {
    let parsedTooltip = this.data.tooltip.replace(/%COLON%/g, ":");
    if (parsedTooltip.includes("%DOC_NAME%")) {
      parsedTooltip = parsedTooltip.replace(
        /%DOC_NAME%/g,
        this.selectedParticipant ? this.selectedParticipant.rollParticipantName : "an Ally"
      );
    }
    if (parsedTooltip.includes("@OPPOSITION_NAME@")) {
      parsedTooltip = parsedTooltip.replace(
        /@OPPOSITION_NAME@/g,
        this.rollInstance.rollOpposition ? this.rollInstance.rollOpposition.rollOppName : "Your Opposition"
      );
    }
    return parsedTooltip;
  }
  get conditionalRollTypes() {
    return this.data.conditionalRollTypes ?? [];
  }
  get autoRollTypes() {
    return this.data.autoRollTypes ?? [];
  }
  get participantRollTypes() {
    return this.data.participantRollTypes ?? [];
  }
  get conditionalRollTraits() {
    return this.data.conditionalRollTraits ?? [];
  }
  get autoRollTraits() {
    return this.data.autoRollTraits ?? [];
  }
  get participantRollTraits() {
    return this.data.participantRollTraits ?? [];
  }
}
class BladesRollPrimary {
  constructor(...args) {
    // #endregion
    __publicField(this, "rollInstance");
    __publicField(this, "rollPrimaryID");
    __publicField(this, "_rollPrimaryDoc");
    __publicField(this, "rollPrimaryName");
    __publicField(this, "rollPrimaryType");
    __publicField(this, "rollPrimaryImg");
    __publicField(this, "rollPrimaryModsSchemaSet");
    __publicField(this, "rollFactors");
    let primaryData = false;
    let primaryDoc = false;
    if (args[0] instanceof BladesRoll) {
      this.rollInstance = args[0];
      args.shift();
    }
    if (BladesRollPrimary.IsDoc(args[0])) {
      primaryDoc = args[0];
    } else if (BladesRollPrimary.IsValidData(args[0])) {
      primaryData = args[0];
    } else if (U.isList(args[0])) {
      if ("rollPrimaryID" in args[0]) {
        primaryDoc = BladesRollPrimary.GetDoc(args[0].rollPrimaryID);
      } else if ("rollPrimaryName" in args[0]) {
        primaryDoc = BladesRollPrimary.GetDoc(args[0].rollPrimaryName);
      }
    }
    if (primaryDoc && !BladesRollPrimary.IsValidData(primaryData)) {
      primaryData = {
        rollPrimaryID: primaryDoc.rollPrimaryID,
        rollPrimaryName: primaryDoc.rollPrimaryName,
        rollPrimaryType: primaryDoc.rollPrimaryType,
        rollPrimaryImg: primaryDoc.rollPrimaryImg,
        rollPrimaryModsSchemaSet: primaryDoc.rollPrimaryModsSchemaSet,
        rollFactors: primaryDoc.rollFactors
      };
    }
    if (!BladesRollPrimary.IsValidData(primaryData) && !BladesRollPrimary.IsDoc(primaryDoc) && this.rollInstance) {
      primaryData = this.rollInstance.rollPrimary.data;
    }
    if (!BladesRollPrimary.IsValidData(primaryData)) {
      throw new Error(`[BladesRoll.constructor] Failed to resolve primary data from provided arguments: ${JSON.stringify(args)}`);
    }
    const {
      rollPrimaryID,
      rollPrimaryName,
      rollPrimaryType,
      rollPrimaryImg,
      rollPrimaryModsSchemaSet,
      rollFactors
    } = primaryData;
    this.rollPrimaryID = rollPrimaryID;
    if (!rollPrimaryName) {
      throw new Error("Must include a rollPrimaryName when constructing a BladesRollPrimary object.");
    }
    if (!rollPrimaryImg) {
      throw new Error("Must include a rollPrimaryImg when constructing a BladesRollPrimary object.");
    }
    if (!rollPrimaryType) {
      throw new Error("Must include a rollPrimaryType when constructing a BladesRollPrimary object.");
    }
    if (!rollFactors) {
      throw new Error("Must include a rollFactors when constructing a BladesRollPrimary object.");
    }
    this.rollPrimaryName = rollPrimaryName;
    this.rollPrimaryType = rollPrimaryType;
    this.rollPrimaryImg = rollPrimaryImg;
    this.rollFactors = rollFactors;
    this.rollPrimaryModsSchemaSet = rollPrimaryModsSchemaSet ?? [];
  }
  // #region Static Methods ~
  static IsValidData(data) {
    if (BladesRollPrimary.IsDoc(data)) {
      return false;
    }
    return U.isList(data) && typeof data.rollPrimaryName === "string" && typeof data.rollPrimaryType === "string" && typeof data.rollPrimaryImg === "string" && Array.isArray(data.rollPrimaryModsSchemaSet) && U.isList(data.rollFactors) && (!data.rollPrimaryID || typeof data.rollPrimaryID === "string") && (!data.rollPrimaryDoc || BladesRollPrimary.IsDoc(data.rollPrimaryDoc));
  }
  static GetDoc(docRef) {
    let doc = docRef;
    if (typeof docRef === "string") {
      doc = game.actors.get(docRef) ?? game.items.get(docRef) ?? game.actors.getName(docRef) ?? game.items.getName(docRef);
    }
    return BladesRollPrimary.IsDoc(doc) && doc;
  }
  static IsDoc(doc) {
    return BladesActor$1.IsType(doc, BladesActorType.pc, BladesActorType.crew) || BladesItem$1.IsType(doc, BladesItemType.cohort_expert, BladesItemType.cohort_gang, BladesItemType.gm_tracker);
  }
  static GetDataFromDoc(doc) {
    return {
      rollPrimaryID: doc.id,
      rollPrimaryName: doc.name,
      rollPrimaryType: doc.type,
      rollPrimaryImg: doc.img,
      rollPrimaryModsSchemaSet: doc.rollPrimaryModsSchemaSet,
      rollFactors: doc.rollFactors
    };
  }
  static BuildData(config) {
    if (BladesRollPrimary.IsValidData(config.rollPrimaryData)) {
      return config.rollPrimaryData;
    }
    let rollPrimary;
    const rollUser = game.users.get(config.rollUserID ?? game.user.id);
    if ("target" in config && BladesRollPrimary.IsDoc(config.target)) {
      rollPrimary = config.target;
    } else if (rollUser && BladesRollPrimary.IsDoc(rollUser.character)) {
      rollPrimary = rollUser.character;
    } else {
      throw new Error("[BladesRollPrimary.BuildData()] A valid source of PrimaryData must be provided to construct a roll.");
    }
    return {
      rollPrimaryID: rollPrimary.rollPrimaryID,
      rollPrimaryName: rollPrimary.rollPrimaryName,
      rollPrimaryType: rollPrimary.rollPrimaryType,
      rollPrimaryImg: rollPrimary.rollPrimaryImg,
      rollPrimaryModsSchemaSet: rollPrimary.rollPrimaryModsSchemaSet,
      rollFactors: rollPrimary.rollFactors
    };
  }
  static Build(config) {
    return new BladesRollPrimary(this.BuildData(config));
  }
  get rollPrimaryDoc() {
    if (!this._rollPrimaryDoc) {
      let doc;
      if (this.rollPrimaryID) {
        doc = game.items.get(this.rollPrimaryID) ?? game.actors.get(this.rollPrimaryID);
      }
      if (!doc && this.rollPrimaryName) {
        doc = game.items.getName(this.rollPrimaryName) ?? game.actors.getName(this.rollPrimaryName);
      }
      if (BladesRollPrimary.IsDoc(doc)) {
        this._rollPrimaryDoc = doc;
      }
    }
    return this._rollPrimaryDoc;
  }
  get data() {
    return {
      rollPrimaryID: this.rollPrimaryID,
      rollPrimaryName: this.rollPrimaryName,
      rollPrimaryType: this.rollPrimaryType,
      rollPrimaryImg: this.rollPrimaryImg,
      rollPrimaryModsSchemaSet: this.rollPrimaryModsSchemaSet,
      rollFactors: this.rollFactors
    };
  }
  get isWorsePosition() {
    if (this.rollPrimaryDoc) {
      return this.rollPrimaryDoc.getFlag("eunos-blades", "isWorsePosition") === true;
    }
    return false;
  }
  async applyHarm(amount, name) {
    if (this.rollPrimaryDoc) {
      return this.rollPrimaryDoc.applyHarm(amount, name);
    }
  }
  async applyWorsePosition() {
    if (this.rollPrimaryDoc) {
      return this.rollPrimaryDoc.applyWorsePosition();
    }
  }
  get hasSpecialArmor() {
    return BladesPC$1.IsType(this.rollPrimaryDoc) && this.rollPrimaryDoc.isSpecialArmorAvailable;
  }
  get availableArmorCount() {
    if (BladesPC$1.IsType(this.rollPrimaryDoc)) {
      return this.rollPrimaryDoc.availableArmor.length;
    } else if (BladesItem$1.IsType(this.rollPrimaryDoc, BladesItemType.cohort_gang, BladesItemType.cohort_expert)) {
      return this.rollPrimaryDoc.system.armor.max - this.rollPrimaryDoc.system.armor.value;
    }
    return 0;
  }
  async spendArmor(count) {
    var _a;
    if (!this.rollPrimaryDoc) {
      throw new Error("[BladesRollPrimary.spendArmor()] Cannot spend armor when rollPrimaryDoc is not defined.");
    }
    if (count > this.availableArmorCount) {
      throw new Error(`[BladesRollPrimary.spendArmor()] Cannot spend more armor (${count}) than ${(_a = this.rollPrimaryDoc) == null ? void 0 : _a.name} has (${this.availableArmorCount}).`);
    }
    if (BladesPC$1.IsType(this.rollPrimaryDoc)) {
      const armorToSpend = this.rollPrimaryDoc.availableArmor.slice(0, count);
      const updateData = {};
      if (armorToSpend.includes("Light Armor")) {
        updateData["system.armor.active.light"] = true;
        updateData["system.armor.checked.light"] = true;
      }
      if (armorToSpend.includes("Heavy Armor")) {
        updateData["system.armor.active.heavy"] = true;
        updateData["system.armor.checked.heavy"] = true;
      }
      await this.rollPrimaryDoc.update(updateData);
    } else if (BladesItem$1.IsType(this.rollPrimaryDoc, BladesItemType.cohort_gang, BladesItemType.cohort_expert)) {
      await this.rollPrimaryDoc.update({ "system.armor.value": this.rollPrimaryDoc.system.armor.value + count });
    }
  }
  // #endregion
}
class BladesRollOpposition {
  // #region Constructor ~
  constructor(rollInstance, {
    rollOppID,
    rollOppName,
    rollOppSubName,
    rollOppType,
    rollOppImg,
    rollOppModsSchemaSet,
    rollFactors
  } = {}) {
    // #endregion
    __publicField(this, "rollInstance");
    __publicField(this, "rollOppID");
    __publicField(this, "rollOppDoc");
    __publicField(this, "rollOppName");
    __publicField(this, "rollOppSubName");
    __publicField(this, "rollOppType");
    __publicField(this, "rollOppImg");
    __publicField(this, "rollOppModsSchemaSet");
    __publicField(this, "rollFactors");
    this.rollInstance = rollInstance;
    const doc = BladesRollOpposition.GetDoc(rollOppID ?? rollOppName);
    if (doc) {
      this.rollOppDoc = doc;
      rollOppID = doc.rollOppID;
      rollOppName ?? (rollOppName = doc.rollOppName);
      rollOppSubName ?? (rollOppSubName = doc.rollOppSubName);
      rollOppType ?? (rollOppType = doc.rollOppType);
      rollOppImg ?? (rollOppImg = doc.rollOppImg);
      rollOppModsSchemaSet = [
        ...rollOppModsSchemaSet ?? [],
        ...doc.rollOppModsSchemaSet ?? []
      ];
      rollFactors = {
        ...doc.rollFactors,
        ...rollFactors ?? {}
      };
    }
    if (!rollOppName) {
      throw new Error("Must include a rollOppName when constructing a BladesRollOpposition object.");
    }
    if (!rollOppType) {
      throw new Error("Must include a rollOppType when constructing a BladesRollOpposition object.");
    }
    if (!rollFactors) {
      throw new Error("Must include a rollFactors when constructing a BladesRollOpposition object.");
    }
    this.rollOppID = rollOppID;
    this.rollOppName = rollOppName;
    this.rollOppSubName = rollOppSubName;
    this.rollOppType = rollOppType;
    this.rollOppImg = rollOppImg ?? "";
    this.rollOppModsSchemaSet = rollOppModsSchemaSet ?? [];
    this.rollFactors = rollFactors;
  }
  // #region Static Methods ~
  static IsValidData(data) {
    if (BladesRollOpposition.IsDoc(data)) {
      return true;
    }
    return U.isList(data) && typeof data.rollOppName === "string" && typeof data.rollOppType === "string" && typeof data.rollOppImg === "string" && (!data.rollOppSubName || typeof data.rollOppSubName === "string") && (!data.rollOppModsSchemaSet || Array.isArray(data.rollOppModsSchemaSet)) && U.isList(data.rollFactors) && (!data.rollOppID || typeof data.rollOppID === "string");
  }
  static GetDoc(docRef) {
    let doc = docRef;
    if (typeof docRef === "string") {
      doc = game.actors.get(docRef) ?? game.items.get(docRef) ?? game.actors.getName(docRef) ?? game.items.getName(docRef);
    }
    if (BladesRollOpposition.IsDoc(doc)) {
      return doc;
    }
    return false;
  }
  static IsDoc(doc) {
    return BladesActor$1.IsType(
      doc,
      BladesActorType.npc,
      BladesActorType.faction
    ) || BladesItem$1.IsType(
      doc,
      BladesItemType.cohort_expert,
      BladesItemType.cohort_gang
    );
  }
  static GetDataFromDoc(doc) {
    return {
      rollOppID: doc.id,
      rollOppName: doc.name,
      rollOppType: doc.type,
      rollOppImg: doc.img,
      rollOppModsSchemaSet: doc.rollOppModsSchemaSet,
      rollFactors: doc.rollFactors
    };
  }
  // #endregion
  get data() {
    return {
      rollOppID: this.rollOppID,
      rollOppName: this.rollOppName,
      rollOppSubName: this.rollOppSubName,
      rollOppType: this.rollOppType,
      rollOppImg: this.rollOppImg,
      rollOppModsSchemaSet: this.rollOppModsSchemaSet,
      rollFactors: this.rollFactors
    };
  }
  async updateRollFlags() {
    if (!this.rollInstance) {
      return;
    }
    await this.rollInstance.updateTarget("rollOppData", this.data);
    if (this.rollInstance.isRendered) {
      socketlib.system.executeForEveryone("renderRollCollab_SocketCall", this.rollInstance.id);
    }
  }
  refresh() {
    if (!this.rollInstance) {
      return;
    }
    const rollOppFlags = this.rollInstance.data.rollOppData;
    if (rollOppFlags) {
      this.rollOppID = rollOppFlags.rollOppID;
      this.rollOppName = rollOppFlags.rollOppName;
      this.rollOppSubName = rollOppFlags.rollOppSubName;
      this.rollOppType = rollOppFlags.rollOppType;
      this.rollOppImg = rollOppFlags.rollOppImg;
      this.rollOppModsSchemaSet = rollOppFlags.rollOppModsSchemaSet ?? [];
      this.rollFactors = rollOppFlags.rollFactors;
    }
    return this;
  }
}
class BladesRollParticipant {
  constructor(rollInstance, section, subSection, rollParticipantDataOrDoc) {
    // #endregion
    __publicField(this, "rollInstance");
    __publicField(this, "rollParticipantID");
    __publicField(this, "rollParticipantDoc");
    __publicField(this, "rollParticipantName");
    __publicField(this, "rollParticipantType");
    __publicField(this, "rollParticipantIcon");
    __publicField(this, "rollParticipantSection");
    __publicField(this, "rollParticipantSubSection");
    __publicField(this, "rollParticipantModsSchemaSet");
    // As applied to MAIN roll when this participant involved
    __publicField(this, "rollFactors");
    this.rollInstance = rollInstance;
    if (!section) {
      throw new Error("Must include a rollParticipantSection when constructing a BladesRollParticipant object.");
    }
    if (!subSection) {
      throw new Error("Must include a rollParticipantSubSection when constructing a BladesRollParticipant object.");
    }
    this.rollParticipantSection = section;
    this.rollParticipantSubSection = subSection;
    const doc = BladesRollParticipant.IsDoc(rollParticipantDataOrDoc) ? rollParticipantDataOrDoc : BladesRollParticipant.GetDoc(
      rollParticipantDataOrDoc.rollParticipantID ?? rollParticipantDataOrDoc.rollParticipantName
    );
    if (doc) {
      rollParticipantDataOrDoc = doc;
    }
    if (!rollParticipantDataOrDoc.rollParticipantName) {
      throw new Error("Must include a rollParticipantName when constructing a BladesRollParticipant object.");
    }
    if (!rollParticipantDataOrDoc.rollParticipantType) {
      throw new Error("Must include a rollParticipantType when constructing a BladesRollParticipant object.");
    }
    if (!rollParticipantDataOrDoc.rollFactors) {
      throw new Error("Must include a rollFactors when constructing a BladesRollParticipant object.");
    }
    this.rollParticipantID = rollParticipantDataOrDoc.rollParticipantID;
    this.rollParticipantName = rollParticipantDataOrDoc.rollParticipantName;
    this.rollParticipantType = rollParticipantDataOrDoc.rollParticipantType;
    this.rollParticipantIcon = rollParticipantDataOrDoc.rollParticipantIcon ?? "";
    this.rollParticipantModsSchemaSet = rollParticipantDataOrDoc.rollParticipantModsSchemaSet ?? [];
    this.rollFactors = rollParticipantDataOrDoc.rollFactors;
  }
  // #region Static Methods ~
  static IsValidData(data) {
    if (BladesRollParticipant.IsDoc(data)) {
      return true;
    }
    return U.isList(data) && typeof data.rollParticipantName === "string" && typeof data.rollParticipantType === "string" && typeof data.rollParticipantIcon === "string" && (!data.rollParticipantModsSchemaSet || Array.isArray(data.rollParticipantModsSchemaSet)) && U.isList(data.rollFactors) && (!data.rollParticipantID || typeof data.rollParticipantID === "string") && (!data.rollParticipantDoc || BladesRollParticipant.IsDoc(data.rollParticipantDoc));
  }
  static GetDoc(docRef) {
    let doc = docRef;
    if (typeof docRef === "string") {
      doc = game.actors.get(docRef) ?? game.items.get(docRef) ?? game.actors.getName(docRef) ?? game.items.getName(docRef);
    }
    if (BladesRollParticipant.IsDoc(doc)) {
      return doc;
    }
    return false;
  }
  static IsDoc(doc) {
    return BladesActor$1.IsType(doc, BladesActorType.pc, BladesActorType.crew, BladesActorType.npc) || BladesItem$1.IsType(doc, BladesItemType.cohort_expert, BladesItemType.cohort_gang, BladesItemType.gm_tracker);
  }
  // #endregion
  get data() {
    return {
      rollParticipantID: this.rollParticipantID,
      rollParticipantName: this.rollParticipantName,
      rollParticipantType: this.rollParticipantType,
      rollParticipantIcon: this.rollParticipantIcon,
      rollParticipantModsSchemaSet: this.rollParticipantModsSchemaSet,
      rollFactors: this.rollFactors
    };
  }
  async updateRollFlags() {
    await this.rollInstance.updateTarget(`rollParticipantData.${this.rollParticipantSection}.${this.rollParticipantSubSection}`, this.data);
    if (this.rollInstance.isRendered) {
      socketlib.system.executeForEveryone("renderRollCollab_SocketCall", this.rollInstance.id);
    }
  }
  refresh() {
    var _a;
    const rollParticipantFlagData = (_a = this.rollInstance.data.rollParticipantData) == null ? void 0 : _a[this.rollParticipantSection];
    if (rollParticipantFlagData && this.rollParticipantSubSection in rollParticipantFlagData) {
      const rollParticipantFlags = rollParticipantFlagData[this.rollParticipantSubSection];
      if (rollParticipantFlags) {
        this.rollParticipantID = rollParticipantFlags.rollParticipantID;
        this.rollParticipantName = rollParticipantFlags.rollParticipantName;
        this.rollParticipantType = rollParticipantFlags.rollParticipantType;
        this.rollParticipantIcon = rollParticipantFlags.rollParticipantIcon;
        this.rollParticipantModsSchemaSet = rollParticipantFlags.rollParticipantModsSchemaSet ?? [];
        this.rollFactors = rollParticipantFlags.rollFactors;
      }
    }
    return this;
  }
}
const _BladesRoll = class _BladesRoll extends BladesTargetLink {
  constructor(dataOrConfig) {
    super(dataOrConfig);
    // #endregion
    // #region *** CONSTRUCTOR *** ~
    __publicField(this, "rollPermission");
    __publicField(this, "_rollPrimary");
    __publicField(this, "_rollOpposition");
    __publicField(this, "_rollParticipants");
    __publicField(this, "projectSelectOptions");
    __publicField(this, "_rollTraitValOverride");
    __publicField(this, "_roll");
    __publicField(this, "rollFactorPenaltiesNegated", {});
    __publicField(this, "tempGMBoosts", {});
    __publicField(this, "getModsDelta", (cat) => {
      return U.sum([
        ...this.getActiveRollMods(cat, "positive").map((mod) => mod.value),
        ...this.getActiveRollMods(cat, "negative").map((mod) => -mod.value)
      ]);
    });
    __publicField(this, "_rollMods");
    // #endregion
    // #region *** EVALUATING ROLL *** ~
    // #region DICE ~
    __publicField(this, "_dieVals");
    // #endregion
    // #region *** ROLL COLLAB HTML ELEMENT ***
    __publicField(this, "_elem$");
    __publicField(this, "_overlayPosition", { x: 200, y: 200 });
    // Async _gmControlSelect(event: SelectChangeEvent) {
    //   event.preventDefault();
    //   const elem$ = $(event.currentTarget);
    //   const section = elem$.data("rollSection");
    //   const subSection = elem$.data("rollSubSection");
    //   const selectedOption = elem$.val();
    //   if (typeof selectedOption !== "string") { return; }
    //   if (selectedOption === "false") {
    //     await this.document.unsetFlag(C.SYSTEM_ID, `rollCollab.rollParticipantData.${section}.${subSection}`);
    //   }
    //   await this.addRollParticipant(selectedOption, section, subSection);
    // }
    // #endregion
    // #region ACTIVATE LISTENERS ~
    __publicField(this, "_positionDragger");
    this.rollPermission = this.data.userPermissions[game.user.id];
    this._rollPrimary = new BladesRollPrimary(this, this.data.rollPrimaryData);
    if (this.data.rollOppData) {
      this._rollOpposition = new BladesRollOpposition(this, this.data.rollOppData);
    } else if (this.data.rollDowntimeAction === DowntimeAction.LongTermProject) {
      this.projectSelectOptions = Array.from(game.items).filter((item) => BladesItem$1.IsType(item, BladesItemType.project)).map((project) => ({ value: project.id ?? "", display: project.name }));
    }
    if (this.data.rollParticipantData) {
      this._rollParticipants = {};
      for (const [rollSection, rollParticipantList] of Object.entries(this.data.rollParticipantData)) {
        if ([RollModSection.roll, RollModSection.position, RollModSection.effect].includes(rollSection) && !U.isEmpty(rollParticipantList)) {
          const sectionParticipants = {};
          for (const [participantType, participantData] of Object.entries(rollParticipantList)) {
            sectionParticipants[participantType] = new BladesRollParticipant(
              this,
              rollSection,
              participantType,
              participantData
            );
          }
          this._rollParticipants[rollSection] = sectionParticipants;
        }
      }
    }
    game.eunoblades.Rolls.set(this.id, this);
  }
  // #region STATIC METHODS: INITIALIZATION & DEFAULTS ~
  static Initialize() {
    return loadTemplates([
      "systems/eunos-blades/templates/roll/partials/roll-collab-gm-number-line.hbs",
      "systems/eunos-blades/templates/roll/partials/roll-collab-gm-select-doc.hbs",
      "systems/eunos-blades/templates/roll/partials/roll-collab-gm-factor-control.hbs",
      "systems/eunos-blades/templates/roll/roll-collab-action.hbs",
      "systems/eunos-blades/templates/roll/roll-collab-action-gm.hbs",
      "systems/eunos-blades/templates/roll/roll-collab-resistance.hbs",
      "systems/eunos-blades/templates/roll/roll-collab-resistance-gm.hbs",
      "systems/eunos-blades/templates/roll/roll-collab-fortune.hbs",
      "systems/eunos-blades/templates/roll/roll-collab-fortune-gm.hbs",
      "systems/eunos-blades/templates/roll/roll-collab-indulgevice.hbs",
      "systems/eunos-blades/templates/roll/roll-collab-indulgevice-gm.hbs"
    ]);
  }
  static InitSockets() {
    socketlib.system.register("constructRollCollab_SocketCall", _BladesRoll.constructRollCollab_SocketResponse.bind(_BladesRoll));
    socketlib.system.register("renderRollCollab_SocketCall", _BladesRoll.renderRollCollab_SocketResponse.bind(_BladesRoll));
    socketlib.system.register("closeRollCollab_SocketCall", _BladesRoll.closeRollCollab_SocketResponse.bind(_BladesRoll));
  }
  static ParseConfigToData(data, parentRollData) {
    const parentRollInst = game.eunoblades.Rolls.get(parentRollData.id);
    if (!parentRollInst) {
      throw new Error(`[BladesRoll.ParseConfigToData] No BladesRoll instance found with id ${parentRollData.id}.`);
    }
    if (data.rollPrimaryData instanceof BladesRollPrimary) {
      data.rollPrimaryData = data.rollPrimaryData.data;
    }
    if (data.rollOppData instanceof BladesRollOpposition) {
      data.rollOppData = data.rollOppData.data;
    }
    if (data.rollParticipantData) {
      if (data.rollParticipantData[RollModSection.roll]) {
        Object.keys(data.rollParticipantData[RollModSection.roll]).forEach((key) => {
          var _a, _b;
          const thisParticipant = (_b = (_a = data.rollParticipantData) == null ? void 0 : _a[RollModSection.roll]) == null ? void 0 : _b[key];
          if (thisParticipant instanceof BladesRollParticipant) {
            data.rollParticipantData[RollModSection.roll][key] = thisParticipant.data;
          }
        });
      }
      if (data.rollParticipantData[RollModSection.position]) {
        Object.keys(data.rollParticipantData[RollModSection.position]).forEach((key) => {
          var _a, _b;
          const thisParticipant = (_b = (_a = data.rollParticipantData) == null ? void 0 : _a[RollModSection.position]) == null ? void 0 : _b[key];
          if (thisParticipant instanceof BladesRollParticipant) {
            data.rollParticipantData[RollModSection.position][key] = thisParticipant.data;
          }
        });
      }
      if (data.rollParticipantData[RollModSection.effect]) {
        Object.keys(data.rollParticipantData[RollModSection.effect]).forEach((key) => {
          var _a, _b;
          const thisParticipant = (_b = (_a = data.rollParticipantData) == null ? void 0 : _a[RollModSection.effect]) == null ? void 0 : _b[key];
          if (thisParticipant instanceof BladesRollParticipant) {
            data.rollParticipantData[RollModSection.effect][key] = thisParticipant.data;
          }
        });
      }
    }
    return super.ParseConfigToData(data);
  }
  static ApplySchemaDefaults(schemaData) {
    if (!schemaData.rollType) {
      throw new Error("Must include a rollType when constructing a BladesRoll object.");
    }
    schemaData.rollPhase ?? (schemaData.rollPhase = RollPhase.Collaboration);
    schemaData.GMBoosts = {
      [Factor.tier]: 0,
      [Factor.quality]: 0,
      [Factor.scale]: 0,
      [Factor.magnitude]: 0,
      ...schemaData.GMBoosts ?? {}
    };
    schemaData.GMOppBoosts = {
      [Factor.tier]: 0,
      [Factor.quality]: 0,
      [Factor.scale]: 0,
      [Factor.magnitude]: 0,
      ...schemaData.GMOppBoosts ?? {}
    };
    schemaData.GMOverrides ?? (schemaData.GMOverrides = {});
    schemaData.userPermissions ?? (schemaData.userPermissions = {});
    if (schemaData.rollPrimaryData instanceof BladesRollPrimary) {
      schemaData.rollPrimaryData = schemaData.rollPrimaryData.data;
    }
    if (schemaData.rollOppData instanceof BladesRollOpposition) {
      schemaData.rollOppData = schemaData.rollOppData.data;
    }
    return schemaData;
  }
  // static override get defaultOptions() {
  //   return foundry.utils.mergeObject(super.defaultOptions, {
  //     classes: ["eunos-blades", "sheet", "roll-collab", game.user.isGM ? "gm-roll-collab" : ""],
  //     template: `systems/eunos-blades/templates/roll/roll-collab${game.user.isGM ? "-gm" : ""}.hbs`,
  //     submitOnChange: true,
  //     width: 500,
  //     dragDrop: [
  //       {dragSelector: null, dropSelector: "[data-action='gm-drop-opposition'"}
  //     ]
  //     // Height: 500
  //   });
  // }
  static get DefaultRollModSchemaSet() {
    return [];
  }
  static GetDieClass(rollType, rollResult, dieVal, dieIndex) {
    switch (rollType) {
      case RollType.Resistance: {
        if (dieVal === 6 && dieIndex <= 1 && rollResult === -1) {
          return "blades-die-critical";
        }
        if (dieIndex === 0) {
          return "blades-die-resistance";
        }
        return "blades-die-fail";
      }
      case RollType.IndulgeVice: {
        if (dieIndex === 0) {
          return "blades-die-indulge-vice";
        }
        return "blades-die-fail";
      }
    }
    if (dieVal === 6 && dieIndex <= 1 && rollResult === RollResult.critical) {
      dieVal++;
    }
    return [
      "",
      "blades-die-fail",
      "blades-die-fail",
      "blades-die-fail",
      "blades-die-partial",
      "blades-die-partial",
      "blades-die-success",
      "blades-die-critical"
    ][dieVal];
  }
  static GetDieImage(rollType, rollResult, dieVal, dieIndex, isGhost = false, isCritical = false) {
    let imgPath = "systems/eunos-blades/assets/dice/image/";
    if (isGhost) {
      imgPath += "ghost-";
    } else if ([RollType.Resistance, RollType.IndulgeVice].includes(rollType)) {
      imgPath += "grad-";
    }
    imgPath += dieVal;
    if (!isGhost && dieVal === 6 && dieIndex <= 1 && isCritical) {
      imgPath += "-crit";
    }
    imgPath += ".webp";
    return imgPath;
  }
  static get Active() {
    return U.getLast(game.eunoblades.Rolls.filter((roll) => roll.isActive));
  }
  // #endregion
  // #region STATIC METHODS: New Roll Creation ~
  // static Current: Record<string, BladesRoll> = {};
  // static _Active?: BladesRoll;
  // static get Active(): BladesRoll | undefined {
  //   if (BladesRoll._Active) {return BladesRoll._Active;}
  //   if (U.objSize(BladesRoll.Current) > 0) {return U.getLast(Object.values(BladesRoll.Current));}
  //   return undefined;
  // }
  // static set Active(val: BladesRoll | undefined) {
  //   BladesRoll._Active = val;
  // }
  static GetUserPermissions(config) {
    var _a, _b, _c, _d;
    if (!config.rollPrimaryData) {
      throw new Error("[BladesRoll.GetUserPermissions()] Missing rollPrimaryData.");
    }
    const GMUserID = (_a = game.users.find((user) => user.isGM)) == null ? void 0 : _a.id;
    if (!GMUserID) {
      throw new Error("[BladesRoll.GetUserPermissions()] No GM found!");
    }
    const playerUserIDs = game.users.filter((user) => BladesPC$1.IsType(user.character) && !user.isGM && typeof user.id === "string").map((user) => user.id);
    const userIDs = {
      [RollPermissions.GM]: [GMUserID],
      [RollPermissions.Primary]: [],
      [RollPermissions.Participant]: [],
      [RollPermissions.Observer]: []
    };
    const { rollPrimaryDoc } = new BladesRollPrimary(config.rollPrimaryData);
    if (BladesPC$1.IsType(rollPrimaryDoc) && U.pullElement(playerUserIDs, (_b = rollPrimaryDoc.primaryUser) == null ? void 0 : _b.id)) {
      userIDs[RollPermissions.Primary].push((_c = rollPrimaryDoc.primaryUser) == null ? void 0 : _c.id);
    } else if (BladesCrew$1.IsType(rollPrimaryDoc)) {
      userIDs[RollPermissions.Primary].push(...playerUserIDs);
    } else if (BladesItem$1.IsType(rollPrimaryDoc, BladesItemType.cohort_gang, BladesItemType.cohort_expert)) {
      if (config.rollUserID === GMUserID) {
        userIDs[RollPermissions.Primary].push(...playerUserIDs);
      } else if (BladesPC$1.IsType(rollPrimaryDoc.parent) && ((_d = rollPrimaryDoc.parent.primaryUser) == null ? void 0 : _d.id)) {
        userIDs[RollPermissions.Primary].push(rollPrimaryDoc.parent.primaryUser.id);
      }
    } else if (BladesGMTracker.IsType(rollPrimaryDoc)) {
      userIDs[RollPermissions.Primary].push(GMUserID);
    }
    if (config.rollParticipantData) {
      userIDs[RollPermissions.Participant].push(...getParticipantDocUserIDs(config.rollParticipantData, playerUserIDs));
    }
    userIDs[RollPermissions.Observer] = playerUserIDs.filter((uID) => !userIDs[RollPermissions.Participant].includes(uID));
    const userFlagData = {};
    Object.entries(userIDs).forEach(([rollPermission, idsArray]) => {
      for (const id of idsArray) {
        userFlagData[id] = rollPermission;
      }
    });
    return userFlagData;
    function getParticipantDocs(participantData) {
      return Object.values(flattenObject(participantData)).map((pData) => {
        if (BladesRollParticipant.IsDoc(pData)) {
          return pData;
        }
        if (BladesRollParticipant.IsValidData(pData)) {
          if (typeof pData.rollParticipantID === "string") {
            const pDoc = game.actors.get(pData.rollParticipantID) ?? game.items.get(pData.rollParticipantID);
            if (BladesRollParticipant.IsDoc(pDoc)) {
              return pDoc;
            }
          }
        }
        throw new Error(`[getParticipantDocs] Invalid participant data encountered. Data: ${JSON.stringify(pData)}, Expected: "BladesRollParticipant or valid participant data", Function Context: "getParticipantDocs", Participant Data: ${JSON.stringify(participantData)}`);
      });
    }
    function getParticipantDocUserIDs(participantData, unassignedIDs) {
      return getParticipantDocs(participantData).map((pDoc) => {
        var _a2;
        if (BladesPC$1.IsType(pDoc) && typeof ((_a2 = pDoc.primaryUser) == null ? void 0 : _a2.id) === "string") {
          return pDoc.primaryUser.id;
        } else if (BladesCrew$1.IsType(pDoc) || BladesItem$1.IsType(pDoc, BladesItemType.cohort_gang, BladesItemType.cohort_expert)) {
          return unassignedIDs;
        }
        return null;
      }).flat().filter((pUser) => pUser !== null && !userIDs[RollPermissions.Primary].includes(pUser));
    }
  }
  static BuildLinkConfig(config) {
    const partialLinkConfig = {};
    if ("targetKey" in config && config.targetKey) {
      partialLinkConfig.targetKey = config.targetKey;
    } else if ("targetFlagKey" in config && config.targetFlagKey) {
      partialLinkConfig.targetFlagKey = config.targetFlagKey;
    }
    if ("target" in config) {
      if (U.isDocUUID(config.target)) {
        partialLinkConfig.targetID = config.target;
      } else if (U.isDocID(config.target)) {
        const confTarget = game.actors.get(config.target) ?? game.items.get(config.target) ?? game.messages.get(config.target) ?? game.users.get(config.target);
        if (confTarget) {
          partialLinkConfig.targetID = confTarget.uuid;
        } else {
          throw new Error(`[BladesRoll.BuildLinkConfig] No target found with id ${config.target}.`);
        }
      } else {
        partialLinkConfig.targetID = config.target.uuid;
      }
    } else if ("targetID" in config) {
      partialLinkConfig.targetID = config.targetID;
    } else {
      throw new Error("[BladesRoll.BuildLinkConfig] You must provide a valid target or targetID in the config object.");
    }
    if (!partialLinkConfig.targetKey && !partialLinkConfig.targetFlagKey) {
      partialLinkConfig.targetFlagKey = "rollCollab";
    }
    if (BladesTargetLink.IsValidConfig(partialLinkConfig)) {
      return BladesTargetLink.BuildLinkConfig(partialLinkConfig);
    }
    throw new Error("[BladesRoll.BuildLinkConfig] Invalid link config.");
  }
  /**
   * Asynchronously creates a new instance of `BladesRoll` or its subclasses.
   *
   * This generic static method is designed to facilitate the creation of roll instances with
   * configurations specific to the type of roll being created. It ensures that the correct type
   * of roll instance is returned based on the class it's called on, allowing for a flexible and
   * type-safe creation process that can be extended to subclasses of `BladesRoll`.
   *
   * @template C The class on which `New` is called. This class must extend `BladesRoll` and
   * must be constructible with a configuration object that is either a `BladesRoll.Config` or
   * a combination of `BladesTargetLink.Data` and a partial `BladesRoll.Schema`. This ensures
   * that any subclass of `BladesRoll` can use this method to create instances of itself while
   * applying any class-specific configurations or behaviors.
   *
   * @param {BladesRoll.Config} config The configuration object for creating a new roll instance.
   * This configuration includes all necessary data to initialize the roll, such as user permissions,
   * roll type, and any modifications or additional data required for the roll's operation.
   *
   * @returns {Promise<InstanceType<C>>} A promise that resolves to an instance of the class
   * from which `New` was called. This allows for the dynamic creation of roll instances based
   * on the subclass calling the method, ensuring that the returned instance is of the correct type.
   *
   * @example
   * // Assuming `MyCustomRoll` is a subclass of `BladesRoll`
   * MyCustomRoll.New(myConfig).then(instance => {
   *   // `instance` is of type `MyCustomRoll`
   * });
   *
   * @remarks
   * - The method performs several key operations as part of the roll instance creation process:
   *   1. Builds link configuration based on the provided config.
   *   2. Prepares roll user flag data to determine permissions for different users.
   *   3. Validates that a roll type is defined in the config, throwing an error if not.
   *   4. Logs the roll data for debugging or auditing purposes.
   *   5. Constructs and initializes the roll instance, including setting up roll modifications
   *      and sending out socket calls to inform all users about the roll.
   * - This method is central to the dynamic and flexible creation of roll instances within the
   *   system, allowing for easy extension and customization in subclasses of `BladesRoll`.
   */
  static async New(config) {
    const linkConfig = this.BuildLinkConfig(config);
    config.userPermissions = this.GetUserPermissions(config);
    if (!config.rollType) {
      throw new Error("rollType must be defined in config");
    }
    eLog.checkLog3("bladesRoll", "BladesRoll.NewRoll()", { config });
    const rollInst = await this.Create({ ...config, ...linkConfig });
    if (!rollInst.isInitPromiseResolved) {
      eLog.checkLog3("bladesRoll", "BladesRoll Init Promise NOT Resolved After Awaiting Create");
      await U.waitFor(rollInst.initPromise);
    } else {
      eLog.checkLog3("bladesRoll", "BladesRoll Init Promise Resolved After Awaiting Create");
    }
    rollInst.constructRollCollab_SocketCall(rollInst.linkData);
    return rollInst;
  }
  async initTargetLink() {
    this.initialSchema.rollModsData = this.rollModsDataSet;
    super.initTargetLink();
  }
  get rollModsSchemaSets() {
    var _a;
    const compiledModSchemaSets = [];
    if (this.rollPrimary) {
      compiledModSchemaSets.push(
        ...this.rollPrimary.rollPrimaryModsSchemaSet.filter((pSchema) => compiledModSchemaSets.every((mSchema) => mSchema.key !== pSchema.key))
      );
    }
    if ((_a = this.rollOpposition) == null ? void 0 : _a.rollOppModsSchemaSet) {
      compiledModSchemaSets.push(
        ...this.rollOpposition.rollOppModsSchemaSet.filter((oSchema) => compiledModSchemaSets.every((mSchema) => mSchema.key !== oSchema.key))
      );
    }
    compiledModSchemaSets.push(...this.constructor.DefaultRollModSchemaSet.filter((dSchema) => compiledModSchemaSets.every((mSchema) => mSchema.key !== dSchema.key)));
    if (this.rollDowntimeAction) {
      compiledModSchemaSets.push({
        key: "HelpFromFriend-positive-roll",
        name: "Help From a Friend",
        section: RollModSection.position,
        base_status: RollModStatus.ToggledOff,
        posNeg: "positive",
        modType: RollModType.general,
        value: 1,
        effectKeys: [],
        tooltip: "<h1>Help From a Friend</h1><p>Add <strong>+1d</strong> if you enlist the help of a friend or contact.</p>"
      });
      if (this.rollDowntimeAction !== DowntimeAction.IndulgeVice) {
        compiledModSchemaSets.push({
          key: "CanBuyResultLevel-positive-after",
          name: "Buying Result Level",
          section: RollModSection.after,
          base_status: RollModStatus.ForcedOn,
          posNeg: "positive",
          modType: RollModType.general,
          value: 0,
          effectKeys: [],
          tooltip: '<h1>Buying Result Level</h1><p>After your roll, you can <strong>increase the result level</strong> by one for each <strong class="gold-bright">Coin</strong> you spend.</p>'
        });
      }
      if (this.rollDowntimeAction === DowntimeAction.AcquireAsset) {
        compiledModSchemaSets.push(
          {
            key: "RepeatPurchase-positive-roll",
            name: "Repeat Purchase",
            section: RollModSection.roll,
            base_status: RollModStatus.ToggledOff,
            posNeg: "positive",
            modType: RollModType.general,
            value: 1,
            effectKeys: [],
            tooltip: "<h1>Repeat Purchase Bonus</h1><p>Add <strong>+1d</strong> if you have previously acquired this asset or service with a <strong>Acquire Asset</strong> Downtime activity.</p>"
          },
          {
            key: "RestrictedItem-negative-after",
            name: "Restricted",
            section: RollModSection.after,
            base_status: RollModStatus.Hidden,
            posNeg: "negative",
            modType: RollModType.general,
            value: 0,
            effectKeys: ["Cost-Heat2"],
            tooltip: '<h1>Restricted</h1><p>Whether contraband goods or dangerous materials, this <strong>Acquire Asset</strong> Downtime activity will add <strong class="red-bright">+2 Heat</strong> to your crew.</p>'
          }
        );
      }
    }
    return compiledModSchemaSets;
  }
  get rollModsDataSet() {
    const { linkData } = this;
    const modLinkConfig = {
      targetID: linkData.targetID,
      isScopingById: true,
      ..."targetKey" in linkData ? { targetKey: `${this.targetKeyPrefix}.rollModsData` } : {},
      ..."targetFlagKey" in linkData ? { targetFlagKey: `${this.targetFlagKeyPrefix}.rollModsData` } : {}
    };
    return Object.fromEntries(
      this.rollModsSchemaSets.map((modSchema) => {
        const modData = BladesTargetLink.ParseConfigToData(
          {
            ...BladesRollMod.ApplySchemaDefaults(modSchema),
            ...modLinkConfig
          }
        );
        return [modData.id, modData];
      })
    );
  }
  // #endregion
  // #region SOCKET CALLS & RESPONSES ~
  static GetRollSubClass(linkData) {
    const targetLink = new BladesTargetLink(linkData);
    switch (targetLink.data.rollType) {
      case RollType.Action:
        return BladesActionRoll;
      case RollType.Fortune: {
        if (targetLink.data.rollSubType === RollSubType.Engagement) {
          return BladesEngagementRoll;
        } else if (targetLink.data.rollSubType === RollSubType.Incarceration) {
          return BladesIncarcerationRoll;
        }
        return BladesFortuneRoll;
      }
      case RollType.Resistance: {
        if (targetLink.data.isInlineResistanceRoll) {
          return BladesInlineResistanceRoll;
        }
        return BladesResistanceRoll;
      }
      case RollType.IndulgeVice:
        return BladesIndulgeViceRoll;
    }
  }
  constructRollCollab_SocketCall(linkData) {
    socketlib.system.executeForEveryone("constructRollCollab_SocketCall", linkData);
  }
  static constructRollCollab_SocketResponse(linkData) {
    const rollInst = new (this.GetRollSubClass(linkData))(linkData);
    eLog.checkLog3("rollCollab", "constructRollCollab_SocketResponse()", { params: { linkData }, rollInst });
    this.renderRollCollab_SocketResponse(rollInst.id);
  }
  renderRollCollab_SocketCall() {
    socketlib.system.executeForEveryone("renderRollCollab_SocketCall", this.id);
  }
  static renderRollCollab_SocketResponse(id) {
    const rollInst = game.eunoblades.Rolls.get(id);
    if (!rollInst) {
      throw new Error(`[BladesRoll.renderRollCollab_SocketResponse] No roll found with id ${id}.`);
    }
    rollInst.renderRollCollab();
  }
  closeRollCollab_Animation() {
    return U.gsap.effects.blurRemove(this.elem$, { ignoreMargins: true });
  }
  async closeRollCollab_SocketCall() {
    if (!game.user.isGM) {
      return;
    }
    socketlib.system.executeForOthers("closeRollCollab_SocketCall", this.id);
    await U.waitFor(this.closeRollCollab_Animation());
  }
  static closeRollCollab_SocketResponse(id) {
    var _a;
    (_a = game.eunoblades.Rolls.get(id)) == null ? void 0 : _a.closeRollCollab_Animation();
  }
  // #endregion
  // #region Roll Participation & User Permissions
  async addRollParticipant(participantRef, rollSection, rollSubSection) {
    if (!rollSubSection) {
      rollSubSection = "Assist";
    }
    const participantData = typeof participantRef === "string" ? game.actors.get(participantRef) ?? game.actors.getName(participantRef) ?? game.items.get(participantRef) ?? game.items.getName(participantRef) : participantRef;
    if (!BladesRollParticipant.IsValidData(participantData)) {
      throw new Error("Bad data.");
    }
    const rollParticipant = new BladesRollParticipant(this, rollSection, rollSubSection, participantData);
    await rollParticipant.updateRollFlags();
    if (this.isRendered) {
      socketlib.system.executeForEveryone("renderRollCollab_SocketCall", this.id);
    }
  }
  async removeRollParticipant(rollSection, rollSubSection) {
    await this.updateTarget(`rollParticipantData.${rollSection}.${rollSubSection}`, null);
  }
  async updateUserPermission(_user, _permission) {
  }
  // #endregion
  // #region Basic User Flag Getters/Setters ~
  // get data(): BladesRoll.FlagData {
  //   if (!this.document.getFlag(C.SYSTEM_ID, "rollCollab")) {
  //     throw new Error("[get flags()] No RollCollab Flags Found on User Document");
  //   }
  //   return this.document.getFlag(C.SYSTEM_ID, "rollCollab") as BladesRoll.FlagData;
  // }
  get rollPrimary() {
    return this._rollPrimary;
  }
  get rollPrimaryDoc() {
    return this.rollPrimary.rollPrimaryDoc;
  }
  get rollOpposition() {
    var _a;
    if (!this._rollOpposition && BladesRollOpposition.IsValidData(this.data.rollOppData)) {
      this._rollOpposition = new BladesRollOpposition(this, this.data.rollOppData);
    }
    return (_a = this._rollOpposition) == null ? void 0 : _a.refresh();
  }
  set rollOpposition(val) {
    if (val === void 0) {
      this._rollOpposition = void 0;
    } else {
      this._rollOpposition = val;
      val.updateRollFlags();
    }
  }
  get rollClockKey() {
    return this.data.rollClockKey ? game.eunoblades.ClockKeys.get(this.data.rollClockKey) : void 0;
  }
  set rollClockKey(val) {
    this.updateTarget("rollClockKeyID", val ?? null);
  }
  /**
   * This method prepares the roll participant data.
   * It iterates over the roll sections (roll, position, effect) and for each section,
   * it creates a new BladesRollParticipant instance for each participant in that section.
   * The created instances are stored in the rollParticipants object.
   */
  prepareRollParticipantData() {
    const participantFlagData = this.data.rollParticipantData;
    if (!participantFlagData) {
      return;
    }
    const rollParticipants = {};
    [
      RollModSection.roll,
      RollModSection.position,
      RollModSection.effect
    ].forEach((rollSection) => {
      const sectionFlagData = participantFlagData[rollSection];
      if (sectionFlagData) {
        const sectionParticipants = {};
        Object.entries(sectionFlagData).forEach(([subSection, subSectionFlagData]) => {
          if (subSectionFlagData) {
            sectionParticipants[subSection] = new BladesRollParticipant(this, rollSection, subSection, subSectionFlagData);
          }
        });
        rollParticipants[rollSection] = sectionParticipants;
      }
    });
    this._rollParticipants = rollParticipants;
  }
  get rollParticipants() {
    return this._rollParticipants;
  }
  getRollParticipant(section, subSection) {
    var _a;
    if (isParticipantSection(section) && isParticipantSubSection(subSection)) {
      const sectionData = (_a = this.rollParticipants) == null ? void 0 : _a[section];
      if (sectionData) {
        return sectionData[subSection] ?? null;
      }
    }
    return null;
  }
  get rollParticipantSelectOptions() {
    const nonPrimaryPCs = BladesPC$1.All.filter((actor) => actor.hasTag(Tag.PC.ActivePC) && actor.id !== this.rollPrimary.rollPrimaryID).map((actor) => ({ value: actor.id, display: actor.name }));
    return {
      Assist: nonPrimaryPCs,
      Setup: nonPrimaryPCs,
      Group: nonPrimaryPCs
    };
  }
  get rollType() {
    return this.data.rollType;
  }
  get rollSubType() {
    return this.data.rollSubType;
  }
  set rollSubType(val) {
    this.updateTarget("rollSubType", val ?? null);
  }
  get rollPhase() {
    return this.data.rollPhase ?? RollPhase.Collaboration;
  }
  get rollDowntimeAction() {
    return this.data.rollDowntimeAction;
  }
  get rollTrait() {
    return this.data.rollTrait;
  }
  get rollTraitVerb() {
    if (!this.rollTrait) {
      return void 0;
    }
    if (!(this.rollTrait in C.ActionVerbs)) {
      return void 0;
    }
    return C.ActionVerbs[this.rollTrait];
  }
  get rollTraitPastVerb() {
    if (!this.rollTrait) {
      return void 0;
    }
    if (!(this.rollTrait in C.ActionPastVerbs)) {
      return void 0;
    }
    return C.ActionPastVerbs[this.rollTrait];
  }
  get rollTraitValOverride() {
    return this._rollTraitValOverride;
  }
  set rollTraitValOverride(val) {
    this._rollTraitValOverride = val;
  }
  get rollTraitData() {
    var _a, _b;
    if (BladesActor$1.IsType(this.rollPrimaryDoc, BladesActorType.pc)) {
      if (isAction(this.rollTrait)) {
        return {
          name: this.rollTrait,
          value: this.rollTraitValOverride ?? this.rollPrimaryDoc.actions[this.rollTrait],
          max: this.rollTraitValOverride ?? this.rollPrimaryDoc.actions[this.rollTrait],
          pcTooltip: this.rollPrimaryDoc.rollTraitPCTooltipActions,
          gmTooltip: C.ActionTooltipsGM[this.rollTrait]
        };
      }
      if (isAttribute(this.rollTrait)) {
        return {
          name: this.rollTrait,
          value: this.rollTraitValOverride ?? this.rollPrimaryDoc.attributes[this.rollTrait],
          max: this.rollTraitValOverride ?? this.rollPrimaryDoc.attributes[this.rollTrait],
          pcTooltip: this.rollPrimaryDoc.rollTraitPCTooltipAttributes,
          gmTooltip: C.AttributeTooltips[this.rollTrait]
        };
      }
    }
    if (U.isInt(this.rollTrait)) {
      return {
        name: `+${this.rollTraitValOverride ?? this.rollTrait}`,
        value: this.rollTraitValOverride ?? this.rollTrait,
        max: this.rollTraitValOverride ?? this.rollTrait
      };
    }
    if (isFactor(this.rollTrait)) {
      return {
        name: U.tCase(this.rollTrait),
        value: this.rollTraitValOverride ?? ((_a = this.rollPrimary.rollFactors[this.rollTrait]) == null ? void 0 : _a.value) ?? 0,
        max: this.rollTraitValOverride ?? ((_b = this.rollPrimary.rollFactors[this.rollTrait]) == null ? void 0 : _b.max) ?? 10
      };
    }
    throw new Error(`[get rollTraitData] Invalid rollTrait: '${this.rollTrait}'`);
  }
  get rollTraitOptions() {
    if (BladesActor$1.IsType(this.rollPrimaryDoc, BladesActorType.pc)) {
      if (isAction(this.rollTrait)) {
        return Object.values(ActionTrait).map((action) => ({
          name: U.uCase(action),
          value: action
        }));
      }
      if (isAttribute(this.rollTrait)) {
        return Object.values(AttributeTrait).map((attribute) => ({
          name: U.uCase(attribute),
          value: attribute
        }));
      }
    }
    if (U.isInt(this.rollTrait)) {
      return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10].map((num) => ({
        name: `+${num}`,
        value: num
      }));
    }
    if (isFactor(this.rollTrait)) {
      return [];
    }
    throw new Error(`[get rollTraitOptions] Invalid rollTrait: '${this.rollTrait}'`);
  }
  get posEffectTrade() {
    var _a;
    return ((_a = this.data) == null ? void 0 : _a.rollPosEffectTrade) ?? false;
  }
  // getFlagVal<T>(flagKey?: string): T | undefined {
  //   if (flagKey) {
  //     return this.document.getFlag(C.SYSTEM_ID, `rollCollab.${flagKey}`.replace(/(rollCollab\.)+/g, "rollCollab.")) as T | undefined;
  //   }
  //   return this.document.getFlag(C.SYSTEM_ID, "rollCollab") as T | undefined;
  // }
  // async setFlagVal(flagKey: string, flagVal: unknown, isRerendering = true) {
  //   await this.document.setFlag(C.SYSTEM_ID, `rollCollab.${flagKey}`.replace(/(rollCollab\.)+/g, "rollCollab."), flagVal);
  //   if (isRerendering) {
  //     socketlib.system.executeForEveryone("renderRollCollab_SocketCall", this.id);
  //   }
  // }
  // async clearFlagVal(flagKey: string, isRerendering = true) {
  //   await this.document.unsetFlag(C.SYSTEM_ID, `rollCollab.${flagKey}`.replace(/(rollCollab\.)+/g, "rollCollab."));
  //   if (isRerendering) {
  //     socketlib.system.executeForEveryone("renderRollCollab_SocketCall", this.id);
  //   }
  // }
  get initialPosition() {
    return this.data.rollPositionInitial ?? Position.risky;
  }
  set initialPosition(val) {
    this.updateTarget("rollPositionInitial", val ?? Position.risky);
  }
  get initialEffect() {
    return this.data.rollEffectInitial ?? Effect.standard;
  }
  set initialEffect(val) {
    this.updateTarget("rollEffectInitial", val ?? Effect.standard);
  }
  get isApplyingConsequences() {
    if (this.rollType !== RollType.Action) {
      return false;
    }
    if (!this.rollResult) {
      return false;
    }
    if (![RollResult.partial, RollResult.fail].includes(this.rollResult)) {
      return false;
    }
    return true;
  }
  // Get rollConsequence() --> For resistance rolls.
  get rollConsequence() {
    const { consequence } = this.data.resistanceData ?? {};
    if (!(consequence == null ? void 0 : consequence.id)) {
      return void 0;
    }
    return game.eunoblades.Consequences.get(consequence.id) ?? new BladesConsequence(consequence);
  }
  // #endregion
  // #region GETTERS: DERIVED DATA ~
  get rollPositionFinal() {
    return Object.values(Position)[U.clampNum(
      Object.values(Position).indexOf(this.initialPosition) + this.getModsDelta(RollModSection.position) + (this.posEffectTrade === "position" ? 1 : 0) + (this.posEffectTrade === "effect" ? -1 : 0),
      [0, 2]
    )];
  }
  get rollEffectFinal() {
    return Object.values(Effect)[U.clampNum(
      Object.values(Effect).indexOf(this.initialEffect) + this.getModsDelta(RollModSection.effect) + (this.posEffectTrade === "effect" ? 1 : 0) + (this.posEffectTrade === "position" ? -1 : 0),
      [0, 4]
    )];
  }
  get rollResultDelta() {
    var _a;
    return this.getModsDelta(RollModSection.result) + (((_a = this.data) == null ? void 0 : _a.GMBoosts.Result) ?? 0) + (this.tempGMBoosts.Result ?? 0);
  }
  get rollResultFinal() {
    if (this.rollResult === false) {
      return false;
    }
    if (this.rollResultDelta === 0) {
      return this.rollResult;
    }
    switch (this.rollType) {
      case RollType.Action:
      case RollType.Fortune: {
        return Object.values(RollResult).toReversed()[U.clampNum(
          Object.values(RollResult).toReversed().indexOf(this.rollResult) + this.rollResultDelta,
          [0, 3]
        )];
      }
      case RollType.Resistance: {
        if (this.isCritical) {
          return -1;
        }
        return U.clampNum(6 - this.highestDieVal - this.rollResultDelta, [-1, Infinity]);
      }
      case RollType.IndulgeVice: {
        return U.clampNum(this.highestDieVal + this.rollResultDelta, [0, Infinity]);
      }
    }
    return false;
  }
  get finalDicePool() {
    return Math.max(0, this.rollTraitData.value + this.getModsDelta(RollModSection.roll) + (this.data.GMBoosts.Dice ?? 0) + (this.tempGMBoosts.Dice ?? 0));
  }
  get isRollingZero() {
    return Math.max(0, this.rollTraitData.value + this.getModsDelta(RollModSection.roll) + (this.data.GMBoosts.Dice ?? 0) + (this.tempGMBoosts.Dice ?? 0)) <= 0;
  }
  get roll() {
    this._roll ?? (this._roll = new Roll(`${this.isRollingZero ? 2 : this.finalDicePool}d6`, {}));
    return this._roll;
  }
  get rollFactors() {
    const defaultFactors = {
      [Factor.tier]: {
        name: "Tier",
        value: 0,
        max: 0,
        baseVal: 0,
        display: "?",
        isActive: false,
        isPrimary: true,
        isDominant: false,
        highFavorsPC: true,
        cssClasses: "factor-gold"
      },
      [Factor.quality]: {
        name: "Quality",
        value: 0,
        max: 0,
        baseVal: 0,
        display: "?",
        isActive: false,
        isPrimary: false,
        isDominant: false,
        highFavorsPC: true,
        cssClasses: "factor-gold"
      },
      [Factor.scale]: {
        name: "Scale",
        value: 0,
        max: 0,
        baseVal: 0,
        display: "?",
        isActive: false,
        isPrimary: false,
        isDominant: false,
        highFavorsPC: true,
        cssClasses: "factor-gold"
      },
      [Factor.magnitude]: {
        name: "Magnitude",
        value: 0,
        max: 0,
        baseVal: 0,
        display: "?",
        isActive: false,
        isPrimary: false,
        isDominant: false,
        highFavorsPC: true,
        cssClasses: "factor-gold"
      }
    };
    const mergedSourceFactors = U.objMerge(
      U.objMerge(
        defaultFactors,
        this.rollPrimary.rollFactors,
        { isMutatingOk: false }
      ),
      this.data.rollFactorToggles.source,
      { isMutatingOk: false }
    );
    const mergedOppFactors = this.rollOpposition ? U.objMerge(
      U.objMerge(
        defaultFactors,
        this.rollOpposition.rollFactors,
        { isMutatingOk: false }
      ),
      this.data.rollFactorToggles.opposition,
      { isMutatingOk: false }
    ) : {};
    return {
      source: Object.fromEntries(
        Object.entries(mergedSourceFactors).map(([factor, factorData]) => {
          factorData.value += (this.data.GMBoosts[factor] ?? 0) + (this.tempGMBoosts[factor] ?? 0);
          if (factor === Factor.tier) {
            factorData.display = U.romanizeNum(factorData.value);
          } else {
            factorData.display = `${factorData.value}`;
          }
          return [factor, factorData];
        })
      ),
      opposition: Object.fromEntries(
        Object.entries(mergedOppFactors).map(([factor, factorData]) => {
          factorData.value += this.data.GMOppBoosts[factor] ?? 0;
          if (factor === Factor.tier) {
            factorData.display = U.romanizeNum(factorData.value);
          } else {
            factorData.display = `${factorData.value}`;
          }
          return [factor, factorData];
        })
      )
    };
  }
  // #endregion
  // #region ROLL MODS: Getters & Update Method ~
  initRollMods() {
    this.rollTraitValOverride = void 0;
    this.rollFactorPenaltiesNegated = {};
    this.tempGMBoosts = {};
    const initReport = {};
    let initReportCount = 0;
    const watchMod = (label) => {
      if (_BladesRoll.Debug.modWatch === false) {
        return;
      }
      const reportLabel = `(${initReportCount}) == ${label}`;
      const rollMod = this.rollMods.find((mod) => _BladesRoll.Debug.modWatch && _BladesRoll.Debug.modWatch.exec(mod.name));
      if (rollMod) {
        initReport[`${reportLabel} : ${rollMod.status}`] = {
          inst: rollMod,
          data: { ...rollMod.data },
          sourceName: rollMod.sourceName,
          status: {
            ALL: rollMod.status,
            base: rollMod.baseStatus,
            held: rollMod.heldStatus,
            user: rollMod.userStatus
          },
          is: {
            active: rollMod.isActive,
            visible: rollMod.isVisible,
            conditional: rollMod.isConditional,
            inInactiveBlock: rollMod.isInInactiveBlock,
            isPush: rollMod.isPush,
            isBasicPush: rollMod.isBasicPush
          }
        };
      } else {
        initReport[reportLabel] = "MOD NOT FOUND";
      }
      initReportCount++;
    };
    watchMod("INITIAL");
    this._rollMods = this.rollMods.filter((rollMod) => rollMod.isValidForRollType());
    watchMod("ROLLTYPE VALIDATION");
    const conditionalDisablePass = this.rollMods.filter((rollMod) => !rollMod.setConditionalStatus());
    watchMod("DISABLE - CONDITIONAL");
    const autoRevealDisablePass = conditionalDisablePass.filter((rollMod) => !rollMod.setAutoStatus());
    watchMod("DISABLE - AUTO-REVEAL/ENABLE");
    autoRevealDisablePass.forEach((rollMod) => {
      rollMod.setPayableStatus();
    });
    watchMod("DISABLE - PAYABLE");
    const parseForceOnKeys = (mod) => {
      var _a, _b;
      const holdKeys = mod.effectKeys.filter((key) => key.startsWith("ForceOn"));
      if (holdKeys.length === 0) {
        return;
      }
      while (holdKeys.length) {
        const thisTarget = (_b = (_a = holdKeys.pop()) == null ? void 0 : _a.split(/-/)) == null ? void 0 : _b.pop();
        if (thisTarget === "BestAction") {
          if (BladesPC$1.IsType(this.rollPrimaryDoc)) {
            this.rollTraitValOverride = Math.max(...Object.values(this.rollPrimaryDoc.actions));
          }
        } else {
          const [targetName, targetCat, targetPosNeg] = (thisTarget == null ? void 0 : thisTarget.split(/,/)) ?? [];
          if (!targetName) {
            throw new Error(`No targetName found in thisTarget: ${thisTarget}.`);
          }
          let targetMod = this.getRollModByName(targetName) ?? this.getRollModByName(targetName, targetCat ?? mod.section);
          if (!targetMod && targetName === "Push") {
            [targetMod] = [
              ...this.getActiveBasicPushMods(targetCat ?? mod.section, "negative").filter((m) => m.status === RollModStatus.ToggledOn),
              ...this.getActiveBasicPushMods(targetCat ?? mod.section, "positive").filter((m) => m.status === RollModStatus.ToggledOn),
              ...this.getInactiveBasicPushMods(targetCat ?? mod.section, "positive").filter((m) => m.status === RollModStatus.ToggledOff)
            ];
          }
          targetMod ?? (targetMod = this.getRollModByName(targetName, targetCat ?? mod.section, targetPosNeg ?? mod.posNeg));
          if (!targetMod) {
            throw new Error(`No mod found matching ${targetName}/${targetCat}/${targetPosNeg}`);
          }
          if (!targetMod.isActive) {
            targetMod.heldStatus = RollModStatus.ForcedOn;
            parseForceOnKeys(targetMod);
          } else {
            targetMod.heldStatus = RollModStatus.ForcedOn;
          }
        }
      }
    };
    this.getActiveRollMods().forEach((rollMod) => parseForceOnKeys(rollMod));
    watchMod("FORCE-ON PASS");
    if (this.isForcePushed()) {
      this.getInactivePushMods().filter((mod) => !mod.isBasicPush).forEach((mod) => {
        mod.heldStatus = RollModStatus.ForcedOff;
      });
      watchMod("PUSH-CHECK: FORCE-OFF IS-PUSH");
    }
    [RollModSection.roll, RollModSection.effect].forEach((cat) => {
      if (this.isPushed(cat)) {
        if (cat === RollModSection.roll && this.isPushed(cat, "positive")) {
          const bargainMod = this.getRollModByKey("Bargain-positive-roll");
          if (bargainMod == null ? void 0 : bargainMod.isVisible) {
            bargainMod.heldStatus = RollModStatus.ForcedOff;
          }
        }
        watchMod("PUSH-CHECK: FORCE OFF BARGAIN");
      } else {
        this.getInactivePushMods(cat).filter((mod) => !mod.isBasicPush).forEach((mod) => {
          mod.heldStatus = RollModStatus.Hidden;
        });
        watchMod("PUSH-CHECK: HIDE IS-PUSH");
      }
    });
    this.getVisibleRollMods().forEach((mod) => {
      mod.setRelevancyStatus();
    });
    watchMod("RELEVANCY PASS");
    const activeArmorCostMod = this.getActiveRollMods().find((mod) => mod.effectKeys.includes("Cost-SpecialArmor"));
    if (activeArmorCostMod) {
      this.getVisibleRollMods().filter((mod) => !mod.isActive && mod.effectKeys.includes("Cost-SpecialArmor")).forEach((mod) => {
        mod.heldStatus = RollModStatus.ForcedOff;
      });
      watchMod("OVERPAYMENT PASS");
    }
    eLog.checkLog2("rollMods", "*** initRollMods() PASS ***", initReport);
  }
  isTraitRelevant(trait) {
    var _a;
    if (trait in Factor) {
      const { source, opposition } = this.rollFactors;
      return Boolean(trait in source && trait in opposition && ((_a = source[trait]) == null ? void 0 : _a.isActive));
    }
    return false;
  }
  get isParticipantRoll() {
    return this.rollType === RollType.Fortune && !game.user.isGM || this.rollSubType === RollSubType.GroupParticipant;
  }
  negatePushCost() {
    const costlyPushMod = this.getActiveRollMods().find((mod) => mod.isPush && mod.stressCost > 0);
    if (costlyPushMod) {
      U.pullElement(costlyPushMod.effectKeys, (k) => k.startsWith("Cost-Stress"));
    }
  }
  negateFactorPenalty(factor) {
    this.rollFactorPenaltiesNegated[factor] = true;
  }
  isPushed(cat, posNeg) {
    return this.getActiveBasicPushMods(cat, posNeg).length > 0;
  }
  hasOpenPush(cat, posNeg) {
    return this.isPushed(cat) && this.getOpenPushMods(cat, posNeg).length > 0;
  }
  isForcePushed(cat, posNeg) {
    return this.isPushed(cat) && this.getForcedPushMods(cat, posNeg).length > 0;
  }
  get rollCosts() {
    if (!this.isPushed) {
      return 0;
    }
    const harmPush = this.getRollModByKey("Push-negative-roll");
    const rollPush = this.getRollModByKey("Push-positive-roll");
    const effectPush = this.getRollModByKey("Push-positive-effect");
    const negatePushCostMods = this.getActiveRollMods(RollModSection.after, "positive").filter((mod) => mod.effectKeys.includes("Negate-PushCost"));
    return ((harmPush == null ? void 0 : harmPush.isActive) && (harmPush == null ? void 0 : harmPush.stressCost) || 0) + ((rollPush == null ? void 0 : rollPush.isActive) && (rollPush == null ? void 0 : rollPush.stressCost) || 0) + ((effectPush == null ? void 0 : effectPush.isActive) && (effectPush == null ? void 0 : effectPush.stressCost) || 0) - negatePushCostMods.length * 2;
  }
  get rollCostData() {
    return this.getActiveRollMods().map((rollMod) => rollMod.costs ?? []).flat();
  }
  getRollModByID(id) {
    return this.rollMods.find((rollMod) => rollMod.id === id);
  }
  getRollModByName(name, cat, posNeg) {
    const modMatches = this.rollMods.filter((rollMod) => {
      if (U.lCase(rollMod.name) !== U.lCase(name)) {
        return false;
      }
      if (cat && rollMod.section !== cat) {
        return false;
      }
      if (posNeg && rollMod.posNeg !== posNeg) {
        return false;
      }
      return true;
    });
    if (modMatches.length === 0) {
      return void 0;
    }
    if (modMatches.length > 1) {
      return void 0;
    }
    return modMatches[0];
  }
  getRollModByKey(key) {
    return this.rollMods.find((rollMod) => rollMod.data.key === key);
  }
  getRollMods(cat, posNeg) {
    return this.rollMods.filter((rollMod) => (!cat || rollMod.section === cat) && (!posNeg || rollMod.posNeg === posNeg));
  }
  getVisibleRollMods(cat, posNeg) {
    return this.getRollMods(cat, posNeg).filter((rollMod) => rollMod.isVisible);
  }
  getActiveRollMods(cat, posNeg) {
    return this.getRollMods(cat, posNeg).filter((rollMod) => rollMod.isActive);
  }
  getVisibleInactiveRollMods(cat, posNeg) {
    return this.getVisibleRollMods(cat, posNeg).filter((rollMod) => !rollMod.isActive);
  }
  getPushMods(cat, posNeg) {
    return this.getRollMods(cat, posNeg).filter((rollMod) => rollMod.isPush);
  }
  getVisiblePushMods(cat, posNeg) {
    return this.getPushMods(cat, posNeg).filter((rollMod) => rollMod.isVisible);
  }
  getActivePushMods(cat, posNeg) {
    return this.getVisiblePushMods(cat, posNeg).filter((rollMod) => rollMod.isActive);
  }
  getActiveBasicPushMods(cat, posNeg) {
    return this.getActivePushMods(cat, posNeg).filter((rollMod) => rollMod.isBasicPush);
  }
  getInactivePushMods(cat, posNeg) {
    return this.getVisiblePushMods(cat, posNeg).filter((rollMod) => !rollMod.isActive);
  }
  getInactiveBasicPushMods(cat, posNeg) {
    return this.getInactivePushMods(cat, posNeg).filter((rollMod) => rollMod.isBasicPush);
  }
  getForcedPushMods(cat, posNeg) {
    return this.getActivePushMods(cat, posNeg).filter((rollMod) => rollMod.isBasicPush && rollMod.status === RollModStatus.ForcedOn);
  }
  getOpenPushMods(cat, posNeg) {
    return this.getActivePushMods(cat, posNeg).filter((rollMod) => rollMod.isBasicPush && rollMod.status === RollModStatus.ToggledOn);
  }
  /**
   * Compare function for sorting roll mods.
   * @param {BladesRollMod} modA First mod to compare.
   * @param {BladesRollMod} modB Second mod to compare.
   * @returns {number} - Comparison result.
   */
  compareMods(modA, modB) {
    const modOrder = ["Bargain", "Assist", "Setup"];
    if (modA.isBasicPush) {
      return -1;
    }
    if (modB.isBasicPush) {
      return 1;
    }
    if (modA.name === "Bargain" && modA.isActive) {
      return -1;
    }
    if (modB.name === "Bargain" && modB.isActive) {
      return 1;
    }
    if (modA.isPush) {
      return -1;
    }
    if (modB.isPush) {
      return 1;
    }
    const modAIndex = modOrder.indexOf(modA.name);
    const modBIndex = modOrder.indexOf(modB.name);
    if (modAIndex !== -1 && modBIndex !== -1) {
      return modAIndex - modBIndex;
    }
    return modA.name.localeCompare(modB.name);
  }
  get rollMods() {
    if (!this._rollMods) {
      this._rollMods = Object.values(this.data.rollModsData).map((modData) => new BladesRollMod(modData, this));
    }
    return [...this._rollMods].sort((modA, modB) => this.compareMods(modA, modB));
  }
  // #endregion
  // #region CONSEQUENCES: Getting, Accepting, Resisting
  get consequences() {
    var _a, _b;
    const csqDataSet = (_b = (_a = this.data.consequenceData) == null ? void 0 : _a[this.rollPositionFinal]) == null ? void 0 : _b[this.rollResult];
    if (csqDataSet) {
      return Object.values(csqDataSet).map((csqData) => new BladesConsequence(csqData));
    }
    return [];
  }
  getConsequenceByID(csqID) {
    return this.consequences.find((csq) => csq.id === csqID) ?? false;
  }
  get acceptedConsequences() {
    if ([RollPhase.AwaitingConsequences, RollPhase.Complete].includes(this.rollPhase)) {
      return this.consequences.filter((csq) => csq.isAccepted === true);
    }
    return [];
  }
  get unacceptedConsequences() {
    if (this.rollPhase === RollPhase.AwaitingConsequences) {
      return this.consequences.filter((csq) => csq.isAccepted !== true);
    }
    return [];
  }
  // #endregion
  // #region *** ROLL COLLAB HTML INTERACTION *** ~
  /**
   * Retrieve the data for rendering the base RollCollab sheet.
   * @returns {Promise<object>} The data which can be used to render the HTML of the sheet.
   */
  get context() {
    this.initRollMods();
    this.rollMods.forEach((rollMod) => rollMod.applyRollModEffectKeys());
    return this.getTemplateContext();
  }
  /**
   * Determines if the user is a game master.
   * @returns {boolean} Whether the user is a GM.
   */
  getIsGM() {
    var _a;
    return ((_a = game.eunoblades.Tracker) == null ? void 0 : _a.system.is_spoofing_player) ? false : game.user.isGM;
  }
  /**
   * Gets the roll costs.
   * @returns {BladesRoll.CostData[]} The roll costs.
   */
  getRollCosts() {
    return this.getActiveRollMods().map((rollMod) => rollMod.costs).flat().filter((costData) => costData !== void 0);
  }
  /**
   * Constructs the sheet data.
   * @param {boolean} isGM If the user is a GM.
   * @param {BladesRoll.CostData[]} rollCosts The roll costs.
   * @returns {BladesRoll.Context} The constructed sheet data.
   */
  getTemplateContext() {
    var _a;
    const {
      data: rData,
      rollPrimary,
      rollTraitData,
      rollTraitOptions,
      rollClockKey,
      finalDicePool,
      rollPositionFinal,
      rollEffectFinal,
      rollResultDelta,
      rollResultFinal,
      rollMods,
      rollFactors
    } = this;
    if (!rollPrimary) {
      throw new Error("A primary roll source is required for BladesRoll.");
    }
    const baseData = {
      ...this.data,
      cssClass: "roll-collab",
      isGM: this.isGM,
      system: (_a = this.rollPrimaryDoc) == null ? void 0 : _a.system,
      rollMods,
      rollPrimary,
      rollTraitData,
      rollTraitOptions,
      diceTotal: finalDicePool,
      rollOpposition: this.rollOpposition,
      rollParticipants: this.rollParticipants,
      rollParticipantOptions: this.rollParticipantSelectOptions,
      rollEffects: Object.values(Effect),
      rollTraitValOverride: this.rollTraitValOverride,
      rollFactorPenaltiesNegated: this.rollFactorPenaltiesNegated,
      posRollMods: Object.fromEntries(Object.values(RollModSection).map((cat) => [cat, this.getRollMods(cat, "positive")])),
      negRollMods: Object.fromEntries(Object.values(RollModSection).map((cat) => [cat, this.getRollMods(cat, "negative")])),
      hasInactiveConditionals: this.calculateHasInactiveConditionalsData(),
      rollFactors,
      ...this.calculateOddsHTML(finalDicePool, rollResultDelta)
    };
    const GMBoostsData = this.calculateGMBoostsData(rData);
    const positionEffectTradeData = this.calculatePositionEffectTradeData();
    const stressCostDataSet = this.getRollCosts().filter((costData) => costData.costType === "Stress").map((costData) => [costData.label, costData.costAmount]);
    const availableArmor = [];
    if (this.rollPrimaryDoc instanceof BladesPC$1) {
      availableArmor.push(...this.rollPrimaryDoc.availableArmor);
    } else if (BladesItem$1.IsType(
      this.rollPrimaryDoc,
      BladesItemType.cohort_gang,
      BladesItemType.cohort_expert
    )) {
      for (let index = 0; index < this.rollPrimaryDoc.system.armor.value; index++) {
        availableArmor.push("Armor");
      }
    }
    const armorCostDataSet = this.getRollCosts().filter((costData) => costData.costType === "Armor").map((costData, index) => [costData.label, availableArmor[index]]).filter(([_label, armorType]) => armorType !== void 0);
    const specialArmorCostDataSet = this.getRollCosts().filter((costData) => costData.costType === "SpecialArmor").map((costData) => costData.label);
    const userPermission = baseData.userPermissions[game.user.id] ?? RollPermissions.Observer;
    return {
      ...baseData,
      rollPrimary: this.rollPrimary,
      rollPositionFinal,
      rollEffectFinal,
      rollResultFinal,
      rollPositions: Object.values(Position),
      rollEffects: Object.values(Effect),
      rollResultDelta,
      isAffectingResult: rollResultDelta !== 0 || this.getVisibleRollMods(RollModSection.result).length > 0 || this.isGM && this.getRollMods(RollModSection.result).length > 0,
      isAffectingAfter: this.getVisibleRollMods(RollModSection.after).length > 0 || this.isGM && this.getRollMods(RollModSection.after).length > 0,
      ...GMBoostsData,
      ...positionEffectTradeData,
      rollClockKey: this.rollClockKey,
      totalStressCost: stressCostDataSet.reduce((acc, [_label, amount]) => acc + amount, 0),
      totalArmorCost: armorCostDataSet.length,
      stressCosts: stressCostDataSet.length > 0 ? Object.fromEntries(stressCostDataSet) : void 0,
      armorCosts: armorCostDataSet.length > 0 ? Object.fromEntries(armorCostDataSet) : void 0,
      specArmorCost: specialArmorCostDataSet[0],
      userPermission,
      editable: userPermission === RollPermissions.Primary || userPermission === RollPermissions.GM,
      gamePhase: game.eunoblades.Tracker.phase
    };
  }
  // type BladesSelectOption<displayType, valueType = string> = {
  //   value: valueType,
  //   display: displayType
  // };
  // protected processDowntimeActions() {
  //   const downtimeData: Record<string,any>;
  //   if (BladesActor.IsType(this.rollPrimaryDoc, BladesActorType.pc)) {
  //     downtimeData.canDoDowntimeActions = true;
  //     downtimeData.downtimeActionsRemaining = this.rollPrimaryDoc.remainingDowntimeActions;
  //     const availableDowntimeActions: DowntimeAction[] = [];
  //     if (this.rollType === RollType.Action) {
  //       availableDowntimeActions.push(...[
  //         DowntimeAction.AcquireAsset,
  //         DowntimeAction.LongTermProject,
  //         DowntimeAction.Recover,
  //         DowntimeAction.ReduceHeat
  //       ]);
  //     } else if (this.rollType === RollType.Fortune) {
  //       availableDowntimeActions.push(...[
  //         DowntimeAction.
  //       ])
  //     }
  //     downtimeData.downtimeActionOptions =
  //   downtimeActionOptions?: Array<BladesSelectOption<string, DowntimeAction>
  // }
  calculateGMBoostsData(data) {
    return {
      GMBoosts: {
        Dice: data.GMBoosts.Dice ?? 0,
        [Factor.tier]: data.GMBoosts[Factor.tier] ?? 0,
        [Factor.quality]: data.GMBoosts[Factor.quality] ?? 0,
        [Factor.scale]: data.GMBoosts[Factor.scale] ?? 0,
        [Factor.magnitude]: data.GMBoosts[Factor.magnitude] ?? 0,
        Result: data.GMBoosts.Result ?? 0
      },
      GMOppBoosts: {
        [Factor.tier]: data.GMOppBoosts[Factor.tier] ?? 0,
        [Factor.quality]: data.GMOppBoosts[Factor.quality] ?? 0,
        [Factor.scale]: data.GMOppBoosts[Factor.scale] ?? 0,
        [Factor.magnitude]: data.GMOppBoosts[Factor.magnitude] ?? 0
      }
    };
  }
  calculateOddsHTML(diceTotal, rollResultDelta) {
    if (this.rollType === RollType.Resistance) {
      return this.calculateOddsHTML_Resistance(diceTotal);
    }
    return this.calculateOddsHTML_Standard(diceTotal, rollResultDelta);
  }
  /**
   * Calculate odds starting & ending HTML based on given dice total.
   * @param {number} diceTotal Total number of dice.
   * @param {number} rollResultDelta
   * @returns {{oddsHTMLStart: string, oddsHTMLStop: string}} Opening & Closing HTML for odds bar display
   */
  calculateOddsHTML_Standard(diceTotal, rollResultDelta) {
    const oddsColors = {
      crit: "var(--blades-gold)",
      success: "var(--blades-white-bright)",
      partial: "var(--blades-grey)",
      fail: "var(--blades-black-dark)"
    };
    const odds = { ...C.DiceOddsStandard[diceTotal] };
    if (rollResultDelta < 0) {
      for (let i = rollResultDelta; i < 0; i++) {
        oddsColors.crit = oddsColors.success;
        oddsColors.success = oddsColors.partial;
        oddsColors.partial = oddsColors.fail;
      }
    } else if (rollResultDelta > 0) {
      for (let i = 0; i < rollResultDelta; i++) {
        oddsColors.fail = oddsColors.partial;
        oddsColors.partial = oddsColors.success;
        oddsColors.success = oddsColors.crit;
      }
    }
    const resultElements = [];
    Object.entries(odds).reverse().forEach(([result, chance]) => {
      if (chance === 0) {
        return;
      }
      resultElements.push(`<div class="odds-section" style="height: 100%; width: ${chance}%; background: ${oddsColors[result]};">&nbsp;</div>`);
    });
    return {
      oddsHTMLStart: [
        '<div class="roll-odds-section-container">',
        ...resultElements
      ].join("\n"),
      oddsHTMLStop: "</div>"
    };
  }
  /**
   * Calculate odds starting & ending HTML based on given dice total.
   * @param {number} diceTotal Total number of dice.
   * @returns {{oddsHTMLStart: string, oddsHTMLStop: string}} Opening & Closing HTML for odds bar display
   */
  calculateOddsHTML_Resistance(diceTotal) {
    const oddsColors = [
      "var(--blades-gold)",
      // -1
      "var(--blades-white)",
      // 0
      "var(--blades-red)",
      // 1
      "var(--blades-red)",
      // 2
      "var(--blades-red)",
      // 3
      "var(--blades-red)",
      // 4
      "var(--blades-red)"
      // 5
    ].reverse();
    const oddsFilters = [
      "none",
      "none",
      "brightness(0.2)",
      "brightness(0.4)",
      "brightness(0.6)",
      "brightness(0.8)",
      "none"
    ].reverse();
    const odds = [...C.DiceOddsResistance[diceTotal]].reverse();
    const resultElements = [];
    for (let index = 0; index < odds.length; index++) {
      const chance = odds[index];
      if (chance > 0) {
        const color = oddsColors[index];
        const filter = oddsFilters[index];
        resultElements.push(...[
          `<div class="odds-section odds-section-stress" style="height: 100%; width: ${chance}%; background: ${color}; filter: ${filter};">&nbsp;</div>`
        ]);
      }
    }
    return {
      oddsHTMLStart: [
        '<div class="roll-odds-section-container">',
        ...resultElements
      ].join("\n"),
      oddsHTMLStop: "</div>"
    };
  }
  /**
   * Calculate data for position and effect trade.
   * @returns {{canTradePosition: boolean, canTradeEffect: boolean}}
   */
  calculatePositionEffectTradeData() {
    const canTradePosition = this.posEffectTrade === "position" || this.posEffectTrade === false && this.rollPositionFinal !== Position.desperate && this.rollEffectFinal !== Effect.extreme;
    const canTradeEffect = this.posEffectTrade === "effect" || this.posEffectTrade === false && this.rollPositionFinal !== Position.controlled && this.rollEffectFinal !== Effect.zero;
    return { canTradePosition, canTradeEffect };
  }
  /**
   * Calculate data on whether there are any inactive conditionals.
   * @returns {Record<RollModSection, boolean>} - Data on inactive conditionals.
   */
  calculateHasInactiveConditionalsData() {
    const hasInactive = {};
    for (const section of Object.values(RollModSection)) {
      hasInactive[section] = this.getRollMods(section).filter((mod) => mod.isInInactiveBlock).length > 0;
    }
    return hasInactive;
  }
  get dieVals() {
    return this.roll.terms[0].results.map((result) => result.result).sort().reverse();
  }
  // Accounts for rolling zero dice by removing highest.
  get finalDieVals() {
    return this.isRollingZero ? this.dieVals.slice(1) : this.dieVals;
  }
  get finalDiceData() {
    eLog.checkLog3("rollCollab", "[get finalDiceData()]", { roll: this, dieVals: this.dieVals });
    const dieVals = [...this.dieVals];
    const ghostNum = this.isRollingZero ? dieVals.shift() : null;
    const isCritical = dieVals.filter((val) => val === 6).length >= 2;
    const diceData = dieVals.map((val, i) => ({
      value: val,
      dieClass: _BladesRoll.GetDieClass(this.rollType, this.rollResult, val, i),
      dieImage: _BladesRoll.GetDieImage(this.rollType, this.rollResult, val, i, false, isCritical)
    }));
    if (ghostNum) {
      diceData.push({
        value: ghostNum,
        dieClass: "blades-die-ghost",
        dieImage: _BladesRoll.GetDieImage(this.rollType, this.rollResult, ghostNum, diceData.length, true, false)
      });
    }
    return diceData;
  }
  // get dieValsHTML(): string {
  //   eLog.checkLog3("rollCollab", "[get dieValsHTML()]", {roll: this, dieVals: this.dieVals});
  //   const dieVals = [...this.dieVals];
  //   const ghostNum = this.isRollingZero ? dieVals.shift() : null;
  //   const isCritical = dieVals.filter((val) => val === 6).length >= 2;
  //   const diceData = dieVals.map((val, i) => ({
  //     value: val,
  //     dieClass: BladesRoll.GetDieClass(this.rollType, this.rollResult, val, i),
  //     dieImage: BladesRoll.GetDieImage(this.rollType, this.rollResult, val, i, false, isCritical)
  //   }));
  //   if (ghostNum) {
  //     diceData.push({
  //       value: ghostNum,
  //       dieClass: "blades-die-ghost",
  //       dieImage: BladesRoll.GetDieImage(this.rollType, this.rollResult, ghostNum, diceData.length, true, false)
  //     });
  //   }
  //   return [
  //     ...dieVals.map((val, i) => `<span class='blades-die ${dieClass} blades-die-${value}'><img src='${dieImage}' /></span>`),
  //     ghostNum ? `<span class='blades-die blades-die-ghost blades-die-${ghostNum}'><img src='${this.getDieImage(ghostNum, 0, true)}' /></span>` : null
  //   ]
  //     .filter((val): val is string => typeof val === "string")
  //     .join("");
  // }
  // #endregion
  // #region RESULT GETTERS ~
  get isCritical() {
    return this.finalDieVals.filter((val) => val === 6).length >= 2;
  }
  get isSuccess() {
    return Boolean(!this.isCritical && this.finalDieVals.find((val) => val === 6));
  }
  get isPartial() {
    return Boolean(!this.isCritical && !this.isSuccess && this.finalDieVals.find((val) => val && val >= 4));
  }
  get isFail() {
    return !this.isCritical && !this.isSuccess && !this.isPartial;
  }
  get highestDieVal() {
    return this.finalDieVals[0];
  }
  get rollResult() {
    throw new Error("[BladesRoll.rollResult] Unimplemented by Subclass.");
  }
  // #endregion
  get isResolved() {
    return this.roll.total !== void 0;
  }
  async evaluateRoll() {
    if (this.isResolved) {
      this.closeRollCollab_Animation();
      return this.data;
    }
    this.closeRollCollab_SocketCall();
    eLog.checkLog3("rollCollab", "[resolveRoll()] Before Evaluation", { roll: this, rollData: { ...this.data } });
    await this.roll.evaluate({ async: true });
    return await this.updateTargetData({
      ...this.data,
      rollPositionFinal: this.rollPositionFinal,
      rollEffectFinal: this.rollEffectFinal,
      rollResult: this.rollResult,
      rollTraitVerb: this.rollTraitVerb,
      rollTraitPastVerb: this.rollTraitPastVerb,
      finalDiceData: this.finalDiceData,
      rollPhase: this.isApplyingConsequences ? RollPhase.AwaitingConsequences : RollPhase.Complete
    });
  }
  async resolveRollResult() {
    throw new Error("[BladesRoll.resolveRollResult] Unimplemented by Subclass.");
  }
  async outputRollToChat() {
    await BladesChat$1.create({
      speaker: this.getSpeaker(BladesChat$1.getSpeaker()),
      content: await renderTemplate(this.chatTemplate, this.data),
      type: CONST.CHAT_MESSAGE_TYPES.ROLL,
      flags: {
        "eunos-blades": { rollData: this.data }
      }
    });
  }
  async resolveRoll() {
    await this.evaluateRoll();
    this.resolveRollResult();
    await this.outputRollToChat();
  }
  // #endregion
  // #region *** INTERFACING WITH BLADESCHAT ***
  getSpeaker(chatSpeaker) {
    var _a;
    const { rollPrimaryID, rollPrimaryName, rollPrimaryType, rollPrimaryDoc } = this.rollPrimary;
    chatSpeaker.alias = rollPrimaryName;
    if ([BladesItemType.cohort_gang, BladesItemType.cohort_expert].includes(rollPrimaryType)) {
      chatSpeaker.actor = ((_a = rollPrimaryDoc == null ? void 0 : rollPrimaryDoc.parent) == null ? void 0 : _a.id) ?? chatSpeaker.actor;
      if ((rollPrimaryDoc == null ? void 0 : rollPrimaryDoc.parent) instanceof BladesPC$1) {
        chatSpeaker.alias = `${chatSpeaker.alias} (${rollPrimaryDoc.parent.name})`;
      }
    } else if ([BladesItemType.gm_tracker, BladesItemType.score].includes(rollPrimaryType)) {
      chatSpeaker.actor = null;
      chatSpeaker.alias = "The Gamemaster";
    } else if (rollPrimaryID) {
      chatSpeaker.actor = rollPrimaryID;
    }
    return chatSpeaker;
  }
  get overlayPosition() {
    return this._overlayPosition;
  }
  set overlayPosition(val) {
    this._overlayPosition = val;
  }
  get elem$() {
    if (this._elem$) {
      return this._elem$;
    }
    const elem$ = $(`#${this.id}`);
    if (elem$.length) {
      this._elem$ = elem$;
    } else {
      this._elem$ = $(`<div id="${this.id}" class="app window-app ${C.SYSTEM_ID} sheet roll-collab${game.user.isGM ? " gm-roll-collab" : ""}"></div>`).appendTo("body");
      this._elem$.css({
        left: `${this.overlayPosition.x}px`,
        top: `${this.overlayPosition.y}px`
      });
    }
    return this._elem$;
  }
  async renderRollCollab() {
    this.prepareRollParticipantData();
    const html = await renderTemplate(this.collabTemplate, this.context);
    this.elem$.html(html);
    this.activateListeners();
  }
  get isRendered() {
    var _a;
    return Boolean((_a = this._elem$) == null ? void 0 : _a.length);
  }
  get collabTemplate() {
    throw new Error("[BladesRoll.collabTemplate] Unimplemented by Subclass.");
  }
  get chatTemplate() {
    throw new Error("[BladesRoll.chatTemplate] Unimplemented by Subclass.");
  }
  // #region LISTENER FUNCTIONS ~
  // async _handleConsequenceClick(event: ClickEvent) {
  //   const clickTarget$ = $(event.currentTarget);
  //   const csqParent$ = clickTarget$.closest(".comp.consequence-display-container");
  //   const csqID = csqParent$.data("csq-id");
  //   const chatElem$ = csqParent$.closest(".blades-roll");
  //   const chatMessage$ = chatElem$.closest(".chat-message");
  //   const chatID = chatMessage$.data("messageId") as IDString;
  //   const chatMessage = game.messages.get(chatID);
  //   if (!chatMessage) {return;}
  //   const csqs = await BladesConsequence.GetFromChatMessage(chatMessage);
  //   const thisCsq = csqs.find((csq) => csq.id === csqID);
  //   if (!thisCsq) {return;}
  //   switch (clickTarget$.data("action")) {
  //     case "accept-consequence": return thisCsq.resolveAccept();
  //     case "resist-consequence": return thisCsq.resistConsequence();
  //     case "armor-consequence": return thisCsq.resistArmorConsequence();
  //     case "special-consequence": return thisCsq.resistSpecialArmorConsequence();
  //   }
  //   return undefined as never;
  // }
  _toggleRollModClick(event) {
    event.preventDefault();
    const elem$ = $(event.currentTarget);
    const id = elem$.data("id");
    const rollMod = this.getRollModByID(id);
    if (!rollMod) {
      throw new Error(`Unable to find roll mod with id '${id}'`);
    }
    rollMod.isRerendering = true;
    switch (rollMod.status) {
      case RollModStatus.Hidden:
        rollMod.userStatus = RollModStatus.ForcedOff;
        break;
      case RollModStatus.ForcedOff:
        rollMod.userStatus = RollModStatus.ToggledOff;
        break;
      case RollModStatus.ToggledOff:
        rollMod.userStatus = RollModStatus.ToggledOn;
        break;
      case RollModStatus.ToggledOn:
        rollMod.userStatus = game.user.isGM ? RollModStatus.ForcedOn : RollModStatus.ToggledOff;
        break;
      case RollModStatus.ForcedOn:
        rollMod.userStatus = RollModStatus.Hidden;
        break;
      default:
        throw new Error(`Unrecognized RollModStatus: ${rollMod.status}`);
    }
    rollMod.isRerendering = false;
  }
  /**
   * Handles setting of rollMod status via GM pop-out controls
   * @param {ClickEvent} event JQuery click event sent to listener.
   */
  _gmControlSet(event) {
    event.preventDefault();
    if (!game.user.isGM) {
      return;
    }
    const elem$ = $(event.currentTarget);
    const id = elem$.data("id");
    const status = elem$.data("status");
    if (!isModStatus(status) && status !== "Reset") {
      return;
    }
    const rollMod = this.getRollModByID(id);
    if (rollMod) {
      rollMod.userStatus = status === "Reset" ? void 0 : status;
    }
  }
  /**
   * Handles setting values via GM number line (e.g. roll factor boosts/modifications).
   * @param {ClickEvent} event JQuery click event sent to listener.
   */
  async _gmControlSetTargetToValue(event) {
    event.preventDefault();
    if (!game.user.isGM) {
      return;
    }
    const elem$ = $(event.currentTarget);
    const target = elem$.data("target").replace(/flags\.eunos-blades\./, "");
    const value = elem$.data("value");
    await this.updateTarget(target, value);
    socketlib.system.executeForEveryone("renderRollCollab_SocketCall", this.id);
  }
  async _gmControlCycleTarget(event) {
    var _a;
    event.preventDefault();
    if (!game.user.isGM) {
      return;
    }
    const elem$ = $(event.currentTarget);
    const flagTarget = elem$.data("flagTarget");
    const curVal = elem$.data("curVal");
    const cycleVals = (_a = elem$.data("vals")) == null ? void 0 : _a.split(/\|/);
    if (!cycleVals) {
      throw new Error(`Unable to parse cycle values from data-vals = ${elem$.data("vals")}`);
    }
    const curValIndex = cycleVals.indexOf(curVal);
    if (curValIndex === -1) {
      throw new Error(`Unable to find current value '${curVal}' in cycle values '${elem$.data("vals")}'`);
    }
    let newValIndex = curValIndex + 1;
    if (newValIndex >= cycleVals.length) {
      newValIndex = 0;
    }
    const newVal = cycleVals[newValIndex];
    eLog.checkLog3("gmControlCycleTarget", "gmControlCycleTarget", { flagTarget, curVal, cycleVals, curValIndex, newValIndex, newVal });
    await this.updateTarget(flagTarget, newVal);
  }
  /**
   * Handles resetting value associated with GM number line on a right-click.
   * @param {ClickEvent} event JQuery context menu event sent to listener.
   */
  async _gmControlResetTarget(event) {
    event.preventDefault();
    if (!game.user.isGM) {
      return;
    }
    await this.updateTarget($(event.currentTarget).data("target"), void 0);
    socketlib.system.executeForEveryone("renderRollCollab_SocketCall", this.id);
  }
  /**
   * Handles setting of baseline rollPosition via GM button line
   * @param {ClickEvent} event JQuery click event sent to listener.
   */
  _gmControlSetPosition(event) {
    event.preventDefault();
    if (!game.user.isGM) {
      return;
    }
    const elem$ = $(event.currentTarget);
    const position = elem$.data("status");
    this.initialPosition = position;
  }
  /**
   * Handles setting of baseline rollPosition via GM button line
   * @param {ClickEvent} event JQuery click event sent to listener.
   */
  _gmControlSetEffect(event) {
    event.preventDefault();
    if (!game.user.isGM) {
      return;
    }
    const elem$ = $(event.currentTarget);
    const effect = elem$.data("status");
    this.initialEffect = effect;
  }
  /**
   * Handles setting of Factor toggles: isActive, isPrimary, highFavorsPC, isDominant
   * @param {ClickEvent} event JQuery click event sent to listener.
   */
  async _gmControlToggleFactor(event) {
    event.preventDefault();
    if (!game.user.isGM) {
      return;
    }
    const elem$ = $(event.currentTarget);
    const target = elem$.data("target");
    const value = !elem$.data("value");
    eLog.checkLog3("toggleFactor", "_gmControlToggleFactor", { event, target, value });
    const factorToggleData = this.data.rollFactorToggles;
    const [thisSource, thisFactor, thisToggle] = target.split(/\./).slice(-3);
    if (!["isActive", "isPrimary", "isDominant", "highFavorsPC"].includes(thisToggle)) {
      await this.updateTarget(target, value);
      socketlib.system.executeForEveryone("renderRollCollab_SocketCall", this.id);
    }
    factorToggleData[thisSource][thisFactor] = {
      ...factorToggleData[thisSource][thisFactor] ?? { display: "" },
      [thisToggle]: value
    };
    switch (thisToggle) {
      case "isDominant":
      case "isPrimary": {
        if (value === true) {
          Object.values(Factor).filter((factor) => factor !== thisFactor).forEach((factor) => {
            var _a;
            if (((_a = factorToggleData[thisSource][factor]) == null ? void 0 : _a[thisToggle]) === true) {
              factorToggleData[thisSource][factor] = {
                ...factorToggleData[thisSource][factor],
                [thisToggle]: false
              };
            }
          });
        }
        break;
      }
      case "isActive": {
        if (value === true) {
          const otherSource = thisSource === "source" ? "opposition" : "source";
          factorToggleData[otherSource][thisFactor] = {
            ...factorToggleData[otherSource][thisFactor] ?? { display: "" },
            isActive: value
          };
        }
        break;
      }
    }
    await this.updateTarget("rollFactorToggles", factorToggleData);
    socketlib.system.executeForEveryone("renderRollCollab_SocketCall", this.id);
  }
  async _onSelectChange(event) {
    event.preventDefault();
    const elem = event.currentTarget;
    const { docType } = elem.dataset;
    if (elem.value !== "" && (docType == null ? void 0 : docType.startsWith("BladesRollParticipant"))) {
      const [_, section, subSection] = docType.split(".");
      await this.addRollParticipant(
        elem.value,
        section,
        subSection
      );
    } else {
      await U.EventHandlers.onSelectChange(this, event);
      socketlib.system.executeForEveryone("renderRollCollab_SocketCall", this.id);
    }
  }
  async _onTextInputBlur(event) {
    await U.EventHandlers.onTextInputBlur(this, event);
    socketlib.system.executeForEveryone("renderRollCollab_SocketCall", this.id);
  }
  async _onGMPopupClick(event) {
    const elem$ = $(event.currentTarget);
    const prompt = elem$.data("prompt");
    const flagTarget = elem$.data("flagTarget");
    if (prompt && flagTarget) {
      BladesDialog.DisplaySimpleInputDialog(this, prompt, void 0, flagTarget);
    }
  }
  get positionDragger() {
    if (this._positionDragger) {
      return this._positionDragger;
    }
    return this.spawnPositionDragger();
  }
  spawnPositionDragger() {
    var _a;
    const self = this;
    if (!this._elem$) {
      throw new Error(`[BladesRoll.spawnPositionDragger] No elem$ found for roll ${this.id}.`);
    }
    (_a = this._positionDragger) == null ? void 0 : _a.kill();
    return this._positionDragger = new Draggable(this._elem$, {
      type: "top,left",
      trigger: ".window-header.dragger",
      onDragStart() {
        U.gsap.to(this.target, { opacity: 0.25, duration: 0.25, ease: "power2" });
      },
      onDragEnd() {
        U.gsap.to(this.target, { opacity: 1, duration: 0.25, ease: "power2" });
        self.overlayPosition = { x: this.endX, y: this.endY };
      }
    });
  }
  activateListeners() {
    ApplyTooltipAnimations(this.elem$);
    this.spawnPositionDragger();
    if (this.rollClockKey) {
      this.elem$.find(".roll-clock").removeClass("hidden");
    }
    this.elem$.find(".roll-mod[data-action='toggle']").on({
      click: this._toggleRollModClick.bind(this)
    });
    this.elem$.find("[data-action='tradePosition']").on({
      click: (event) => {
        const curVal = `${$(event.currentTarget).data("value")}`;
        if (curVal === "false") {
          this.updateTarget("rollPosEffectTrade", "effect").then(() => socketlib.system.executeForEveryone("renderRollCollab_SocketCall", this.id));
        } else {
          this.updateTarget("rollPosEffectTrade", false).then(() => socketlib.system.executeForEveryone("renderRollCollab_SocketCall", this.id));
        }
      }
    });
    this.elem$.find("[data-action='tradeEffect']").on({
      click: (event) => {
        const curVal = `${$(event.currentTarget).data("value")}`;
        if (curVal === "false") {
          this.updateTarget("rollPosEffectTrade", "position").then(() => socketlib.system.executeForEveryone("renderRollCollab_SocketCall", this.id));
        } else {
          this.updateTarget("rollPosEffectTrade", false).then(() => socketlib.system.executeForEveryone("renderRollCollab_SocketCall", this.id));
        }
      }
    });
    this.elem$.find("[data-action='roll']").on({
      click: () => this.resolveRoll()
    });
    this.elem$.find("select[data-action='player-select']").on({ change: this._onSelectChange.bind(this) });
    if (!game.user.isGM) {
      return;
    }
    this.elem$.find(".controls-toggle").on({
      click: (event) => {
        event.preventDefault();
        $(event.currentTarget).parents(".controls-panel").toggleClass("active");
      }
    });
    this.elem$.find('[data-action="gm-set"]').on({
      click: this._gmControlSet.bind(this)
    });
    this.elem$.find('[data-action="gm-set-position"]').on({
      click: this._gmControlSetPosition.bind(this)
    });
    this.elem$.find('[data-action="gm-set-effect"]').on({
      click: this._gmControlSetEffect.bind(this)
    });
    this.elem$.find('[data-action="gm-set-target"]').on({
      click: this._gmControlSetTargetToValue.bind(this),
      contextmenu: this._gmControlResetTarget.bind(this)
    });
    this.elem$.find('[data-action="gm-cycle-target"]').on({
      click: this._gmControlCycleTarget.bind(this)
    });
    this.elem$.find('[data-action="gm-toggle-factor"]').on({
      click: this._gmControlToggleFactor.bind(this)
    });
    this.elem$.find("select[data-action='gm-select']").on({ change: this._onSelectChange.bind(this) });
    this.elem$.find('[data-action="gm-text-popup"]').on({ click: this._onGMPopupClick.bind(this) });
    this.elem$.find("[data-action='gm-text-input']").on({ blur: this._onTextInputBlur.bind(this) });
  }
  // #endregion
  // #endregion
  // #region OVERRIDES: _canDragDrop, _onDrop, _onSubmit, close, render ~
  // override _canDragDrop() {
  //   return game.user.isGM;
  // }
  // override _onDrop(event: DragEvent) {
  //   const {uuid} = TextEditor.getDragEventData(event) as {uuid: UUIDString};
  //   const dropDoc = fromUuidSync(uuid);
  //   if (BladesRollOpposition.IsDoc(dropDoc)) {
  //     this.rollOpposition = new BladesRollOpposition(this, {rollOppDoc: dropDoc});
  //   } else if (dropDoc instanceof BladesProject && dropDoc.clockKey) {
  //     // Project dropped on roll: Assign project's clock key to roll.
  //     this.rollClockKey = dropDoc.clockKey;
  //   }
  // }
  async submitChange(prop, val) {
    await this.updateTarget(prop, val);
    socketlib.system.executeForEveryone("renderRollCollab_SocketCall", this.id);
  }
  // #endregion
};
__publicField(_BladesRoll, "Debug", {
  modWatch: false,
  watchRollMod(name) {
    if (typeof name === "string") {
      _BladesRoll.Debug.modWatch = new RegExp(name, "g");
    } else {
      _BladesRoll.Debug.modWatch = false;
    }
  }
});
let BladesRoll = _BladesRoll;
class BladesActionRoll extends BladesRoll {
  /* Not much -- most action roll things will extend to other rolls, but split out things like Position, Effect, default Mods */
  static ApplySchemaDefaults(schemaData) {
    var _a, _b;
    schemaData.rollType = RollType.Action;
    if (!schemaData.rollPrimaryData) {
      throw new Error("Must include a rollPrimaryData when constructing a BladesActionRoll object.");
    }
    if (!(schemaData.rollTrait === "" || U.isInt(schemaData.rollTrait) || U.lCase(schemaData.rollTrait) in { ...ActionTrait, ...Factor })) {
      throw new Error(`[BladesActionRoll.ApplySchemaDefaults()] Bad RollTrait for Action Roll: ${schemaData.rollTrait}`);
    }
    const fullSchema = super.ApplySchemaDefaults(schemaData);
    const rollPrimary = BladesRollPrimary.Build(fullSchema);
    switch (fullSchema.rollDowntimeAction) {
      case DowntimeAction.AcquireAsset: {
        fullSchema.rollTrait = Factor.tier;
        break;
      }
      case DowntimeAction.LongTermProject: {
        if (!BladesRollOpposition.IsValidData(fullSchema.rollOppData)) {
          throw new Error("No rollOppData provided for LongTermProject roll.");
        }
        if (![
          BladesItemType.project,
          BladesItemType.design
        ].includes(fullSchema.rollOppData.rollOppType)) {
          throw new Error("rollOppType must be 'project' or 'design' for LongTermProject roll.");
        }
        break;
      }
      case DowntimeAction.Recover: {
        if (BladesPC$1.IsType(rollPrimary.rollPrimaryDoc)) {
          if (!rollPrimary.rollPrimaryDoc.abilities.find((ability) => ability.name === "Physiker")) {
            throw new Error("A PC rollPrimary on a Recovery roll must have the Physiker ability.");
          }
          fullSchema.rollTrait = ActionTrait.tinker;
        } else if (((_a = rollPrimary.rollPrimaryDoc) == null ? void 0 : _a.rollPrimaryType) === BladesActorType.npc) {
          fullSchema.rollTrait = Factor.quality;
        } else {
          throw new Error("Only a PC with Physiker or an NPC can be rollPrimary on a Recover roll.");
        }
        break;
      }
      case DowntimeAction.ReduceHeat: {
        let parentCrew = void 0;
        if (rollPrimary.rollPrimaryDoc) {
          const { parent } = rollPrimary.rollPrimaryDoc;
          if (BladesCrew$1.IsType(parent)) {
            parentCrew = parent;
          } else if (BladesPC$1.IsType(parent) && BladesCrew$1.IsType(parent.crew)) {
            parentCrew = parent.crew;
          }
        }
        if (!BladesCrew$1.IsType(parentCrew)) {
          throw new Error(`Could not find crew for rollPrimary '${(_b = rollPrimary.rollPrimaryDoc) == null ? void 0 : _b.rollPrimaryName}'`);
        }
        if (parentCrew.system.heat.value === 0) {
          throw new Error("Attempt to Reduce Heat for a Crew with no Heat.");
        }
        break;
      }
      case void 0:
        break;
      default:
        throw new Error(`Unrecognized Roll Downtime Action: ${fullSchema.rollDowntimeAction}`);
    }
    return {
      rollPositionInitial: Position.risky,
      rollEffectInitial: Effect.standard,
      rollPosEffectTrade: false,
      GMBoosts: {
        [Factor.tier]: 0,
        [Factor.quality]: 0,
        [Factor.scale]: 0,
        [Factor.magnitude]: 0
      },
      GMOppBoosts: {
        [Factor.tier]: 0,
        [Factor.quality]: 0,
        [Factor.scale]: 0,
        [Factor.magnitude]: 0
      },
      GMOverrides: {},
      rollFactorToggles: {
        source: {
          [Factor.tier]: {
            display: "",
            isActive: false,
            isPrimary: false,
            isDominant: false,
            highFavorsPC: true
          },
          [Factor.quality]: {
            display: "",
            isActive: false,
            isPrimary: false,
            isDominant: false,
            highFavorsPC: true
          },
          [Factor.scale]: {
            display: "",
            isActive: false,
            isPrimary: false,
            isDominant: false,
            highFavorsPC: true
          },
          [Factor.magnitude]: {
            display: "",
            isActive: false,
            isPrimary: false,
            isDominant: false,
            highFavorsPC: true
          }
        },
        opposition: {
          [Factor.tier]: {
            display: "",
            isActive: false,
            isPrimary: false,
            isDominant: false,
            highFavorsPC: true
          },
          [Factor.quality]: {
            display: "",
            isActive: false,
            isPrimary: false,
            isDominant: false,
            highFavorsPC: true
          },
          [Factor.scale]: {
            display: "",
            isActive: false,
            isPrimary: false,
            isDominant: false,
            highFavorsPC: true
          },
          [Factor.magnitude]: {
            display: "",
            isActive: false,
            isPrimary: false,
            isDominant: false,
            highFavorsPC: true
          }
        }
      },
      ...fullSchema,
      rollPrimaryData: rollPrimary.data,
      rollOppData: fullSchema.rollOppData instanceof BladesRollOpposition ? fullSchema.rollOppData.data : fullSchema.rollOppData
    };
  }
  static get DefaultRollModSchemaSet() {
    return [
      {
        key: "Push-positive-roll",
        name: "PUSH",
        section: RollModSection.roll,
        base_status: RollModStatus.ToggledOff,
        posNeg: "positive",
        modType: RollModType.general,
        value: 1,
        effectKeys: ["ForceOff-Bargain", "Cost-Stress2"],
        tooltip: "<h1>Push for +1d</h1><p>For <strong class='red-bright'>2 Stress</strong>, add <strong class='gold-bright'>1 die</strong> to your pool.</p><p><em>(You <strong>cannot</strong> also accept a <strong class='red-bright'>Devil's Bargain</strong> to increase your dice pool: It's one or the other.)</em></p>"
      },
      {
        key: "Bargain-positive-roll",
        name: "Bargain",
        section: RollModSection.roll,
        base_status: RollModStatus.Hidden,
        posNeg: "positive",
        modType: RollModType.general,
        value: 1,
        effectKeys: [],
        tooltip: "<h1 class='red-bright'>Devil's Bargain</h1><p>The GM has offered you a <strong class='red-bright'>Devil's Bargain</strong>.</p><p><strong class='red-bright'>Accept the terms</strong> to add <strong class='gold-bright'>1 die</strong> to your pool.</p><p><em>(You <strong>cannot</strong> also <strong>Push for +1d</strong> to increase your dice pool: It's one or the other.)</em></p>"
      },
      {
        key: "Assist-positive-roll",
        name: "Assist",
        section: RollModSection.roll,
        base_status: RollModStatus.Hidden,
        posNeg: "positive",
        modType: RollModType.teamwork,
        value: 1,
        tooltip: "<h1 class='gold-bright'>%DOC_NAME% Assists</h1><p><strong class='gold-bright'>%DOC_NAME%</strong> is <strong>Assisting</strong> your efforts, adding <strong class='gold-bright'>1 die</strong> to your pool.</p>"
      },
      {
        key: "Setup-positive-position",
        name: "Setup",
        section: RollModSection.position,
        base_status: RollModStatus.Hidden,
        posNeg: "positive",
        modType: RollModType.teamwork,
        value: 1,
        tooltip: "<h1 class='gold-bright'>%DOC_NAME% Sets You Up</h1><p><strong class='gold-bright'>%DOC_NAME%</strong> has set you up for success with a preceding <strong>Setup</strong> action, increasing your <strong class='gold-bright'>Position</strong> by one level.</p>"
      },
      {
        key: "Push-positive-effect",
        name: "PUSH",
        section: RollModSection.effect,
        base_status: RollModStatus.ToggledOff,
        posNeg: "positive",
        modType: RollModType.general,
        value: 1,
        effectKeys: ["Cost-Stress2"],
        tooltip: "<h1>Push for Effect</h1><p>For <strong class='red-bright'>2 Stress</strong>, increase your <strong class='gold-bright'>Effect</strong> by one level.</p>"
      },
      {
        key: "Setup-positive-effect",
        name: "Setup",
        section: RollModSection.effect,
        base_status: RollModStatus.Hidden,
        posNeg: "positive",
        modType: RollModType.teamwork,
        value: 1,
        tooltip: "<h1 class='gold-bright'>%DOC_NAME% Sets You Up</h1><p><strong class='gold-bright'>%DOC_NAME%</strong> has set you up for success with a preceding <strong>Setup</strong> action, increasing your <strong class='gold-bright'>Effect</strong> by one level.</p>"
      },
      {
        key: "Potency-positive-effect",
        name: "Potency",
        section: RollModSection.effect,
        base_status: RollModStatus.Hidden,
        posNeg: "positive",
        modType: RollModType.general,
        value: 1,
        tooltip: "<h1>Potency</h1><p>By circumstance or advantage, you have <strong>Potency</strong> in this action, increasing your <strong class='gold-bright'>Effect</strong> by one level.</p>"
      },
      {
        key: "Potency-negative-effect",
        name: "Potency",
        section: RollModSection.effect,
        base_status: RollModStatus.Hidden,
        posNeg: "negative",
        modType: RollModType.general,
        value: 1,
        tooltip: "<h1 class='red-bright'>Potency</h1><p>By circumstance or advantage, <strong class='red-bright'>@OPPOSITION_NAME@</strong> has <strong>Potency</strong> against you, reducing your <strong class='red-bright'>Effect</strong> by one level."
      }
    ];
  }
  /**
   * Asynchronously creates a new instance of this subclass of `BladesRoll`.
   *
   * Overrides the `New` static method from `BladesRoll`, applying subclass-specific configurations
   * to the instance creation process. It ensures that the returned instance is correctly typed
   * and configured for this subclass.
   *
   * @param {BladesRoll.Config} config The configuration object for creating a new roll instance,
   * extended with any subclass-specific configurations or requirements.
   *
   * @returns {Promise<InstanceType<this>>} A promise that resolves to an instance of this subclass.
   *
   * @see {@link BladesRoll.New} for the base method's functionality and the generic creation process
   * for roll instances.
   */
  static async New(config) {
    const linkConfig = this.BuildLinkConfig(config);
    const parsedConfig = {
      ...config,
      ...linkConfig
    };
    const rollInst = await super.New(parsedConfig);
    return rollInst;
  }
  get rollModsSchemaSets() {
    const rollModSchemaSets = super.rollModsSchemaSets;
    if (this.rollPrimary.isWorsePosition) {
      rollModSchemaSets.push({
        key: "WorsePosition-negative-position",
        name: "Worse Position",
        section: RollModSection.position,
        base_status: RollModStatus.ForcedOn,
        posNeg: "negative",
        modType: RollModType.general,
        value: 1,
        effectKeys: [],
        tooltip: "<h1>Worse Position</h1><p>A <strong class='red-bright'>Consequence</strong> on a previous roll has worsened your <strong>Position</strong>.</p>"
      });
    }
    if (this.acceptedConsequences.some((csq) => csq.type === ConsequenceType.ReducedEffect)) {
      rollModSchemaSets.push({
        key: "ReducedEffect-negative-effect",
        name: "Reduced Effect",
        section: RollModSection.effect,
        base_status: RollModStatus.ForcedOn,
        posNeg: "negative",
        modType: RollModType.general,
        value: 1,
        effectKeys: [],
        tooltip: "<h1>Reduced Effect</h1><p>A <strong class='red-bright'>Consequence</strong> has worsened your <strong>Effect</strong>.</p>"
      });
    }
    return rollModSchemaSets;
  }
  get collabTemplate() {
    return `systems/eunos-blades/templates/roll/roll-collab-action${game.user.isGM ? "-gm" : ""}.hbs`;
  }
  get chatTemplate() {
    const templateParts = [
      "systems/eunos-blades/templates/chat/roll-result/action",
      this.rollClockKey ? "-clock" : ""
    ];
    if (this.rollDowntimeAction && [
      DowntimeAction.AcquireAsset,
      // action-acquireasset
      DowntimeAction.ReduceHeat,
      //   action-reduceheat
      DowntimeAction.Recover
      //       action-clock-recover
    ].includes(this.rollDowntimeAction)) {
      templateParts.push(`-${U.lCase(this.rollDowntimeAction)}`);
    } else if (this.rollSubType && [
      RollSubType.GatherInfo
      //      action-gatherinfo
    ].includes(this.rollSubType)) {
      templateParts.push(`-${U.lCase(this.rollSubType)}`);
    }
    templateParts.push(".hbs");
    return templateParts.join("");
  }
  get rollResult() {
    if (!this.isResolved) {
      return false;
    }
    if (this.isCritical) {
      return RollResult.critical;
    }
    if (this.isSuccess) {
      return RollResult.success;
    }
    if (this.isPartial) {
      return RollResult.partial;
    }
    return RollResult.fail;
  }
  async resolveRollResult() {
    var _a, _b;
    eLog.checkLog2("bladesRoll", "[BladesActionRoll] Costs", this.getRollCosts());
    const armorCost = this.getRollCosts().filter((costData) => costData.costType === "Armor").length;
    if (this.rollPrimaryDoc instanceof BladesPC$1) {
      const stressCost = this.getRollCosts().filter((costData) => costData.costType === "Stress").reduce((acc, costData) => acc + costData.costAmount, 0);
      if (stressCost !== 0) {
        this.rollPrimaryDoc.adjustStress(stressCost);
      }
      const specArmorCost = this.getRollCosts().filter((costData) => costData.costType === "SpecialArmor").length;
      if (specArmorCost !== 0) {
        this.rollPrimaryDoc.spendSpecialArmor();
      }
    }
    if (armorCost !== 0) {
      this.rollPrimary.spendArmor(armorCost);
    }
    if ((_a = this.getRollModByKey("WorsePosition-negative-position")) == null ? void 0 : _a.isActive) {
      (_b = this.rollPrimaryDoc) == null ? void 0 : _b.unsetFlag("eunos-blades", "isWorsePosition");
    }
  }
}
class BladesResistanceRoll extends BladesRoll {
  static ApplySchemaDefaults(config) {
    var _a;
    if (!config.resistanceData || !BladesConsequence.IsValidConsequenceData((_a = config.resistanceData) == null ? void 0 : _a.consequence)) {
      eLog.error("rollCollab", "[PrepareResistanceRoll] Bad Roll Consequence Data.", config);
      throw new Error("[PrepareResistanceRoll()] Bad Consequence Data for Resistance Roll");
    }
    config.rollTrait = config.resistanceData.consequence.attribute;
    eLog.checkLog3("bladesRoll", "BladesRoll.PrepareResistanceRoll() [1]", { config });
    return config;
  }
  /**
   * Asynchronously creates a new instance of this subclass of `BladesRoll`.
   *
   * Overrides the `New` static method from `BladesRoll`, applying subclass-specific configurations
   * to the instance creation process. It ensures that the returned instance is correctly typed
   * and configured for this subclass.
   *
   * @param {BladesRoll.Config} config The configuration object for creating a new roll instance,
   * extended with any subclass-specific configurations or requirements.
   *
   * @returns {Promise<InstanceType<this>>} A promise that resolves to an instance of this subclass.
   *
   * @see {@link BladesRoll.New} for the base method's functionality and the generic creation process
   * for roll instances.
   */
  static async New(config) {
    const linkConfig = this.BuildLinkConfig(config);
    const parsedConfig = {
      ...config,
      ...linkConfig
    };
    const rollInst = await super.New(parsedConfig);
    return rollInst;
  }
  get collabTemplate() {
    return `systems/eunos-blades/templates/roll/roll-collab-resistance${game.user.isGM ? "-gm" : ""}.hbs`;
  }
  get chatTemplate() {
    return "systems/eunos-blades/templates/chat/roll-result/resistance.hbs";
  }
  get stressCost() {
    if (!this.isResolved) {
      return 0;
    }
    const dieVals = [...this.finalDieVals];
    if (this.isCritical) {
      return -1;
    }
    return 6 - (dieVals.shift() ?? 0);
  }
  get rollResult() {
    if (!this.isResolved) {
      return false;
    }
    return this.stressCost;
  }
  async resolveRollResult() {
    if (this.rollPrimaryDoc instanceof BladesPC$1 && this.stressCost !== 0) {
      this.rollPrimaryDoc.adjustStress(this.stressCost);
    }
  }
}
class BladesInlineResistanceRoll extends BladesResistanceRoll {
  get chatTemplate() {
    return "systems/eunos-blades/templates/chat/components/inline-resistance.hbs";
  }
}
class BladesFortuneRoll extends BladesRoll {
  static ApplySchemaDefaults(config) {
    if (!(U.isInt(config.rollTrait) || U.lCase(config.rollTrait) in { ...ActionTrait, ...AttributeTrait, ...Factor })) {
      throw new Error(`[PrepareFortuneRoll()] Bad RollTrait for Fortune Roll: ${config.rollTrait}`);
    }
    return config;
  }
  /**
   * Asynchronously creates a new instance of this subclass of `BladesRoll`.
   *
   * Overrides the `New` static method from `BladesRoll`, applying subclass-specific configurations
   * to the instance creation process. It ensures that the returned instance is correctly typed
   * and configured for this subclass.
   *
   * @param {BladesRoll.Config} config The configuration object for creating a new roll instance,
   * extended with any subclass-specific configurations or requirements.
   *
   * @returns {Promise<InstanceType<this>>} A promise that resolves to an instance of this subclass.
   *
   * @see {@link BladesRoll.New} for the base method's functionality and the generic creation process
   * for roll instances.
   */
  static async New(config) {
    const linkConfig = this.BuildLinkConfig(config);
    const parsedConfig = {
      ...config,
      ...linkConfig
    };
    const rollInst = await super.New(parsedConfig);
    return rollInst;
  }
}
class BladesIndulgeViceRoll extends BladesRoll {
  static ApplySchemaDefaults(config) {
    var _a;
    const rollPrimaryDoc = BladesRollPrimary.GetDoc((_a = config.rollPrimaryData) == null ? void 0 : _a.rollPrimaryID);
    if (!rollPrimaryDoc || !BladesPC$1.IsType(rollPrimaryDoc)) {
      throw new Error("[BladesRoll.PrepareIndulgeViceRollConfig] RollPrimary must be a PC for Indulge Vice rolls.");
    }
    const { attributes } = rollPrimaryDoc;
    const minAttrVal = Math.min(...Object.values(attributes));
    config.rollTrait = U.sample(
      Object.values(AttributeTrait).filter((attr) => attributes[attr] === minAttrVal)
    )[0];
    config.rollDowntimeAction = DowntimeAction.IndulgeVice;
    return config;
  }
  /**
   * Asynchronously creates a new instance of this subclass of `BladesRoll`.
   *
   * Overrides the `New` static method from `BladesRoll`, applying subclass-specific configurations
   * to the instance creation process. It ensures that the returned instance is correctly typed
   * and configured for this subclass.
   *
   * @param {BladesRoll.Config} config The configuration object for creating a new roll instance,
   * extended with any subclass-specific configurations or requirements.
   *
   * @returns {Promise<InstanceType<this>>} A promise that resolves to an instance of this subclass.
   *
   * @see {@link BladesRoll.New} for the base method's functionality and the generic creation process
   * for roll instances.
   */
  static async New(config) {
    const linkConfig = this.BuildLinkConfig(config);
    const parsedConfig = {
      ...config,
      ...linkConfig
    };
    const rollInst = await super.New(parsedConfig);
    return rollInst;
  }
  get collabTemplate() {
    return `systems/eunos-blades/templates/roll/roll-collab-indulgevice${game.user.isGM ? "-gm" : ""}.hbs`;
  }
  get chatTemplate() {
    return "systems/eunos-blades/templates/chat/roll-result/indulgevice.hbs";
  }
  get rollResult() {
    if (!this.isResolved) {
      return false;
    }
    return this.highestDieVal;
  }
  async resolveRollResult() {
    if (BladesPC$1.IsType(this.rollPrimaryDoc)) {
      this.rollPrimaryDoc.indulgeStress(this.highestDieVal);
    }
  }
}
class BladesEngagementRoll extends BladesFortuneRoll {
  static get DefaultRollModSchemaSet() {
    return [
      {
        key: "BoldPlan-positive-roll",
        name: "Bold Plan",
        section: RollModSection.roll,
        base_status: RollModStatus.ToggledOff,
        posNeg: "positive",
        modType: RollModType.general,
        value: 1,
        effectKeys: [],
        tooltip: "<h1></h1><p></p>"
      },
      {
        key: "ComplexPlan-negative-roll",
        name: "Complex Plan",
        section: RollModSection.roll,
        base_status: RollModStatus.ToggledOff,
        posNeg: "negative",
        modType: RollModType.general,
        value: 1,
        effectKeys: [],
        tooltip: "<h1></h1><p></p>"
      },
      {
        key: "ExploitWeakness-positive-roll",
        name: "Exploiting a Weakness",
        section: RollModSection.roll,
        base_status: RollModStatus.ToggledOff,
        posNeg: "positive",
        modType: RollModType.general,
        value: 1,
        effectKeys: [],
        tooltip: "<h1></h1><p></p>"
      },
      {
        key: "WellDefended-negative-roll",
        name: "Well-Defended",
        section: RollModSection.roll,
        base_status: RollModStatus.ToggledOff,
        posNeg: "negative",
        modType: RollModType.general,
        value: 1,
        effectKeys: [],
        tooltip: "<h1></h1><p></p>"
      },
      {
        key: "HelpFromFriend-positive-roll",
        name: "Help From a Friend",
        section: RollModSection.position,
        base_status: RollModStatus.ToggledOff,
        posNeg: "positive",
        modType: RollModType.general,
        value: 1,
        effectKeys: [],
        tooltip: "<h1>Help From a Friend</h1><p>Add <strong>+1d</strong> if you enlist the help of a friend or contact.</p>"
      },
      {
        key: "EnemyInterference-negative-roll",
        name: "Enemy Interference",
        section: RollModSection.roll,
        base_status: RollModStatus.ToggledOff,
        posNeg: "negative",
        modType: RollModType.general,
        value: 1,
        effectKeys: [],
        tooltip: "<h1></h1><p></p>"
      }
    ];
  }
  get chatTemplate() {
    return "systems/eunos-blades/templates/chat/roll-result/fortune-engagement.hbs";
  }
}
class BladesIncarcerationRoll extends BladesFortuneRoll {
  get chatTemplate() {
    return "systems/eunos-blades/templates/chat/roll-result/fortune-incarceration.hbs";
  }
}
const BladesRoll$1 = BladesRoll;
class BladesChat extends ChatMessage {
  static Initialize() {
    Hooks.on("renderChatMessage", (msg, html) => {
      ApplyTooltipAnimations(html);
      const { rollData } = msg.flagData;
      if (rollData) {
        BladesConsequence.ApplyChatListeners(msg);
      }
      html.addClass("display-ok");
    });
    return loadTemplates([
      "systems/eunos-blades/templates/chat/roll-result/action.hbs",
      "systems/eunos-blades/templates/chat/roll-result/action-clock.hbs",
      "systems/eunos-blades/templates/chat/roll-result/action-acquireasset.hbs",
      "systems/eunos-blades/templates/chat/roll-result/action-reduceheat.hbs",
      "systems/eunos-blades/templates/chat/roll-result/action-clock-recover.hbs",
      "systems/eunos-blades/templates/chat/roll-result/action-gatherinfo.hbs",
      "systems/eunos-blades/templates/chat/roll-result/fortune.hbs",
      "systems/eunos-blades/templates/chat/roll-result/fortune-clock.hbs",
      "systems/eunos-blades/templates/chat/roll-result/fortune-gatherinfo.hbs",
      "systems/eunos-blades/templates/chat/roll-result/fortune-incarceration.hbs",
      "systems/eunos-blades/templates/chat/roll-result/fortune-engagement.hbs",
      "systems/eunos-blades/templates/chat/roll-result/indulgevice.hbs",
      "systems/eunos-blades/templates/chat/roll-result/resistance.hbs",
      "systems/eunos-blades/templates/chat/components/inline-resistance.hbs",
      "systems/eunos-blades/templates/chat/components/die.hbs"
    ]);
  }
  // static async ConstructRollOutput(rollInst: BladesRoll): Promise<BladesChat> {
  //   const rollData = {
  //     ...rollInst.data,
  //     rollTraitVerb: rollInst.rollTraitVerb ?? "",
  //     rollTraitPastVerb: rollInst.rollTraitPastVerb ?? rollInst.rollTraitVerb ?? ""
  //   };
  //   return await BladesChat.create({
  //     speaker: rollInst.getSpeaker(BladesChat.getSpeaker()),
  //     content: await renderTemplate(rollInst.template, rollData),
  //     type: CONST.CHAT_MESSAGE_TYPES.ROLL,
  //     flags: {
  //       "eunos-blades": {
  //         template: rollInst.template,
  //         rollData
  //       }
  //     }
  //   }) as BladesChat;
  // }
  static IsNewestRollResult(rollInst) {
    const lastRollResultID = $("#chat-log .chat-message .blades-roll:not(.inline-roll)").last().attr("id");
    return typeof lastRollResultID === "string" && lastRollResultID === rollInst.id;
  }
  get flagData() {
    return this.flags["eunos-blades"];
  }
  get rollData() {
    return this.flagData.rollData;
  }
  async setFlagVal(scope, key, val) {
    return await this.setFlag(C.SYSTEM_ID, `${scope}.${key}`, val);
  }
  get allRollConsequences() {
    const returnData = {
      [Position.controlled]: {
        [RollResult.critical]: {},
        [RollResult.success]: {},
        [RollResult.partial]: {},
        [RollResult.fail]: {}
      },
      [Position.risky]: {
        [RollResult.critical]: {},
        [RollResult.success]: {},
        [RollResult.partial]: {},
        [RollResult.fail]: {}
      },
      [Position.desperate]: {
        [RollResult.critical]: {},
        [RollResult.success]: {},
        [RollResult.partial]: {},
        [RollResult.fail]: {}
      }
    };
    const { consequenceData } = this.flagData.rollData ?? {};
    if (!consequenceData) {
      return returnData;
    }
    Object.entries(consequenceData).forEach(([position, positionData]) => {
      Object.entries(positionData).forEach(([rollResult, csqDataSet]) => {
        returnData[position][rollResult] = Object.fromEntries(
          Object.entries(csqDataSet).filter(([id, cData]) => cData.id).map(([id, cData]) => [
            id,
            game.eunoblades.Consequences.get(cData.id) ?? new BladesConsequence(cData)
          ])
        );
      });
    });
    return returnData;
  }
  get rollConsequences() {
    var _a;
    if (!this.parentRoll) {
      return [];
    }
    const { rollPositionFinal, rollResult, consequenceData } = this.parentRoll.data;
    if (!rollPositionFinal || !rollResult || !consequenceData) {
      return [];
    }
    if (typeof rollResult !== "string" || ![RollResult.partial, RollResult.fail].includes(rollResult)) {
      return [];
    }
    const activeConsequences = ((_a = consequenceData == null ? void 0 : consequenceData[rollPositionFinal]) == null ? void 0 : _a[rollResult]) ?? {};
    return Object.values(activeConsequences).map((cData) => game.eunoblades.Consequences.get(cData.id) ?? new BladesConsequence(cData));
  }
  get elem$() {
    return $("#chat-log").find(`.chat-message[data-message-id="${this.id}"]`);
  }
  get elem() {
    return this.elem$[0];
  }
  get isRollResult() {
    return "rollData" in this.flagData;
  }
  get parentRoll() {
    if (!this.isRollResult) {
      return void 0;
    }
    const { rollData } = this.flagData;
    if (!rollData) {
      return void 0;
    }
    return game.eunoblades.Rolls.get(rollData.id ?? "") ?? new BladesRoll$1({
      ...rollData,
      isScopingById: false
    });
  }
  get roll$() {
    return this.parentRoll ? this.elem$.find(`#${this.parentRoll.id}`) : void 0;
  }
  async regenerateFromFlags() {
    if (this.isRollResult) {
      await this.update({ content: await renderTemplate(this.flagData.template, this) });
    }
  }
  async render(force) {
    await super.render(force);
    await this.activateListeners();
  }
  async activateListeners() {
    if (!this.elem$) {
      eLog.error("BladesChat", `No BladesChat.elem found for id ${this.id}.`);
      return;
    }
    ApplyTooltipAnimations(this.elem$);
    BladesConsequence.ApplyChatListeners(this);
    if (this.parentRoll) {
      this.elem$.addClass(`${this.parentRoll.rollType.toLowerCase()}-roll`);
      if (this.parentRoll.rollType === RollType.Action && this.rollConsequences.some((csq) => !csq.isAccepted)) {
        this.elem$.addClass("unresolved-action-roll");
      } else {
        this.elem$.removeClass("unresolved-action-roll");
      }
      if (BladesChat.IsNewestRollResult(this.parentRoll)) {
        $("#chat-log .chat-message").removeClass("active-chat-roll");
        this.elem$.addClass("active-chat-roll");
      } else {
        this.elem$.removeClass("active-chat-roll");
      }
    }
    U.gsap.to(this.elem$, { autoAlpha: 1, duration: 0.15, ease: "none" });
  }
}
const BladesChat$1 = BladesChat;
const LOGGERCONFIG = {
  fullName: "eLogger",
  aliases: ["dbLog"],
  stackTraceExclusions: {
    handlebars: [/scripts\/handlebars/]
    // From internal Handlebars module
  }
};
const STYLES = {
  base: {
    background: C.Colors.BLACK,
    color: C.Colors.dGOLD,
    "font-family": "Pragmata Pro",
    padding: "0 25px",
    "margin-right": "25px"
  },
  log0: {
    background: C.Colors.dGOLD,
    color: C.Colors.dBLACK,
    "font-size": "16px"
  },
  log1: {
    background: C.Colors.dBLACK,
    color: C.Colors.bGOLD,
    "font-size": "16px"
  },
  log2: {
    background: C.Colors.dBLACK,
    color: C.Colors.dGOLD,
    "font-size": "16px"
  },
  log3: {
    "font-size": "14px"
  },
  log4: {
    "font-size": "12px"
  },
  log5: {
    background: C.Colors.dGREY,
    color: C.Colors.bGREY,
    "font-size": "10px"
  },
  display: {
    color: C.Colors.bGOLD,
    "font-family": "Kirsty",
    "font-size": "16px",
    "margin-left": "-100px",
    padding: "0 100px"
  },
  warn: {
    color: C.Colors.dBLACK,
    background: C.Colors.dGOLD,
    "font-weight": 500
  },
  error: {
    color: C.Colors.bRED,
    background: C.Colors.ddRED,
    "font-weight": 500
  },
  handlebars: {
    background: C.Colors.GREY,
    color: C.Colors.BLUE,
    "font-family": "Pragmata Pro",
    padding: "0",
    "margin-right": "25px"
  },
  stack: {
    color: C.Colors.GOLD,
    "font-weight": 100,
    "font-size": "10px",
    "font-family": "Pragmata Pro"
  }
};
const { base: baseStyles, ...typeStyles } = STYLES;
const STYLELINES = Object.fromEntries(
  Object.entries(typeStyles).map(([styleName, styles]) => [
    styleName,
    Object.entries({ ...baseStyles, ...styles }).map(([prop, val]) => `${prop}: ${val};`).join(" ")
  ])
);
const eLogger = (type = "base", ...content) => {
  if (!(["error", "display"].includes(type) || CONFIG.debug.logging)) {
    return;
  }
  const lastElem = U.getLast(content);
  let dbLevel = typeof lastElem === "number" && [0, 1, 2, 3, 4, 5].includes(lastElem) ? content.pop() : 3;
  let key = false;
  if (type === "checkLog") {
    key = content.shift();
    type = `log${dbLevel}`;
  }
  const [message, ...data] = content;
  if (key) {
    const blacklist = (U.getSetting("blacklist") ?? "").split(/,/).map((pat) => new RegExp(`\\b${pat.trim()}\\b`, "igu"));
    const whitelist = (U.getSetting("whitelist") ?? "").split(/,/).map((pat) => new RegExp(`\\b${pat.trim()}\\b`, "igu"));
    const isBlack = blacklist.some((pat) => pat.test(key));
    const isWhite = whitelist.some((pat) => pat.test(key));
    if (isBlack && !isWhite) {
      dbLevel = Math.max(4, Math.min(5, dbLevel + 2));
    }
    if (isWhite && !isBlack) {
      dbLevel = Math.min(3, Math.max(1, dbLevel - 2));
    }
  }
  if ((U.getSetting("debug") ?? 5) < dbLevel) {
    return;
  }
  if (type === "log") {
    type = `${type}${dbLevel}`;
  }
  const stackTrace = type === "display" ? null : getStackTrace(LOGGERCONFIG.stackTraceExclusions[type] ?? []);
  let logFunc;
  if (stackTrace) {
    logFunc = console.groupCollapsed;
  } else if (data.length <= 1) {
    logFunc = console.log;
  } else {
    logFunc = console.group;
  }
  if (data.length === 0) {
    if (typeof message === "string") {
      logFunc(`%c${message}`, STYLELINES[type]);
    } else {
      logFunc("%o", message);
    }
  } else {
    logFunc(`%c${message}${typeof data[0] === "string" ? "" : " %o"}`, STYLELINES[type], data.shift());
    data.forEach((line) => {
      if (typeof line === "string") {
        console.log(line);
      } else {
        console.log("%o", line);
      }
    });
  }
  if (stackTrace) {
    console.group("%cSTACK TRACE", `color: ${C.Colors.dGOLD}; font-family: "Pragmata Pro"; font-size: 12px; background: ${C.Colors.BLACK}; font-weight: bold; padding: 0 10px;`);
    console.log(`%c${stackTrace}`, Object.entries(STYLES.stack).map(([prop, val]) => `${prop}: ${val};`).join(" "));
    console.groupEnd();
  }
  console.groupEnd();
  function getStackTrace(regExpFilters = []) {
    regExpFilters.push(new RegExp(`at (getStackTrace|${LOGGERCONFIG.fullName}|${LOGGERCONFIG.aliases.map(String).join("|")}|Object\\.(log|display|hbsLog|error))`), /^Error/);
    return (new Error().stack ?? "").split(/\n/).map((sLine) => sLine.trim()).filter((sLine) => !regExpFilters.some((rTest) => rTest.test(sLine))).join("\n");
  }
};
const logger = {
  display: (...content) => eLogger("display", ...content),
  log0: (...content) => eLogger("log", ...content, 0),
  log1: (...content) => eLogger("log", ...content, 1),
  log2: (...content) => eLogger("log", ...content, 2),
  log: (...content) => eLogger("log", ...content, 3),
  log3: (...content) => eLogger("log", ...content, 3),
  log4: (...content) => eLogger("log", ...content, 4),
  log5: (...content) => eLogger("log", ...content, 5),
  checkLog0: (...content) => eLogger("checkLog", ...content, 0),
  checkLog1: (...content) => eLogger("checkLog", ...content, 1),
  checkLog2: (...content) => eLogger("checkLog", ...content, 2),
  checkLog: (...content) => eLogger("checkLog", ...content, 3),
  checkLog3: (...content) => eLogger("checkLog", ...content, 3),
  checkLog4: (...content) => eLogger("checkLog", ...content, 4),
  checkLog5: (...content) => eLogger("checkLog", ...content, 5),
  warn: (...content) => eLogger("warn", ...content),
  error: (...content) => eLogger("error", ...content),
  hbsLog: (...content) => eLogger("handlebars", ...content)
};
class BladesScene extends Scene {
  async registerClockKey(clockKey) {
    this.update({ [`clockKeys.${clockKey.id}`]: true });
  }
  async unregisterClockKey(clockKey) {
    if (typeof clockKey === "string") {
      this.update({ [`clockKeys.-=${clockKey}`]: null });
    } else {
      this.update({ [`clockKeys.-=${clockKey.id}`]: null });
    }
  }
}
class AIAssistant {
  constructor(nameOrID, instructions, model = "gpt-4-1106-preview", { isUsingRetrieval, functionTools, file_ids, metadata } = {}) {
    __privateAdd(this, _apiKey, void 0);
    __privateAdd(this, _id, void 0);
    __privateAdd(this, _name, void 0);
    __privateAdd(this, _instructions, void 0);
    __privateAdd(this, _tools, void 0);
    __privateAdd(this, _model, void 0);
    __privateAdd(this, _fileIDs, void 0);
    __privateAdd(this, _metadata, void 0);
    __privateSet(this, _id, "");
    __privateSet(this, _name, "");
    __privateSet(this, _instructions, instructions ?? "");
    __privateSet(this, _tools, []);
    __privateSet(this, _model, model);
    __privateSet(this, _fileIDs, file_ids ?? []);
    __privateSet(this, _metadata, metadata ?? {});
    const apiKey = U.getSetting("openAPIKey");
    if (!apiKey) {
      throw new Error("API Key required in Settings to use AI features.");
    }
    __privateSet(this, _apiKey, apiKey);
    if (instructions) {
      __privateSet(this, _name, nameOrID);
      if (isUsingRetrieval) {
        __privateGet(this, _tools).push({ type: "retrieval" });
      }
      if (functionTools && functionTools.length) {
        __privateGet(this, _tools).push(...functionTools);
      }
      this.createAssistant();
    } else {
      __privateSet(this, _id, nameOrID);
      this.retrieveAssistant();
    }
  }
  get name() {
    return __privateGet(this, _name);
  }
  async createAssistant() {
    const fetchRequest = {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${__privateGet(this, _apiKey)}`,
        "OpenAI-Beta": "assistants=v1"
      },
      body: JSON.stringify({
        name: __privateGet(this, _name),
        instructions: __privateGet(this, _instructions),
        tools: __privateGet(this, _tools),
        model: __privateGet(this, _model),
        file_ids: __privateGet(this, _fileIDs)
      })
    };
    eLog.checkLog3("BladesAssistant", "Fetch Request", fetchRequest);
    const response = await fetch(
      "https://api.openai.com/v1/assistants",
      fetchRequest
    );
    if (!response.ok) {
      console.log("Failed AI Request:", JSON.parse(fetchRequest.body));
      throw new Error(`OpenAI API request failed with status ${response.status}`);
    }
    const data = await response.json();
    fetchRequest.body = JSON.parse(fetchRequest.body);
    eLog.checkLog3("BladesAI", "AI Query", { prompt: fetchRequest, response: data });
    __privateSet(this, _id, data.id);
  }
  async retrieveAssistant() {
    const fetchRequest = {
      method: "GET",
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${__privateGet(this, _apiKey)}`,
        "OpenAI-Beta": "assistants=v1"
      }
    };
    const response = await fetch(
      `https://api.openai.com/v1/assistants/${__privateGet(this, _id)}`,
      fetchRequest
    );
    if (!response.ok) {
      throw new Error(`OpenAI API request failed with status ${response.status}`);
    }
    const data = await response.json();
    eLog.checkLog3("BladesAI", "AI Query", { prompt: fetchRequest, response: data });
    __privateSet(this, _name, data.name);
    __privateSet(this, _instructions, data.instructions);
    __privateSet(this, _tools, data.tools);
    __privateSet(this, _model, data.model);
    __privateSet(this, _fileIDs, data.file_ids);
    __privateSet(this, _metadata, data.metadata);
  }
}
_apiKey = new WeakMap();
_id = new WeakMap();
_name = new WeakMap();
_instructions = new WeakMap();
_tools = new WeakMap();
_model = new WeakMap();
_fileIDs = new WeakMap();
_metadata = new WeakMap();
class BladesAI {
  /**
   * AI class constructor
   * @param {BladesAI.Config} [config] Configuration settings for the API
   */
  constructor(config) {
    __publicField(this, "apiKey");
    __publicField(this, "model");
    __publicField(this, "temperature", 0.5);
    __publicField(this, "frequency_penalty", 0.8);
    __publicField(this, "presence_penalty", 0.8);
    __publicField(this, "systemMessage");
    __publicField(this, "examplePrompts");
    __publicField(this, "_initialMessages", []);
    __publicField(this, "prompts", {});
    __publicField(this, "responses", {});
    const apiKey = U.getSetting("openAPIKey");
    if (!apiKey) {
      throw new Error("You must configure your OpenAI API Key in Settings to use AI features.");
    }
    this.model = U.getSetting("openAPIModelLevel");
    if (typeof this.model !== "number") {
      eLog.error("BladesAI", "Set base AI quality in settings. Defaulting to lowest.");
      this.model = 0;
    }
    this.apiKey = apiKey;
    this.systemMessage = config.systemMessage;
    this.examplePrompts = config.examplePrompts;
    this.temperature = config.temperature ?? this.temperature;
    this.frequency_penalty = config.frequency_penalty ?? this.frequency_penalty;
    this.presence_penalty = config.presence_penalty ?? this.presence_penalty;
  }
  static async GetModels(isVerbose = false) {
    const apiKey = U.getSetting("openAPIKey");
    if (!apiKey) {
      throw new Error("You must configure your OpenAI API Key in Settings to use AI features.");
    }
    const fetchRequest = {
      method: "GET",
      headers: {
        Authorization: `Bearer ${apiKey}`
      }
    };
    const response = await fetch(
      "https://api.openai.com/v1/models",
      fetchRequest
    );
    if (!response.ok) {
      throw new Error(`OpenAI API request failed with status ${response.status}`);
    }
    const data = await response.json();
    const dataList = Object.fromEntries(data.map(({ id, ...mData }) => [id, mData]));
    if (isVerbose) {
      eLog.checkLog3("BladesAI", "Available Models", { dataList });
    }
  }
  get initialMessages() {
    if (this._initialMessages.length === 0) {
      this._initialMessages.push({
        role: "system",
        content: this.systemMessage
      });
      for (const { human, ai } of this.examplePrompts) {
        this._initialMessages.push({
          role: "user",
          content: human
        });
        this._initialMessages.push({
          role: "assistant",
          content: ai
        });
      }
    }
    return this._initialMessages;
  }
  getResponse(queryID) {
    return this.responses[queryID] ?? null;
  }
  hasQueried(queryID) {
    return this.prompts[queryID] !== void 0;
  }
  /**
   * Query OpenAI API
   * @param {string} queryID A label for later retrieval of the query data
   * @param {string} prompt The prompt to send to the API
   * @param {number} [modelMod] Optional modifier to the base model level.
   *                            If provided, the final model quality will be adjusted by this number.
   * @param {boolean} [extendedContext=false] Optional flag to indicate whether to use extended context models.
   *                            If true, extended context models are used; otherwise, base context models are used.
   * @returns {Promise<Response>} The API response
   */
  async query(queryID, prompt, modelMod, extendedContext = false) {
    if (!prompt) {
      return;
    }
    this.responses[queryID] = null;
    const modelNum = typeof modelMod === "number" ? U.clampNum(this.model + modelMod, [0, 2]) : this.model;
    const model = extendedContext ? C.AI_MODELS.extendedContext[modelNum] : C.AI_MODELS.baseContext[modelNum];
    const fetchRequest = {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${this.apiKey}`
      },
      body: JSON.stringify({
        model,
        temperature: this.temperature,
        frequency_penalty: this.frequency_penalty,
        presence_penalty: this.presence_penalty,
        messages: [
          ...this.initialMessages,
          {
            role: "user",
            content: prompt
          }
        ]
      })
    };
    const response = await fetch(
      "https://api.openai.com/v1/chat/completions",
      fetchRequest
    );
    if (!response.ok) {
      console.log("Failed AI Request:", JSON.parse(fetchRequest.body));
      throw new Error(`OpenAI API request failed with status ${response.status}`);
    }
    const data = await response.json();
    fetchRequest.body = JSON.parse(fetchRequest.body);
    eLog.checkLog3("BladesAI", "AI Query", { prompt: fetchRequest, response: data });
    this.responses[queryID] = data.choices[0].message.content;
    return this.responses[queryID];
  }
}
const AGENTS = {
  GeneralContentGenerator: {
    systemMessage: `You will act as a creative content generator for a game of Blades In The Dark set in the city of Duskvol. You will be prompted with some element of the game world (a location, a character, an event, a faction, a dilemma) in the form of a JSON object. Your job is to analyze the JSON object and replace any values that equal "<GEN>" with original content of your own creation. Original content must meet these requirements:  (A) it should align with and be consistent with the provided contextual information, as well as your broader understanding of the game's themes. (B) It should be presented in a format that matches (in length and in style) other entries for that particular value, examples of which will also be provided. (C) It should be creative, interesting, and daring: Be bold with your creativity. Specific context for this prompt is as follows:`,
    examplePrompts: []
  },
  NPCGenerator: {
    systemMessage: `You will play the role of a "creative content generator" for random NPCs generated for the Blades In The Dark roleplaying system. When prompted with a description of a subject (an NPC, a category of NPCs, a faction, or a group of NPCs), you will respond with a pipe-delimited list of sixteen items, divided into four categories, prefacing each category with the associated header in square brackets: [5 KEYWORDS] Five one-word keywords describing the subject. [5 PHRASES] Five evocative phrases that could be used by a GM directly when narrating the subject during play. These should be extremely well-worded, very original, and packed with drama and evocative imagery. Be bold with your responses here. [3 QUIRKS/MOTIFFS] Three phrases describing potential quirks or motiffs that a GM could employ in a scene involving the subject. [3 PLOT HOOKS] Three plot hooks that could directly and specifically involve one or more of the PCs. The PCs are: (1) Alistair, full name Lord Alistair Bram Chesterfield, the crew's boss, a Spider with connections among the nobility; (2) High-Flyer, a former noble himself, now serving as the crew's Slide; (3) Jax, a stoic and laconic Hound with ties to the disenfranchised of Duskvol; (4) Ollie, the youngest of the crew at barely nineteen, a prodigy Leech with knowledge of alchemy and spark-craft, who grew up as an orphan in Duskvol's underground; (5) Wraith, the mysterious Lurk of the crew, who never speaks for reasons unknown; and (6) Spencer, the bookish Whisper of the crew, who harbors a secret fascination for demons and all things related to them.`,
    examplePrompts: [
      {
        human: "The Billhooks, a hack-and-slash gang of toughened thugs. The Billhooks have a bloody reputation, often leaving the butchered corpses of their victims strewn about in a grisly display. Many wonder why the Bluecoats turn a blind eye to their savagery. Based out of their butcher shop headquarters, they are led by Tarvul, who is currently serving life in prison.",
        ai: "[5 KEYWORDS]brutal|unrelenting|savage|fierce|unhinged|[5 PHRASES]blood-flecked, yellowed teeth|eyes that want to flay your skin from your bones|crooked leer like he's looking at his Judas goat|reek like a charnel house|gobbets of a meaty lunch still in his beard|[3 QUIRKS/MOTIFFS]always ready to wreck, vandalize or destroy something|relish in instilling fear in others|have a twisted sense of loyalty|[3 PLOT HOOKS]Tarvul hires the crew to start a war among his most promising underlings, intending to make whoever survives his successor|the Billhooks kidnap a member of High-Flyer's noble family|a Demon of Shadows promises Spencer the answer to three questions, in exchange for an artifact recently stolen by the Billhooks"
      },
      {
        human: "The hooded proprietor of a half-flooded grotto tavern near the docks. 'Strange passageways lead to stranger chambers beyond.' Vice Purveyor - Weird.",
        ai: "[5 KEYWORDS]mysterious|cryptic|enigmatic|peculiar|shrouded|[5 PHRASES]a voice like wet burlap sliding over gravel|the flicker of torchlight dancing on the flooded floor|the scent of brackish water and old spices|a smile that hinted at a thousand secrets hidden in the shadows|hands gnarled as driftwood, eternally damp|[3 QUIRKS/MOTIFFS]has an uncanny knack for knowing patrons' darkest secrets without them telling him|never seems to sleep or leave the tavern, always there no matter what time you visit|always seen with a strange, luminescent creature that lives in one of the flooded chambers behind the bar|[3 PLOT HOOKS]Alistair hears rumors that this tavern is actually a front for a powerful secret society - perhaps they could be useful allies...or dangerous enemies.|The proprietor offers Ollie a rare alchemical ingredient - but it's not for sale. He'll only trade it for something equally valuable.|Wraith overhears whispers about a hidden chamber beneath the tavern where unimaginable treasures are kept."
      },
      {
        human: "Setarra, a Demon. Patient, Defiant, Ruthless, Cold",
        ai: "[5 KEYWORDS]shadowy|sinister|unfathomable|enigmatic|tempting|[5 PHRASES]whispers that crawl under your skin|always watching, always plotting|in tones of silk and venom|intoxicating presence that draws you closer, despite your instincts urging you to run|eyes like black holes, swallowing all light around them|[3 QUIRKS/MOTIFFS]a disorienting mist clings to her form, obscuring her true shape|casually discusses the devastating acts of capricious revenge she has taken on those who crossed her|never forgets a slight or betrayal, no matter how small or insignificant it may seem at the time|[3 PLOT HOOKS]seeks revenge against Alistair for meddling in her affairs years ago|makes Ollie an offer he can't refuse: unlimited access to forbidden alchemical knowledge in exchange for a single favor, to be called in at some future time|tempts Spencer with forbidden knowledge about demons, promising answers to all their questions if they perform a dangerous ritual"
      }
      /*
      "brutish,merciless,terrifying,savage,loyal,
      bloody tools,hulking figures,blood-soaked alleys,grimy aprons,grisly displays,
      never clean their tools,relishes the terror they inspire,occasional laughter among them,
      recruiting a PC to perform a job for them from prison,
      the gang blames one of the PCs for Tarvul's imprisonment and they're out for revenge" */
    ]
  },
  ConsequenceAdjuster: {
    systemMessage: `You will act as a "Setback Adjuster" for a game of Blades In The Dark.  You will be prompted with a short phrase describing an injury, lasting consequence or other setback. Your job is to respond with a pipe-delimited list of three possible alternative consequences that are less severe by one level, using the following scale as a rough guide: Level 1 = Lesser (e.g. 'Battered', 'Drained', 'Distracted', 'Scared', 'Confused'), Level 2 = Moderate (e.g. 'Exhausted', 'Deep Cut to Arm', 'Concussion', 'Panicked', 'Seduced'), Level 3 = Severe (e.g. 'Impaled', 'Broken Leg', 'Shot In Chest', 'Badly Burned', 'Terrified'), Level 4 = Fatal or Ruinous (e.g. 'Impaled Through Heart', 'Electrocuted', 'Headquarters Burned to the Ground'). So, if you determine that the consequence described in the prompt is severity level 3, you should respond with three narratively similar consequences that are severity level 2.  Your three suggestions should be different from each other, but they should all logically follow from the initial harm described: You should not introduce new facts or make assumptions that are not indicated in the initial prompt. The consequences you suggest should always describe a NEGATIVE setback or complication, just one that is less severe than the one described in the prompt.`,
    examplePrompts: [
      { human: "Shattered Right Leg", ai: "Fractured Right Ankle|Dislocated Knee|Broken Foot" },
      { human: "Soul Destroyed", ai: "Fully Corrupted|Lost In Darkness|Spirit Broken" },
      { human: "Humiliated", ai: "Embarrassed|Momentarily Off-Balance|Enraged" },
      { human: "She Escapes!", ai: "She Spots a Means of Escape|She Puts More Distance Between You|She Stops to Gloat" },
      { human: "The fire spreads to the hostages.", ai: "The fire approaches the hostages.|The hostages must be evacuated.|The fire billows choking black smoke." }
    ]
  }
};
class BladesGMTrackerSheet extends BladesItemSheet {
  // static Get() { return game.eunoblades.Tracker as BladesGMTracker; }
  static get defaultOptions() {
    return foundry.utils.mergeObject(super.defaultOptions, {
      classes: ["eunos-blades", "sheet", "item", "gm-tracker"],
      template: "systems/eunos-blades/templates/items/gm_tracker-sheet.hbs",
      width: 700,
      height: 970
    });
  }
  static async Initialize() {
    Items.registerSheet("blades", BladesGMTrackerSheet, { types: ["gm_tracker"], makeDefault: true });
    return loadTemplates([
      "systems/eunos-blades/templates/items/gm_tracker-sheet.hbs"
    ]);
  }
  async activateListeners(html) {
    super.activateListeners(html);
  }
  async _onSubmit(event, params = {}) {
    const prevPhase = this.item.system.phase;
    const submitData = await super._onSubmit(event, params);
    const newPhase = this.item.system.phase;
    let isForcingRender = true;
    if (prevPhase !== newPhase) {
      switch (prevPhase) {
        case BladesPhase.CharGen: {
          break;
        }
        case BladesPhase.Freeplay: {
          break;
        }
        case BladesPhase.Score: {
          isForcingRender = false;
          game.actors.filter((actor) => BladesActor$1.IsType(actor, BladesActorType.pc)).forEach((actor) => actor.clearLoadout());
          break;
        }
        case BladesPhase.Downtime: {
          break;
        }
      }
      switch (newPhase) {
        case BladesPhase.CharGen: {
          break;
        }
        case BladesPhase.Freeplay: {
          break;
        }
        case BladesPhase.Score: {
          break;
        }
        case BladesPhase.Downtime: {
          break;
        }
      }
    }
    if (isForcingRender) {
      game.actors.filter((actor) => actor.type === BladesActorType.pc).forEach((actor) => {
        var _a;
        return (_a = actor.sheet) == null ? void 0 : _a.render();
      });
    }
    return submitData;
  }
}
class BladesClockKeeperSheet extends BladesItemSheet {
  // static Get() { return game.eunoblades.ClockKeeper as BladesClockKeeper; }
  static get defaultOptions() {
    return foundry.utils.mergeObject(super.defaultOptions, {
      classes: ["eunos-blades", "sheet", "item", "clock-keeper"],
      template: "systems/eunos-blades/templates/items/clock_keeper-sheet.hbs",
      width: 700,
      height: 970,
      // submitOnChange: false,
      tabs: [{ navSelector: ".nav-tabs", contentSelector: ".tab-content", initial: "scene-keys" }]
    });
  }
  static async Initialize() {
    Items.registerSheet("blades", BladesClockKeeperSheet, { types: ["clock_keeper"], makeDefault: true });
    return loadTemplates([
      "systems/eunos-blades/templates/items/clock_keeper-sheet.hbs"
    ]);
  }
  getData() {
    const context = super.getData();
    const sheetData = {
      currentScene: game.scenes.current.id,
      targetScene: this.item.targetSceneID,
      sceneOptions: Array.from(game.scenes),
      sceneKeys: this.item.getSceneKeys(this.item.system.targetScene ?? game.scenes.current.id),
      pcsWithProjects: BladesPC$1.All.filter((pc) => pc.projects.length > 0),
      factions: Array.from(BladesFaction$1.All)
    };
    return { ...context, ...sheetData };
  }
  addKey(event) {
    event.preventDefault();
    this.item.addClockKey();
  }
  deleteKey(event) {
    event.preventDefault();
    const keyID = event.currentTarget.dataset.id;
    if (keyID) {
      this.item.deleteClockKey(keyID);
    }
  }
  setSelectColor(select$, value) {
    value ?? (value = select$.data("value"));
    switch (value) {
      case ClockColor.yellow: {
        U.gsap.set(select$, {
          color: "var(--blades-black)",
          background: "var(--blades-gold-bright)",
          textShadow: "none"
        });
        break;
      }
      case ClockColor.red: {
        U.gsap.set(select$, {
          color: "var(--blades-white)",
          background: "var(--blades-red)"
        });
        break;
      }
      case ClockColor.cyan: {
        U.gsap.set(select$, {
          color: "var(--blades-black)",
          background: "var(--blades-blue-bright)",
          textShadow: "none"
        });
        break;
      }
      case ClockColor.white: {
        U.gsap.set(select$, {
          color: "var(--blades-black)",
          background: "var(--blades-white)",
          textShadow: "none"
        });
        break;
      }
    }
  }
  async activateListeners(html) {
    await super.activateListeners(html);
    html.find('[data-action="create-clock-key"').on({
      click: async (event) => {
        event.preventDefault();
        await this.item.addClockKey();
      }
    });
    function getClockKeyFromEvent(event) {
      const id = $(event.currentTarget).data("keyId") || $(event.currentTarget).closest(".control-flipper").data("clockKeyId");
      if (!id) {
        throw new Error("No id found on element");
      }
      const clockKey = game.eunoblades.ClockKeys.get(id);
      if (!clockKey) {
        throw new Error(`Clock key with id ${id} not found`);
      }
      return clockKey;
    }
    function getClockFromEvent(event) {
      const clockKey = getClockKeyFromEvent(event);
      const clockID = $(event.currentTarget).data("clockId") || $(event.currentTarget).closest(".control-flipper").data("clockId");
      if (!clockID) {
        throw new Error("No clockID found on element");
      }
      const clock = clockKey.getClockByID(clockID);
      if (!clock) {
        throw new Error(`Clock with id ${clockID} not found`);
      }
      return [clockKey, clock];
    }
    const clockKeyControls$ = html.find(".clock-key-control-flipper");
    clockKeyControls$.find('[data-action="toggle-name-visibility"]').each((i, elem) => {
      const elem$ = $(elem);
      const control$ = elem$.closest(".clock-key-control-flipper");
      elem$.on({
        click: async (event) => {
          event.preventDefault();
          const clockKey = getClockKeyFromEvent(event);
          const isNameVisible = !clockKey.isNameVisible;
          clockKey.updateTarget("isNameVisible", isNameVisible);
          if (clockKey.isInScene() && clockKey.isVisible) {
            if (isNameVisible) {
              clockKey.fadeInName_SocketCall(ClockDisplayContext.overlay);
            } else {
              clockKey.fadeOutName_SocketCall(ClockDisplayContext.overlay);
            }
          }
          control$.find('[data-action="toggle-name-visibility"] i').toggleClass("fa-signature").toggleClass("fa-signature-slash").toggleClass("fa-solid").toggleClass("fa-regular");
        }
      });
    });
    clockKeyControls$.find('[data-action="toggle-spotlight"]').each((i, elem) => {
      const elem$ = $(elem);
      const control$ = elem$.closest(".clock-key-control-flipper");
      elem$.on({
        click: async (event) => {
          event.preventDefault();
          const clockKey = getClockKeyFromEvent(event);
          const isSpotlit = !clockKey.isSpotlit;
          clockKey.updateTarget("isSpotlit", isSpotlit);
          if (clockKey.isInScene() && clockKey.isVisible)
            ;
          control$.find('[data-action="toggle-spotlight"] i').toggleClass("fa-message").toggleClass("fa-message-slash").toggleClass("fa-solid").toggleClass("fa-regular");
        }
      });
    });
    clockKeyControls$.find('[data-action="pull-clock-key"]').each((i, elem) => {
      const elem$ = $(elem);
      const control$ = elem$.closest(".clock-key-control-flipper");
      elem$.on({
        click: (event) => {
          event.preventDefault();
          U.gsap.effects.keyControlPanelFlip(control$, { angle: 180 });
          const clockKey = getClockKeyFromEvent(event);
          clockKey.updateTarget("isVisible", false);
          game.eunoblades.Director.pullKey_SocketCall(clockKey.id);
        }
      });
    });
    clockKeyControls$.find('[data-action="drop-clock-key"]').each((i, elem) => {
      const elem$ = $(elem);
      const control$ = elem$.closest(".clock-key-control-flipper");
      elem$.on({
        click: (event) => {
          event.preventDefault();
          U.gsap.effects.keyControlPanelFlip(control$, { angle: 0 });
          const clockKey = getClockKeyFromEvent(event);
          clockKey.updateTarget("isVisible", true);
          game.eunoblades.Director.renderClockKey_SocketCall(clockKey.id);
        }
      });
    });
    clockKeyControls$.find('[data-action="spawn-position-dragger"]').on({
      click: async (event) => {
        event.preventDefault();
        const clockKey = getClockKeyFromEvent(event);
        clockKey.spawnPositionDragger(game.eunoblades.Director.clockKeySection$);
      }
    });
    clockKeyControls$.find('[data-action="delete-clock-key"]').on({
      click: async (event) => {
        event.preventDefault();
        await getClockKeyFromEvent(event).delete(game.eunoblades.ClockKeys);
      }
    });
    clockKeyControls$.find('[data-action="add-key-to-scene"]').on({
      click: async (event) => {
        event.preventDefault();
        await getClockKeyFromEvent(event).addToScene(this.document.targetSceneID);
      }
    });
    clockKeyControls$.find('[data-action="remove-key-from-scene"]').on({
      click: async (event) => {
        event.preventDefault();
        await getClockKeyFromEvent(event).removeFromScene(this.document.targetSceneID);
      }
    });
    clockKeyControls$.find('[data-action="add-clock-to-key"]').on({
      click: async (event) => {
        event.preventDefault();
        await getClockKeyFromEvent(event).addClock();
      }
    });
    clockKeyControls$.find("input.clock-key-input:not([readonly])").on({
      change: async (event) => {
        event.preventDefault();
        const input$ = $(event.currentTarget);
        const inputVal = input$.val();
        if (typeof inputVal === "string") {
          getClockKeyFromEvent(event).updateTarget(input$.data("targetProp"), inputVal);
          clockKeyControls$.find("input.clock-key-input").val(inputVal);
        }
      }
    });
    const clockControls$ = html.find(".clock-control-flipper");
    clockControls$.find('[data-action="toggle-visible"]').each((i, elem) => {
      const elem$ = $(elem);
      const control$ = elem$.closest(".clock-control-flipper");
      elem$.on({
        click: async (event) => {
          event.preventDefault();
          const [clockKey, clock] = getClockFromEvent(event);
          const isVisible = !clock.isVisible;
          clock.updateTarget("isVisible", isVisible);
          if (clockKey.isInScene() && clockKey.isVisible) {
            if (isVisible) {
              clock.reveal_SocketCall(ClockDisplayContext.overlay);
            } else {
              clock.hide_SocketCall(ClockDisplayContext.overlay);
            }
          }
          control$.find('[data-action="toggle-visible"] i').toggleClass("fa-eye").toggleClass("fa-eye-slash").toggleClass("fa-solid").toggleClass("fa-regular");
        }
      });
    });
    clockControls$.find('[data-action="toggle-active"]').each((i, elem) => {
      const elem$ = $(elem);
      const control$ = elem$.closest(".clock-control-flipper");
      elem$.on({
        click: async (event) => {
          event.preventDefault();
          const [clockKey, clock] = getClockFromEvent(event);
          const isActive = !clock.isActive;
          clock.updateTarget("isActive", isActive);
          if (clock.parentKey.isInScene() && clock.parentKey.isVisible && clock.isVisible) {
            if (isActive) {
              clock.activate_SocketCall(ClockDisplayContext.overlay);
            } else {
              clock.deactivate_SocketCall(ClockDisplayContext.overlay);
            }
          }
          control$.find('[data-action="toggle-active"] i').toggleClass("fa-bolt").toggleClass("fa-bolt-slash").toggleClass("fa-solid").toggleClass("fa-regular");
        }
      });
    });
    clockControls$.find('[data-action="toggle-name-visibility"]').each((i, elem) => {
      const elem$ = $(elem);
      const control$ = elem$.closest(".clock-control-flipper");
      elem$.on({
        click: async (event) => {
          event.preventDefault();
          const clock = getClockFromEvent(event)[1];
          const isNameVisible = !clock.isNameVisible;
          clock.updateTarget("isNameVisible", isNameVisible);
          if (clock.parentKey.isInScene() && clock.parentKey.isVisible && clock.isVisible) {
            if (isNameVisible) {
              clock.fadeInClockName_SocketCall(ClockDisplayContext.overlay);
            } else {
              clock.fadeOutClockName_SocketCall(ClockDisplayContext.overlay);
            }
          }
          control$.find('[data-action="toggle-name-visibility"] i').toggleClass("fa-signature").toggleClass("fa-signature-slash").toggleClass("fa-solid").toggleClass("fa-regular");
        }
      });
    });
    clockControls$.find('[data-action="toggle-highlight"]').each((i, elem) => {
      const elem$ = $(elem);
      const control$ = elem$.closest(".clock-control-flipper");
      elem$.on({
        click: async (event) => {
          event.preventDefault();
          const [clockKey, clock] = getClockFromEvent(event);
          const isHighlighted = !clock.isHighlighted;
          clock.updateTarget("isHighlighted", isHighlighted);
          if (clock.parentKey.isInScene() && clock.parentKey.isVisible && clock.isVisible) {
            if (isHighlighted) {
              clock.highlight_SocketCall(ClockDisplayContext.overlay);
            } else {
              clock.unhighlight_SocketCall(ClockDisplayContext.overlay);
            }
          }
          control$.find('[data-action="toggle-highlight"] i').toggleClass("fa-lightbulb").toggleClass("fa-lightbulb-slash").toggleClass("fa-solid").toggleClass("fa-regular");
        }
      });
    });
    clockControls$.find('[data-action="change-segments"]').each((i, elem) => {
      const elem$ = $(elem);
      const control$ = elem$.closest(".clock-control-flipper");
      elem$.on({
        click: async (event) => {
          event.preventDefault();
          const [clockKey, clock] = getClockFromEvent(event);
          const delta = U.pInt($(event.currentTarget).data("value"));
          const finalVal = U.gsap.utils.clamp(0, clock.max, clock.value + delta);
          if (delta > 0) {
            clock.fillSegments(delta, true);
          } else {
            clock.clearSegments(Math.abs(delta), true);
          }
          control$.find("select.clock-select-value").val(finalVal);
          clock.changeSegments_SocketCall(ClockDisplayContext.overlay, clock.value, finalVal);
        }
      });
    });
    clockControls$.find("select.clock-control-select").each((i, elem) => {
      const elem$ = $(elem);
      if (elem$.hasClass("clock-select-color"))
        ;
    }).on({
      change: (event) => {
        event.preventDefault();
        const select$ = $(event.currentTarget);
        const value = select$.data("dtype") === "number" ? U.pInt(select$.val()) : select$.val();
        const prop = select$.data("targetProp");
        getClockFromEvent(event)[1].updateTarget(prop, value);
        if (prop === "color" && typeof value === "string" && value in ClockColor) {
          this.setSelectColor(select$, value);
        }
      }
    });
    clockControls$.find("input.clock-input:not([readonly])").each((i, elem) => {
      const elem$ = $(elem);
      const control$ = elem$.closest(".clock-control-flipper");
      elem$.on({
        change: (event) => {
          event.preventDefault();
          const input$ = $(event.currentTarget);
          const inputVal = input$.val();
          if (typeof inputVal === "string") {
            getClockFromEvent(event)[1].updateTarget(input$.data("targetProp"), inputVal);
            control$.find("input.clock-input").val(inputVal);
          }
        }
      });
    });
    clockControls$.find('[data-action="delete-clock"]').on({
      click: async (event) => {
        event.preventDefault();
        await getClockFromEvent(event)[1].delete();
      }
    });
  }
}
class BladesDebug {
  static async GetSampleSchemas(docNames = {}) {
    const SAMPLE_USER_NAME = docNames.user || "Alistair";
    const SAMPLE_PC_NAME = docNames.pc || "Alistair";
    const SAMPLE_NPC_NAME = docNames.npc || "Setarra";
    const SAMPLE_FACTION_NAME = docNames.faction || "the Bluecoats";
    const sampleUser = game.users.getName(SAMPLE_USER_NAME);
    if (!sampleUser) {
      throw new Error(`Sample user with name "${SAMPLE_USER_NAME}" not found.`);
    }
    const samplePC = game.actors.getName(SAMPLE_PC_NAME);
    if (!BladesPC$1.IsType(samplePC)) {
      throw new Error(`Sample BladesPC with name "${SAMPLE_PC_NAME}" not found.`);
    }
    const sampleNPC = game.actors.getName(SAMPLE_NPC_NAME);
    if (!BladesNPC$1.IsType(sampleNPC)) {
      throw new Error(`Sample BladesNPC with name "${SAMPLE_NPC_NAME}" not found or is not a valid BladesNPC.`);
    }
    const sampleFaction = game.actors.getName(SAMPLE_FACTION_NAME);
    if (!BladesFaction$1.IsType(sampleFaction)) {
      throw new Error(`Sample BladesFaction with name "${SAMPLE_FACTION_NAME}" not found or is not a valid BladesFaction.`);
    }
    const BladesActionRoll_Schema = {
      rollType: RollType.Action,
      // rollSubType: RollSubType.GatherInfo,
      // rollPrompt: "Gathering Information",
      rollTrait: ActionTrait.skirmish,
      // rollUserID: sampleUser.id,
      // rollDowntimeAction: DowntimeAction.AcquireAsset,
      // rollClockKey: U.getLast(game.eunoblades.ClockKeys.contents)?.id,
      rollPrimaryData: BladesRollPrimary.GetDataFromDoc(samplePC),
      rollOppData: BladesRollOpposition.GetDataFromDoc(sampleFaction),
      // rollParticipantData: {},
      // consequenceData: {},
      // resistanceData: {
      //   consequence: {}
      // },
      rollModsData: {},
      rollPositionInitial: Position.risky,
      rollEffectInitial: Effect.standard,
      rollPosEffectTrade: false,
      rollPhase: RollPhase.Collaboration,
      GMBoosts: {},
      GMOppBoosts: {},
      GMOverrides: {},
      rollFactorToggles: {
        source: {},
        opposition: {}
      },
      userPermissions: {
        [sampleUser.id]: RollPermissions.Primary
      }
      // rollPositionFinal: Position.risky,
      // rollEffectFinal: Effect.standard,
      // rollResult: RollResult.success,
      // rollResultDelta: 0,
      // rollResultFinal: RollResult.success,
      // rollTraitVerb: "skirmishes",
      // rollTraitPastVerb: "skirmished",
      // finalDiceData: [],
      // isInlineResistanceRoll: false
    };
    return {
      BladesActionRoll_Schema
    };
  }
}
CONFIG.debug.logging = true;
Object.assign(globalThis, { eLog: logger, BladesDebug });
Handlebars.registerHelper("eLog", logger.hbsLog);
let socket;
class GlobalGetter {
  get clockKeys() {
    return game.eunoblades.ClockKeys.filter((clockKey) => clockKey.isInScene() && clockKey.isVisible);
  }
  get roll() {
    return BladesRoll$1.Active;
  }
  get user() {
    return game.users.getName("Alistair");
  }
  get actor() {
    return game.actors.getName("Alistair");
  }
  get rollTarget() {
    var _a;
    return (_a = this.roll) == null ? void 0 : _a.target;
  }
  get rollData() {
    var _a;
    return (_a = this.roll) == null ? void 0 : _a.data;
  }
  get userFlags() {
    var _a, _b;
    return (_b = (_a = this.user) == null ? void 0 : _a.flags) == null ? void 0 : _b["eunos-blades"];
  }
  get actorFlags() {
    var _a, _b;
    return (_b = (_a = this.actor) == null ? void 0 : _a.flags) == null ? void 0 : _b["eunos-blades"];
  }
  get rollPrimary() {
    var _a;
    return (_a = this.roll) == null ? void 0 : _a.rollPrimary;
  }
  get rollPrimaryDoc() {
    var _a;
    return (_a = this.roll) == null ? void 0 : _a.rollPrimaryDoc;
  }
  get rollOpposition() {
    var _a;
    return (_a = this.roll) == null ? void 0 : _a.rollOpposition;
  }
  get sheetData() {
    var _a;
    return (_a = this.roll) == null ? void 0 : _a.context;
  }
  newActionRoll() {
    var _a;
    const pc = game.actors.getName("Alistair");
    if (!pc) {
      return;
    }
    const conf = {
      target: pc,
      targetFlagKey: "rollCollab",
      rollType: RollType.Action,
      rollTrait: ActionTrait.finesse,
      rollUserID: (_a = game.users.find((user) => {
        var _a2;
        return ((_a2 = user.character) == null ? void 0 : _a2.name) === "Alistair";
      })) == null ? void 0 : _a.id,
      rollPrimaryData: pc
    };
    BladesActionRoll.New(conf);
  }
  // async newResistanceRoll() {
  //   const pc = game.actors.getName("Alistair") as BladesPC|undefined;
  //   if (!pc?.id) { return; }
  //   const csq = await BladesConsequence.Create({
  //     target: pc,
  //     targetFlagKey: "rollConsequence" as TargetFlagKey,
  //     name: "Shattered Knee",
  //     isScopingById: true,
  //     type: ConsequenceType.ProwessHarm3,
  //     primaryID: pc.uuid,
  //     attribute: AttributeTrait.prowess,
  //     attributeVal: 3,
  //     resistSchema: {
  //       name: "Banged Knee",
  //       type: ConsequenceType.ProwessHarm2,
  //       primaryID: pc.uuid,
  //       canResistWithSpecial: true,
  //       resistWithSpecialNegates: true,
  //       specialFooterMsg: "Ability: Spend to Fully Negate."
  //     },
  //     canResistWithRoll: true,
  //     canResistWithSpecial: true,
  //     resistWithSpecialNegates: true,
  //     specialFooterMsg: "Ability: Spend to Fully Negate."
  //   });
  //   const conf: BladesRoll.Config = {
  //     target: pc,
  //     targetFlagKey: "rollCollab" as TargetFlagKey,
  //     rollType: RollType.Resistance,
  //     rollUserID: game.users.find((user) => user.character?.name === "Alistair")?.id as IDString,
  //     rollPrimaryData: pc,
  //     resistanceData: {
  //       consequence: csq.data
  //     }
  //   };
  //   BladesResistanceRoll.New(conf);
  // }
}
Object.assign(
  globalThis,
  {
    get: new GlobalGetter(),
    // updateClaims,
    // updateContacts,
    // updateOps,
    // updateFactions,
    // updateDescriptions,
    // updateRollMods,
    BladesScene,
    BladesDirector,
    BladesActor: BladesActor$1,
    BladesPC: BladesPC$1,
    BladesCrew: BladesCrew$1,
    BladesNPC: BladesNPC$1,
    BladesFaction: BladesFaction$1,
    BladesPCSheet,
    BladesCrewSheet,
    BladesFactionSheet,
    BladesClockKey,
    BladesNPCSheet,
    BladesActiveEffect,
    BladesRoll: BladesRoll$1,
    BladesRollMod,
    BladesRollPrimary,
    BladesRollOpposition,
    BladesRollParticipant,
    BladesActionRoll,
    BladesEngagementRoll,
    BladesFortuneRoll,
    BladesIncarcerationRoll,
    BladesIndulgeViceRoll,
    BladesInlineResistanceRoll,
    BladesResistanceRoll,
    BladesChat: BladesChat$1,
    BladesConsequence,
    G,
    U,
    C,
    BladesItem: BladesItem$1,
    BladesClockKeeper: BladesClockKeeper$1,
    BladesGMTracker,
    BladesLocation,
    BladesProject: BladesProject$1,
    BladesScore: BladesScore$1,
    BladesItemSheet,
    BladesClockKeeperSheet,
    BladesGMTrackerSheet,
    BladesAI,
    AIAssistant,
    AGENTS
  }
);
Hooks.once("init", async () => {
  game.eunoblades = {
    Rolls: new Collection(),
    ClockKeys: new Collection(),
    Consequences: new Collection(),
    Director: BladesDirector.getInstance(),
    Tooltips: /* @__PURE__ */ new WeakMap()
  };
  eLog.display("Initializing Blades In the Dark System");
  registerSettings();
  CONFIG.debug.hooks = U.getSetting("debugHooks");
  Initialize();
  CONFIG.Item.documentClass = BladesItemProxy;
  CONFIG.Actor.documentClass = BladesActorProxy;
  CONFIG.Scene.documentClass = BladesScene;
  CONFIG.ChatMessage.documentClass = BladesChat$1;
  Actors.unregisterSheet("core", ActorSheet);
  Items.unregisterSheet("core", ItemSheet);
  Items.registerSheet("blades", BladesItemSheet, { types: C.ItemTypes, makeDefault: true });
  registerHandlebarHelpers();
  preloadHandlebarsTemplates();
  await Promise.all([
    BladesPC$1.Initialize(),
    BladesCrew$1.Initialize(),
    BladesNPC$1.Initialize(),
    BladesFaction$1.Initialize(),
    BladesActiveEffect.Initialize(),
    BladesGMTrackerSheet.Initialize(),
    BladesClockKeeperSheet.Initialize(),
    BladesScore$1.Initialize(),
    BladesDialog.Initialize(),
    BladesRoll$1.Initialize(),
    BladesProject$1.Initialize(),
    BladesChat$1.Initialize()
  ]);
});
Hooks.once("ready", async () => {
  await Promise.all([
    BladesDirector.Initialize(),
    BladesGMTracker.Initialize(),
    BladesClockKeeper$1.Initialize()
  ]);
  BladesClockKey.Initialize();
  await BladesConsequence.Initialize();
  initDOMStyles();
  initCanvasStyles();
  initTinyMCEStyles();
  await BladesDirector.getInstance().renderOverlay_SocketResponse();
  BladesDirector.InitSockets();
  BladesRoll$1.InitSockets();
});
Hooks.once("socketlib.ready", () => {
  socket = socketlib.registerSystem("eunos-blades");
  Object.assign(
    globalThis,
    { socket, socketlib }
  );
});
Hooks.once("diceSoNiceReady", (dice3d) => {
  dice3d.addSystem({ id: "eunos-blades", name: "Euno's Blades" }, "preferred");
  dice3d.addDicePreset({
    type: "d6",
    labels: [1, 2, 3, 4, 5, 6].map((num) => `systems/eunos-blades/assets/dice/faces/${num}.webp`),
    system: "eunos-blades",
    bumpMaps: [1, 2, 3, 4, 5, 6].map((num) => `systems/eunos-blades/assets/dice/bump-maps/${num}.webp`),
    emissiveMaps: [void 0, void 0, void 0, void 0, void 0, "systems/eunos-blades/assets/dice/emission-maps/6.webp"],
    emissive: "#d89300"
  });
});
//# sourceMappingURL=blades.js.map

{"version":3,"sources":["../../ts/core/mixins.ts"],"names":[],"mappings":"AACA,OAAU,EAA8D,cAAc,EAAyL,MAAM,gBAAgB,CAAC;AAGtS,OAAO,UAAU,MAAM,mBAAmB,CAAC;AA4C3C,wBAAwB;AACxB,MAAM,YAAY;IAChB,UAAU,CAAa;IACzB,wBAAwB;IACtB,YAAY,UAAsB,IAAI,IAAI,CAAC,UAAU,GAAG,UAAU,CAAA,CAAC,CAAC;IACpE,IAAI,CAAkD,GAAG,MAAc;QACrE,OAAO,MAAM,CAAC,MAAM,CAClB,CAAC,GAAG,EAAE,KAAK,GAAG,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,EAAE,EAAE,CAAC,KAAK,CAAC,GAAG,CAAC,EACrC,IAAI,CAAC,UAAU,CACsB,CAAC;IAC1C,CAAC;CACF;AAeD,wBAAwB;AACxB,MAAM,GAAG,GAAG,CAAmC,UAA4B,EAAE,EAAE,CAAC,IAAI,YAAY,CAAsB,UAAU,CAAC,CAAC;AAClI,wBAAwB;AACxB,MAAM,CAAC,MAAM,WAAW,GAAG,CAAC,UAAsC,EAAE,EAAE,CAAC,KAAM,SAAQ,UAAU;IAC/F,wBAAwB;IACtB,IAAI,YAAY;QACd,OAAO,IAAI,CAAC,QAAQ,EAAE,IAA0C,CAAC;IACnE,CAAC;IACD,IAAI,QAAQ;QACV,OAAO,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,CAAC,IAAI,EAAkF,EAAE,CAAC,UAAU,CAAC,MAAM,CAAC,IAAI,EAAE,cAAc,CAAC,QAAQ,EAAE,cAAc,CAAC,aAAa,CAAC,CAAC,CAAC;IAC5M,CAAC;CAEF,CAAC;AACF,wBAAwB;AACxB,eAAe,GAAG,CAAC","file":"mixins.js","sourcesContent":["import U from \"./utilities.js\";\r\nimport C, {BladesActorType, BladesPhase, Vice, Tag, District, Playbook, BladesItemType, Attribute, Action, InsightActions, ProwessActions, ResolveActions, PrereqType, Position, Effect, AdvancementPoint, Randomizers, RollModCategory, RollModStatus, RollType, Factor, Harm} from \"./constants.js\";\r\nimport {SelectionCategory} from \"../blades-dialog.js\";\r\nimport BladesActor from \"../blades-actor.js\";\r\nimport BladesItem from \"../blades-item.js\";\r\nimport BladesPC from \"../documents/actors/blades-pc.js\";\r\nimport BladesCrew from \"../documents/actors/blades-crew.js\";\r\nimport type {ItemDataConstructorData} from \"@league-of-foundry-developers/foundry-vtt-types/src/foundry/common/data/data.mjs/itemData.js\";\r\n\r\n// type Constructor = new (...args: readonly any[]) => {};\r\n\r\n// type ConstructorOf<T extends BladesActor|BladesItem> = new (...args: readonly any[]) => T;\r\n\r\n// type ApplyMixin<T extends BladesActor|BladesItem, Superclass extends ConstructorOf<T>, MixinClass extends ConstructorOf<T>> = Superclass & MixinClass;\r\n// type MixinType<T extends BladesActor|BladesItem, MixinClass extends ConstructorOf<T>> = <Superclass extends ConstructorOf<T>>(superclass: Superclass) => ApplyMixin<T, Superclass, MixinClass>;\r\n\r\n// class MixinBuilder<T extends BladesActor|BladesItem, Superclass extends ConstructorOf<T>> {\r\n//   superclass: Superclass;\r\n\r\n//   constructor(superclass: Superclass) { this.superclass = superclass }\r\n//   with<Mixins extends ReadonlyArray<MixinType<T, any>>>(...mixins: Mixins): ApplyMixins<T, Superclass, Mixins> {\r\n//     return mixins.reduce(\r\n//       (cls, mixin = (x) => x) => mixin(cls),\r\n//       this.superclass\r\n//     ) as ApplyMixins<T, Superclass, Mixins>;\r\n//   }\r\n// }\r\n\r\n// type ApplyMixins<\r\n//   T extends BladesActor|BladesItem,\r\n//   Superclass extends ConstructorOf<T>,\r\n//   Mixins extends ReadonlyArray<MixinType<T, any>>\r\n// > = Mixins extends [infer Mixin extends MixinType<T, any>, ...infer Rest extends ReadonlyArray<MixinType<T, any>>] ?\r\n//   ApplyMixins<T, CalculateMixin<T, Superclass, Mixin>, Rest> :\r\n//   Superclass;\r\n\r\n// type CalculateMixin<\r\n//   T extends BladesActor|BladesItem,\r\n//   Superclass extends ConstructorOf<T>,\r\n//   Mixin extends MixinType<T, any>\r\n// > = (Mixin extends (superclass: Superclass) => (infer MixinClass extends ConstructorOf<T>) ? ApplyMixin<T, Superclass, MixinClass> : never)\r\n\r\n// const MIX = <T extends BladesActor|BladesItem>(superclass: ConstructorOf<T>) => new MixinBuilder<T, ConstructorOf<T>>(superclass);\r\n\r\ntype ConstructorOf<T extends BladesActor|BladesItem> = new (...args: readonly any[]) => T;\r\n\r\ntype ApplyMixin<T extends BladesActor|BladesItem, Superclass extends ConstructorOf<T>, MixinClass extends ConstructorOf<T>> = Superclass & MixinClass;\r\ntype MixinType<T extends BladesActor|BladesItem, MixinClass extends ConstructorOf<T>> = <Superclass extends ConstructorOf<T>>(superclass: Superclass) => ApplyMixin<T, Superclass, MixinClass>;\r\n\r\nclass MixinBuilder<T extends BladesActor|BladesItem, Superclass extends ConstructorOf<T>> {\r\n  superclass: Superclass;\r\n\r\n  constructor(superclass: Superclass) { this.superclass = superclass }\r\n  with<Mixins extends ReadonlyArray<MixinType<T, any>>>(...mixins: Mixins): ApplyMixins<T, Superclass, Mixins> {\r\n    return mixins.reduce(\r\n      (cls, mixin = (x) => x) => mixin(cls),\r\n      this.superclass\r\n    ) as ApplyMixins<T, Superclass, Mixins>;\r\n  }\r\n}\r\n\r\ntype ApplyMixins<\r\n  T extends BladesActor|BladesItem,\r\n  Superclass extends ConstructorOf<T>,\r\n  Mixins extends ReadonlyArray<MixinType<T, any>>\r\n> = Mixins extends [infer Mixin extends MixinType<T, any>, ...infer Rest extends ReadonlyArray<MixinType<T, any>>] ?\r\n  ApplyMixins<T, CalculateMixin<T, Superclass, Mixin>, Rest> :\r\n  Superclass;\r\n\r\ntype CalculateMixin<\r\n  T extends BladesActor|BladesItem,\r\n  Superclass extends ConstructorOf<T>,\r\n  Mixin extends MixinType<T, any>\r\n> = (Mixin extends (superclass: Superclass) => (infer MixinClass extends ConstructorOf<T>) ? ApplyMixin<T, Superclass, MixinClass> : never)\r\n\r\nconst MIX = <T extends BladesActor|BladesItem>(superclass: ConstructorOf<T>) => new MixinBuilder<T, ConstructorOf<T>>(superclass);\r\n\r\nexport const HasPlaybook = (superclass: ConstructorOf<BladesActor>) => class extends superclass {\r\n\r\n  get playbookName() {\r\n    return this.playbook?.name as (BladesTag & Playbook) | undefined;\r\n  }\r\n  get playbook(): BladesItemOfType<BladesItemType.crew_playbook|BladesItemType.playbook>|undefined {\r\n    return this.activeSubItems.find((item): item is BladesItemOfType<BladesItemType.crew_playbook|BladesItemType.playbook> => BladesItem.IsType(item, BladesItemType.playbook, BladesItemType.crew_playbook));\r\n  }\r\n\r\n};\r\n\r\n\r\nexport default MIX;"]}
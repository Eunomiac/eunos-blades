{"version":3,"sources":["sheets/roll/blades-roll-collab-sheet.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"blades-roll-collab-sheet.js","sourcesContent":["import U from \"../../core/utilities.js\";\nimport C, { BladesActorType, RollType, RollModStatus, RollModCategory, Action, Attribute, Position, Effect, Factor } from \"../../core/constants.js\";\nimport BladesActor from \"../../blades-actor.js\";\nimport BladesItem from \"../../blades-item.js\";\nimport { ApplyTooltipListeners } from \"../../core/gsap.js\";\r\n\nfunction isAction(trait) {\n    return Boolean(trait && typeof trait === \"string\" && trait in Action);\n}\nfunction isAttribute(trait) {\n    return Boolean(trait && typeof trait === \"string\" && trait in Attribute);\n}\nfunction isTier(trait) { return U.lCase(trait) === \"tier\"; }\nfunction isNumber(trait) { return U.isInt(trait); }\r\n\nexport const ModEffects = {\n    NegateTierPenalty: (mod, sheetData) => {\n                return sheetData;\n    },\n    NegateQualityPenalty: (mod, sheetData) => {\n                return sheetData;\n    },\n    IsPush: (mod, sheetData) => {\n                \n        return sheetData;\n    }\n};\r\n\nclass BladesRollCollabSheet extends DocumentSheet {\n    \n    static get defaultOptions() {\n        return foundry.utils.mergeObject(super.defaultOptions, {\n            classes: [\"eunos-blades\", \"sheet\", \"roll-collab\"],\n            template: `systems/eunos-blades/templates/roll/roll-collab${game.user.isGM ? \"-gm\" : \"\"}.hbs`,\n            submitOnChange: true,\n            width: 500\r\n        });\n    }\n    \n    static Initialize() {\n        return loadTemplates([\n            \"systems/eunos-blades/templates/roll/roll-collab.hbs\",\n            \"systems/eunos-blades/templates/roll/roll-collab-gm.hbs\",\n            \"systems/eunos-blades/templates/roll/partials/roll-collab-gm-number-line.hbs\",\n            \"systems/eunos-blades/templates/roll/partials/roll-collab-gm-select-doc.hbs\",\n            \"systems/eunos-blades/templates/roll/partials/roll-collab-action.hbs\",\n            \"systems/eunos-blades/templates/roll/partials/roll-collab-action-gm.hbs\",\n            \"systems/eunos-blades/templates/roll/partials/roll-collab-resistance.hbs\",\n            \"systems/eunos-blades/templates/roll/partials/roll-collab-resistance-gm.hbs\",\n            \"systems/eunos-blades/templates/roll/partials/roll-collab-downtime.hbs\",\n            \"systems/eunos-blades/templates/roll/partials/roll-collab-downtime-gm.hbs\",\n            \"systems/eunos-blades/templates/roll/partials/roll-collab-fortune.hbs\",\n            \"systems/eunos-blades/templates/roll/partials/roll-collab-fortune-gm.hbs\",\n            \"systems/eunos-blades/templates/roll/partials/roll-collab-incarceration.hbs\",\n            \"systems/eunos-blades/templates/roll/partials/roll-collab-incarceration-gm.hbs\"\n        ]);\n    }\n    \n    static InitSockets() {\n        socketlib.system.register(\"renderRollCollab\", BladesRollCollabSheet.RenderRollCollab);\n        socketlib.system.register(\"closeRollCollab\", BladesRollCollabSheet.CloseRollCollab);\n    }\n    \n    static Current = {};\n    \n    static get DefaultFlagData() {\n        return {\n            rollID: randomID(),\n            rollType: RollType.Action,\n            rollSourceType: \"Actor\",\n            rollSourceID: \"\",\n            rollTrait: Factor.tier,\n            rollMods: {\n                [RollModCategory.roll]: {\n                    positive: {\n                        Push: {\n                            name: \"Push\",\n                            category: RollModCategory.roll,\n                            status: RollModStatus.ToggledOff,\n                            posNeg: \"positive\",\n                            modType: \"general\",\n                            stressCost: 2,\n                            value: 1,\n                            tooltip: \"<h1>Push for +1d</h1><p>For <strong class='red-bright'>2 Stress</strong>, add <strong class='gold-bright'>1 die</strong> to your pool.</p><p><em>(You <strong>cannot</strong> also accept a <strong class='red-bright'>Devil's Bargain</strong> to increase your dice pool: It's one or the other.)</em></p>\"\n                        },\n                        Bargain: {\n                            name: \"Bargain\",\n                            category: RollModCategory.roll,\n                            status: RollModStatus.Hidden,\n                            posNeg: \"positive\",\n                            modType: \"general\",\n                            value: 1,\n                            tooltip: \"<h1 class='red-bright'>Devil's Bargain</h1><p>The GM has offered you a <strong class='red-bright'>Devil's Bargain</strong>.</p><p><strong class='red-bright'>Accept the terms</strong> to add <strong class='gold-bright'>1 die</strong> to your pool.</p><p><em>(You <strong>cannot</strong> also <strong>Push for +1d</strong> to increase your dice pool: It's one or the other.)</em></p>\"\n                        },\n                        Assist: {\n                            name: \"Assist\",\n                            category: RollModCategory.roll,\n                            status: RollModStatus.Hidden,\n                            posNeg: \"positive\",\n                            modType: \"teamwork\",\n                            value: 1,\n                            sideString: \"\",\n                            tooltip: \"<h1 class='gold-bright'>@CHARACTER_NAME@ Assists</h1><p><strong class='gold-bright'>@CHARACTER_NAME@</strong> is <strong>Assisting</strong> your efforts, adding <strong class='gold-bright'>1 die</strong> to your pool.</p>\"\n                        }\n                    },\n                    negative: {}\n                },\n                [RollModCategory.position]: {\n                    positive: {\n                        Setup: {\n                            name: \"Setup\",\n                            category: RollModCategory.position,\n                            status: RollModStatus.Hidden,\n                            posNeg: \"positive\",\n                            modType: \"teamwork\",\n                            value: 1,\n                            sideString: undefined,\n                            tooltip: \"<h1 class='gold-bright'>@CHARACTER_NAME@ Sets You Up</h1><p><strong class='gold-bright'>@CHARACTER_NAME@</strong> has set you up for success with a preceding <strong>Setup</strong> action, increasing your <strong class='gold-bright'>Position</strong> by one level.</p>\"\n                        }\n                    },\n                    negative: {}\n                },\n                [RollModCategory.effect]: {\n                    positive: {\n                        Push: {\n                            name: \"Push\",\n                            category: RollModCategory.effect,\n                            status: RollModStatus.ToggledOff,\n                            posNeg: \"positive\",\n                            modType: \"general\",\n                            stressCost: 2,\n                            value: 1,\n                            tooltip: \"<h1>Push for Effect</h1><p>For <strong class='red-bright'>2 Stress</strong>, increase your <strong class='gold-bright'>Effect</strong> by one level.</p>\"\n                        },\n                        Setup: {\n                            name: \"Setup\",\n                            category: RollModCategory.effect,\n                            status: RollModStatus.Hidden,\n                            posNeg: \"positive\",\n                            modType: \"teamwork\",\n                            value: 1,\n                            sideString: undefined,\n                            tooltip: \"<h1 class='gold-bright'>@CHARACTER_NAME@ Sets You Up</h1><p><strong class='gold-bright'>@CHARACTER_NAME@</strong> has set you up for success with a preceding <strong>Setup</strong> action, increasing your <strong class='gold-bright'>Effect</strong> by one level.</p>\"\n                        },\n                        Potency: {\n                            name: \"Potency\",\n                            category: RollModCategory.effect,\n                            status: RollModStatus.Hidden,\n                            posNeg: \"positive\",\n                            modType: \"general\",\n                            value: 1,\n                            tooltip: \"<h1>Potency</h1><p>By circumstance or advantage, you have <strong>Potency</strong> in this action, increasing your <strong class='gold-bright'>Effect</strong> by one level.</p>\"\n                        }\n                    },\n                    negative: {\n                        Potency: {\n                            name: \"Potency\",\n                            category: RollModCategory.effect,\n                            status: RollModStatus.Hidden,\n                            posNeg: \"negative\",\n                            modType: \"general\",\n                            value: 1,\n                            tooltip: \"<h1 class='red-bright'>Potency</h1><p>By circumstance or advantage, <strong class='red-bright'>@OPPOSITION_NAME@</strong> has <strong>Potency</strong> against you, reducing your <strong class='red-bright'>Effect</strong> by one level.\"\n                        }\n                    }\n                },\n                [RollModCategory.result]: { positive: {}, negative: {} },\n                [RollModCategory.after]: { positive: {}, negative: {} }\n            },\n            rollPositionInitial: Position.risky,\n            rollEffectInitial: Effect.standard,\n            rollPosEffectTrade: false,\n            rollFactors: {\n                [Factor.tier]: { name: \"Tier\", cssClasses: \"roll-factor roll-factor-tier\", value: 0, max: 0, isActive: false, isDominant: false, highFavorsPC: true }\n            },\n            isGMReady: false,\n            GMBoosts: {},\n            GMOppBoosts: {},\n            docSelections: {\n                [RollModCategory.roll]: {\n                    Assist: false,\n                    Group_1: false,\n                    Group_2: false,\n                    Group_3: false,\n                    Group_4: false,\n                    Group_5: false,\n                    Group_6: false\n                },\n                [RollModCategory.position]: {\n                    Setup: false\n                },\n                [RollModCategory.effect]: {\n                    Setup: false\n                }\n            }\n        };\n    }\n    \n    static async RenderRollCollab({ userID, rollID }) {\n        const user = game.users.get(userID);\n        if (!user) {\n            return;\n        }\n        BladesRollCollabSheet.Current[rollID] = new BladesRollCollabSheet(user, rollID);\n        BladesRollCollabSheet.Current[rollID].render(true);\n    }\n    \n    static async CloseRollCollab(rollID) {\n        eLog.checkLog3(\"rollCollab\", \"CloseRollCollab()\", { rollID });\n        await BladesRollCollabSheet.Current[rollID]?.close({ rollID });\n        delete BladesRollCollabSheet.Current[rollID];\n    }\n    \n    static async NewRoll(config) {\r\n\n        \r\n\n        \n        const user = game.users.get(config.userID ?? game.user._id);\n        if (!(user instanceof User)) {\n            eLog.error(\"rollCollab\", `[NewRoll()] Can't Find User '${config.userID}'`, config);\n            return;\n        }\n        await user.unsetFlag(C.SYSTEM_ID, \"rollCollab\");\n        \n        const flagUpdateData = { ...BladesRollCollabSheet.DefaultFlagData };\n        \n        flagUpdateData.rollType = config.rollType;\n        if (!(flagUpdateData.rollType in RollType)) {\n            eLog.error(\"rollCollab\", `[RenderRollCollab()] Invalid rollType: ${flagUpdateData.rollType}`, config);\n            return;\n        }\n        const rollSource = config.rollSource ?? user.character;\n        if (!(rollSource instanceof BladesActor || rollSource instanceof BladesItem)) {\n            eLog.error(\"rollCollab\", \"[RenderRollCollab()] Invalid rollSource\", { rollSource, config });\n            return;\n        }\n        flagUpdateData.rollSourceID = rollSource.id;\n        flagUpdateData.rollSourceType = rollSource instanceof BladesActor ? \"Actor\" : \"Item\";\n        if (U.isInt(config.rollTrait)) {\n            flagUpdateData.rollTrait = config.rollTrait;\n        }\n        else if (!config.rollTrait) {\n            eLog.error(\"rollCollab\", \"[RenderRollCollab()] No RollTrait in Config\", config);\n            return;\n        }\n        else {\n            switch (flagUpdateData.rollType) {\n                case RollType.Action: {\n                    if (!(U.lCase(config.rollTrait) in { ...Action, ...Factor })) {\n                        eLog.error(\"rollCollab\", `[RenderRollCollab()] Bad RollTrait for Action Roll: ${config.rollTrait}`, config);\n                        return;\n                    }\n                    flagUpdateData.rollTrait = U.lCase(config.rollTrait);\n                    break;\n                }\n                case RollType.Downtime: {\n                    if (!(U.lCase(config.rollTrait) in { ...Action, ...Factor })) {\n                        eLog.error(\"rollCollab\", `[RenderRollCollab()] Bad RollTrait for Downtime Roll: ${config.rollTrait}`, config);\n                        return;\n                    }\n                    flagUpdateData.rollTrait = U.lCase(config.rollTrait);\n                    break;\n                }\n                case RollType.Fortune: {\n                    if (!(U.lCase(config.rollTrait) in { ...Action, ...Attribute, ...Factor })) {\n                        eLog.error(\"rollCollab\", `[RenderRollCollab()] Bad RollTrait for Fortune Roll: ${config.rollTrait}`, config);\n                        return;\n                    }\n                    flagUpdateData.rollTrait = U.lCase(config.rollTrait);\n                    break;\n                }\n                case RollType.Resistance: {\n                    if (!(U.lCase(config.rollTrait) in Attribute)) {\n                        eLog.error(\"rollCollab\", `[RenderRollCollab()] Bad RollTrait for Resistance Roll: ${config.rollTrait}`, config);\n                        return;\n                    }\n                    break;\n                }\r\n            }\n            flagUpdateData.rollTrait = U.lCase(config.rollTrait);\n        }\n        \n        await user.setFlag(C.SYSTEM_ID, \"rollCollab\", flagUpdateData);\n        BladesRollCollabSheet.RenderRollCollab({ userID: user._id, rollID: flagUpdateData.rollID });\n        socketlib.system.executeForAllGMs(\"renderRollCollab\", { userID: user._id, rollID: flagUpdateData.rollID });\n    }\n    \n    rollID;\n    constructor(user, rollID) {\n        super(user);\n        this.rollID = rollID;\n    }\n    \n    get rData() {\n        if (!this.document.getFlag(C.SYSTEM_ID, \"rollCollab\")) {\n            eLog.error(\"rollCollab\", \"[get flags()] No RollCollab Flags Found on User\", { user: this.document, flags: this.document.flags });\n            return null;\n        }\n        return this.document.flags[\"eunos-blades\"].rollCollab;\n    }\n    get rollSource() {\n        if (!this.rData) {\n            return undefined;\n        }\n        return this.rData.rollSourceType === \"Actor\"\n            ? game.actors.get(this.rData.rollSourceID)\n            : game.items.get(this.rData.rollSourceID);\n    }\n    \n    getData() {\n        \n        const context = super.getData();\n        \n        const { rData } = this;\n        if (!rData) {\n            return context;\n        }\n        \n        const sheetData = {\n            cssClass: \"roll-collab\",\n            editable: this.options.editable,\n            isGM: game.eunoblades.Tracker.system.is_spoofing_player ? false : game.user.isGM,\n            rollPositions: Object.values(Position),\n            rollEffects: Object.values(Effect),\n            ...rData\n        };\n        \n        if (!this.rollSource) {\n            eLog.error(\"rollCollab\", `[getData()] No '${sheetData.rollSourceType}' Found with ID '${sheetData.rollSourceID}'`, { user: this.document, rData: rData });\n            return null;\n        }\n        \n        sheetData.system = this.rollSource.system;\n        sheetData.rollSource = this.rollSource;\n        \r\n        if (sheetData.rollOppositionID) {\n            const rollOpposition = BladesActor.Get(sheetData.rollOppositionID) ?? BladesItem.Get(sheetData.rollOppositionID);\n            if (!rollOpposition) {\n                throw new Error(`Cannot find Roll Opposition with ID '${sheetData.rollOppositionID}'`);\n            }\n            sheetData.rollOpposition = rollOpposition;\n        }\n        \r\n        if (BladesActor.IsType(this.rollSource, BladesActorType.pc) && isAction(sheetData.rollTrait)) {\n            const { rollSource } = this;\n            sheetData.rollTraitData = {\n                name: sheetData.rollTrait,\n                value: rollSource.actions[sheetData.rollTrait],\n                max: rollSource.actions[sheetData.rollTrait]\n            };\n            sheetData.rollTraitOptions = Object.values(Action)\n                .map((action) => ({\n                name: U.uCase(action),\n                value: action\n            }));\n        }\n        else if (BladesActor.IsType(this.rollSource, BladesActorType.pc) && isAttribute(sheetData.rollTrait)) {\n            const { rollSource } = this;\n            sheetData.rollTraitData = {\n                name: sheetData.rollTrait,\n                value: rollSource.attributes[sheetData.rollTrait],\n                max: rollSource.attributes[sheetData.rollTrait]\n            };\n            sheetData.rollTraitOptions = Object.values(Attribute)\n                .map((attribute) => ({\n                name: U.uCase(attribute),\n                value: attribute\n            }));\n        }\n        else if (sheetData.rollTrait === \"tier\") {\n            const { rollSource } = this;\n            sheetData.rollTraitData = {\n                name: \"Tier\",\n                value: rollSource.getTierTotal(),\n                max: rollSource.getTierTotal()\n            };\n            sheetData.rollTraitOptions = false;\n        }\n        else if (U.isInt(sheetData.rollTrait)) {\n            sheetData.rollTraitData = {\n                name: `+${sheetData.rollTrait}`,\n                value: sheetData.rollTrait,\n                max: sheetData.rollTrait\n            };\n            sheetData.rollTraitOptions = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n                .map((num) => ({\n                name: `+${num}`,\n                value: num\n            }));\n        }\n        \r\n        sheetData.rollMods = mergeObject(sheetData.rollSource.rollMods, sheetData.rollMods);\n        \r\n        function isModAutoActive(mod) {\n            const autoRollTypes = mod.autoRollTypes ?? [];\n            const autoRollTraits = mod.autoRollTraits ?? [];\n            return autoRollTypes.length + autoRollTraits.length > 0\n                && (autoRollTypes.length === 0 || autoRollTypes.includes(sheetData.rollType))\n                && (autoRollTraits.length === 0 || autoRollTraits.includes(sheetData.rollTrait));\n        }\n        function isModConditional(mod) {\n            const conditionalRollTypes = mod.conditionalRollTypes ?? [];\n            const conditionalRollTraits = mod.conditionalRollTraits ?? [];\n            return conditionalRollTypes.length + conditionalRollTraits.length > 0\n                && (conditionalRollTypes.length === 0 || conditionalRollTypes.includes(sheetData.rollType))\n                && (conditionalRollTraits.length === 0 || conditionalRollTraits.includes(sheetData.rollTrait));\n        }\n        \n        Object.values(RollModCategory).forEach((modCat) => {\n            Object.values(sheetData.rollMods[modCat]?.positive ?? {})\n                .filter((mod) => mod.isConditional && mod.status === RollModStatus.ToggledOff)\n                .forEach((mod) => {\n                if (isModAutoActive(mod)) {\n                    sheetData.rollMods[modCat].positive[mod.name].status = RollModStatus.ForcedOn;\n                }\n                else if (!isModConditional(mod)) {\n                    sheetData.rollMods[modCat].positive[mod.name].status = RollModStatus.Hidden;\n                }\n            });\n        });\n        \r\n        function getModsDelta(cat) {\n            const activePosMods = Object.values(sheetData.rollMods?.[cat]?.positive ?? {})\n                .filter((mod) => [RollModStatus.ToggledOn, RollModStatus.ForcedOn].includes(mod.status));\n            const posModVals = activePosMods.map((mod) => mod.value);\n            const posModSum = U.sum(posModVals);\n            const activeNegMods = Object.values(sheetData.rollMods?.[cat]?.negative ?? {})\n                .filter((mod) => [RollModStatus.ToggledOn, RollModStatus.ForcedOn].includes(mod.status));\n            const negModVals = activeNegMods.map((mod) => mod.value);\n            const negModSum = U.sum(negModVals);\n            eLog.checkLog3(\"rollMods\", `getModsDelta(${cat})`, { activePosMods, posModVals, posModSum, activeNegMods, negModVals, negModSum, returnVal: U.sum(Object.values(sheetData.rollMods?.[cat]?.positive ?? {})\n                    .filter((mod) => [RollModStatus.ToggledOn, RollModStatus.ForcedOn].includes(mod.status))\n                    .map((mod) => mod.value))\n                    - U.sum(Object.values(sheetData.rollMods?.[cat]?.negative ?? {})\n                        .filter((mod) => [RollModStatus.ToggledOn, RollModStatus.ForcedOn].includes(mod.status))\n                        .map((mod) => mod.value)) });\n            \n            return U.sum(Object.values(sheetData.rollMods?.[cat]?.positive ?? {})\n                .filter((mod) => [RollModStatus.ToggledOn, RollModStatus.ForcedOn].includes(mod.status))\n                .map((mod) => mod.value))\n                - U.sum(Object.values(sheetData.rollMods?.[cat]?.negative ?? {})\n                    .filter((mod) => [RollModStatus.ToggledOn, RollModStatus.ForcedOn].includes(mod.status))\n                    .map((mod) => mod.value));\n        }\n        \n        sheetData.diceTotal = Math.max(0, (sheetData.rollTraitData?.value ?? 0)\n            + getModsDelta(RollModCategory.roll)\n            + (sheetData.GMBoosts.Dice ?? 0));\n        \r\n        let finalPosIndex = Object.values(Position).indexOf(sheetData.rollPositionInitial ?? Position.risky)\n            + getModsDelta(RollModCategory.position);\n        let finalEffectIndex = Object.values(Effect).indexOf(sheetData.rollEffectInitial ?? Effect.standard)\n            + getModsDelta(RollModCategory.effect);\n        \n        sheetData.canTradePosition = sheetData.rollPosEffectTrade === \"position\"\n            || (sheetData.rollPosEffectTrade === false && (finalPosIndex > 0 && finalEffectIndex < 4));\n        sheetData.canTradeEffect = sheetData.rollPosEffectTrade === \"effect\"\n            || (sheetData.rollPosEffectTrade === false && (finalPosIndex < 2 && finalEffectIndex > 1));\n        \n        if (sheetData.rollPosEffectTrade === \"position\") {\n            finalPosIndex++;\n            finalEffectIndex--;\n        }\n        if (sheetData.rollPosEffectTrade === \"effect\") {\n            finalPosIndex--;\n            finalEffectIndex++;\n        }\n        \n        sheetData.rollPositionFinal = Object.values(Position)[U.clampNum(finalPosIndex, [0, 2])];\n        sheetData.rollEffectFinal = Object.values(Effect)[U.clampNum(finalEffectIndex, [0, 4])];\n        \r\n        sheetData.isAffectingResult = getModsDelta(RollModCategory.result) !== 0\n            || (sheetData.GMBoosts.Result ?? 0) !== 0\n            || Object.values({\n                ...(sheetData.rollMods.result?.negative ?? {}),\n                ...(sheetData.rollMods.result?.positive ?? {})\n            }).filter((mod) => sheetData.isGM || mod.status !== RollModStatus.Hidden).length > 0;\n        \n        if (sheetData.isAffectingResult) {\n            sheetData.rollResultFinal = getModsDelta(RollModCategory.result)\n                + (sheetData.GMBoosts.Result ?? 0);\n        }\n        \r\n        if (sheetData.rollFactors) {\n            for (const [factorName] of Object.entries(sheetData.rollFactors)) {\n                if (sheetData.GMBoosts && factorName in sheetData.GMBoosts) {\n                    sheetData.rollFactors[factorName].value += sheetData.GMBoosts[factorName] ?? 0;\n                }\n                if ([Factor.tier, Factor.quality].includes(factorName)) {\n                    sheetData.rollFactors[factorName].display = U.romanizeNum(sheetData.rollFactors[factorName].value);\n                }\n            }\n        }\n        \r\n        if (sheetData.rollOpposition) {\n            sheetData.rollOppositionFactors = sheetData.rollOpposition.rollFactors;\n            \n            if (sheetData.rollOppositionFactors) {\n                for (const [factorName] of Object.entries(sheetData.rollOppositionFactors)) {\n                    if (sheetData.GMOppBoosts && factorName in sheetData.GMOppBoosts) {\n                        sheetData.rollOppositionFactors[factorName].value += sheetData.GMOppBoosts[factorName] ?? 0;\n                    }\n                    if ([Factor.tier, Factor.quality].includes(factorName)) {\n                        sheetData.rollOppositionFactors[factorName].display = U.romanizeNum(sheetData.rollOppositionFactors[factorName].value);\n                    }\n                }\n            }\n        }\n        \r\n        sheetData.hasInactiveConditionals = {\n            [RollModCategory.roll]: Object.values(sheetData.rollMods?.roll?.positive ?? {})\n                .filter((mod) => mod.isConditional && mod.status === RollModStatus.ToggledOff)\n                .length > 0,\n            [RollModCategory.position]: Object.values(sheetData.rollMods?.position?.positive ?? {})\n                .filter((mod) => mod.isConditional && mod.status === RollModStatus.ToggledOff)\n                .length > 0,\n            [RollModCategory.effect]: Object.values(sheetData.rollMods?.effect?.positive ?? {})\n                .filter((mod) => mod.isConditional && mod.status === RollModStatus.ToggledOff)\n                .length > 0,\n            [RollModCategory.result]: Object.values(sheetData.rollMods?.result?.positive ?? {})\n                .filter((mod) => mod.isConditional && mod.status === RollModStatus.ToggledOff)\n                .length > 0,\n            [RollModCategory.after]: Object.values(sheetData.rollMods?.after?.positive ?? {})\n                .filter((mod) => mod.isConditional && mod.status === RollModStatus.ToggledOff)\n                .length > 0\n        };\n        \r\n        const { success, partial, fail } = C.DiceOdds[sheetData.diceTotal ?? 0];\n        sheetData.oddsGradient = [\n            \"linear-gradient(to right\",\n            `var(--blades-black-dark) ${fail}%`,\n            `var(--blades-grey) ${fail + partial}%`,\n            `var(--blades-white-bright) ${fail + partial + success}%`,\n            \"var(--blades-gold-bright))\"\n        ].join(\", \");\n        \r\n        const stressMods = Object.values(sheetData.rollMods ?? {})\n            .map((catModData) => Object.values(catModData)\n            .map((posNegModData) => Object.values(posNegModData)))\n            .flat(3)\n            .filter((modData) => [RollModStatus.ForcedOn, RollModStatus.ToggledOn].includes(modData.status) && (modData.stressCost ?? 0) > 0);\n        const stressTotal = U.sum(stressMods.map((mod) => mod.stressCost));\n        \n        if (stressTotal > 0) {\n            sheetData.stressData = {\n                cost: stressTotal,\n                tooltip: [\n                    `<h1>Stress Cost: <span class='red-bright shadowed'>${stressTotal}</span></h1><ul>`,\n                    ...stressMods\n                        .map((mod) => `<li><strong class='shadowed'>${mod.name} (${mod.category}):</strong> <strong class='shadowed red-bright'>${mod.stressCost}</strong> Stress.</li>`),\n                    \"</ul>\"\n                ].join(\"\")\n            };\n        }\n        \n        eLog.checkLog3(\"getData\", \"RollCollab.getData()\", { ...context, ...sheetData });\n        \n        return {\n            ...context,\n            ...sheetData\n        };\n    }\n    \n    _toggleRollModClick(target, status) {\n        switch (status) {\n            case RollModStatus.Hidden: {\n                return this.document.setFlag(C.SYSTEM_ID, target, RollModStatus.ForcedOn);\n            }\n            case RollModStatus.ToggledOff: {\n                return this.document.setFlag(C.SYSTEM_ID, target, RollModStatus.ToggledOn);\n            }\n            case RollModStatus.ToggledOn: {\n                return this.document.setFlag(C.SYSTEM_ID, target, RollModStatus.ToggledOff);\n            }\n            case RollModStatus.ForcedOn: {\n                if (game.user.isGM) {\n                    return this.document.setFlag(C.SYSTEM_ID, target, RollModStatus.ToggledOff);\n                }\n                return undefined;\n            }\r\n        }\n        return undefined;\n    }\n    \n    async _toggleRollModContext(target, status) {\n        if (!game.user.isGM) {\n            return undefined;\n        }\n        switch (status) {\n            case RollModStatus.Hidden: {\n                return this.document.setFlag(C.SYSTEM_ID, target, RollModStatus.ToggledOff);\n            }\n            case RollModStatus.ToggledOff: {\n                return this.document.setFlag(C.SYSTEM_ID, target, RollModStatus.Hidden);\n            }\n            case RollModStatus.ToggledOn: {\n                return this.document.setFlag(C.SYSTEM_ID, target, RollModStatus.Hidden);\n            }\n            case RollModStatus.ForcedOn: {\n                if (game.user.isGM) {\n                    return this.document.setFlag(C.SYSTEM_ID, target, RollModStatus.Hidden);\n                }\n                return undefined;\n            }\r\n        }\n        return undefined;\n    }\n    \n    activateListeners(html) {\n        super.activateListeners(html);\n        ApplyTooltipListeners(html);\n        \r\n        html.find(\"[data-action='toggle']\").on({\n            click: async (event) => {\n                event.preventDefault();\n                const elem$ = $(event.currentTarget);\n                const status = elem$.data(\"status\");\n                const cat = elem$.data(\"cat\");\n                const posNeg = elem$.data(\"posNeg\");\n                const name = elem$.data(\"name\");\n                await this._toggleRollModClick(`rollCollab.rollMods.${cat}.${posNeg}.${name}.status`, status);\n                const bargainStatus = this.document.getFlag(C.SYSTEM_ID, \"rollCollab.rollMods.roll.positive.Bargain.status\");\n                const pushStatus = this.document.getFlag(C.SYSTEM_ID, \"rollCollab.rollMods.roll.positive.Push.status\");\n                if (name === \"Bargain\") {\n                    if ([RollModStatus.ForcedOn, RollModStatus.ToggledOn].includes(bargainStatus ?? \"\") && pushStatus !== RollModStatus.Hidden) {\n                        await this.document.setFlag(C.SYSTEM_ID, \"rollCollab.rollMods.roll.positive.Push.status\", RollModStatus.Hidden);\n                    }\n                    else if ([RollModStatus.ToggledOff, RollModStatus.Hidden].includes(bargainStatus ?? \"\") && pushStatus === RollModStatus.Hidden) {\n                        await this.document.setFlag(C.SYSTEM_ID, \"rollCollab.rollMods.roll.positive.Push.status\", RollModStatus.ToggledOff);\n                    }\n                }\n            },\n            contextmenu: (event) => {\n                event.preventDefault();\n                const elem$ = $(event.currentTarget);\n                const status = elem$.data(\"status\");\n                const cat = elem$.data(\"cat\");\n                const posNeg = elem$.data(\"posNeg\");\n                const name = elem$.data(\"name\");\n                this._toggleRollModContext(`rollCollab.rollMods.${cat}.${posNeg}.${name}.status`, status);\n            }\n        });\n        \n        html.find(\"[data-action='tradePosition']\").on({\n            click: (event) => {\n                const curVal = `${$(event.currentTarget).data(\"value\")}`;\n                if (curVal === \"false\") {\n                    this.document.setFlag(C.SYSTEM_ID, \"rollCollab.rollPosEffectTrade\", \"effect\");\n                }\n                else {\n                    this.document.setFlag(C.SYSTEM_ID, \"rollCollab.rollPosEffectTrade\", false);\n                }\n            }\n        });\n        html.find(\"[data-action='tradeEffect']\").on({\n            click: (event) => {\n                const curVal = `${$(event.currentTarget).data(\"value\")}`;\n                if (curVal === \"false\") {\n                    this.document.setFlag(C.SYSTEM_ID, \"rollCollab.rollPosEffectTrade\", \"position\");\n                }\n                else {\n                    this.document.setFlag(C.SYSTEM_ID, \"rollCollab.rollPosEffectTrade\", false);\n                }\n            }\n        });\n    }\n    \n    async _onSubmit(event, { updateData } = {}) {\n        return super._onSubmit(event, { updateData, preventClose: true })\n            .then((returnVal) => { this.render(); return returnVal; });\n    }\n    \n    async close(options = {}) {\n        eLog.checkLog3(\"rollCollab\", \"RollCollab.close()\", { options });\n        if (options.rollID) {\n            return super.close({});\n        }\n        this.document.setFlag(C.SYSTEM_ID, \"rollCollab\", null);\n        socketlib.system.executeForEveryone(\"closeRollCollab\", this.rollID);\n        \n        return undefined;\n    }\n    \n    render(force, options) {\n        if (!this.document.getFlag(C.SYSTEM_ID, \"rollCollab\")) {\n            return this;\n        }\n        return super.render(force, options);\n    }\n}\r\n\nexport default BladesRollCollabSheet;"]}
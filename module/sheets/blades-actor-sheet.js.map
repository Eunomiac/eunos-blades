{"version":3,"sources":["sheets/blades-actor-sheet.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"blades-actor-sheet.js","sourcesContent":["import C, { BladesActorType, BladesItemType, Tag } from \"../core/constants.js\";\nimport { BladesPhase } from \"./blades-tracker-sheet.js\";\r\n\nimport U from \"../core/utilities.js\";\nimport BladesSheet from \"./blades-sheet.js\";\nimport BladesItem from \"../blades-item.js\";\nimport BladesActor from \"../blades-actor.js\";\r\n\nclass BladesActorSheet extends BladesSheet {\n    \n    static get defaultOptions() {\n        return foundry.utils.mergeObject(super.defaultOptions, {\n            classes: [\"eunos-blades\", \"sheet\", \"actor\", \"pc\"],\n            template: \"systems/eunos-blades/templates/actor-sheet.hbs\",\n            width: 775,\n            height: 775,\n            tabs: [{ navSelector: \".nav-tabs\", contentSelector: \".tab-content\", initial: \"abilities\" }]\n        });\n    }\n    \n    static Initialize() {\n        Actors.registerSheet(\"blades\", BladesActorSheet, { types: [\"pc\"], makeDefault: true });\n        \n        Hooks.on(\"dropActorSheetData\", async (parentActor, _, { uuid }) => {\n            const doc = await fromUuid(uuid);\n            if (doc instanceof BladesActor) {\n                if (parentActor.type === BladesActorType.crew && doc.type === BladesActorType.pc) {\r\n                    doc.addSubActor(parentActor);\n                }\n                else if (parentActor.type === BladesActorType.pc && doc.type === BladesActorType.crew) {\r\n                    parentActor.addSubActor(doc);\n                }\n            }\n            if (doc instanceof BladesItem) {\n                BladesItem.create(doc, { parent: parentActor });\n                return;\n            }\n        });\n        return loadTemplates([\n            \"systems/eunos-blades/templates/items/clock_keeper-sheet.hbs\",\n            \"systems/eunos-blades/templates/parts/clock-sheet-row.hbs\"\n        ]);\n    }\n    \n    getData() {\n        const context = super.getData();\n        \n        const sheetData = {};\n        \n        sheetData.isOwner = this.actor.testUserPermission(game.user, CONST.DOCUMENT_PERMISSION_LEVELS.OWNER);\n        \n        context.attributes = U.objMap(context.system.attributes, (attrData) => U.objMap(attrData, (value) => ({\n            value: value.value,\n            max: game.eunoblades.Tracker.system.game_phase === BladesPhase.CharGen ? 2 : value.max\n        })));\n        \n        const { activeSubItems, activeSubActors } = this.actor;\n        \n        Object.assign(sheetData, {\n            phases: Object.values(BladesPhase),\n            items: {\n                abilities: activeSubItems.filter((item) => item.type === BladesItemType.ability).map((item) => {\n                    // Assign dotlines to abilities with usage data\n                    if (item.system.uses?.max) {\n                        Object.assign(item, {\n                            inRuleDotline: {\n                                data: item.system.uses,\n                                dotlineLabel: \"Uses\",\n                                target: \"item.system.uses.value\",\n                                iconEmpty: \"dot-empty.svg\",\n                                iconEmptyHover: \"dot-empty-hover.svg\",\n                                iconFull: \"dot-full.svg\",\n                                iconFullHover: \"dot-full-hover.svg\"\n                            }\n                        });\n                    }\n                    return item;\n                }),\n                background: activeSubItems.find((item) => item.type === BladesItemType.background),\n                heritage: activeSubItems.find((item) => item.type === BladesItemType.heritage),\n                vice: activeSubItems.find((item) => item.type === BladesItemType.vice),\n                loadout: activeSubItems.filter((item) => item.type === BladesItemType.item).map((item) => {\r\n                    if (item.system.load) {\n                        Object.assign(item, {\n                            numberCircle: item.system.load,\n                            numberCircleClass: \"item-load\"\n                        });\n                    }\n                    if (item.system.uses?.max) {\n                        Object.assign(item, {\n                            inRuleDotline: {\n                                data: item.system.uses,\n                                dotlineLabel: \"Uses\",\n                                target: \"item.system.uses.value\",\n                                iconEmpty: \"dot-empty.svg\",\n                                iconEmptyHover: \"dot-empty-hover.svg\",\n                                iconFull: \"dot-full.svg\",\n                                iconFullHover: \"dot-full-hover.svg\"\n                            }\n                        });\n                    }\n                    return item;\n                }),\n                playbook: this.actor.playbook\n            },\n            actors: {\n                crew: activeSubActors.find((actor) => actor.type === BladesActorType.crew),\n                vice_purveyor: activeSubActors.find((actor) => actor.hasTag(Tag.NPC.VicePurveyor)),\n                friends: activeSubActors.filter((actor) => actor.hasTag(Tag.NPC.Friend)),\n                rivals: activeSubActors.filter((actor) => actor.hasTag(Tag.NPC.Rival))\n            },\n            stashData: {\n                label: \"Stash:\",\n                dotline: {\n                    data: this.actor.system.stash,\n                    target: \"system.stash.value\",\n                    iconEmpty: \"coin-empty.svg\",\n                    iconEmptyHover: \"coin-empty-hover.svg\",\n                    iconFull: \"coin-full.svg\",\n                    iconFullHover: \"coin-full-hover.svg\",\n                    altIconFull: \"coin-ten.svg\",\n                    altIconFullHover: \"coin-ten-hover.svg\",\n                    altIconStep: 10\n                }\n            },\n            healing_clock: {\n                value: this.actor.system.healing.value,\n                size: this.actor.system.healing.max\n            },\n            armor: Object.fromEntries(Object.entries(this.actor.system.armor.active)\n                .filter(([, isActive]) => isActive)\n                .map(([armor]) => [armor, this.actor.system.armor.checked[armor]])),\n            loadData: {\n                curLoad: this.actor.currentLoad,\n                selLoadCount: this.actor.system.loadout.levels[U.lCase(game.i18n.localize(this.actor.system.loadout.selected.toString()))],\n                selections: C.Loadout.selections,\n                selLoadLevel: this.actor.system.loadout.selected.toString()\n            },\n            stressData: {\n                name: this.actor.system.stress.name,\n                dotline: {\n                    data: this.actor.system.stress,\n                    target: \"system.stress.value\",\n                    svgKey: \"teeth.tall\",\n                    svgFull: \"full|half|frame\",\n                    svgEmpty: \"full|half|frame\"\n                }\n            },\n            traumaData: {\n                name: this.actor.system.trauma.name,\n                dotline: {\n                    data: { value: this.actor.trauma, max: this.actor.system.trauma.max },\n                    svgKey: \"teeth.short\",\n                    svgFull: \"full|frame\",\n                    svgEmpty: \"frame\",\n                    isLocked: true\n                },\n                compContainer: {\n                    \"class\": \"comp-trauma-conditions comp-vertical full-width\",\n                    \"blocks\": [\n                        this.actor.traumaList.slice(0, Math.ceil(this.actor.traumaList.length / 2))\n                            .map((tName) => ({\n                            checkLabel: tName,\n                            checkClasses: {\n                                active: \"comp-toggle-red\",\n                                inactive: \"comp-toggle-grey\"\n                            },\n                            checkTarget: `system.trauma.checked.${tName}`,\n                            checkValue: this.actor.system.trauma.checked[tName] ?? false\n                        })),\n                        this.actor.traumaList.slice(Math.ceil(this.actor.traumaList.length / 2))\n                            .map((tName) => ({\n                            checkLabel: tName,\n                            checkClasses: {\n                                active: \"comp-toggle-red\",\n                                inactive: \"comp-toggle-grey\"\n                            },\n                            checkTarget: `system.trauma.checked.${tName}`,\n                            checkValue: this.actor.system.trauma.checked[tName] ?? false\n                        }))\n                    ]\n                }\n            },\n            acquaintancesName: this.actor.system.acquaintances_name ?? \"Friends & Rivals\",\n            friendsName: this.actor.system.friends_name,\n            rivalsName: this.actor.system.rivals_name,\n            abilityData: {\n                dotline: {\n                    \"class\": \"dotline-right\",\n                    \"data\": {\n                        value: this.actor.availableAbilityPoints,\n                        max: this.actor.availableAbilityPoints\n                    },\n                    \"dotlineLabel\": \"Available Abilities\",\n                    \"isLocked\": true,\n                    \"iconFull\": \"dot-full.svg\"\n                }\n            }\n        });\n        \n        eLog.checkLog(\"actor\", \"[BladesActorSheet] getData()\", { ...context, ...sheetData });\n        \n        return {\n            ...context,\n            ...sheetData\n        };\n    }\n    \n    get activeArmor() {\n        return Object.keys(U.objFilter(this.actor.system.armor.active, (val) => val === true));\n    }\n    get checkedArmor() {\n        return Object.keys(U.objFilter(this.actor.system.armor.checked, (val, key) => val === true\n            && this.actor.system.armor.active[key] === true));\n    }\n    get uncheckedArmor() {\n        return Object.keys(U.objFilter(this.actor.system.armor.active, (val, key) => val === true\n            && this.actor.system.armor.checked[key] === false));\n    }\n    \n    _getHoverArmor() {\n        if (!this.activeArmor.length) {\n            return false;\n        }\n        if (this.activeArmor.includes(\"heavy\")) {\n            return this.checkedArmor.includes(\"heavy\") ? \"light\" : \"heavy\";\n        }\n        else if (this.activeArmor.includes(\"light\")) {\n            return \"light\";\n        }\n        return \"special\";\n    }\n    \n    _getClickArmor() {\n        if (!this.uncheckedArmor.length) {\n            return false;\n        }\n        if (this.uncheckedArmor.includes(\"heavy\")) {\n            return \"heavy\";\n        }\n        if (this.uncheckedArmor.includes(\"light\")) {\n            return \"light\";\n        }\n        return \"special\";\n    }\n    \n    _getContextMenuArmor() {\n        if (!this.checkedArmor.length) {\n            return false;\n        }\n        if (this.checkedArmor.includes(\"light\")) {\n            return \"light\";\n        }\n        if (this.checkedArmor.includes(\"heavy\")) {\n            return \"heavy\";\n        }\n        return \"special\";\n    }\n    \n    activateListeners(html) {\n        \n        super.activateListeners(html);\n        \n        // Everything below here is only needed if the sheet is editable\n        if (!this.options.editable) {\n            return;\n        }\n        \n        const self = this;\n        \n        // Armor Control\n        html.find(\".main-armor-control\").on({\n            click: function () {\n                const targetArmor = self._getClickArmor();\n                if (!targetArmor) {\n                    return;\n                }\n                self.actor.update({ [`system.armor.checked.${targetArmor}`]: true });\n            },\n            contextmenu: function () {\n                const targetArmor = self._getContextMenuArmor();\n                if (!targetArmor) {\n                    return;\n                }\n                self.actor.update({ [`system.armor.checked.${targetArmor}`]: false });\n            },\n            mouseenter: function () {\n                const targetArmor = self._getHoverArmor();\n                eLog.log4(\"Mouse Enter\", targetArmor, this, $(this), $(this).next());\n                if (!targetArmor) {\n                    return;\n                }\n                $(this).siblings(`.svg-armor.armor-${targetArmor}`).addClass(\"hover-over\");\n            },\n            mouseleave: function () {\n                const targetArmor = self._getHoverArmor();\n                if (!targetArmor) {\n                    return;\n                }\n                $(this).siblings(`.svg-armor.armor-${targetArmor}`).removeClass(\"hover-over\");\n            }\n        });\n        \n        html.find(\".special-armor-control\").on({\n            click: function () {\n                if (!self.activeArmor.includes(\"special\")) {\n                    return;\n                }\n                self.actor.update({ [\"system.armor.checked.special\"]: self.uncheckedArmor.includes(\"special\") });\n            },\n            contextmenu: function () {\n                if (!self.activeArmor.includes(\"special\")) {\n                    return;\n                }\n                self.actor.update({ [\"system.armor.checked.special\"]: self.uncheckedArmor.includes(\"special\") });\n            },\n            mouseenter: function () {\n                if (!self.activeArmor.includes(\"special\") || self.activeArmor.length === 1) {\n                    return;\n                }\n                $(this).siblings(\".svg-armor.armor-special\").addClass(\"hover-over\");\n            },\n            mouseleave: function () {\n                if (!self.activeArmor.includes(\"special\") || self.activeArmor.length === 1) {\n                    return;\n                }\n                $(this).siblings(\".svg-armor.armor-special\").removeClass(\"hover-over\");\n            }\n        });\n    }\n}\r\n\nexport default BladesActorSheet;"]}